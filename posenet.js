let __defineProperty = Object.defineProperty;
let __commonJS = (callback, module) => () => {
  if (!module) {
    module = {exports: {}};
    callback(module.exports, module);
  }
  return module.exports;
};
let __markAsModule = (target) => {
  return __defineProperty(target, "__esModule", {value: true});
};
let __export = (target, all) => {
  __markAsModule(target);
  for (let name in all)
    __defineProperty(target, name, {get: all[name], enumerable: true});
};

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS((exports, module) => {
  "use strict";
  var buffer = require("buffer");
  var Buffer2 = buffer.Buffer;
  var safer = {};
  var key;
  for (key in buffer) {
    if (!buffer.hasOwnProperty(key))
      continue;
    if (key === "SlowBuffer" || key === "Buffer")
      continue;
    safer[key] = buffer[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key))
      continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow")
      continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e2) {
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  module.exports = safer;
});

// node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = __commonJS((exports) => {
  "use strict";
  var BOMChar = "ï»¿";
  exports.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  exports.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
      return res;
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
});

// node_modules/iconv-lite/encodings/internal.js
var require_internal = __commonJS((exports, module) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  module.exports = {
    utf8: {type: "_internal", bomAware: true},
    cesu8: {type: "_internal", bomAware: true},
    unicode11utf8: "utf8",
    ucs2: {type: "_internal", bomAware: true},
    utf16le: "ucs2",
    binary: {type: "_internal"},
    base64: {type: "_internal"},
    hex: {type: "_internal"},
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "ğŸ’©") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = require("string_decoder").StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {
    };
  function InternalDecoder(options, codec) {
    this.decoder = new StringDecoder(codec.enc);
  }
  InternalDecoder.prototype.write = function(buf) {
    if (!Buffer2.isBuffer(buf)) {
      buf = Buffer2.from(buf);
    }
    return this.decoder.write(buf);
  };
  InternalDecoder.prototype.end = function() {
    return this.decoder.end();
  };
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str) {
    return Buffer2.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer2.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
    for (var i2 = 0; i2 < str.length; i2++) {
      var charCode = str.charCodeAt(i2);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for (var i2 = 0; i2 < buf.length; i2++) {
      var curByte = buf[i2];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res += this.defaultCharUnicode;
            else
              res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
      res += this.defaultCharUnicode;
    return res;
  };
});

// node_modules/iconv-lite/encodings/utf32.js
var require_utf32 = __commonJS((exports) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  exports._utf32 = Utf32Codec;
  function Utf32Codec(codecOptions, iconv) {
    this.iconv = iconv;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
  }
  exports.utf32le = {type: "_utf32", isLE: true};
  exports.utf32be = {type: "_utf32", isLE: false};
  exports.ucs4le = "utf32le";
  exports.ucs4be = "utf32be";
  Utf32Codec.prototype.encoder = Utf32Encoder;
  Utf32Codec.prototype.decoder = Utf32Decoder;
  function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
  }
  Utf32Encoder.prototype.write = function(str) {
    var src = Buffer2.from(str, "ucs2");
    var dst = Buffer2.alloc(src.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;
    for (var i2 = 0; i2 < src.length; i2 += 2) {
      var code = src.readUInt16LE(i2);
      var isHighSurrogate = 55296 <= code && code < 56320;
      var isLowSurrogate = 56320 <= code && code < 57344;
      if (this.highSurrogate) {
        if (isHighSurrogate || !isLowSurrogate) {
          write32.call(dst, this.highSurrogate, offset);
          offset += 4;
        } else {
          var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
          write32.call(dst, codepoint, offset);
          offset += 4;
          this.highSurrogate = 0;
          continue;
        }
      }
      if (isHighSurrogate)
        this.highSurrogate = code;
      else {
        write32.call(dst, code, offset);
        offset += 4;
        this.highSurrogate = 0;
      }
    }
    if (offset < dst.length)
      dst = dst.slice(0, offset);
    return dst;
  };
  Utf32Encoder.prototype.end = function() {
    if (!this.highSurrogate)
      return;
    var buf = Buffer2.alloc(4);
    if (this.isLE)
      buf.writeUInt32LE(this.highSurrogate, 0);
    else
      buf.writeUInt32BE(this.highSurrogate, 0);
    this.highSurrogate = 0;
    return buf;
  };
  function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = [];
  }
  Utf32Decoder.prototype.write = function(src) {
    if (src.length === 0)
      return "";
    var i2 = 0;
    var codepoint = 0;
    var dst = Buffer2.alloc(src.length + 4);
    var offset = 0;
    var isLE = this.isLE;
    var overflow = this.overflow;
    var badChar = this.badChar;
    if (overflow.length > 0) {
      for (; i2 < src.length && overflow.length < 4; i2++)
        overflow.push(src[i2]);
      if (overflow.length === 4) {
        if (isLE) {
          codepoint = overflow[i2] | overflow[i2 + 1] << 8 | overflow[i2 + 2] << 16 | overflow[i2 + 3] << 24;
        } else {
          codepoint = overflow[i2 + 3] | overflow[i2 + 2] << 8 | overflow[i2 + 1] << 16 | overflow[i2] << 24;
        }
        overflow.length = 0;
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
    }
    for (; i2 < src.length - 3; i2 += 4) {
      if (isLE) {
        codepoint = src[i2] | src[i2 + 1] << 8 | src[i2 + 2] << 16 | src[i2 + 3] << 24;
      } else {
        codepoint = src[i2 + 3] | src[i2 + 2] << 8 | src[i2 + 1] << 16 | src[i2] << 24;
      }
      offset = _writeCodepoint(dst, offset, codepoint, badChar);
    }
    for (; i2 < src.length; i2++) {
      overflow.push(src[i2]);
    }
    return dst.slice(0, offset).toString("ucs2");
  };
  function _writeCodepoint(dst, offset, codepoint, badChar) {
    if (codepoint < 0 || codepoint > 1114111) {
      codepoint = badChar;
    }
    if (codepoint >= 65536) {
      codepoint -= 65536;
      var high = 55296 | codepoint >> 10;
      dst[offset++] = high & 255;
      dst[offset++] = high >> 8;
      var codepoint = 56320 | codepoint & 1023;
    }
    dst[offset++] = codepoint & 255;
    dst[offset++] = codepoint >> 8;
    return offset;
  }
  Utf32Decoder.prototype.end = function() {
    this.overflow.length = 0;
  };
  exports.utf32 = Utf32AutoCodec;
  exports.ucs4 = "utf32";
  function Utf32AutoCodec(options, iconv) {
    this.iconv = iconv;
  }
  Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
  Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
  function Utf32AutoEncoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
  }
  Utf32AutoEncoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf32AutoEncoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf32AutoDecoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 32)
        return "";
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i2 = 0; i2 < this.initialBufs.length; i2++)
        resStr += this.decoder.write(this.initialBufs[i2]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf32AutoDecoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i2 = 0; i2 < this.initialBufs.length; i2++)
        resStr += this.decoder.write(this.initialBufs[i2]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b2 = [];
    var charsProcessed = 0;
    var invalidLE = 0, invalidBE = 0;
    var bmpCharsLE = 0, bmpCharsBE = 0;
    outer_loop:
      for (var i2 = 0; i2 < bufs.length; i2++) {
        var buf = bufs[i2];
        for (var j2 = 0; j2 < buf.length; j2++) {
          b2.push(buf[j2]);
          if (b2.length === 4) {
            if (charsProcessed === 0) {
              if (b2[0] === 255 && b2[1] === 254 && b2[2] === 0 && b2[3] === 0) {
                return "utf-32le";
              }
              if (b2[0] === 0 && b2[1] === 0 && b2[2] === 254 && b2[3] === 255) {
                return "utf-32be";
              }
            }
            if (b2[0] !== 0 || b2[1] > 16)
              invalidBE++;
            if (b2[3] !== 0 || b2[2] > 16)
              invalidLE++;
            if (b2[0] === 0 && b2[1] === 0 && (b2[2] !== 0 || b2[3] !== 0))
              bmpCharsBE++;
            if ((b2[0] !== 0 || b2[1] !== 0) && b2[2] === 0 && b2[3] === 0)
              bmpCharsLE++;
            b2.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE)
      return "utf-32be";
    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE)
      return "utf-32le";
    return defaultEncoding || "utf-32le";
  }
});

// node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = __commonJS((exports) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  exports.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer2.from(str, "ucs2");
    for (var i2 = 0; i2 < buf.length; i2 += 2) {
      var tmp = buf[i2];
      buf[i2] = buf[i2 + 1];
      buf[i2 + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i2 = 0, j2 = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i2 = 1;
      j2 = 2;
    }
    for (; i2 < buf.length - 1; i2 += 2, j2 += 2) {
      buf2[j2] = buf[i2 + 1];
      buf2[j2 + 1] = buf[i2];
    }
    this.overflowByte = i2 == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j2).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
    this.overflowByte = -1;
  };
  exports.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 16)
        return "";
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i2 = 0; i2 < this.initialBufs.length; i2++)
        resStr += this.decoder.write(this.initialBufs[i2]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i2 = 0; i2 < this.initialBufs.length; i2++)
        resStr += this.decoder.write(this.initialBufs[i2]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b2 = [];
    var charsProcessed = 0;
    var asciiCharsLE = 0, asciiCharsBE = 0;
    outer_loop:
      for (var i2 = 0; i2 < bufs.length; i2++) {
        var buf = bufs[i2];
        for (var j2 = 0; j2 < buf.length; j2++) {
          b2.push(buf[j2]);
          if (b2.length === 2) {
            if (charsProcessed === 0) {
              if (b2[0] === 255 && b2[1] === 254)
                return "utf-16le";
              if (b2[0] === 254 && b2[1] === 255)
                return "utf-16be";
            }
            if (b2[0] === 0 && b2[1] !== 0)
              asciiCharsBE++;
            if (b2[0] !== 0 && b2[1] === 0)
              asciiCharsLE++;
            b2.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (asciiCharsBE > asciiCharsLE)
      return "utf-16be";
    if (asciiCharsBE < asciiCharsLE)
      return "utf-16le";
    return defaultEncoding || "utf-16le";
  }
});

// node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = __commonJS((exports) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  exports.utf7 = Utf7Codec;
  exports.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str) {
    return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }.bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i2 = 0; i2 < 256; i2++)
    base64Chars[i2] = base64Regex.test(String.fromCharCode(i2));
  var plusChar = "+".charCodeAt(0);
  var minusChar = "-".charCodeAt(0);
  var andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i3 = 0; i3 < buf.length; i3++) {
      if (!inBase64) {
        if (buf[i3] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i3), "ascii");
          lastI = i3 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i3]]) {
          if (i3 == lastI && buf[i3] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i3), "ascii");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i3] != minusChar)
            i3--;
          lastI = i3 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  exports.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
    for (var i3 = 0; i3 < str.length; i3++) {
      var uChar = str.charCodeAt(i3);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i3 = 0; i3 < buf.length; i3++) {
      if (!inBase64) {
        if (buf[i3] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i3), "ascii");
          lastI = i3 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i3]]) {
          if (i3 == lastI && buf[i3] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i3), "ascii").replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i3] != minusChar)
            i3--;
          lastI = i3 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
});

// node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = __commonJS((exports) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  exports._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i2 = 0; i2 < 128; i2++)
        asciiString += String.fromCharCode(i2);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i2 = 0; i2 < codecOptions.chars.length; i2++)
      encodeBuf[codecOptions.chars.charCodeAt(i2)] = i2;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length);
    for (var i2 = 0; i2 < str.length; i2++)
      buf[i2] = this.encodeBuf[str.charCodeAt(i2)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i2 = 0; i2 < buf.length; i2++) {
      idx1 = buf[i2] * 2;
      idx2 = i2 * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
});

// node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = __commonJS((exports, module) => {
  "use strict";
  module.exports = {
    "10029": "maccenteuro",
    maccenteuro: {
      type: "_sbcs",
      chars: "Ã„Ä€ÄÃ‰Ä„Ã–ÃœÃ¡Ä…ÄŒÃ¤ÄÄ†Ä‡Ã©Å¹ÅºÄÃ­ÄÄ’Ä“Ä–Ã³Ä—Ã´Ã¶ÃµÃºÄšÄ›Ã¼â€ Â°Ä˜Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Ä™Â¨â‰ Ä£Ä®Ä¯Äªâ‰¤â‰¥Ä«Ä¶âˆ‚âˆ‘Å‚Ä»Ä¼Ä½Ä¾Ä¹ÄºÅ…Å†ÅƒÂ¬âˆšÅ„Å‡âˆ†Â«Â»â€¦Â ÅˆÅÃ•Å‘ÅŒâ€“â€”â€œâ€â€˜â€™Ã·â—ŠÅÅ”Å•Å˜â€¹â€ºÅ™Å–Å—Å â€šâ€Å¡ÅšÅ›ÃÅ¤Å¥ÃÅ½Å¾ÅªÃ“Ã”Å«Å®ÃšÅ¯Å°Å±Å²Å³ÃÃ½Ä·Å»ÅÅ¼Ä¢Ë‡"
    },
    "808": "cp808",
    ibm808: "cp808",
    cp808: {
      type: "_sbcs",
      chars: "ĞĞ‘Ğ’Ğ“Ğ”Ğ•Ğ–Ğ—Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ Ğ¡Ğ¢Ğ£Ğ¤Ğ¥Ğ¦Ğ§Ğ¨Ğ©ĞªĞ«Ğ¬Ğ­Ğ®Ğ¯Ğ°Ğ±Ğ²Ğ³Ğ´ĞµĞ¶Ğ·Ğ¸Ğ¹ĞºĞ»Ğ¼Ğ½Ğ¾Ğ¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•â•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑÑĞÑ‘Ğ„Ñ”Ğ‡Ñ—ĞÑÂ°âˆ™Â·âˆšâ„–â‚¬â– Â "
    },
    mik: {
      type: "_sbcs",
      chars: "ĞĞ‘Ğ’Ğ“Ğ”Ğ•Ğ–Ğ—Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ Ğ¡Ğ¢Ğ£Ğ¤Ğ¥Ğ¦Ğ§Ğ¨Ğ©ĞªĞ«Ğ¬Ğ­Ğ®Ğ¯Ğ°Ğ±Ğ²Ğ³Ğ´ĞµĞ¶Ğ·Ğ¸Ğ¹ĞºĞ»Ğ¼Ğ½Ğ¾Ğ¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑÑâ””â”´â”¬â”œâ”€â”¼â•£â•‘â•šâ•”â•©â•¦â• â•â•¬â”â–‘â–’â–“â”‚â”¤â„–Â§â•—â•â”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    cp720: {
      type: "_sbcs",
      chars: "Â€ÂÃ©Ã¢Â„Ã Â†Ã§ÃªÃ«Ã¨Ã¯Ã®ÂÂÂÂÙ‘Ù’Ã´Â¤Ù€Ã»Ã¹Ø¡Ø¢Ø£Ø¤Â£Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµÂ«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•â•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ø¶Ø·Ø¸Ø¹ØºÙÂµÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙ‰ÙŠâ‰¡Ù‹ÙŒÙÙÙÙâ‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    ascii8bit: "ascii",
    usascii: "ascii",
    ansix34: "ascii",
    ansix341968: "ascii",
    ansix341986: "ascii",
    csascii: "ascii",
    cp367: "ascii",
    ibm367: "ascii",
    isoir6: "ascii",
    iso646us: "ascii",
    iso646irv: "ascii",
    us: "ascii",
    latin1: "iso88591",
    latin2: "iso88592",
    latin3: "iso88593",
    latin4: "iso88594",
    latin5: "iso88599",
    latin6: "iso885910",
    latin7: "iso885913",
    latin8: "iso885914",
    latin9: "iso885915",
    latin10: "iso885916",
    csisolatin1: "iso88591",
    csisolatin2: "iso88592",
    csisolatin3: "iso88593",
    csisolatin4: "iso88594",
    csisolatincyrillic: "iso88595",
    csisolatinarabic: "iso88596",
    csisolatingreek: "iso88597",
    csisolatinhebrew: "iso88598",
    csisolatin5: "iso88599",
    csisolatin6: "iso885910",
    l1: "iso88591",
    l2: "iso88592",
    l3: "iso88593",
    l4: "iso88594",
    l5: "iso88599",
    l6: "iso885910",
    l7: "iso885913",
    l8: "iso885914",
    l9: "iso885915",
    l10: "iso885916",
    isoir14: "iso646jp",
    isoir57: "iso646cn",
    isoir100: "iso88591",
    isoir101: "iso88592",
    isoir109: "iso88593",
    isoir110: "iso88594",
    isoir144: "iso88595",
    isoir127: "iso88596",
    isoir126: "iso88597",
    isoir138: "iso88598",
    isoir148: "iso88599",
    isoir157: "iso885910",
    isoir166: "tis620",
    isoir179: "iso885913",
    isoir199: "iso885914",
    isoir203: "iso885915",
    isoir226: "iso885916",
    cp819: "iso88591",
    ibm819: "iso88591",
    cyrillic: "iso88595",
    arabic: "iso88596",
    arabic8: "iso88596",
    ecma114: "iso88596",
    asmo708: "iso88596",
    greek: "iso88597",
    greek8: "iso88597",
    ecma118: "iso88597",
    elot928: "iso88597",
    hebrew: "iso88598",
    hebrew8: "iso88598",
    turkish: "iso88599",
    turkish8: "iso88599",
    thai: "iso885911",
    thai8: "iso885911",
    celtic: "iso885914",
    celtic8: "iso885914",
    isoceltic: "iso885914",
    tis6200: "tis620",
    tis62025291: "tis620",
    tis62025330: "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    cspc8codepage437: "cp437",
    cspc775baltic: "cp775",
    cspc850multilingual: "cp850",
    cspcp852: "cp852",
    cspc862latinhebrew: "cp862",
    cpgr: "cp869",
    msee: "cp1250",
    mscyrl: "cp1251",
    msansi: "cp1252",
    msgreek: "cp1253",
    msturk: "cp1254",
    mshebr: "cp1255",
    msarab: "cp1256",
    winbaltrim: "cp1257",
    cp20866: "koi8r",
    "20866": "koi8r",
    ibm878: "koi8r",
    cskoi8r: "koi8r",
    cp21866: "koi8u",
    "21866": "koi8u",
    ibm1168: "koi8u",
    strk10482002: "rk1048",
    tcvn5712: "tcvn",
    tcvn57121: "tcvn",
    gb198880: "iso646cn",
    cn: "iso646cn",
    csiso14jisc6220ro: "iso646jp",
    jisc62201969ro: "iso646jp",
    jp: "iso646jp",
    cshproman8: "hproman8",
    r8: "hproman8",
    roman8: "hproman8",
    xroman8: "hproman8",
    ibm1051: "hproman8",
    mac: "macintosh",
    csmacintosh: "macintosh"
  };
});

// node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = __commonJS((exports, module) => {
  "use strict";
  module.exports = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    windows874: {
      type: "_sbcs",
      chars: "â‚¬ï¿½ï¿½ï¿½ï¿½â€¦ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸à¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸à¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹à¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    },
    win874: "windows874",
    cp874: "windows874",
    windows1250: {
      type: "_sbcs",
      chars: "â‚¬ï¿½â€šï¿½â€â€¦â€ â€¡ï¿½â€°Å â€¹ÅšÅ¤Å½Å¹ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Å¡â€ºÅ›Å¥Å¾ÅºÂ Ë‡Ë˜ÅÂ¤Ä„Â¦Â§Â¨Â©ÅÂ«Â¬Â­Â®Å»Â°Â±Ë›Å‚Â´ÂµÂ¶Â·Â¸Ä…ÅŸÂ»Ä½ËÄ¾Å¼Å”ÃÃ‚Ä‚Ã„Ä¹Ä†Ã‡ÄŒÃ‰Ä˜Ã‹ÄšÃÃÄÄÅƒÅ‡Ã“Ã”ÅÃ–Ã—Å˜Å®ÃšÅ°ÃœÃÅ¢ÃŸÅ•Ã¡Ã¢ÄƒÃ¤ÄºÄ‡Ã§ÄÃ©Ä™Ã«Ä›Ã­Ã®ÄÄ‘Å„ÅˆÃ³Ã´Å‘Ã¶Ã·Å™Å¯ÃºÅ±Ã¼Ã½Å£Ë™"
    },
    win1250: "windows1250",
    cp1250: "windows1250",
    windows1251: {
      type: "_sbcs",
      chars: "Ğ‚Ğƒâ€šÑ“â€â€¦â€ â€¡â‚¬â€°Ğ‰â€¹ĞŠĞŒĞ‹ĞÑ’â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Ñ™â€ºÑšÑœÑ›ÑŸÂ ĞÑĞˆÂ¤ÒÂ¦Â§ĞÂ©Ğ„Â«Â¬Â­Â®Ğ‡Â°Â±Ğ†Ñ–Ò‘ÂµÂ¶Â·Ñ‘â„–Ñ”Â»Ñ˜Ğ…Ñ•Ñ—ĞĞ‘Ğ’Ğ“Ğ”Ğ•Ğ–Ğ—Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ Ğ¡Ğ¢Ğ£Ğ¤Ğ¥Ğ¦Ğ§Ğ¨Ğ©ĞªĞ«Ğ¬Ğ­Ğ®Ğ¯Ğ°Ğ±Ğ²Ğ³Ğ´ĞµĞ¶Ğ·Ğ¸Ğ¹ĞºĞ»Ğ¼Ğ½Ğ¾Ğ¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑÑ"
    },
    win1251: "windows1251",
    cp1251: "windows1251",
    windows1252: {
      type: "_sbcs",
      chars: "â‚¬ï¿½â€šÆ’â€â€¦â€ â€¡Ë†â€°Å â€¹Å’ï¿½Å½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ï¿½Å¾Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    win1252: "windows1252",
    cp1252: "windows1252",
    windows1253: {
      type: "_sbcs",
      chars: "â‚¬ï¿½â€šÆ’â€â€¦â€ â€¡ï¿½â€°ï¿½â€¹ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½Â Î…Î†Â£Â¤Â¥Â¦Â§Â¨Â©ï¿½Â«Â¬Â­Â®â€•Â°Â±Â²Â³Î„ÂµÂ¶Â·ÎˆÎ‰ÎŠÂ»ÎŒÂ½ÎÎÎÎ‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎÎŸÎ Î¡ï¿½Î£Î¤Î¥Î¦Î§Î¨Î©ÎªÎ«Î¬Î­Î®Î¯Î°Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏ‚ÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰ÏŠÏ‹ÏŒÏÏï¿½"
    },
    win1253: "windows1253",
    cp1253: "windows1253",
    windows1254: {
      type: "_sbcs",
      chars: "â‚¬ï¿½â€šÆ’â€â€¦â€ â€¡Ë†â€°Å â€¹Å’ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ï¿½ï¿½Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃÃÄÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÄ°ÅÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÄŸÃ±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ä±ÅŸÃ¿"
    },
    win1254: "windows1254",
    cp1254: "windows1254",
    windows1255: {
      type: "_sbcs",
      chars: "â‚¬ï¿½â€šÆ’â€â€¦â€ â€¡Ë†â€°ï¿½â€¹ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½Â Â¡Â¢Â£â‚ªÂ¥Â¦Â§Â¨Â©Ã—Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ã·Â»Â¼Â½Â¾Â¿Ö°Ö±Ö²Ö³Ö´ÖµÖ¶Ö·Ö¸Ö¹ÖºÖ»Ö¼Ö½Ö¾Ö¿×€××‚×ƒ×°×±×²×³×´ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½××‘×’×“×”×•×–×—×˜×™×š×›×œ×××Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½ï¿½â€â€ï¿½"
    },
    win1255: "windows1255",
    cp1255: "windows1255",
    windows1256: {
      type: "_sbcs",
      chars: "â‚¬Ù¾â€šÆ’â€â€¦â€ â€¡Ë†â€°Ù¹â€¹Å’Ú†Ú˜ÚˆÚ¯â€˜â€™â€œâ€â€¢â€“â€”Ú©â„¢Ú‘â€ºÅ“â€Œâ€ÚºÂ ØŒÂ¢Â£Â¤Â¥Â¦Â§Â¨Â©Ú¾Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ø›Â»Â¼Â½Â¾ØŸÛØ¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ã—Ø·Ø¸Ø¹ØºÙ€ÙÙ‚ÙƒÃ Ù„Ã¢Ù…Ù†Ù‡ÙˆÃ§Ã¨Ã©ÃªÃ«Ù‰ÙŠÃ®Ã¯Ù‹ÙŒÙÙÃ´ÙÙÃ·Ù‘Ã¹Ù’Ã»Ã¼â€â€Û’"
    },
    win1256: "windows1256",
    cp1256: "windows1256",
    windows1257: {
      type: "_sbcs",
      chars: "â‚¬ï¿½â€šï¿½â€â€¦â€ â€¡ï¿½â€°ï¿½â€¹ï¿½Â¨Ë‡Â¸ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½Â¯Ë›ï¿½Â ï¿½Â¢Â£Â¤ï¿½Â¦Â§Ã˜Â©Å–Â«Â¬Â­Â®Ã†Â°Â±Â²Â³Â´ÂµÂ¶Â·Ã¸Â¹Å—Â»Â¼Â½Â¾Ã¦Ä„Ä®Ä€Ä†Ã„Ã…Ä˜Ä’ÄŒÃ‰Å¹Ä–Ä¢Ä¶ÄªÄ»Å ÅƒÅ…Ã“ÅŒÃ•Ã–Ã—Å²ÅÅšÅªÃœÅ»Å½ÃŸÄ…Ä¯ÄÄ‡Ã¤Ã¥Ä™Ä“ÄÃ©ÅºÄ—Ä£Ä·Ä«Ä¼Å¡Å„Å†Ã³ÅÃµÃ¶Ã·Å³Å‚Å›Å«Ã¼Å¼Å¾Ë™"
    },
    win1257: "windows1257",
    cp1257: "windows1257",
    windows1258: {
      type: "_sbcs",
      chars: "â‚¬ï¿½â€šÆ’â€â€¦â€ â€¡Ë†â€°ï¿½â€¹Å’ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢ï¿½â€ºÅ“ï¿½ï¿½Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿"
    },
    win1258: "windows1258",
    cp1258: "windows1258",
    iso88591: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    cp28591: "iso88591",
    iso88592: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ Ä„Ë˜ÅÂ¤Ä½ÅšÂ§Â¨Å ÅÅ¤Å¹Â­Å½Å»Â°Ä…Ë›Å‚Â´Ä¾Å›Ë‡Â¸Å¡ÅŸÅ¥ÅºËÅ¾Å¼Å”ÃÃ‚Ä‚Ã„Ä¹Ä†Ã‡ÄŒÃ‰Ä˜Ã‹ÄšÃÃÄÄÅƒÅ‡Ã“Ã”ÅÃ–Ã—Å˜Å®ÃšÅ°ÃœÃÅ¢ÃŸÅ•Ã¡Ã¢ÄƒÃ¤ÄºÄ‡Ã§ÄÃ©Ä™Ã«Ä›Ã­Ã®ÄÄ‘Å„ÅˆÃ³Ã´Å‘Ã¶Ã·Å™Å¯ÃºÅ±Ã¼Ã½Å£Ë™"
    },
    cp28592: "iso88592",
    iso88593: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ Ä¦Ë˜Â£Â¤ï¿½Ä¤Â§Â¨Ä°ÅÄÄ´Â­ï¿½Å»Â°Ä§Â²Â³Â´ÂµÄ¥Â·Â¸Ä±ÅŸÄŸÄµÂ½ï¿½Å¼Ã€ÃÃ‚ï¿½Ã„ÄŠÄˆÃ‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃÃï¿½Ã‘Ã’Ã“Ã”Ä Ã–Ã—ÄœÃ™ÃšÃ›ÃœÅ¬ÅœÃŸÃ Ã¡Ã¢ï¿½Ã¤Ä‹Ä‰Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ï¿½Ã±Ã²Ã³Ã´Ä¡Ã¶Ã·ÄÃ¹ÃºÃ»Ã¼Å­ÅË™"
    },
    cp28593: "iso88593",
    iso88594: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ Ä„Ä¸Å–Â¤Ä¨Ä»Â§Â¨Å Ä’Ä¢Å¦Â­Å½Â¯Â°Ä…Ë›Å—Â´Ä©Ä¼Ë‡Â¸Å¡Ä“Ä£Å§ÅŠÅ¾Å‹Ä€ÃÃ‚ÃƒÃ„Ã…Ã†Ä®ÄŒÃ‰Ä˜Ã‹Ä–ÃÃÄªÄÅ…ÅŒÄ¶Ã”Ã•Ã–Ã—Ã˜Å²ÃšÃ›ÃœÅ¨ÅªÃŸÄÃ¡Ã¢Ã£Ã¤Ã¥Ã¦Ä¯ÄÃ©Ä™Ã«Ä—Ã­Ã®Ä«Ä‘Å†ÅÄ·Ã´ÃµÃ¶Ã·Ã¸Å³ÃºÃ»Ã¼Å©Å«Ë™"
    },
    cp28594: "iso88594",
    iso88595: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ ĞĞ‚ĞƒĞ„Ğ…Ğ†Ğ‡ĞˆĞ‰ĞŠĞ‹ĞŒÂ­ĞĞĞĞ‘Ğ’Ğ“Ğ”Ğ•Ğ–Ğ—Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ Ğ¡Ğ¢Ğ£Ğ¤Ğ¥Ğ¦Ğ§Ğ¨Ğ©ĞªĞ«Ğ¬Ğ­Ğ®Ğ¯Ğ°Ğ±Ğ²Ğ³Ğ´ĞµĞ¶Ğ·Ğ¸Ğ¹ĞºĞ»Ğ¼Ğ½Ğ¾Ğ¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑÑâ„–Ñ‘Ñ’Ñ“Ñ”Ñ•Ñ–Ñ—Ñ˜Ñ™ÑšÑ›ÑœÂ§ÑÑŸ"
    },
    cp28595: "iso88595",
    iso88596: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ ï¿½ï¿½ï¿½Â¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ØŒÂ­ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ø›ï¿½ï¿½ï¿½ØŸï¿½Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·Ø¸Ø¹Øºï¿½ï¿½ï¿½ï¿½ï¿½Ù€ÙÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙ‰ÙŠÙ‹ÙŒÙÙÙÙÙ‘Ù’ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    cp28596: "iso88596",
    iso88597: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ â€˜â€™Â£â‚¬â‚¯Â¦Â§Â¨Â©ÍºÂ«Â¬Â­ï¿½â€•Â°Â±Â²Â³Î„Î…Î†Â·ÎˆÎ‰ÎŠÂ»ÎŒÂ½ÎÎÎÎ‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎÎŸÎ Î¡ï¿½Î£Î¤Î¥Î¦Î§Î¨Î©ÎªÎ«Î¬Î­Î®Î¯Î°Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏ‚ÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰ÏŠÏ‹ÏŒÏÏï¿½"
    },
    cp28597: "iso88597",
    iso88598: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ ï¿½Â¢Â£Â¤Â¥Â¦Â§Â¨Â©Ã—Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ã·Â»Â¼Â½Â¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â€—××‘×’×“×”×•×–×—×˜×™×š×›×œ×××Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½ï¿½â€â€ï¿½"
    },
    cp28598: "iso88598",
    iso88599: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃÃÄÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÄ°ÅÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÄŸÃ±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ä±ÅŸÃ¿"
    },
    cp28599: "iso88599",
    iso885910: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ Ä„Ä’Ä¢ÄªÄ¨Ä¶Â§Ä»ÄÅ Å¦Å½Â­ÅªÅŠÂ°Ä…Ä“Ä£Ä«Ä©Ä·Â·Ä¼Ä‘Å¡Å§Å¾â€•Å«Å‹Ä€ÃÃ‚ÃƒÃ„Ã…Ã†Ä®ÄŒÃ‰Ä˜Ã‹Ä–ÃÃÃÃÅ…ÅŒÃ“Ã”Ã•Ã–Å¨Ã˜Å²ÃšÃ›ÃœÃÃÃŸÄÃ¡Ã¢Ã£Ã¤Ã¥Ã¦Ä¯ÄÃ©Ä™Ã«Ä—Ã­Ã®Ã¯Ã°Å†ÅÃ³Ã´ÃµÃ¶Å©Ã¸Å³ÃºÃ»Ã¼Ã½Ã¾Ä¸"
    },
    cp28600: "iso885910",
    iso885911: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸à¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸à¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹à¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    },
    cp28601: "iso885911",
    iso885913: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ â€Â¢Â£Â¤â€Â¦Â§Ã˜Â©Å–Â«Â¬Â­Â®Ã†Â°Â±Â²Â³â€œÂµÂ¶Â·Ã¸Â¹Å—Â»Â¼Â½Â¾Ã¦Ä„Ä®Ä€Ä†Ã„Ã…Ä˜Ä’ÄŒÃ‰Å¹Ä–Ä¢Ä¶ÄªÄ»Å ÅƒÅ…Ã“ÅŒÃ•Ã–Ã—Å²ÅÅšÅªÃœÅ»Å½ÃŸÄ…Ä¯ÄÄ‡Ã¤Ã¥Ä™Ä“ÄÃ©ÅºÄ—Ä£Ä·Ä«Ä¼Å¡Å„Å†Ã³ÅÃµÃ¶Ã·Å³Å‚Å›Å«Ã¼Å¼Å¾â€™"
    },
    cp28603: "iso885913",
    iso885914: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ á¸‚á¸ƒÂ£ÄŠÄ‹á¸ŠÂ§áº€Â©áº‚á¸‹á»²Â­Â®Å¸á¸á¸ŸÄ Ä¡á¹€á¹Â¶á¹–áºá¹—áºƒá¹ á»³áº„áº…á¹¡Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃÃÅ´Ã‘Ã’Ã“Ã”Ã•Ã–á¹ªÃ˜Ã™ÃšÃ›ÃœÃÅ¶ÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÅµÃ±Ã²Ã³Ã´ÃµÃ¶á¹«Ã¸Ã¹ÃºÃ»Ã¼Ã½Å·Ã¿"
    },
    cp28604: "iso885914",
    iso885915: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ Â¡Â¢Â£â‚¬Â¥Å Â§Å¡Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å½ÂµÂ¶Â·Å¾Â¹ÂºÂ»Å’Å“Å¸Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    cp28605: "iso885915",
    iso885916: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ Ä„Ä…Åâ‚¬â€Å Â§Å¡Â©È˜Â«Å¹Â­ÅºÅ»Â°Â±ÄŒÅ‚Å½â€Â¶Â·Å¾ÄÈ™Â»Å’Å“Å¸Å¼Ã€ÃÃ‚Ä‚Ã„Ä†Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃÃÄÅƒÃ’Ã“Ã”ÅÃ–ÅšÅ°Ã™ÃšÃ›ÃœÄ˜ÈšÃŸÃ Ã¡Ã¢ÄƒÃ¤Ä‡Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ä‘Å„Ã²Ã³Ã´Å‘Ã¶Å›Å±Ã¹ÃºÃ»Ã¼Ä™È›Ã¿"
    },
    cp28606: "iso885916",
    cp437: {
      type: "_sbcs",
      chars: "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÂ¢Â£Â¥â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•â•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    ibm437: "cp437",
    csibm437: "cp437",
    cp737: {
      type: "_sbcs",
      chars: "Î‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎÎŸÎ Î¡Î£Î¤Î¥Î¦Î§Î¨Î©Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏƒÏ‚Ï„Ï…Ï†Ï‡Ïˆâ–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•â•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ï‰Î¬Î­Î®ÏŠÎ¯ÏŒÏÏ‹ÏÎ†ÎˆÎ‰ÎŠÎŒÎÎÂ±â‰¥â‰¤ÎªÎ«Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    ibm737: "cp737",
    csibm737: "cp737",
    cp775: {
      type: "_sbcs",
      chars: "Ä†Ã¼Ã©ÄÃ¤Ä£Ã¥Ä‡Å‚Ä“Å–Å—Ä«Å¹Ã„Ã…Ã‰Ã¦Ã†ÅÃ¶Ä¢Â¢ÅšÅ›Ã–ÃœÃ¸Â£Ã˜Ã—Â¤Ä€ÄªÃ³Å»Å¼Åºâ€Â¦Â©Â®Â¬Â½Â¼ÅÂ«Â»â–‘â–’â–“â”‚â”¤Ä„ÄŒÄ˜Ä–â•£â•‘â•—â•Ä®Å â”â””â”´â”¬â”œâ”€â”¼Å²Åªâ•šâ•”â•©â•¦â• â•â•¬Å½Ä…ÄÄ™Ä—Ä¯Å¡Å³Å«Å¾â”˜â”Œâ–ˆâ–„â–Œâ–â–€Ã“ÃŸÅŒÅƒÃµÃ•ÂµÅ„Ä¶Ä·Ä»Ä¼Å†Ä’Å…â€™Â­Â±â€œÂ¾Â¶Â§Ã·â€Â°âˆ™Â·Â¹Â³Â²â– Â "
    },
    ibm775: "cp775",
    csibm775: "cp775",
    cp850: {
      type: "_sbcs",
      chars: "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜Ã—Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ã°ÃÃŠÃ‹ÃˆÄ±ÃÃÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•ÂµÃ¾ÃÃšÃ›Ã™Ã½ÃÂ¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    ibm850: "cp850",
    csibm850: "cp850",
    cp852: {
      type: "_sbcs",
      chars: "Ã‡Ã¼Ã©Ã¢Ã¤Å¯Ä‡Ã§Å‚Ã«ÅÅ‘Ã®Å¹Ã„Ä†Ã‰Ä¹ÄºÃ´Ã¶Ä½Ä¾ÅšÅ›Ã–ÃœÅ¤Å¥ÅÃ—ÄÃ¡Ã­Ã³ÃºÄ„Ä…Å½Å¾Ä˜Ä™Â¬ÅºÄŒÅŸÂ«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚ÄšÅâ•£â•‘â•—â•Å»Å¼â”â””â”´â”¬â”œâ”€â”¼Ä‚Äƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ä‘ÄÄÃ‹ÄÅ‡ÃÃÄ›â”˜â”Œâ–ˆâ–„Å¢Å®â–€Ã“ÃŸÃ”ÅƒÅ„ÅˆÅ Å¡Å”ÃšÅ•Å°Ã½ÃÅ£Â´Â­ËË›Ë‡Ë˜Â§Ã·Â¸Â°Â¨Ë™Å±Å˜Å™â– Â "
    },
    ibm852: "cp852",
    csibm852: "cp852",
    cp855: {
      type: "_sbcs",
      chars: "Ñ’Ğ‚Ñ“ĞƒÑ‘ĞÑ”Ğ„Ñ•Ğ…Ñ–Ğ†Ñ—Ğ‡Ñ˜ĞˆÑ™Ğ‰ÑšĞŠÑ›Ğ‹ÑœĞŒÑĞÑŸĞÑĞ®ÑŠĞªĞ°ĞĞ±Ğ‘Ñ†Ğ¦Ğ´Ğ”ĞµĞ•Ñ„Ğ¤Ğ³Ğ“Â«Â»â–‘â–’â–“â”‚â”¤Ñ…Ğ¥Ğ¸Ğ˜â•£â•‘â•—â•Ğ¹Ğ™â”â””â”´â”¬â”œâ”€â”¼ĞºĞšâ•šâ•”â•©â•¦â• â•â•¬Â¤Ğ»Ğ›Ğ¼ĞœĞ½ĞĞ¾ĞĞ¿â”˜â”Œâ–ˆâ–„ĞŸÑâ–€Ğ¯Ñ€Ğ ÑĞ¡Ñ‚Ğ¢ÑƒĞ£Ğ¶Ğ–Ğ²Ğ’ÑŒĞ¬â„–Â­Ñ‹Ğ«Ğ·Ğ—ÑˆĞ¨ÑĞ­Ñ‰Ğ©Ñ‡Ğ§Â§â– Â "
    },
    ibm855: "cp855",
    csibm855: "cp855",
    cp856: {
      type: "_sbcs",
      chars: "××‘×’×“×”×•×–×—×˜×™×š×›×œ×××Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½Â£ï¿½Ã—ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â®Â¬Â½Â¼ï¿½Â«Â»â–‘â–’â–“â”‚â”¤ï¿½ï¿½ï¿½Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼ï¿½ï¿½â•šâ•”â•©â•¦â• â•â•¬Â¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â”˜â”Œâ–ˆâ–„Â¦ï¿½â–€ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Âµï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    ibm856: "cp856",
    csibm856: "cp856",
    cp857: {
      type: "_sbcs",
      chars: "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ä±Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ä°Ã–ÃœÃ¸Â£Ã˜ÅÅŸÃ¡Ã­Ã³ÃºÃ±Ã‘ÄÄŸÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤ÂºÂªÃŠÃ‹Ãˆï¿½ÃÃÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•Âµï¿½Ã—ÃšÃ›Ã™Ã¬Ã¿Â¯Â´Â­Â±ï¿½Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    ibm857: "cp857",
    csibm857: "cp857",
    cp858: {
      type: "_sbcs",
      chars: "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜Ã—Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ã°ÃÃŠÃ‹Ãˆâ‚¬ÃÃÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•ÂµÃ¾ÃÃšÃ›Ã™Ã½ÃÂ¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    ibm858: "cp858",
    csibm858: "cp858",
    cp860: {
      type: "_sbcs",
      chars: "Ã‡Ã¼Ã©Ã¢Ã£Ã ÃÃ§ÃªÃŠÃ¨ÃÃ”Ã¬ÃƒÃ‚Ã‰Ã€ÃˆÃ´ÃµÃ²ÃšÃ¹ÃŒÃ•ÃœÂ¢Â£Ã™â‚§Ã“Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Ã’Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•â•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    ibm860: "cp860",
    csibm860: "cp860",
    cp861: {
      type: "_sbcs",
      chars: "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨ÃÃ°ÃÃ„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã¾Ã»ÃÃ½Ã–ÃœÃ¸Â£Ã˜â‚§Æ’Ã¡Ã­Ã³ÃºÃÃÃ“ÃšÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•â•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    ibm861: "cp861",
    csibm861: "cp861",
    cp862: {
      type: "_sbcs",
      chars: "××‘×’×“×”×•×–×—×˜×™×š×›×œ×××Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªÂ¢Â£Â¥â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•â•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    ibm862: "cp862",
    csibm862: "cp862",
    cp863: {
      type: "_sbcs",
      chars: "Ã‡Ã¼Ã©Ã¢Ã‚Ã Â¶Ã§ÃªÃ«Ã¨Ã¯Ã®â€—Ã€Â§Ã‰ÃˆÃŠÃ´Ã‹ÃÃ»Ã¹Â¤Ã”ÃœÂ¢Â£Ã™Ã›Æ’Â¦Â´Ã³ÃºÂ¨Â¸Â³Â¯ÃâŒÂ¬Â½Â¼Â¾Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•â•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    ibm863: "cp863",
    csibm863: "cp863",
    cp864: {
      type: "_sbcs",
      chars: "\0\b	\n\v\f\r !\"#$Ùª&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~Â°Â·âˆ™âˆšâ–’â”€â”‚â”¼â”¤â”¬â”œâ”´â”â”Œâ””â”˜Î²âˆÏ†Â±Â½Â¼â‰ˆÂ«Â»ï»·ï»¸ï¿½ï¿½ï»»ï»¼ï¿½Â Â­ïº‚Â£Â¤ïº„ï¿½ï¿½ïºïºïº•ïº™ØŒïºïº¡ïº¥Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©ï»‘Ø›ïº±ïºµïº¹ØŸÂ¢ïº€ïºïºƒïº…ï»Šïº‹ïºïº‘ïº“ïº—ïº›ïºŸïº£ïº§ïº©ïº«ïº­ïº¯ïº³ïº·ïº»ïº¿ï»ï»…ï»‹ï»Â¦Â¬Ã·Ã—ï»‰Ù€ï»“ï»—ï»›ï»Ÿï»£ï»§ï»«ï»­ï»¯ï»³ïº½ï»Œï»ï»ï»¡ï¹½Ù‘ï»¥ï»©ï»¬ï»°ï»²ï»ï»•ï»µï»¶ï»ï»™ï»±â– ï¿½"
    },
    ibm864: "cp864",
    csibm864: "cp864",
    cp865: {
      type: "_sbcs",
      chars: "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â¤â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•â•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    ibm865: "cp865",
    csibm865: "cp865",
    cp866: {
      type: "_sbcs",
      chars: "ĞĞ‘Ğ’Ğ“Ğ”Ğ•Ğ–Ğ—Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ Ğ¡Ğ¢Ğ£Ğ¤Ğ¥Ğ¦Ğ§Ğ¨Ğ©ĞªĞ«Ğ¬Ğ­Ğ®Ğ¯Ğ°Ğ±Ğ²Ğ³Ğ´ĞµĞ¶Ğ·Ğ¸Ğ¹ĞºĞ»Ğ¼Ğ½Ğ¾Ğ¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•â•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑÑĞÑ‘Ğ„Ñ”Ğ‡Ñ—ĞÑÂ°âˆ™Â·âˆšâ„–Â¤â– Â "
    },
    ibm866: "cp866",
    csibm866: "cp866",
    cp869: {
      type: "_sbcs",
      chars: "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Î†ï¿½Â·Â¬Â¦â€˜â€™Îˆâ€•Î‰ÎŠÎªÎŒï¿½ï¿½ÎÎ«Â©ÎÂ²Â³Î¬Â£Î­Î®Î¯ÏŠÎÏŒÏÎ‘Î’Î“Î”Î•Î–Î—Â½Î˜Î™Â«Â»â–‘â–’â–“â”‚â”¤ÎšÎ›ÎœÎâ•£â•‘â•—â•ÎÎŸâ”â””â”´â”¬â”œâ”€â”¼Î Î¡â•šâ•”â•©â•¦â• â•â•¬Î£Î¤Î¥Î¦Î§Î¨Î©Î±Î²Î³â”˜â”Œâ–ˆâ–„Î´Îµâ–€Î¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏƒÏ‚Ï„Î„Â­Â±Ï…Ï†Ï‡Â§ÏˆÎ…Â°Â¨Ï‰Ï‹Î°Ïâ– Â "
    },
    ibm869: "cp869",
    csibm869: "cp869",
    cp922: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®â€¾Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃÃÅ Ã‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÅ½ÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Å¡Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Å¾Ã¿"
    },
    ibm922: "cp922",
    csibm922: "cp922",
    cp1046: {
      type: "_sbcs",
      chars: "ïºˆÃ—Ã·ï£¶ï£µï£´ï£·ï¹±Âˆâ– â”‚â”€â”â”Œâ””â”˜ï¹¹ï¹»ï¹½ï¹¿ï¹·ïºŠï»°ï»³ï»²ï»ï»ï»ï»¶ï»¸ï»ºï»¼Â ï£ºï£¹ï£¸Â¤ï£»ïº‹ïº‘ïº—ïº›ïºŸïº£ØŒÂ­ïº§ïº³Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©ïº·Ø›ïº»ïº¿ï»ŠØŸï»‹Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·ï»‡Ø¹Øºï»Œïº‚ïº„ïºï»“Ù€ÙÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙ‰ÙŠÙ‹ÙŒÙÙÙÙÙ‘Ù’ï»—ï»›ï»Ÿï£¼ï»µï»·ï»¹ï»»ï»£ï»§ï»¬ï»©ï¿½"
    },
    ibm1046: "cp1046",
    csibm1046: "cp1046",
    cp1124: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ ĞĞ‚ÒĞ„Ğ…Ğ†Ğ‡ĞˆĞ‰ĞŠĞ‹ĞŒÂ­ĞĞĞĞ‘Ğ’Ğ“Ğ”Ğ•Ğ–Ğ—Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ Ğ¡Ğ¢Ğ£Ğ¤Ğ¥Ğ¦Ğ§Ğ¨Ğ©ĞªĞ«Ğ¬Ğ­Ğ®Ğ¯Ğ°Ğ±Ğ²Ğ³Ğ´ĞµĞ¶Ğ·Ğ¸Ğ¹ĞºĞ»Ğ¼Ğ½Ğ¾Ğ¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑÑâ„–Ñ‘Ñ’Ò‘Ñ”Ñ•Ñ–Ñ—Ñ˜Ñ™ÑšÑ›ÑœÂ§ÑÑŸ"
    },
    ibm1124: "cp1124",
    csibm1124: "cp1124",
    cp1125: {
      type: "_sbcs",
      chars: "ĞĞ‘Ğ’Ğ“Ğ”Ğ•Ğ–Ğ—Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ Ğ¡Ğ¢Ğ£Ğ¤Ğ¥Ğ¦Ğ§Ğ¨Ğ©ĞªĞ«Ğ¬Ğ­Ğ®Ğ¯Ğ°Ğ±Ğ²Ğ³Ğ´ĞµĞ¶Ğ·Ğ¸Ğ¹ĞºĞ»Ğ¼Ğ½Ğ¾Ğ¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•â•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑÑĞÑ‘ÒÒ‘Ğ„Ñ”Ğ†Ñ–Ğ‡Ñ—Â·âˆšâ„–Â¤â– Â "
    },
    ibm1125: "cp1125",
    csibm1125: "cp1125",
    cp1129: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Å“Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å¸ÂµÂ¶Â·Å’Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿"
    },
    ibm1129: "cp1129",
    csibm1129: "cp1129",
    cp1133: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ àºàº‚àº„àº‡àºˆàºªàºŠàºàº”àº•àº–àº—àº™àºšàº›àºœàºàºàºŸàº¡àº¢àº£àº¥àº§àº«àº­àº®ï¿½ï¿½ï¿½àº¯àº°àº²àº³àº´àºµàº¶àº·àº¸àº¹àº¼àº±àº»àº½ï¿½ï¿½ï¿½à»€à»à»‚à»ƒà»„à»ˆà»‰à»Šà»‹à»Œà»à»†ï¿½à»œà»â‚­ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à»à»‘à»’à»“à»”à»•à»–à»—à»˜à»™ï¿½ï¿½Â¢Â¬Â¦ï¿½"
    },
    ibm1133: "cp1133",
    csibm1133: "cp1133",
    cp1161: {
      type: "_sbcs",
      chars: "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à¹ˆà¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸à¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸à¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºà¹‰à¹Šà¹‹â‚¬à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹à¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›Â¢Â¬Â¦Â "
    },
    ibm1161: "cp1161",
    csibm1161: "cp1161",
    cp1162: {
      type: "_sbcs",
      chars: "â‚¬ÂÂ‚ÂƒÂ„â€¦Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂâ€˜â€™â€œâ€â€¢â€“â€”Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸à¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸à¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹à¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    },
    ibm1162: "cp1162",
    csibm1162: "cp1162",
    cp1163: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ Â¡Â¢Â£â‚¬Â¥Â¦Â§Å“Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å¸ÂµÂ¶Â·Å’Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿"
    },
    ibm1163: "cp1163",
    csibm1163: "cp1163",
    maccroatian: {
      type: "_sbcs",
      chars: "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Å â„¢Â´Â¨â‰ Å½Ã˜âˆÂ±â‰¤â‰¥âˆ†Âµâˆ‚âˆ‘âˆÅ¡âˆ«ÂªÂºâ„¦Å¾Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆÄ†Â«ÄŒâ€¦Â Ã€ÃƒÃ•Å’Å“Äâ€”â€œâ€â€˜â€™Ã·â—Šï¿½Â©â„Â¤â€¹â€ºÃ†Â»â€“Â·â€šâ€â€°Ã‚Ä‡ÃÄÃˆÃÃÃÃŒÃ“Ã”Ä‘Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ï€Ã‹ËšÂ¸ÃŠÃ¦Ë‡"
    },
    maccyrillic: {
      type: "_sbcs",
      chars: "ĞĞ‘Ğ’Ğ“Ğ”Ğ•Ğ–Ğ—Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ Ğ¡Ğ¢Ğ£Ğ¤Ğ¥Ğ¦Ğ§Ğ¨Ğ©ĞªĞ«Ğ¬Ğ­Ğ®Ğ¯â€ Â°Â¢Â£Â§â€¢Â¶Ğ†Â®Â©â„¢Ğ‚Ñ’â‰ ĞƒÑ“âˆÂ±â‰¤â‰¥Ñ–Âµâˆ‚ĞˆĞ„Ñ”Ğ‡Ñ—Ğ‰Ñ™ĞŠÑšÑ˜Ğ…Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ğ‹Ñ›ĞŒÑœÑ•â€“â€”â€œâ€â€˜â€™Ã·â€ĞÑĞÑŸâ„–ĞÑ‘ÑĞ°Ğ±Ğ²Ğ³Ğ´ĞµĞ¶Ğ·Ğ¸Ğ¹ĞºĞ»Ğ¼Ğ½Ğ¾Ğ¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑÂ¤"
    },
    macgreek: {
      type: "_sbcs",
      chars: "Ã„Â¹Â²Ã‰Â³Ã–ÃœÎ…Ã Ã¢Ã¤Î„Â¨Ã§Ã©Ã¨ÃªÃ«Â£â„¢Ã®Ã¯â€¢Â½â€°Ã´Ã¶Â¦Â­Ã¹Ã»Ã¼â€ Î“Î”Î˜Î›ÎÎ ÃŸÂ®Â©Î£ÎªÂ§â‰ Â°Î‡Î‘Â±â‰¤â‰¥Â¥Î’Î•Î–Î—Î™ÎšÎœÎ¦Î«Î¨Î©Î¬ÎÂ¬ÎŸÎ¡â‰ˆÎ¤Â«Â»â€¦Â Î¥Î§Î†ÎˆÅ“â€“â€•â€œâ€â€˜â€™Ã·Î‰ÎŠÎŒÎÎ­Î®Î¯ÏŒÎÏÎ±Î²ÏˆÎ´ÎµÏ†Î³Î·Î¹Î¾ÎºÎ»Î¼Î½Î¿Ï€ÏÏÏƒÏ„Î¸Ï‰Ï‚Ï‡Ï…Î¶ÏŠÏ‹ÎÎ°ï¿½"
    },
    maciceland: {
      type: "_sbcs",
      chars: "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼ÃÂ°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤ÃÃ°ÃÃ¾Ã½Â·â€šâ€â€°Ã‚ÃŠÃÃ‹ÃˆÃÃÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    macroman: {
      type: "_sbcs",
      chars: "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºï¬ï¬‚â€¡Â·â€šâ€â€°Ã‚ÃŠÃÃ‹ÃˆÃÃÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    macromania: {
      type: "_sbcs",
      chars: "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ä‚ÅâˆÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦ÄƒÅŸÂ¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºÅ¢Å£â€¡Â·â€šâ€â€°Ã‚ÃŠÃÃ‹ÃˆÃÃÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    macthai: {
      type: "_sbcs",
      chars: "Â«Â»â€¦ï¢Œï¢ï¢’ï¢•ï¢˜ï¢‹ï¢ï¢‘ï¢”ï¢—â€œâ€ï¢™ï¿½â€¢ï¢„ï¢‰ï¢…ï¢†ï¢‡ï¢ˆï¢Šï¢ï¢ï¢“ï¢–â€˜â€™ï¿½Â à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸à¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸à¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï»¿â€‹â€“â€”à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹â„¢à¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™Â®Â©ï¿½ï¿½ï¿½ï¿½"
    },
    macturkish: {
      type: "_sbcs",
      chars: "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸ÄÄŸÄ°Ä±ÅÅŸâ€¡Â·â€šâ€â€°Ã‚ÃŠÃÃ‹ÃˆÃÃÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™ï¿½Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    macukraine: {
      type: "_sbcs",
      chars: "ĞĞ‘Ğ’Ğ“Ğ”Ğ•Ğ–Ğ—Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ Ğ¡Ğ¢Ğ£Ğ¤Ğ¥Ğ¦Ğ§Ğ¨Ğ©ĞªĞ«Ğ¬Ğ­Ğ®Ğ¯â€ Â°ÒÂ£Â§â€¢Â¶Ğ†Â®Â©â„¢Ğ‚Ñ’â‰ ĞƒÑ“âˆÂ±â‰¤â‰¥Ñ–ÂµÒ‘ĞˆĞ„Ñ”Ğ‡Ñ—Ğ‰Ñ™ĞŠÑšÑ˜Ğ…Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ğ‹Ñ›ĞŒÑœÑ•â€“â€”â€œâ€â€˜â€™Ã·â€ĞÑĞÑŸâ„–ĞÑ‘ÑĞ°Ğ±Ğ²Ğ³Ğ´ĞµĞ¶Ğ·Ğ¸Ğ¹ĞºĞ»Ğ¼Ğ½Ğ¾Ğ¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑÂ¤"
    },
    koi8r: {
      type: "_sbcs",
      chars: "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥Â âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘â•“â•”â••â•–â•—â•˜â•™â•šâ•›â•œâ•â•â•Ÿâ• â•¡Ğâ•¢â•£â•¤â•¥â•¦â•§â•¨â•©â•ªâ•«â•¬Â©ÑĞ°Ğ±Ñ†Ğ´ĞµÑ„Ğ³Ñ…Ğ¸Ğ¹ĞºĞ»Ğ¼Ğ½Ğ¾Ğ¿ÑÑ€ÑÑ‚ÑƒĞ¶Ğ²ÑŒÑ‹Ğ·ÑˆÑÑ‰Ñ‡ÑŠĞ®ĞĞ‘Ğ¦Ğ”Ğ•Ğ¤Ğ“Ğ¥Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ¯Ğ Ğ¡Ğ¢Ğ£Ğ–Ğ’Ğ¬Ğ«Ğ—Ğ¨Ğ­Ğ©Ğ§Ğª"
    },
    koi8u: {
      type: "_sbcs",
      chars: "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥Â âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘Ñ”â•”Ñ–Ñ—â•—â•˜â•™â•šâ•›Ò‘â•â•â•Ÿâ• â•¡ĞĞ„â•£Ğ†Ğ‡â•¦â•§â•¨â•©â•ªÒâ•¬Â©ÑĞ°Ğ±Ñ†Ğ´ĞµÑ„Ğ³Ñ…Ğ¸Ğ¹ĞºĞ»Ğ¼Ğ½Ğ¾Ğ¿ÑÑ€ÑÑ‚ÑƒĞ¶Ğ²ÑŒÑ‹Ğ·ÑˆÑÑ‰Ñ‡ÑŠĞ®ĞĞ‘Ğ¦Ğ”Ğ•Ğ¤Ğ“Ğ¥Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ¯Ğ Ğ¡Ğ¢Ğ£Ğ–Ğ’Ğ¬Ğ«Ğ—Ğ¨Ğ­Ğ©Ğ§Ğª"
    },
    koi8ru: {
      type: "_sbcs",
      chars: "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥Â âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘Ñ”â•”Ñ–Ñ—â•—â•˜â•™â•šâ•›Ò‘Ñâ•â•Ÿâ• â•¡ĞĞ„â•£Ğ†Ğ‡â•¦â•§â•¨â•©â•ªÒĞÂ©ÑĞ°Ğ±Ñ†Ğ´ĞµÑ„Ğ³Ñ…Ğ¸Ğ¹ĞºĞ»Ğ¼Ğ½Ğ¾Ğ¿ÑÑ€ÑÑ‚ÑƒĞ¶Ğ²ÑŒÑ‹Ğ·ÑˆÑÑ‰Ñ‡ÑŠĞ®ĞĞ‘Ğ¦Ğ”Ğ•Ğ¤Ğ“Ğ¥Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ¯Ğ Ğ¡Ğ¢Ğ£Ğ–Ğ’Ğ¬Ğ«Ğ—Ğ¨Ğ­Ğ©Ğ§Ğª"
    },
    koi8t: {
      type: "_sbcs",
      chars: "Ò›Ò“â€šÒ’â€â€¦â€ â€¡ï¿½â€°Ò³â€¹Ò²Ò·Ò¶ï¿½Òšâ€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½ï¿½Ó¯Ó®Ñ‘Â¤Ó£Â¦Â§ï¿½ï¿½ï¿½Â«Â¬Â­Â®ï¿½Â°Â±Â²Ğï¿½Ó¢Â¶Â·ï¿½â„–ï¿½Â»ï¿½ï¿½ï¿½Â©ÑĞ°Ğ±Ñ†Ğ´ĞµÑ„Ğ³Ñ…Ğ¸Ğ¹ĞºĞ»Ğ¼Ğ½Ğ¾Ğ¿ÑÑ€ÑÑ‚ÑƒĞ¶Ğ²ÑŒÑ‹Ğ·ÑˆÑÑ‰Ñ‡ÑŠĞ®ĞĞ‘Ğ¦Ğ”Ğ•Ğ¤Ğ“Ğ¥Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ¯Ğ Ğ¡Ğ¢Ğ£Ğ–Ğ’Ğ¬Ğ«Ğ—Ğ¨Ğ­Ğ©Ğ§Ğª"
    },
    armscii8: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ ï¿½Ö‡Ö‰)(Â»Â«â€”.Õ,-ÖŠâ€¦ÕœÕ›ÕÔ±Õ¡Ô²Õ¢Ô³Õ£Ô´Õ¤ÔµÕ¥Ô¶Õ¦Ô·Õ§Ô¸Õ¨Ô¹Õ©ÔºÕªÔ»Õ«Ô¼Õ¬Ô½Õ­Ô¾Õ®Ô¿Õ¯Õ€Õ°ÕÕ±Õ‚Õ²ÕƒÕ³Õ„Õ´Õ…ÕµÕ†Õ¶Õ‡Õ·ÕˆÕ¸Õ‰Õ¹ÕŠÕºÕ‹Õ»ÕŒÕ¼ÕÕ½ÕÕ¾ÕÕ¿ÕÖ€Õ‘ÖÕ’Ö‚Õ“ÖƒÕ”Ö„Õ•Ö…Õ–Ö†Õšï¿½"
    },
    rk1048: {
      type: "_sbcs",
      chars: "Ğ‚Ğƒâ€šÑ“â€â€¦â€ â€¡â‚¬â€°Ğ‰â€¹ĞŠÒšÒºĞÑ’â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Ñ™â€ºÑšÒ›Ò»ÑŸÂ Ò°Ò±Ó˜Â¤Ó¨Â¦Â§ĞÂ©Ò’Â«Â¬Â­Â®Ò®Â°Â±Ğ†Ñ–Ó©ÂµÂ¶Â·Ñ‘â„–Ò“Â»Ó™Ò¢Ò£Ò¯ĞĞ‘Ğ’Ğ“Ğ”Ğ•Ğ–Ğ—Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ Ğ¡Ğ¢Ğ£Ğ¤Ğ¥Ğ¦Ğ§Ğ¨Ğ©ĞªĞ«Ğ¬Ğ­Ğ®Ğ¯Ğ°Ğ±Ğ²Ğ³Ğ´ĞµĞ¶Ğ·Ğ¸Ğ¹ĞºĞ»Ğ¼Ğ½Ğ¾Ğ¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑÑ"
    },
    tcvn: {
      type: "_sbcs",
      chars: "\0Ãšá»¤á»ªá»¬á»®\b	\n\v\f\rá»¨á»°á»²á»¶á»¸Ãá»´ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~Ã€áº¢ÃƒÃáº áº¶áº¬Ãˆáººáº¼Ã‰áº¸á»†ÃŒá»ˆÄ¨Ãá»ŠÃ’á»Ã•Ã“á»Œá»˜á»œá»á» á»šá»¢Ã™á»¦Å¨Â Ä‚Ã‚ÃŠÃ”Æ Æ¯ÄÄƒÃ¢ÃªÃ´Æ¡Æ°Ä‘áº°Ì€Ì‰ÌƒÌÌ£Ã áº£Ã£Ã¡áº¡áº²áº±áº³áºµáº¯áº´áº®áº¦áº¨áºªáº¤á»€áº·áº§áº©áº«áº¥áº­Ã¨á»‚áº»áº½Ã©áº¹á»á»ƒá»…áº¿á»‡Ã¬á»‰á»„áº¾á»’Ä©Ã­á»‹Ã²á»”á»ÃµÃ³á»á»“á»•á»—á»‘á»™á»á»Ÿá»¡á»›á»£Ã¹á»–á»§Å©Ãºá»¥á»«á»­á»¯á»©á»±á»³á»·á»¹Ã½á»µá»"
    },
    georgianacademy: {
      type: "_sbcs",
      chars: "Â€Ââ€šÆ’â€â€¦â€ â€¡Ë†â€°Å â€¹Å’ÂÂÂÂâ€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ÂÂÅ¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿áƒáƒ‘áƒ’áƒ“áƒ”áƒ•áƒ–áƒ—áƒ˜áƒ™áƒšáƒ›áƒœáƒáƒáƒŸáƒ áƒ¡áƒ¢áƒ£áƒ¤áƒ¥áƒ¦áƒ§áƒ¨áƒ©áƒªáƒ«áƒ¬áƒ­áƒ®áƒ¯áƒ°áƒ±áƒ²áƒ³áƒ´áƒµáƒ¶Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    georgianps: {
      type: "_sbcs",
      chars: "Â€Ââ€šÆ’â€â€¦â€ â€¡Ë†â€°Å â€¹Å’ÂÂÂÂâ€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ÂÂÅ¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿áƒáƒ‘áƒ’áƒ“áƒ”áƒ•áƒ–áƒ±áƒ—áƒ˜áƒ™áƒšáƒ›áƒœáƒ²áƒáƒáƒŸáƒ áƒ¡áƒ¢áƒ³áƒ£áƒ¤áƒ¥áƒ¦áƒ§áƒ¨áƒ©áƒªáƒ«áƒ¬áƒ­áƒ®áƒ´áƒ¯áƒ°áƒµÃ¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    pt154: {
      type: "_sbcs",
      chars: "Ò–Ò’Ó®Ò“â€â€¦Ò¶Ò®Ò²Ò¯Ò Ó¢Ò¢ÒšÒºÒ¸Ò—â€˜â€™â€œâ€â€¢â€“â€”Ò³Ò·Ò¡Ó£Ò£Ò›Ò»Ò¹Â ĞÑĞˆÓ¨Ò˜Ò°Â§ĞÂ©Ó˜Â«Â¬Ó¯Â®ÒœÂ°Ò±Ğ†Ñ–Ò™Ó©Â¶Â·Ñ‘â„–Ó™Â»Ñ˜ÒªÒ«ÒĞĞ‘Ğ’Ğ“Ğ”Ğ•Ğ–Ğ—Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ Ğ¡Ğ¢Ğ£Ğ¤Ğ¥Ğ¦Ğ§Ğ¨Ğ©ĞªĞ«Ğ¬Ğ­Ğ®Ğ¯Ğ°Ğ±Ğ²Ğ³Ğ´ĞµĞ¶Ğ·Ğ¸Ğ¹ĞºĞ»Ğ¼Ğ½Ğ¾Ğ¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑÑ"
    },
    viscii: {
      type: "_sbcs",
      chars: "\0áº²áº´áºª\b	\n\v\f\rá»¶á»¸á»´ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~áº áº®áº°áº¶áº¤áº¦áº¨áº¬áº¼áº¸áº¾á»€á»‚á»„á»†á»á»’á»”á»–á»˜á»¢á»šá»œá»á»Šá»á»Œá»ˆá»¦Å¨á»¤á»²Ã•áº¯áº±áº·áº¥áº§áº©áº­áº½áº¹áº¿á»á»ƒá»…á»‡á»‘á»“á»•á»—á» Æ á»™á»á»Ÿá»‹á»°á»¨á»ªá»¬Æ¡á»›Æ¯Ã€ÃÃ‚Ãƒáº¢Ä‚áº³áºµÃˆÃ‰ÃŠáººÃŒÃÄ¨á»³Äá»©Ã’Ã“Ã”áº¡á»·á»«á»­Ã™Ãšá»¹á»µÃá»¡Æ°Ã Ã¡Ã¢Ã£áº£Äƒá»¯áº«Ã¨Ã©Ãªáº»Ã¬Ã­Ä©á»‰Ä‘á»±Ã²Ã³Ã´Ãµá»á»á»¥Ã¹ÃºÅ©á»§Ã½á»£á»®"
    },
    iso646cn: {
      type: "_sbcs",
      chars: "\0\b	\n\v\f\r !\"#Â¥%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}â€¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    iso646jp: {
      type: "_sbcs",
      chars: "\0\b	\n\v\f\r !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[Â¥]^_`abcdefghijklmnopqrstuvwxyz{|}â€¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    hproman8: {
      type: "_sbcs",
      chars: "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂÂŸÂ Ã€Ã‚ÃˆÃŠÃ‹ÃÃÂ´Ë‹Ë†Â¨ËœÃ™Ã›â‚¤Â¯ÃÃ½Â°Ã‡Ã§Ã‘Ã±Â¡Â¿Â¤Â£Â¥Â§Æ’Â¢Ã¢ÃªÃ´Ã»Ã¡Ã©Ã³ÃºÃ Ã¨Ã²Ã¹Ã¤Ã«Ã¶Ã¼Ã…Ã®Ã˜Ã†Ã¥Ã­Ã¸Ã¦Ã„Ã¬Ã–ÃœÃ‰Ã¯ÃŸÃ”ÃÃƒÃ£ÃÃ°ÃÃŒÃ“Ã’Ã•ÃµÅ Å¡ÃšÅ¸Ã¿ÃÃ¾Â·ÂµÂ¶Â¾â€”Â¼Â½ÂªÂºÂ«â– Â»Â±ï¿½"
    },
    macintosh: {
      type: "_sbcs",
      chars: "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºï¬ï¬‚â€¡Â·â€šâ€â€°Ã‚ÃŠÃÃ‹ÃˆÃÃÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    ascii: {
      type: "_sbcs",
      chars: "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    tis620: {
      type: "_sbcs",
      chars: "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸à¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸à¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹à¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    }
  };
});

// node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = __commonJS((exports) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  exports._dbcs = DBCSCodec;
  var UNASSIGNED = -1;
  var GB18030_CODE = -2;
  var SEQ_START = -10;
  var NODE_START = -1e3;
  var UNASSIGNED_NODE = new Array(256);
  var DEF_CHAR = -1;
  for (var i2 = 0; i2 < 256; i2++)
    UNASSIGNED_NODE[i2] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i3 = 0; i3 < mappingTable.length; i3++)
      this._addDecodeChunk(mappingTable[i3]);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var commonThirdByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var commonFourthByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var firstByteNode = this.decodeTables[0];
      for (var i3 = 129; i3 <= 254; i3++) {
        var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i3]];
        for (var j2 = 48; j2 <= 57; j2++) {
          if (secondByteNode[j2] === UNASSIGNED) {
            secondByteNode[j2] = NODE_START - commonThirdByteNodeIdx;
          } else if (secondByteNode[j2] > NODE_START) {
            throw new Error("gb18030 decode tables conflict at byte 2");
          }
          var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j2]];
          for (var k2 = 129; k2 <= 254; k2++) {
            if (thirdByteNode[k2] === UNASSIGNED) {
              thirdByteNode[k2] = NODE_START - commonFourthByteNodeIdx;
            } else if (thirdByteNode[k2] === NODE_START - commonFourthByteNodeIdx) {
              continue;
            } else if (thirdByteNode[k2] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 3");
            }
            var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k2]];
            for (var l2 = 48; l2 <= 57; l2++) {
              if (fourthByteNode[l2] === UNASSIGNED)
                fourthByteNode[l2] = GB18030_CODE;
            }
          }
        }
      }
    }
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i3 = 0; i3 < codecOptions.encodeSkipVals.length; i3++) {
        var val = codecOptions.encodeSkipVals[i3];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j2 = val.from; j2 <= val.to; j2++)
            skipEncodeChars[j2] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = "?".charCodeAt(0);
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>>= 8)
      bytes.push(addr & 255);
    if (bytes.length == 0)
      bytes.push(0);
    var node = this.decodeTables[0];
    for (var i3 = bytes.length - 1; i3 > 0; i3--) {
      var val = node[bytes[i3]];
      if (val == UNASSIGNED) {
        node[bytes[i3]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k2 = 1; k2 < chunk.length; k2++) {
      var part = chunk[k2];
      if (typeof part === "string") {
        for (var l2 = 0; l2 < part.length; ) {
          var code = part.charCodeAt(l2++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l2++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq = [];
            for (var m2 = 0; m2 < len; m2++)
              seq.push(part.charCodeAt(l2++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l2 = 0; l2 < part; l2++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === void 0)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node;
    if (bucket[low] <= SEQ_START) {
      node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node = {};
      if (bucket[low] !== UNASSIGNED)
        node[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node);
    }
    for (var j2 = 1; j2 < seq.length - 1; j2++) {
      var oldVal = node[uCode];
      if (typeof oldVal === "object")
        node = oldVal;
      else {
        node = node[uCode] = {};
        if (oldVal !== void 0)
          node[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for (var i3 = 0; i3 < 256; i3++) {
      var uCode = node[i3];
      var mbCode = prefix + i3;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0) {
        this._setEncodeChar(uCode, mbCode);
        hasValues = true;
      } else if (uCode <= NODE_START) {
        var subNodeIdx = NODE_START - uCode;
        if (!subNodeEmpty[subNodeIdx]) {
          var newPrefix = mbCode << 8 >>> 0;
          if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
            hasValues = true;
          else
            subNodeEmpty[subNodeIdx] = true;
        }
      } else if (uCode <= SEQ_START) {
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        hasValues = true;
      }
    }
    return hasValues;
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = void 0;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i3 = 0, j2 = 0;
    while (true) {
      if (nextChar === -1) {
        if (i3 == str.length)
          break;
        var uCode = str.charCodeAt(i3++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == void 0) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== void 0) {
            dbcsCode = resCode;
            nextChar = uCode;
          } else {
          }
        }
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j2++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j2++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j2++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j2++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j2++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j2++] = dbcsCode >> 8;
        newBuf[j2++] = dbcsCode & 255;
      } else if (dbcsCode < 16777216) {
        newBuf[j2++] = dbcsCode >> 16;
        newBuf[j2++] = dbcsCode >> 8 & 255;
        newBuf[j2++] = dbcsCode & 255;
      } else {
        newBuf[j2++] = dbcsCode >>> 24;
        newBuf[j2++] = dbcsCode >>> 16 & 255;
        newBuf[j2++] = dbcsCode >>> 8 & 255;
        newBuf[j2++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j2);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === void 0)
      return;
    var newBuf = Buffer2.alloc(10), j2 = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== void 0) {
        if (dbcsCode < 256) {
          newBuf[j2++] = dbcsCode;
        } else {
          newBuf[j2++] = dbcsCode >> 8;
          newBuf[j2++] = dbcsCode & 255;
        }
      } else {
      }
      this.seqObj = void 0;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j2++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j2);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBytes = [];
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
    for (var i3 = 0, j2 = 0; i3 < buf.length; i3++) {
      var curByte = i3 >= 0 ? buf[i3] : prevBytes[i3 + prevOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) {
      } else if (uCode === UNASSIGNED) {
        uCode = this.defaultCharUnicode.charCodeAt(0);
        i3 = seqStart;
      } else if (uCode === GB18030_CODE) {
        if (i3 >= 3) {
          var ptr = (buf[i3 - 3] - 129) * 12600 + (buf[i3 - 2] - 48) * 1260 + (buf[i3 - 1] - 129) * 10 + (curByte - 48);
        } else {
          var ptr = (prevBytes[i3 - 3 + prevOffset] - 129) * 12600 + ((i3 - 2 >= 0 ? buf[i3 - 2] : prevBytes[i3 - 2 + prevOffset]) - 48) * 1260 + ((i3 - 1 >= 0 ? buf[i3 - 1] : prevBytes[i3 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
        }
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k2 = 0; k2 < seq.length - 1; k2++) {
          uCode = seq[k2];
          newBuf[j2++] = uCode & 255;
          newBuf[j2++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode >= 65536) {
        uCode -= 65536;
        var uCodeLead = 55296 | uCode >> 10;
        newBuf[j2++] = uCodeLead & 255;
        newBuf[j2++] = uCodeLead >> 8;
        uCode = 56320 | uCode & 1023;
      }
      newBuf[j2++] = uCode & 255;
      newBuf[j2++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i3 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
    return newBuf.slice(0, j2).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBytes.length > 0) {
      ret += this.defaultCharUnicode;
      var bytesArr = this.prevBytes.slice(1);
      this.prevBytes = [];
      this.nodeIdx = 0;
      if (bytesArr.length > 0)
        ret += this.write(bytesArr);
    }
    this.prevBytes = [];
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l2 = 0, r2 = table.length;
    while (l2 < r2 - 1) {
      var mid = l2 + (r2 - l2 + 1 >> 1);
      if (table[mid] <= val)
        l2 = mid;
      else
        r2 = mid;
    }
    return l2;
  }
});

// node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\0", 128],
    ["a1", "ï½¡", 62],
    ["8140", "ã€€ã€ã€‚ï¼Œï¼ãƒ»ï¼šï¼›ï¼Ÿï¼ã‚›ã‚œÂ´ï½€Â¨ï¼¾ï¿£ï¼¿ãƒ½ãƒ¾ã‚ã‚ã€ƒä»ã€…ã€†ã€‡ãƒ¼â€•â€ï¼ï¼¼ï½âˆ¥ï½œâ€¦â€¥â€˜â€™â€œâ€ï¼ˆï¼‰ã€”ã€•ï¼»ï¼½ï½›ï½ã€ˆ", 9, "ï¼‹ï¼Â±Ã—"],
    ["8180", "Ã·ï¼â‰ ï¼œï¼â‰¦â‰§âˆâˆ´â™‚â™€Â°â€²â€³â„ƒï¿¥ï¼„ï¿ ï¿¡ï¼…ï¼ƒï¼†ï¼Šï¼ Â§â˜†â˜…â—‹â—â—â—‡â—†â–¡â– â–³â–²â–½â–¼â€»ã€’â†’â†â†‘â†“ã€“"],
    ["81b8", "âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©"],
    ["81c8", "âˆ§âˆ¨ï¿¢â‡’â‡”âˆ€âˆƒ"],
    ["81da", "âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬"],
    ["81f0", "â„«â€°â™¯â™­â™ªâ€ â€¡Â¶"],
    ["81fc", "â—¯"],
    ["824f", "ï¼", 9],
    ["8260", "ï¼¡", 25],
    ["8281", "ï½", 25],
    ["829f", "ã", 82],
    ["8340", "ã‚¡", 62],
    ["8380", "ãƒ ", 22],
    ["839f", "Î‘", 16, "Î£", 6],
    ["83bf", "Î±", 16, "Ïƒ", 6],
    ["8440", "Ğ", 5, "ĞĞ–", 25],
    ["8470", "Ğ°", 5, "Ñ‘Ğ¶", 7],
    ["8480", "Ğ¾", 17],
    ["849f", "â”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚"],
    ["8740", "â‘ ", 19, "â… ", 9],
    ["875f", "ã‰ãŒ”ãŒ¢ããŒ˜ãŒ§ãŒƒãŒ¶ã‘ã—ãŒãŒ¦ãŒ£ãŒ«ãŠãŒ»ãœããããã„ã¡"],
    ["877e", "ã»"],
    ["8780", "ã€ã€Ÿâ„–ãâ„¡ãŠ¤", 4, "ãˆ±ãˆ²ãˆ¹ã¾ã½ã¼â‰’â‰¡âˆ«âˆ®âˆ‘âˆšâŠ¥âˆ âˆŸâŠ¿âˆµâˆ©âˆª"],
    ["889f", "äºœå”–å¨ƒé˜¿å“€æ„›æŒ¨å§¶é€¢è‘µèŒœç©æ‚ªæ¡æ¸¥æ—­è‘¦èŠ¦é¯µæ¢“åœ§æ–¡æ‰±å®›å§è™»é£´çµ¢ç¶¾é®æˆ–ç²Ÿè¢·å®‰åºµæŒ‰æš—æ¡ˆé—‡éæä»¥ä¼Šä½ä¾å‰å›²å¤·å§”å¨å°‰æƒŸæ„æ…°æ˜“æ¤…ç‚ºç•ç•°ç§»ç¶­ç·¯èƒƒèè¡£è¬‚é•éºåŒ»äº•äº¥åŸŸè‚²éƒç£¯ä¸€å£±æº¢é€¸ç¨²èŒ¨èŠ‹é°¯å…å°å’½å“¡å› å§»å¼•é£²æ·«èƒ¤è”­"],
    ["8940", "é™¢é™°éš éŸ»å‹å³å®‡çƒç¾½è¿‚é›¨å¯éµœçªºä¸‘ç¢“è‡¼æ¸¦å˜˜å”„æ¬è”šé°»å§¥å©æµ¦ç“œé–å™‚äº‘é‹é›²èé¤Œå¡å–¶å¬°å½±æ˜ æ›³æ „æ°¸æ³³æ´©ç‘›ç›ˆç©é ´è‹±è¡›è© é‹­æ¶²ç–«ç›Šé§…æ‚¦è¬è¶Šé–²æ¦å­å††"],
    ["8980", "åœ’å °å¥„å®´å»¶æ€¨æ©æ´æ²¿æ¼”ç‚ç„”ç…™ç‡•çŒ¿ç¸è‰¶è‹‘è–—é é‰›é´›å¡©æ–¼æ±šç”¥å‡¹å¤®å¥¥å¾€å¿œæŠ¼æ—ºæ¨ªæ¬§æ®´ç‹ç¿è¥–é´¬é´é»„å²¡æ²–è»å„„å±‹æ†¶è‡†æ¡¶ç‰¡ä¹™ä¿ºå¸æ©æ¸©ç©éŸ³ä¸‹åŒ–ä»®ä½•ä¼½ä¾¡ä½³åŠ å¯å˜‰å¤å«å®¶å¯¡ç§‘æš‡æœæ¶æ­Œæ²³ç«ç‚ç¦ç¦¾ç¨¼ç®‡èŠ±è‹›èŒ„è·è¯è“è¦èª²å˜©è²¨è¿¦ééœèšŠä¿„å³¨æˆ‘ç‰™ç”»è‡¥èŠ½è›¾è³€é›…é¤“é§•ä»‹ä¼šè§£å›å¡Šå£Šå»»å¿«æ€ªæ‚”æ¢æ‡æˆ’æ‹æ”¹"],
    ["8a40", "é­æ™¦æ¢°æµ·ç°ç•Œçš†çµµèŠ¥èŸ¹é–‹éšè²å‡±åŠ¾å¤–å’³å®³å´–æ…¨æ¦‚æ¶¯ç¢è“‹è¡—è©²é§éª¸æµ¬é¦¨è›™å£æŸ¿è›éˆåŠƒåš‡å„å»“æ‹¡æ’¹æ ¼æ ¸æ®»ç²ç¢ºç©«è¦šè§’èµ«è¼ƒéƒ­é–£éš”é©å­¦å²³æ¥½é¡é¡æ›ç¬ æ¨«"],
    ["8a80", "æ©¿æ¢¶é°æ½Ÿå‰²å–æ°æ‹¬æ´»æ¸‡æ»‘è‘›è¤è½„ä¸”é°¹å¶æ¤›æ¨ºé„æ ªå…œç«ƒè’²é‡œéŒå™›é´¨æ ¢èŒ…è±ç²¥åˆˆè‹…ç“¦ä¹¾ä¾ƒå† å¯’åˆŠå‹˜å‹§å·»å–šå ªå§¦å®Œå®˜å¯›å¹²å¹¹æ‚£æ„Ÿæ…£æ†¾æ›æ•¢æŸ‘æ¡“æ£ºæ¬¾æ­“æ±—æ¼¢æ¾—æ½…ç’°ç”˜ç›£çœ‹ç«¿ç®¡ç°¡ç·©ç¼¶ç¿°è‚è‰¦èè¦³è«Œè²«é‚„é‘‘é–“é–‘é–¢é™¥éŸ“é¤¨èˆ˜ä¸¸å«å²¸å·Œç©ç™Œçœ¼å²©ç¿«è´‹é›é ‘é¡”é¡˜ä¼ä¼å±å–œå™¨åŸºå¥‡å¬‰å¯„å²å¸Œå¹¾å¿Œæ®æœºæ——æ—¢æœŸæ£‹æ£„"],
    ["8b40", "æ©Ÿå¸°æ¯…æ°—æ±½ç•¿ç¥ˆå­£ç¨€ç´€å¾½è¦è¨˜è²´èµ·è»Œè¼é£¢é¨é¬¼äº€å½å„€å¦“å®œæˆ¯æŠ€æ“¬æ¬ºçŠ ç–‘ç¥‡ç¾©èŸ»èª¼è­°æ¬èŠé å‰åƒå–«æ¡”æ©˜è©°ç §æµé»å´å®¢è„šè™é€†ä¸˜ä¹…ä»‡ä¼‘åŠå¸å®®å¼“æ€¥æ•‘"],
    ["8b80", "æœ½æ±‚æ±²æ³£ç¸çƒç©¶çª®ç¬ˆç´šç³¾çµ¦æ—§ç‰›å»å±…å·¨æ‹’æ‹ æŒ™æ¸ è™šè¨±è·é‹¸æ¼ç¦¦é­šäº¨äº«äº¬ä¾›ä¾ åƒ‘å…‡ç«¶å…±å‡¶å”åŒ¡å¿å«å–¬å¢ƒå³¡å¼·å½Šæ€¯ææ­æŒŸæ•™æ©‹æ³ç‹‚ç‹­çŸ¯èƒ¸è„…èˆˆè•éƒ·é¡éŸ¿é¥—é©šä»°å‡å°­æšæ¥­å±€æ›²æ¥µç‰æ¡ç²åƒ…å‹¤å‡å·¾éŒ¦æ–¤æ¬£æ¬½ç´ç¦ç¦½ç­‹ç·ŠèŠ¹èŒè¡¿è¥Ÿè¬¹è¿‘é‡‘åŸéŠ€ä¹å€¶å¥åŒºç‹—ç–çŸ©è‹¦èº¯é§†é§ˆé§’å…·æ„šè™å–°ç©ºå¶å¯“é‡éš…ä¸²æ«›é‡§å±‘å±ˆ"],
    ["8c40", "æ˜çªŸæ²“é´è½¡çªªç†Šéšˆç²‚æ —ç¹°æ¡‘é¬å‹²å›è–«è¨“ç¾¤è»éƒ¡å¦è¢ˆç¥ä¿‚å‚¾åˆ‘å…„å•“åœ­çªå‹å¥‘å½¢å¾„æµæ…¶æ…§æ†©æ²æºæ•¬æ™¯æ¡‚æ¸“ç•¦ç¨½ç³»çµŒç¶™ç¹‹ç½«èŒèŠè›è¨ˆè©£è­¦è»½é šé¶èŠ¸è¿é¯¨"],
    ["8c80", "åŠ‡æˆŸæ’ƒæ¿€éš™æ¡å‚‘æ¬ æ±ºæ½”ç©´çµè¡€è¨£æœˆä»¶å€¹å€¦å¥å…¼åˆ¸å‰£å–§åœå …å«Œå»ºæ†²æ‡¸æ‹³æ²æ¤œæ¨©ç‰½çŠ¬çŒ®ç ”ç¡¯çµ¹çœŒè‚©è¦‹è¬™è³¢è»’é£éµé™ºé¡•é¨“é¹¸å…ƒåŸå³å¹»å¼¦æ¸›æºç„ç¾çµƒèˆ·è¨€è«ºé™ä¹å€‹å¤å‘¼å›ºå§‘å­¤å·±åº«å¼§æˆ¸æ•…æ¯æ¹–ç‹ç³Šè¢´è‚¡èƒ¡è°è™èª‡è·¨éˆ·é›‡é¡§é¼“äº”äº’ä¼åˆå‘‰å¾å¨¯å¾Œå¾¡æ‚Ÿæ¢§æªç‘šç¢èªèª¤è­·é†ä¹é¯‰äº¤ä½¼ä¾¯å€™å€–å…‰å…¬åŠŸåŠ¹å‹¾åšå£å‘"],
    ["8d40", "åå–‰å‘å¢å¥½å­”å­å®å·¥å·§å··å¹¸åºƒåºšåº·å¼˜æ’æ…ŒæŠ—æ‹˜æ§æ”»æ˜‚æ™ƒæ›´æ­æ ¡æ¢—æ§‹æ±Ÿæ´ªæµ©æ¸¯æºç”²çš‡ç¡¬ç¨¿ç³ ç´…ç´˜çµç¶±è€•è€ƒè‚¯è‚±è…”è†èˆªè’è¡Œè¡¡è¬›è²¢è³¼éƒŠé…µé‰±ç ¿é‹¼é–¤é™"],
    ["8d80", "é …é¦™é«˜é´»å‰›åŠ«å·åˆå£•æ‹·æ¿ è±ªè½Ÿéº¹å…‹åˆ»å‘Šå›½ç©€é…·éµ é»’ç„æ¼‰è…°ç”‘å¿½æƒšéª¨ç‹›è¾¼æ­¤é ƒä»Šå›°å¤å¢¾å©šæ¨æ‡‡æ˜æ˜†æ ¹æ¢±æ··ç—•ç´ºè‰®é­‚äº›ä½å‰å”†åµ¯å·¦å·®æŸ»æ²™ç‘³ç ‚è©é–è£Ÿååº§æŒ«å‚µå‚¬å†æœ€å“‰å¡å¦»å®°å½©æ‰æ¡æ ½æ­³æ¸ˆç½é‡‡çŠ€ç •ç ¦ç¥­æ–ç´°èœè£è¼‰éš›å‰¤åœ¨æç½ªè²¡å†´å‚é˜ªå ºæ¦Šè‚´å’²å´åŸ¼ç¢•é·ºä½œå‰Šå’‹æ¾æ˜¨æœ”æŸµçª„ç­–ç´¢éŒ¯æ¡œé®­ç¬¹åŒ™å†Šåˆ·"],
    ["8e40", "å¯Ÿæ‹¶æ’®æ“¦æœ­æ®ºè–©é›‘çšé¯–æŒéŒ†é®«çš¿æ™’ä¸‰å‚˜å‚å±±æƒ¨æ’’æ•£æ¡Ÿç‡¦çŠç”£ç®—çº‚èš•è®ƒè³›é…¸é¤æ–¬æš«æ®‹ä»•ä»”ä¼ºä½¿åˆºå¸å²å—£å››å£«å§‹å§‰å§¿å­å±å¸‚å¸«å¿—æ€æŒ‡æ”¯å­œæ–¯æ–½æ—¨ææ­¢"],
    ["8e80", "æ­»æ°ç…ç¥‰ç§ç³¸ç´™ç´«è‚¢è„‚è‡³è¦–è©è©©è©¦èªŒè«®è³‡è³œé›Œé£¼æ­¯äº‹ä¼¼ä¾å…å­—å¯ºæ…ˆæŒæ™‚æ¬¡æ»‹æ²»çˆ¾ç’½ç—”ç£ç¤ºè€Œè€³è‡ªè’”è¾æ±é¹¿å¼è­˜é´«ç«ºè»¸å®é›«ä¸ƒå±åŸ·å¤±å«‰å®¤æ‚‰æ¹¿æ¼†ç–¾è³ªå®Ÿè”€ç¯ å²æŸ´èŠå±¡è•Šç¸èˆå†™å°„æ¨èµ¦æ–œç…®ç¤¾ç´—è€…è¬è»Šé®è›‡é‚ªå€Ÿå‹ºå°ºæ“ç¼çˆµé…Œé‡ˆéŒ«è‹¥å¯‚å¼±æƒ¹ä¸»å–å®ˆæ‰‹æœ±æ®Šç‹©ç ç¨®è…«è¶£é…’é¦–å„’å—å‘ªå¯¿æˆæ¨¹ç¶¬éœ€å›šåå‘¨"],
    ["8f40", "å®—å°±å·ä¿®æ„æ‹¾æ´²ç§€ç§‹çµ‚ç¹ç¿’è‡­èˆŸè’è¡†è¥²è®è¹´è¼¯é€±é…‹é…¬é›†é†œä»€ä½å……åå¾“æˆæŸ”æ±æ¸‹ç£ç¸¦é‡éŠƒå”å¤™å®¿æ·‘ç¥ç¸®ç²›å¡¾ç†Ÿå‡ºè¡“è¿°ä¿Šå³»æ˜¥ç¬ç«£èˆœé§¿å‡†å¾ªæ—¬æ¥¯æ®‰æ·³"],
    ["8f80", "æº–æ½¤ç›¾ç´”å·¡éµé†‡é †å‡¦åˆæ‰€æš‘æ›™æ¸šåº¶ç·’ç½²æ›¸è–¯è—·è«¸åŠ©å™å¥³åºå¾æ•é‹¤é™¤å‚·å„Ÿå‹åŒ å‡å¬å“¨å•†å”±å˜—å¥¨å¦¾å¨¼å®µå°†å°å°‘å°šåº„åºŠå» å½°æ‰¿æŠ„æ‹›æŒæ·æ˜‡æ˜Œæ˜­æ™¶æ¾æ¢¢æ¨Ÿæ¨µæ²¼æ¶ˆæ¸‰æ¹˜ç„¼ç„¦ç…§ç—‡çœç¡ç¤ç¥¥ç§°ç« ç¬‘ç²§ç´¹è‚–è–è’‹è•‰è¡è£³è¨Ÿè¨¼è©”è©³è±¡è³é†¤é‰¦é¾é˜éšœé˜ä¸Šä¸ˆä¸ä¹—å†—å‰°åŸå ´å£Œå¬¢å¸¸æƒ…æ“¾æ¡æ–æµ„çŠ¶ç•³ç©£è’¸è­²é†¸éŒ å˜±åŸ´é£¾"],
    ["9040", "æ‹­æ¤æ®–ç‡­ç¹”è·è‰²è§¦é£Ÿè•è¾±å°»ä¼¸ä¿¡ä¾µå”‡å¨ å¯å¯©å¿ƒæ…æŒ¯æ–°æ™‹æ£®æ¦›æµ¸æ·±ç”³ç–¹çœŸç¥ç§¦ç´³è‡£èŠ¯è–ªè¦ªè¨ºèº«è¾›é€²é‡éœ‡äººä»åˆƒå¡µå£¬å°‹ç”šå°½è…è¨Šè¿…é™£é­ç¬¥è«é ˆé…¢å›³å¨"],
    ["9080", "é€—å¹å‚å¸¥æ¨æ°´ç‚Šç¡ç²‹ç¿ è¡°é‚é…”éŒéŒ˜éšç‘é«„å´‡åµ©æ•°æ¢è¶¨é››æ®æ‰æ¤™è…é —é›€è£¾æ¾„æ‘ºå¯¸ä¸–ç€¬ç•æ˜¯å‡„åˆ¶å‹¢å§“å¾æ€§æˆæ”¿æ•´æ˜Ÿæ™´æ£²æ –æ­£æ¸…ç‰²ç”Ÿç››ç²¾è–å£°è£½è¥¿èª èª“è«‹é€é†’é’é™æ–‰ç¨è„†éš»å¸­æƒœæˆšæ–¥æ˜”æçŸ³ç©ç±ç¸¾è„Šè²¬èµ¤è·¡è¹Ÿç¢©åˆ‡æ‹™æ¥æ‘‚æŠ˜è¨­çªƒç¯€èª¬é›ªçµ¶èˆŒè‰ä»™å…ˆåƒå å®£å°‚å°–å·æˆ¦æ‰‡æ’°æ “æ ´æ³‰æµ…æ´—æŸ“æ½œç…ç…½æ—‹ç©¿ç®­ç·š"],
    ["9140", "ç¹Šç¾¨è…ºèˆ›èˆ¹è–¦è©®è³è·µé¸é·éŠ­éŠ‘é–ƒé®®å‰å–„æ¼¸ç„¶å…¨ç¦…ç¹•è†³ç³å™Œå¡‘å²¨æªæ›¾æ›½æ¥šç‹™ç–ç–ç¤ç¥–ç§Ÿç²—ç´ çµ„è˜‡è¨´é˜»é¡é¼ åƒ§å‰µåŒå¢å€‰å–ªå£®å¥çˆ½å®‹å±¤åŒæƒ£æƒ³æœæƒæŒ¿æ»"],
    ["9180", "æ“æ—©æ›¹å·£æ§æ§½æ¼•ç‡¥äº‰ç—©ç›¸çª“ç³Ÿç·ç¶œè¡è‰è˜è‘¬è’¼è—»è£…èµ°é€é­é—éœœé¨’åƒå¢—æ†è‡“è”µè´ˆé€ ä¿ƒå´å‰‡å³æ¯æ‰æŸæ¸¬è¶³é€Ÿä¿—å±è³Šæ—ç¶šå’è¢–å…¶æƒå­˜å­«å°Šææ‘éœä»–å¤šå¤ªæ±°è©‘å”¾å •å¦¥æƒ°æ‰“æŸèˆµæ¥•é™€é§„é¨¨ä½“å †å¯¾è€å²±å¸¯å¾…æ€ æ…‹æˆ´æ›¿æ³°æ»èƒè…¿è‹”è¢‹è²¸é€€é€®éšŠé»›é¯›ä»£å°å¤§ç¬¬é†é¡Œé·¹æ»ç€§å“å•„å®…æ‰˜æŠæ‹“æ²¢æ¿¯ç¢è¨—é¸æ¿è«¾èŒ¸å‡§è›¸åª"],
    ["9240", "å©ä½†é”è¾°å¥ªè„±å·½ç«ªè¾¿æ£šè°·ç‹¸é±ˆæ¨½èª°ä¸¹å˜å˜†å¦æ‹…æ¢æ—¦æ­æ·¡æ¹›ç‚­çŸ­ç«¯ç®ªç¶»è€½èƒ†è›‹èª•é›å›£å£‡å¼¾æ–­æš–æª€æ®µç”·è«‡å€¤çŸ¥åœ°å¼›æ¥æ™ºæ± ç—´ç¨šç½®è‡´èœ˜é…é¦³ç¯‰ç•œç«¹ç­‘è“„"],
    ["9280", "é€ç§©çª’èŒ¶å«¡ç€ä¸­ä»²å®™å¿ æŠ½æ˜¼æŸ±æ³¨è™«è¡·è¨»é…é‹³é§æ¨—ç€¦çŒªè‹§è‘—è²¯ä¸å…†å‡‹å–‹å¯µå¸–å¸³åºå¼”å¼µå½«å¾´æ‡²æŒ‘æš¢æœæ½®ç‰’ç”ºçœºè´è„¹è…¸è¶èª¿è«œè¶…è·³éŠšé•·é ‚é³¥å‹…æ—ç›´æœ•æ²ˆçè³ƒé®é™³æ´¥å¢œæ¤æ§Œè¿½éšç—›é€šå¡šæ ‚æ´æ§»ä½ƒæ¼¬æŸ˜è¾»è”¦ç¶´é”æ¤¿æ½°åªå£·å¬¬ç´¬çˆªåŠé‡£é¶´äº­ä½åœåµå‰ƒè²å‘ˆå ¤å®šå¸åº•åº­å»·å¼Ÿæ‚ŒæŠµæŒºææ¢¯æ±€ç¢‡ç¦ç¨‹ç· è‰‡è¨‚è«¦è¹„é€“"],
    ["9340", "é‚¸é„­é‡˜é¼æ³¥æ‘˜æ“¢æ•µæ»´çš„ç¬›é©é‘æººå“²å¾¹æ’¤è½è¿­é‰„å…¸å¡«å¤©å±•åº—æ·»çºç”œè²¼è»¢é¡›ç‚¹ä¼æ®¿æ¾±ç”°é›»å…åå µå¡—å¦¬å± å¾’æ–—æœæ¸¡ç™»èŸè³­é€”éƒ½éç ¥ç ºåŠªåº¦åœŸå¥´æ€’å€’å…šå†¬"],
    ["9380", "å‡åˆ€å”å¡”å¡˜å¥—å®•å³¶å¶‹æ‚¼æŠ•æ­æ±æ¡ƒæ¢¼æ£Ÿç›—æ·˜æ¹¯æ¶›ç¯ç‡ˆå½“ç—˜ç¥·ç­‰ç­”ç­’ç³–çµ±åˆ°è‘£è•©è—¤è¨è¬„è±†è¸é€ƒé€é™é™¶é ­é¨°é—˜åƒå‹•åŒå ‚å°æ†§æ’æ´ç³ç«¥èƒ´è„é“éŠ…å³ é´‡åŒ¿å¾—å¾³æ¶œç‰¹ç£ç¦¿ç¯¤æ¯’ç‹¬èª­æ ƒæ©¡å‡¸çªæ¤´å±Šé³¶è‹«å¯…é…‰ç€å™¸å±¯æƒ‡æ•¦æ²Œè±šéé “å‘‘æ›‡éˆå¥ˆé‚£å†…ä¹å‡ªè–™è¬ç˜æºé‹æ¥¢é¦´ç¸„ç•·å—æ¥ è»Ÿé›£æ±äºŒå°¼å¼è¿©åŒ‚è³‘è‚‰è™¹å»¿æ—¥ä¹³å…¥"],
    ["9440", "å¦‚å°¿éŸ®ä»»å¦Šå¿èªæ¿¡ç¦°ç¥¢å¯§è‘±çŒ«ç†±å¹´å¿µæ»æ’šç‡ƒç²˜ä¹ƒå»¼ä¹‹åŸœåš¢æ‚©æ¿ƒç´èƒ½è„³è†¿è¾²è¦—èš¤å·´æŠŠæ’­è¦‡æ·æ³¢æ´¾ç¶ç ´å©†ç½µèŠ­é¦¬ä¿³å»ƒæ‹æ’æ•—æ¯ç›ƒç‰ŒèƒŒè‚ºè¼©é…å€åŸ¹åª’æ¢…"],
    ["9480", "æ¥³ç…¤ç‹½è²·å£²è³ é™ªé€™è¿ç§¤çŸ§è©ä¼¯å‰¥åšæ‹æŸæ³Šç™½ç®”ç²•èˆ¶è–„è¿«æ›æ¼ çˆ†ç¸›è«é§éº¦å‡½ç®±ç¡²ç®¸è‚‡ç­ˆæ«¨å¹¡è‚Œç•‘ç• å…«é‰¢æºŒç™ºé†—é«ªä¼ç½°æŠœç­é–¥é³©å™ºå¡™è›¤éš¼ä¼´åˆ¤åŠåå›å¸†æ¬æ–‘æ¿æ°¾æ±ç‰ˆçŠ¯ç­ç•”ç¹èˆ¬è—©è²©ç¯„é‡†ç…©é ’é£¯æŒ½æ™©ç•ªç›¤ç£è•ƒè›®åŒªå‘å¦å¦ƒåº‡å½¼æ‚²æ‰‰æ‰¹æŠ«æ–æ¯”æ³Œç–²çš®ç¢‘ç§˜ç·‹ç½·è‚¥è¢«èª¹è²»é¿éé£›æ¨‹ç°¸å‚™å°¾å¾®æ‡æ¯˜çµçœ‰ç¾"],
    ["9540", "é¼»æŸŠç¨—åŒ¹ç–‹é«­å½¦è†è±è‚˜å¼¼å¿…ç•¢ç­†é€¼æ¡§å§«åª›ç´ç™¾è¬¬ä¿µå½ªæ¨™æ°·æ¼‚ç“¢ç¥¨è¡¨è©•è±¹å»Ÿæç—…ç§’è‹—éŒ¨é‹²è’œè›­é°­å“å½¬æ–Œæµœç€•è²§è³“é »æ•ç“¶ä¸ä»˜åŸ å¤«å©¦å¯Œå†¨å¸ƒåºœæ€–æ‰¶æ•·"],
    ["9580", "æ–§æ™®æµ®çˆ¶ç¬¦è…è†šèŠ™è­œè² è³¦èµ´é˜œé™„ä¾®æ’«æ­¦èˆè‘¡è•ªéƒ¨å°æ¥“é¢¨è‘ºè•—ä¼å‰¯å¾©å¹…æœç¦è…¹è¤‡è¦†æ·µå¼—æ‰•æ²¸ä»ç‰©é®’åˆ†å»å™´å¢³æ†¤æ‰®ç„šå¥®ç²‰ç³ç´›é›°æ–‡èä¸™ä½µå…µå¡€å¹£å¹³å¼ŠæŸ„ä¸¦è”½é–‰é™›ç±³é åƒ»å£ç™–ç¢§åˆ¥ç¥è”‘ç®†åå¤‰ç‰‡ç¯‡ç·¨è¾ºè¿”éä¾¿å‹‰å¨©å¼é­ä¿èˆ—é‹ªåœƒæ•æ­©ç”«è£œè¼”ç©‚å‹Ÿå¢“æ…•æˆŠæš®æ¯ç°¿è©å€£ä¿¸åŒ…å‘†å ±å¥‰å®å³°å³¯å´©åº–æŠ±æ§æ”¾æ–¹æœ‹"],
    ["9640", "æ³•æ³¡çƒ¹ç ²ç¸«èƒèŠ³èŒè“¬èœ‚è¤’è¨ªè±Šé‚¦é‹’é£½é³³éµ¬ä¹äº¡å‚å‰–åŠå¦¨å¸½å¿˜å¿™æˆ¿æš´æœ›æŸæ£’å†’ç´¡è‚ªè†¨è¬€è²Œè²¿é‰¾é˜²å é ¬åŒ—åƒ•åœå¢¨æ’²æœ´ç‰§ç¦ç©†é‡¦å‹ƒæ²¡æ®†å €å¹Œå¥”æœ¬ç¿»å‡¡ç›†"],
    ["9680", "æ‘©ç£¨é­”éº»åŸ‹å¦¹æ˜§æšæ¯å“©æ§™å¹•è†œæ•é®ªæŸ¾é±’æ¡äº¦ä¿£åˆæŠ¹æœ«æ²«è¿„ä¾­ç¹­éº¿ä¸‡æ…¢æº€æ¼«è”“å‘³æœªé­…å·³ç®•å²¬å¯†èœœæ¹Šè“‘ç¨”è„ˆå¦™ç²æ°‘çœ å‹™å¤¢ç„¡ç‰ŸçŸ›éœ§éµ¡æ¤‹å©¿å¨˜å†¥åå‘½æ˜ç›Ÿè¿·éŠ˜é³´å§ªç‰æ»…å…æ£‰ç¶¿ç·¬é¢éººæ‘¸æ¨¡èŒ‚å¦„å­Ÿæ¯›çŒ›ç›²ç¶²è€—è’™å„²æœ¨é»™ç›®æ¢å‹¿é¤…å°¤æˆ»ç±¾è²°å•æ‚¶ç´‹é–€åŒä¹Ÿå†¶å¤œçˆºè€¶é‡å¼¥çŸ¢å„å½¹ç´„è–¬è¨³èºé–æŸ³è–®é‘“æ„‰æ„ˆæ²¹ç™’"],
    ["9740", "è«­è¼¸å”¯ä½‘å„ªå‹‡å‹å®¥å¹½æ‚ æ†‚æ–æœ‰æŸšæ¹§æ¶ŒçŒ¶çŒ·ç”±ç¥è£•èª˜éŠé‚‘éƒµé›„èå¤•äºˆä½™ä¸èª‰è¼¿é å‚­å¹¼å¦–å®¹åº¸æšæºæ“æ›œæ¥Šæ§˜æ´‹æº¶ç†”ç”¨çª¯ç¾Šè€€è‘‰è“‰è¦è¬¡è¸Šé¥é™½é¤Šæ…¾æŠ‘æ¬²"],
    ["9780", "æ²ƒæµ´ç¿Œç¿¼æ·€ç¾…èºè£¸æ¥è±é ¼é›·æ´›çµ¡è½é…ªä¹±åµåµæ¬„æ¿«è—è˜­è¦§åˆ©åå±¥ææ¢¨ç†ç’ƒç—¢è£è£¡é‡Œé›¢é™¸å¾‹ç‡ç«‹è‘æ ç•¥åŠ‰æµæºœç‰ç•™ç¡«ç²’éš†ç«œé¾ä¾¶æ…®æ—…è™œäº†äº®åƒšä¸¡å‡Œå¯®æ–™æ¢æ¶¼çŒŸç™‚ç­ç¨œç³§è‰¯è«’é¼é‡é™µé ˜åŠ›ç·‘å€«å˜æ—æ·‹ç‡ç³è‡¨è¼ªéš£é±—éºŸç‘ å¡æ¶™ç´¯é¡ä»¤ä¼¶ä¾‹å†·åŠ±å¶ºæ€œç²ç¤¼è‹“éˆ´éš·é›¶éœŠéº—é½¢æš¦æ­´åˆ—åŠ£çƒˆè£‚å»‰æ‹æ†æ¼£ç…‰ç°¾ç·´è¯"],
    ["9840", "è“®é€£éŒ¬å‘‚é­¯æ«“ç‚‰è³‚è·¯éœ²åŠ´å©å»Šå¼„æœ—æ¥¼æ¦”æµªæ¼ç‰¢ç‹¼ç¯­è€è¾è‹éƒå…­éº“ç¦„è‚‹éŒ²è«–å€­å’Œè©±æ­ªè³„è„‡æƒ‘æ é·²äº™äº˜é°è©«è—è•¨æ¤€æ¹¾ç¢—è…•"],
    ["989f", "å¼Œä¸ä¸•ä¸ªä¸±ä¸¶ä¸¼ä¸¿ä¹‚ä¹–ä¹˜äº‚äº…è±«äºŠèˆ’å¼äºäºäºŸäº äº¢äº°äº³äº¶ä»ä»ä»„ä»†ä»‚ä»—ä»ä»­ä»Ÿä»·ä¼‰ä½šä¼°ä½›ä½ä½—ä½‡ä½¶ä¾ˆä¾ä¾˜ä½»ä½©ä½°ä¾‘ä½¯ä¾†ä¾–å„˜ä¿”ä¿Ÿä¿ä¿˜ä¿›ä¿‘ä¿šä¿ä¿¤ä¿¥å€šå€¨å€”å€ªå€¥å€…ä¼œä¿¶å€¡å€©å€¬ä¿¾ä¿¯å€‘å€†åƒå‡æœƒå•ååˆåšå–å¬å¸å‚€å‚šå‚…å‚´å‚²"],
    ["9940", "åƒ‰åƒŠå‚³åƒ‚åƒ–åƒåƒ¥åƒ­åƒ£åƒ®åƒ¹åƒµå„‰å„å„‚å„–å„•å„”å„šå„¡å„ºå„·å„¼å„»å„¿å…€å…’å…Œå…”å…¢ç«¸å…©å…ªå…®å†€å†‚å›˜å†Œå†‰å†å†‘å†“å†•å†–å†¤å†¦å†¢å†©å†ªå†«å†³å†±å†²å†°å†µå†½å‡…å‡‰å‡›å‡ è™•å‡©å‡­"],
    ["9980", "å‡°å‡µå‡¾åˆ„åˆ‹åˆ”åˆåˆ§åˆªåˆ®åˆ³åˆ¹å‰å‰„å‰‹å‰Œå‰å‰”å‰ªå‰´å‰©å‰³å‰¿å‰½åŠåŠ”åŠ’å‰±åŠˆåŠ‘è¾¨è¾§åŠ¬åŠ­åŠ¼åŠµå‹å‹å‹—å‹å‹£å‹¦é£­å‹ å‹³å‹µå‹¸å‹¹åŒ†åŒˆç”¸åŒåŒåŒåŒ•åŒšåŒ£åŒ¯åŒ±åŒ³åŒ¸å€å†å…ä¸—å‰åå‡–åå©å®å¤˜å»å·å‚å–å å¦å¥å®å°å¶åƒç°’é›™åŸæ›¼ç‡®å®å¨å­åºåå½å‘€å¬å­å¼å®å¶å©åå‘å’å‘µå’å‘Ÿå‘±å‘·å‘°å’’å‘»å’€å‘¶å’„å’å’†å“‡å’¢å’¸å’¥å’¬å“„å“ˆå’¨"],
    ["9a40", "å’«å“‚å’¤å’¾å’¼å“˜å“¥å“¦å”å””å“½å“®å“­å“ºå“¢å”¹å•€å•£å•Œå”®å•œå•…å•–å•—å”¸å”³å•å–™å–€å’¯å–Šå–Ÿå•»å•¾å–˜å–å–®å•¼å–ƒå–©å–‡å–¨å—šå—…å—Ÿå—„å—œå—¤å—”å˜”å—·å˜–å—¾å—½å˜›å—¹å™å™ç‡Ÿå˜´å˜¶å˜²å˜¸"],
    ["9a80", "å™«å™¤å˜¯å™¬å™ªåš†åš€åšŠåš åš”åšåš¥åš®åš¶åš´å›‚åš¼å›å›ƒå›€å›ˆå›å›‘å›“å›—å›®å›¹åœ€å›¿åœ„åœ‰åœˆåœ‹åœåœ“åœ˜åœ–å—‡åœœåœ¦åœ·åœ¸ååœ»å€åå©åŸ€åˆå¡å¿å‰å“å å³å¤åªå°åŸƒåŸ†åŸ”åŸ’åŸ“å ŠåŸ–åŸ£å ‹å ™å å¡²å ¡å¡¢å¡‹å¡°æ¯€å¡’å ½å¡¹å¢…å¢¹å¢Ÿå¢«å¢ºå£å¢»å¢¸å¢®å£…å£“å£‘å£—å£™å£˜å£¥å£œå£¤å£Ÿå£¯å£ºå£¹å£»å£¼å£½å¤‚å¤Šå¤å¤›æ¢¦å¤¥å¤¬å¤­å¤²å¤¸å¤¾ç«’å¥•å¥å¥å¥šå¥˜å¥¢å¥ å¥§å¥¬å¥©"],
    ["9b40", "å¥¸å¦å¦ä½ä¾«å¦£å¦²å§†å§¨å§œå¦å§™å§šå¨¥å¨Ÿå¨‘å¨œå¨‰å¨šå©€å©¬å©‰å¨µå¨¶å©¢å©ªåªšåª¼åª¾å«‹å«‚åª½å«£å«—å«¦å«©å«–å«ºå«»å¬Œå¬‹å¬–å¬²å«å¬ªå¬¶å¬¾å­ƒå­…å­€å­‘å­•å­šå­›å­¥å­©å­°å­³å­µå­¸æ–ˆå­ºå®€"],
    ["9b80", "å®ƒå®¦å®¸å¯ƒå¯‡å¯‰å¯”å¯å¯¤å¯¦å¯¢å¯å¯¥å¯«å¯°å¯¶å¯³å°…å°‡å°ˆå°å°“å° å°¢å°¨å°¸å°¹å±å±†å±å±“å±å±å­±å±¬å±®ä¹¢å±¶å±¹å²Œå²‘å²”å¦›å²«å²»å²¶å²¼å²·å³…å²¾å³‡å³™å³©å³½å³ºå³­å¶Œå³ªå´‹å´•å´—åµœå´Ÿå´›å´‘å´”å´¢å´šå´™å´˜åµŒåµ’åµåµ‹åµ¬åµ³åµ¶å¶‡å¶„å¶‚å¶¢å¶å¶¬å¶®å¶½å¶å¶·å¶¼å·‰å·å·“å·’å·–å·›å·«å·²å·µå¸‹å¸šå¸™å¸‘å¸›å¸¶å¸·å¹„å¹ƒå¹€å¹å¹—å¹”å¹Ÿå¹¢å¹¤å¹‡å¹µå¹¶å¹ºéº¼å¹¿åº å»å»‚å»ˆå»å»"],
    ["9c40", "å»–å»£å»å»šå»›å»¢å»¡å»¨å»©å»¬å»±å»³å»°å»´å»¸å»¾å¼ƒå¼‰å½å½œå¼‹å¼‘å¼–å¼©å¼­å¼¸å½å½ˆå½Œå½å¼¯å½‘å½–å½—å½™å½¡å½­å½³å½·å¾ƒå¾‚å½¿å¾Šå¾ˆå¾‘å¾‡å¾å¾™å¾˜å¾ å¾¨å¾­å¾¼å¿–å¿»å¿¤å¿¸å¿±å¿æ‚³å¿¿æ€¡æ "],
    ["9c80", "æ€™æ€æ€©æ€æ€±æ€›æ€•æ€«æ€¦æ€æ€ºæšææªæ·æŸæŠæ†ææ£æƒæ¤æ‚æ¬æ«æ™æ‚æ‚æƒ§æ‚ƒæ‚šæ‚„æ‚›æ‚–æ‚—æ‚’æ‚§æ‚‹æƒ¡æ‚¸æƒ æƒ“æ‚´å¿°æ‚½æƒ†æ‚µæƒ˜æ…æ„•æ„†æƒ¶æƒ·æ„€æƒ´æƒºæ„ƒæ„¡æƒ»æƒ±æ„æ„æ…‡æ„¾æ„¨æ„§æ…Šæ„¿æ„¼æ„¬æ„´æ„½æ…‚æ…„æ…³æ…·æ…˜æ…™æ…šæ…«æ…´æ…¯æ…¥æ…±æ…Ÿæ…æ…“æ…µæ†™æ†–æ†‡æ†¬æ†”æ†šæ†Šæ†‘æ†«æ†®æ‡Œæ‡Šæ‡‰æ‡·æ‡ˆæ‡ƒæ‡†æ†ºæ‡‹ç½¹æ‡æ‡¦æ‡£æ‡¶æ‡ºæ‡´æ‡¿æ‡½æ‡¼æ‡¾æˆ€æˆˆæˆ‰æˆæˆŒæˆ”æˆ›"],
    ["9d40", "æˆæˆ¡æˆªæˆ®æˆ°æˆ²æˆ³æ‰æ‰æ‰æ‰£æ‰›æ‰ æ‰¨æ‰¼æŠ‚æŠ‰æ‰¾æŠ’æŠ“æŠ–æ‹”æŠƒæŠ”æ‹—æ‹‘æŠ»æ‹æ‹¿æ‹†æ“”æ‹ˆæ‹œæ‹Œæ‹Šæ‹‚æ‹‡æŠ›æ‹‰æŒŒæ‹®æ‹±æŒ§æŒ‚æŒˆæ‹¯æ‹µææŒ¾ææœææ–ææ€æ«æ¶æ£ææ‰æŸæµæ«"],
    ["9d80", "æ©æ¾æ©æ€æ†æ£æ‰æ’æ¶æ„æ–æ´æ†æ“æ¦æ¶æ”æ—æ¨ææ‘§æ‘¯æ‘¶æ‘æ”ªæ’•æ’“æ’¥æ’©æ’ˆæ’¼æ“šæ“’æ“…æ“‡æ’»æ“˜æ“‚æ“±æ“§èˆ‰æ“ æ“¡æŠ¬æ“£æ“¯æ”¬æ“¶æ“´æ“²æ“ºæ”€æ“½æ”˜æ”œæ”…æ”¤æ”£æ”«æ”´æ”µæ”·æ”¶æ”¸ç•‹æ•ˆæ•–æ••æ•æ•˜æ•æ•æ•²æ•¸æ–‚æ–ƒè®Šæ–›æ–Ÿæ–«æ–·æ—ƒæ—†æ—æ—„æ—Œæ—’æ—›æ—™æ— æ—¡æ—±æ²æ˜Šæ˜ƒæ—»æ³æ˜µæ˜¶æ˜´æ˜œæ™æ™„æ™‰æ™æ™æ™æ™¤æ™§æ™¨æ™Ÿæ™¢æ™°æšƒæšˆæšæš‰æš„æš˜æšæ›æš¹æ›‰æš¾æš¼"],
    ["9e40", "æ›„æš¸æ›–æ›šæ› æ˜¿æ›¦æ›©æ›°æ›µæ›·æœæœ–æœæœ¦æœ§éœ¸æœ®æœ¿æœ¶ææœ¸æœ·æ†ææ æ™æ£æ¤æ‰æ°æ©æ¼æªæŒæ‹æ¦æ¡æ…æ·æŸ¯æ´æŸ¬æ³æŸ©æ¸æŸ¤æŸæŸæŸ¢æŸ®æ¹æŸæŸ†æŸ§æªœæ æ¡†æ ©æ¡€æ¡æ ²æ¡"],
    ["9e80", "æ¢³æ «æ¡™æ¡£æ¡·æ¡¿æ¢Ÿæ¢æ¢­æ¢”æ¢æ¢›æ¢ƒæª®æ¢¹æ¡´æ¢µæ¢ æ¢ºæ¤æ¢æ¡¾æ¤æ£Šæ¤ˆæ£˜æ¤¢æ¤¦æ£¡æ¤Œæ£æ£”æ£§æ£•æ¤¶æ¤’æ¤„æ£—æ££æ¤¥æ£¹æ£ æ£¯æ¤¨æ¤ªæ¤šæ¤£æ¤¡æ£†æ¥¹æ¥·æ¥œæ¥¸æ¥«æ¥”æ¥¾æ¥®æ¤¹æ¥´æ¤½æ¥™æ¤°æ¥¡æ¥æ¥æ¦æ¥ªæ¦²æ¦®æ§æ¦¿æ§æ§“æ¦¾æ§å¯¨æ§Šæ§æ¦»æ§ƒæ¦§æ¨®æ¦‘æ¦ æ¦œæ¦•æ¦´æ§æ§¨æ¨‚æ¨›æ§¿æ¬Šæ§¹æ§²æ§§æ¨…æ¦±æ¨æ§­æ¨”æ§«æ¨Šæ¨’æ«æ¨£æ¨“æ©„æ¨Œæ©²æ¨¶æ©¸æ©‡æ©¢æ©™æ©¦æ©ˆæ¨¸æ¨¢æªæªæª æª„æª¢æª£"],
    ["9f40", "æª—è˜—æª»æ«ƒæ«‚æª¸æª³æª¬æ«æ«‘æ«Ÿæªªæ«šæ«ªæ«»æ¬…è˜–æ«ºæ¬’æ¬–é¬±æ¬Ÿæ¬¸æ¬·ç›œæ¬¹é£®æ­‡æ­ƒæ­‰æ­æ­™æ­”æ­›æ­Ÿæ­¡æ­¸æ­¹æ­¿æ®€æ®„æ®ƒæ®æ®˜æ®•æ®æ®¤æ®ªæ®«æ®¯æ®²æ®±æ®³æ®·æ®¼æ¯†æ¯‹æ¯“æ¯Ÿæ¯¬æ¯«æ¯³æ¯¯"],
    ["9f80", "éº¾æ°ˆæ°“æ°”æ°›æ°¤æ°£æ±æ±•æ±¢æ±ªæ²‚æ²æ²šæ²æ²›æ±¾æ±¨æ±³æ²’æ²æ³„æ³±æ³“æ²½æ³—æ³…æ³æ²®æ²±æ²¾æ²ºæ³›æ³¯æ³™æ³ªæ´Ÿè¡æ´¶æ´«æ´½æ´¸æ´™æ´µæ´³æ´’æ´Œæµ£æ¶“æµ¤æµšæµ¹æµ™æ¶æ¶•æ¿¤æ¶…æ·¹æ¸•æ¸Šæ¶µæ·‡æ·¦æ¶¸æ·†æ·¬æ·æ·Œæ·¨æ·’æ·…æ·ºæ·™æ·¤æ·•æ·ªæ·®æ¸­æ¹®æ¸®æ¸™æ¹²æ¹Ÿæ¸¾æ¸£æ¹«æ¸«æ¹¶æ¹æ¸Ÿæ¹ƒæ¸ºæ¹æ¸¤æ»¿æ¸æ¸¸æº‚æºªæº˜æ»‰æº·æ»“æº½æº¯æ»„æº²æ»”æ»•æºæº¥æ»‚æºŸæ½æ¼‘çŒæ»¬æ»¸æ»¾æ¼¿æ»²æ¼±æ»¯æ¼²æ»Œ"],
    ["e040", "æ¼¾æ¼“æ»·æ¾†æ½ºæ½¸æ¾æ¾€æ½¯æ½›æ¿³æ½­æ¾‚æ½¼æ½˜æ¾æ¾‘æ¿‚æ½¦æ¾³æ¾£æ¾¡æ¾¤æ¾¹æ¿†æ¾ªæ¿Ÿæ¿•æ¿¬æ¿”æ¿˜æ¿±æ¿®æ¿›ç€‰ç€‹æ¿ºç€‘ç€ç€æ¿¾ç€›ç€šæ½´ç€ç€˜ç€Ÿç€°ç€¾ç€²ç‘ç£ç‚™ç‚’ç‚¯çƒ±ç‚¬ç‚¸ç‚³ç‚®çƒŸçƒ‹çƒ"],
    ["e080", "çƒ™ç„‰çƒ½ç„œç„™ç…¥ç…•ç†ˆç…¦ç…¢ç…Œç…–ç…¬ç†ç‡»ç†„ç†•ç†¨ç†¬ç‡—ç†¹ç†¾ç‡’ç‡‰ç‡”ç‡ç‡ ç‡¬ç‡§ç‡µç‡¼ç‡¹ç‡¿çˆçˆçˆ›çˆ¨çˆ­çˆ¬çˆ°çˆ²çˆ»çˆ¼çˆ¿ç‰€ç‰†ç‰‹ç‰˜ç‰´ç‰¾çŠ‚çŠçŠ‡çŠ’çŠ–çŠ¢çŠ§çŠ¹çŠ²ç‹ƒç‹†ç‹„ç‹ç‹’ç‹¢ç‹ ç‹¡ç‹¹ç‹·å€çŒ—çŒŠçŒœçŒ–çŒçŒ´çŒ¯çŒ©çŒ¥çŒ¾ççé»˜ç—çªç¨ç°ç¸çµç»çºçˆç³çç»ç€ç¥ç®çç’¢ç…ç‘¯ç¥ç¸ç²çºç‘•ç¿ç‘Ÿç‘™ç‘ç‘œç‘©ç‘°ç‘£ç‘ªç‘¶ç‘¾ç’‹ç’ç’§ç“Šç“ç“”ç±"],
    ["e140", "ç“ ç“£ç“§ç“©ç“®ç“²ç“°ç“±ç“¸ç“·ç”„ç”ƒç”…ç”Œç”ç”ç”•ç”“ç”ç”¦ç”¬ç”¼ç•„ç•ç•Šç•‰ç•›ç•†ç•šç•©ç•¤ç•§ç•«ç•­ç•¸ç•¶ç–†ç–‡ç•´ç–Šç–‰ç–‚ç–”ç–šç–ç–¥ç–£ç—‚ç–³ç—ƒç–µç–½ç–¸ç–¼ç–±ç—ç—Šç—’ç—™ç—£ç—ç—¾ç—¿"],
    ["e180", "ç—¼ç˜ç—°ç—ºç—²ç—³ç˜‹ç˜ç˜‰ç˜Ÿç˜§ç˜ ç˜¡ç˜¢ç˜¤ç˜´ç˜°ç˜»ç™‡ç™ˆç™†ç™œç™˜ç™¡ç™¢ç™¨ç™©ç™ªç™§ç™¬ç™°ç™²ç™¶ç™¸ç™¼çš€çšƒçšˆçš‹çšçš–çš“çš™çššçš°çš´çš¸çš¹çšºç›‚ç›ç›–ç›’ç›ç›¡ç›¥ç›§ç›ªè˜¯ç›»çœˆçœ‡çœ„çœ©çœ¤çœçœ¥çœ¦çœ›çœ·çœ¸ç‡çšç¨ç«ç›ç¥ç¿ç¾ç¹çç‹ç‘ç çç°ç¶ç¹ç¿ç¼ç½ç»çŸ‡çŸçŸ—çŸšçŸœçŸ£çŸ®çŸ¼ç Œç ’ç¤¦ç  ç¤ªç¡…ç¢ç¡´ç¢†ç¡¼ç¢šç¢Œç¢£ç¢µç¢ªç¢¯ç£‘ç£†ç£‹ç£”ç¢¾ç¢¼ç£…ç£Šç£¬"],
    ["e240", "ç£§ç£šç£½ç£´ç¤‡ç¤’ç¤‘ç¤™ç¤¬ç¤«ç¥€ç¥ ç¥—ç¥Ÿç¥šç¥•ç¥“ç¥ºç¥¿ç¦Šç¦ç¦§é½‹ç¦ªç¦®ç¦³ç¦¹ç¦ºç§‰ç§•ç§§ç§¬ç§¡ç§£ç¨ˆç¨ç¨˜ç¨™ç¨ ç¨Ÿç¦€ç¨±ç¨»ç¨¾ç¨·ç©ƒç©—ç©‰ç©¡ç©¢ç©©é¾ç©°ç©¹ç©½çªˆçª—çª•çª˜çª–çª©ç«ˆçª°"],
    ["e280", "çª¶ç«…ç«„çª¿é‚ƒç«‡ç«Šç«ç«ç«•ç«“ç«™ç«šç«ç«¡ç«¢ç«¦ç«­ç«°ç¬‚ç¬ç¬Šç¬†ç¬³ç¬˜ç¬™ç¬ç¬µç¬¨ç¬¶ç­ç­ºç¬„ç­ç¬‹ç­Œç­…ç­µç­¥ç­´ç­§ç­°ç­±ç­¬ç­®ç®ç®˜ç®Ÿç®ç®œç®šç®‹ç®’ç®ç­ç®™ç¯‹ç¯ç¯Œç¯ç®´ç¯†ç¯ç¯©ç°‘ç°”ç¯¦ç¯¥ç± ç°€ç°‡ç°“ç¯³ç¯·ç°—ç°ç¯¶ç°£ç°§ç°ªç°Ÿç°·ç°«ç°½ç±Œç±ƒç±”ç±ç±€ç±ç±˜ç±Ÿç±¤ç±–ç±¥ç±¬ç±µç²ƒç²ç²¤ç²­ç²¢ç²«ç²¡ç²¨ç²³ç²²ç²±ç²®ç²¹ç²½ç³€ç³…ç³‚ç³˜ç³’ç³œç³¢é¬»ç³¯ç³²ç³´ç³¶ç³ºç´†"],
    ["e340", "ç´‚ç´œç´•ç´Šçµ…çµ‹ç´®ç´²ç´¿ç´µçµ†çµ³çµ–çµçµ²çµ¨çµ®çµçµ£ç¶“ç¶‰çµ›ç¶çµ½ç¶›ç¶ºç¶®ç¶£ç¶µç·‡ç¶½ç¶«ç¸½ç¶¢ç¶¯ç·œç¶¸ç¶Ÿç¶°ç·˜ç·ç·¤ç·ç·»ç·²ç·¡ç¸…ç¸Šç¸£ç¸¡ç¸’ç¸±ç¸Ÿç¸‰ç¸‹ç¸¢ç¹†ç¹¦ç¸»ç¸µç¸¹ç¹ƒç¸·"],
    ["e380", "ç¸²ç¸ºç¹§ç¹ç¹–ç¹ç¹™ç¹šç¹¹ç¹ªç¹©ç¹¼ç¹»çºƒç·•ç¹½è¾®ç¹¿çºˆçº‰çºŒçº’çºçº“çº”çº–çºçº›çºœç¼¸ç¼ºç½…ç½Œç½ç½ç½ç½‘ç½•ç½”ç½˜ç½Ÿç½ ç½¨ç½©ç½§ç½¸ç¾‚ç¾†ç¾ƒç¾ˆç¾‡ç¾Œç¾”ç¾ç¾ç¾šç¾£ç¾¯ç¾²ç¾¹ç¾®ç¾¶ç¾¸è­±ç¿…ç¿†ç¿Šç¿•ç¿”ç¿¡ç¿¦ç¿©ç¿³ç¿¹é£œè€†è€„è€‹è€’è€˜è€™è€œè€¡è€¨è€¿è€»èŠè†è’è˜èšèŸè¢è¨è³è²è°è¶è¹è½è¿è‚„è‚†è‚…è‚›è‚“è‚šè‚­å†è‚¬èƒ›èƒ¥èƒ™èƒèƒ„èƒšèƒ–è„‰èƒ¯èƒ±è„›è„©è„£è„¯è…‹"],
    ["e440", "éš‹è…†è„¾è…“è…‘èƒ¼è…±è…®è…¥è…¦è…´è†ƒè†ˆè†Šè†€è†‚è† è†•è†¤è†£è…Ÿè†“è†©è†°è†µè†¾è†¸è†½è‡€è‡‚è†ºè‡‰è‡è‡‘è‡™è‡˜è‡ˆè‡šè‡Ÿè‡ è‡§è‡ºè‡»è‡¾èˆèˆ‚èˆ…èˆ‡èˆŠèˆèˆèˆ–èˆ©èˆ«èˆ¸èˆ³è‰€è‰™è‰˜è‰è‰šè‰Ÿè‰¤"],
    ["e480", "è‰¢è‰¨è‰ªè‰«èˆ®è‰±è‰·è‰¸è‰¾èŠèŠ’èŠ«èŠŸèŠ»èŠ¬è‹¡è‹£è‹Ÿè‹’è‹´è‹³è‹ºè“èŒƒè‹»è‹¹è‹èŒ†è‹œèŒ‰è‹™èŒµèŒ´èŒ–èŒ²èŒ±è€èŒ¹èè…èŒ¯èŒ«èŒ—èŒ˜è…èšèªèŸè¢è–èŒ£èè‡èŠè¼èµè³èµè è‰è¨è´è“è«èè½èƒè˜è‹èè·è‡è è²èè¢è è½è¸è”†è»è‘­èªè¼è•šè’„è‘·è‘«è’­è‘®è’‚è‘©è‘†è¬è‘¯è‘¹èµè“Šè‘¢è’¹è’¿è’Ÿè“™è“è’»è“šè“è“è“†è“–è’¡è”¡è“¿è“´è”—è”˜è”¬è”Ÿè”•è””è“¼è•€è•£è•˜è•ˆ"],
    ["e540", "è•è˜‚è•‹è••è–€è–¤è–ˆè–‘è–Šè–¨è•­è–”è–›è—ªè–‡è–œè•·è•¾è–è—‰è–ºè—è–¹è—è—•è—è—¥è—œè—¹è˜Šè˜“è˜‹è—¾è—ºè˜†è˜¢è˜šè˜°è˜¿è™ä¹•è™”è™Ÿè™§è™±èš“èš£èš©èšªèš‹èšŒèš¶èš¯è›„è›†èš°è›‰è £èš«è›”è›è›©è›¬"],
    ["e580", "è›Ÿè››è›¯èœ’èœ†èœˆèœ€èœƒè›»èœ‘èœ‰èœè›¹èœŠèœ´èœ¿èœ·èœ»èœ¥èœ©èœšè èŸè¸èŒèè´è—è¨è®è™è“è£èªè …è¢èŸè‚è¯èŸ‹è½èŸ€èŸé›–è«èŸ„è³èŸ‡èŸ†è»èŸ¯èŸ²èŸ è è èŸ¾èŸ¶èŸ·è èŸ’è ‘è –è •è ¢è ¡è ±è ¶è ¹è §è »è¡„è¡‚è¡’è¡™è¡è¡¢è¡«è¢è¡¾è¢è¡µè¡½è¢µè¡²è¢‚è¢—è¢’è¢®è¢™è¢¢è¢è¢¤è¢°è¢¿è¢±è£ƒè£„è£”è£˜è£™è£è£¹è¤‚è£¼è£´è£¨è£²è¤„è¤Œè¤Šè¤“è¥ƒè¤è¤¥è¤ªè¤«è¥è¥„è¤»è¤¶è¤¸è¥Œè¤è¥ è¥"],
    ["e640", "è¥¦è¥¤è¥­è¥ªè¥¯è¥´è¥·è¥¾è¦ƒè¦ˆè¦Šè¦“è¦˜è¦¡è¦©è¦¦è¦¬è¦¯è¦²è¦ºè¦½è¦¿è§€è§šè§œè§è§§è§´è§¸è¨ƒè¨–è¨è¨Œè¨›è¨è¨¥è¨¶è©è©›è©’è©†è©ˆè©¼è©­è©¬è©¢èª…èª‚èª„èª¨èª¡èª‘èª¥èª¦èªšèª£è«„è«è«‚è«šè««è«³è«§"],
    ["e680", "è«¤è«±è¬”è« è«¢è«·è«è«›è¬Œè¬‡è¬šè«¡è¬–è¬è¬—è¬ è¬³é«è¬¦è¬«è¬¾è¬¨è­è­Œè­è­è­‰è­–è­›è­šè­«è­Ÿè­¬è­¯è­´è­½è®€è®Œè®è®’è®“è®–è®™è®šè°ºè±è°¿è±ˆè±Œè±è±è±•è±¢è±¬è±¸è±ºè²‚è²‰è²…è²Šè²è²è²”è±¼è²˜æˆè²­è²ªè²½è²²è²³è²®è²¶è³ˆè³è³¤è³£è³šè³½è³ºè³»è´„è´…è´Šè´‡è´è´è´é½è´“è³è´”è´–èµ§èµ­èµ±èµ³è¶è¶™è·‚è¶¾è¶ºè·è·šè·–è·Œè·›è·‹è·ªè·«è·Ÿè·£è·¼è¸ˆè¸‰è·¿è¸è¸è¸è¸Ÿè¹‚è¸µè¸°è¸´è¹Š"],
    ["e740", "è¹‡è¹‰è¹Œè¹è¹ˆè¹™è¹¤è¹ è¸ªè¹£è¹•è¹¶è¹²è¹¼èºèº‡èº…èº„èº‹èºŠèº“èº‘èº”èº™èºªèº¡èº¬èº°è»†èº±èº¾è»…è»ˆè»‹è»›è»£è»¼è»»è»«è»¾è¼Šè¼…è¼•è¼’è¼™è¼“è¼œè¼Ÿè¼›è¼Œè¼¦è¼³è¼»è¼¹è½…è½‚è¼¾è½Œè½‰è½†è½è½—è½œ"],
    ["e780", "è½¢è½£è½¤è¾œè¾Ÿè¾£è¾­è¾¯è¾·è¿šè¿¥è¿¢è¿ªè¿¯é‚‡è¿´é€…è¿¹è¿ºé€‘é€•é€¡é€é€é€–é€‹é€§é€¶é€µé€¹è¿¸ééé‘é’é€é‰é€¾é–é˜éé¨é¯é¶éš¨é²é‚‚é½é‚é‚€é‚Šé‚‰é‚é‚¨é‚¯é‚±é‚µéƒ¢éƒ¤æ‰ˆéƒ›é„‚é„’é„™é„²é„°é…Šé…–é…˜é…£é…¥é…©é…³é…²é†‹é†‰é†‚é†¢é†«é†¯é†ªé†µé†´é†ºé‡€é‡é‡‰é‡‹é‡é‡–é‡Ÿé‡¡é‡›é‡¼é‡µé‡¶éˆé‡¿éˆ”éˆ¬éˆ•éˆ‘é‰é‰—é‰…é‰‰é‰¤é‰ˆéŠ•éˆ¿é‰‹é‰éŠœéŠ–éŠ“éŠ›é‰šé‹éŠ¹éŠ·é‹©éŒé‹ºé„éŒ®"],
    ["e840", "éŒ™éŒ¢éŒšéŒ£éŒºéŒµéŒ»éœé é¼é®é–é°é¬é­é”é¹é–é—é¨é¥é˜éƒéééˆé¤éšé”é“éƒé‡éé¶é«éµé¡éºé‘é‘’é‘„é‘›é‘ é‘¢é‘é‘ªéˆ©é‘°é‘µé‘·é‘½é‘šé‘¼é‘¾é’é‘¿é–‚é–‡é–Šé–”é––é–˜é–™"],
    ["e880", "é– é–¨é–§é–­é–¼é–»é–¹é–¾é—Šæ¿¶é—ƒé—é—Œé—•é—”é—–é—œé—¡é—¥é—¢é˜¡é˜¨é˜®é˜¯é™‚é™Œé™é™‹é™·é™œé™é™é™Ÿé™¦é™²é™¬éšéš˜éš•éš—éšªéš§éš±éš²éš°éš´éš¶éš¸éš¹é›é›‹é›‰é›è¥é›œéœé›•é›¹éœ„éœ†éœˆéœ“éœéœ‘éœéœ–éœ™éœ¤éœªéœ°éœ¹éœ½éœ¾é„é†éˆé‚é‰éœé é¤é¦é¨å‹’é«é±é¹é…é¼ééºé†é‹éééœé¨é¦é£é³é´éŸƒéŸ†éŸˆéŸ‹éŸœéŸ­é½éŸ²ç«ŸéŸ¶éŸµé é Œé ¸é ¤é ¡é ·é ½é¡†é¡é¡‹é¡«é¡¯é¡°"],
    ["e940", "é¡±é¡´é¡³é¢ªé¢¯é¢±é¢¶é£„é£ƒé£†é£©é£«é¤ƒé¤‰é¤’é¤”é¤˜é¤¡é¤é¤é¤¤é¤ é¤¬é¤®é¤½é¤¾é¥‚é¥‰é¥…é¥é¥‹é¥‘é¥’é¥Œé¥•é¦—é¦˜é¦¥é¦­é¦®é¦¼é§Ÿé§›é§é§˜é§‘é§­é§®é§±é§²é§»é§¸é¨é¨é¨…é§¢é¨™é¨«é¨·é©…é©‚é©€é©ƒ"],
    ["e980", "é¨¾é©•é©é©›é©—é©Ÿé©¢é©¥é©¤é©©é©«é©ªéª­éª°éª¼é«€é«é«‘é«“é«”é«é«Ÿé«¢é«£é«¦é«¯é««é«®é«´é«±é«·é«»é¬†é¬˜é¬šé¬Ÿé¬¢é¬£é¬¥é¬§é¬¨é¬©é¬ªé¬®é¬¯é¬²é­„é­ƒé­é­é­é­‘é­˜é­´é®“é®ƒé®‘é®–é®—é®Ÿé® é®¨é®´é¯€é¯Šé®¹é¯†é¯é¯‘é¯’é¯£é¯¢é¯¤é¯”é¯¡é°ºé¯²é¯±é¯°é°•é°”é°‰é°“é°Œé°†é°ˆé°’é°Šé°„é°®é°›é°¥é°¤é°¡é°°é±‡é°²é±†é°¾é±šé± é±§é±¶é±¸é³§é³¬é³°é´‰é´ˆé³«é´ƒé´†é´ªé´¦é¶¯é´£é´Ÿéµ„é´•é´’éµé´¿é´¾éµ†éµˆ"],
    ["ea40", "éµéµéµ¤éµ‘éµéµ™éµ²é¶‰é¶‡é¶«éµ¯éµºé¶šé¶¤é¶©é¶²é·„é·é¶»é¶¸é¶ºé·†é·é·‚é·™é·“é·¸é·¦é·­é·¯é·½é¸šé¸›é¸é¹µé¹¹é¹½éºéºˆéº‹éºŒéº’éº•éº‘éºéº¥éº©éº¸éºªéº­é¡é»Œé»é»é»é»”é»œé»é»é» é»¥é»¨é»¯"],
    ["ea80", "é»´é»¶é»·é»¹é»»é»¼é»½é¼‡é¼ˆçš·é¼•é¼¡é¼¬é¼¾é½Šé½’é½”é½£é½Ÿé½ é½¡é½¦é½§é½¬é½ªé½·é½²é½¶é¾•é¾œé¾ å ¯æ§‡é™ç‘¤å‡œç†™"],
    ["ed40", "çºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€å†å°å‚å‚”åƒ´åƒ˜å…Šå…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²å“å²åï¨å’œå’Šå’©å“¿å–†å™å¥å¬åŸˆåŸ‡ï¨"],
    ["ed80", "ï¨å¢å¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°å²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·å¿ææ‚…æ‚Šæƒæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“æ•æ˜€æ˜•æ˜»æ˜‰æ˜®æ˜æ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœï¤©æ¦æ»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±"],
    ["ee40", "çŠ¾çŒ¤ï¨–ç·ç½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡ç¡¤ç¡ºç¤°ï¨˜ï¨™ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®ï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨èŒè¢è¿è‡è¶è‘ˆè’´è•“è•™"],
    ["ee80", "è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒï¨¦é„•é„§é‡šé‡—é‡é‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰é‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒé‹¿éŒéŒ‚é°é—é¤é†éé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦é©é«™é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘"],
    ["eeef", "â…°", 9, "ï¿¢ï¿¤ï¼‡ï¼‚"],
    ["f040", "î€€", 62],
    ["f080", "î€¿", 124],
    ["f140", "î‚¼", 62],
    ["f180", "îƒ»", 124],
    ["f240", "î…¸", 62],
    ["f280", "î†·", 124],
    ["f340", "îˆ´", 62],
    ["f380", "î‰³", 124],
    ["f440", "î‹°", 62],
    ["f480", "îŒ¯", 124],
    ["f540", "î¬", 62],
    ["f580", "î«", 124],
    ["f640", "î‘¨", 62],
    ["f680", "î’§", 124],
    ["f740", "î”¤", 62],
    ["f780", "î•£", 124],
    ["f840", "î— ", 62],
    ["f880", "î˜Ÿ", 124],
    ["f940", "îšœ"],
    ["fa40", "â…°", 9, "â… ", 9, "ï¿¢ï¿¤ï¼‡ï¼‚ãˆ±â„–â„¡âˆµçºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€å†å°å‚å‚”åƒ´åƒ˜å…Š"],
    ["fa80", "å…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²å“å²åï¨å’œå’Šå’©å“¿å–†å™å¥å¬åŸˆåŸ‡ï¨ï¨å¢å¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°å²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·å¿ææ‚…æ‚Šæƒæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“æ•æ˜€æ˜•æ˜»æ˜‰æ˜®æ˜æ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœï¤©æ¦æ»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯"],
    ["fb40", "æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±çŠ¾çŒ¤ï¨–ç·ç½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡ç¡¤ç¡ºç¤°ï¨˜ï¨™"],
    ["fb80", "ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®ï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨èŒè¢è¿è‡è¶è‘ˆè’´è•“è•™è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒï¨¦é„•é„§é‡šé‡—é‡é‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰é‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒé‹¿éŒéŒ‚é°é—é¤é†éé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦é©é«™"],
    ["fc40", "é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘"]
  ];
});

// node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\0", 127],
    ["8ea1", "ï½¡", 62],
    ["a1a1", "ã€€ã€ã€‚ï¼Œï¼ãƒ»ï¼šï¼›ï¼Ÿï¼ã‚›ã‚œÂ´ï½€Â¨ï¼¾ï¿£ï¼¿ãƒ½ãƒ¾ã‚ã‚ã€ƒä»ã€…ã€†ã€‡ãƒ¼â€•â€ï¼ï¼¼ï½âˆ¥ï½œâ€¦â€¥â€˜â€™â€œâ€ï¼ˆï¼‰ã€”ã€•ï¼»ï¼½ï½›ï½ã€ˆ", 9, "ï¼‹ï¼Â±Ã—Ã·ï¼â‰ ï¼œï¼â‰¦â‰§âˆâˆ´â™‚â™€Â°â€²â€³â„ƒï¿¥ï¼„ï¿ ï¿¡ï¼…ï¼ƒï¼†ï¼Šï¼ Â§â˜†â˜…â—‹â—â—â—‡"],
    ["a2a1", "â—†â–¡â– â–³â–²â–½â–¼â€»ã€’â†’â†â†‘â†“ã€“"],
    ["a2ba", "âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©"],
    ["a2ca", "âˆ§âˆ¨ï¿¢â‡’â‡”âˆ€âˆƒ"],
    ["a2dc", "âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬"],
    ["a2f2", "â„«â€°â™¯â™­â™ªâ€ â€¡Â¶"],
    ["a2fe", "â—¯"],
    ["a3b0", "ï¼", 9],
    ["a3c1", "ï¼¡", 25],
    ["a3e1", "ï½", 25],
    ["a4a1", "ã", 82],
    ["a5a1", "ã‚¡", 85],
    ["a6a1", "Î‘", 16, "Î£", 6],
    ["a6c1", "Î±", 16, "Ïƒ", 6],
    ["a7a1", "Ğ", 5, "ĞĞ–", 25],
    ["a7d1", "Ğ°", 5, "Ñ‘Ğ¶", 25],
    ["a8a1", "â”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚"],
    ["ada1", "â‘ ", 19, "â… ", 9],
    ["adc0", "ã‰ãŒ”ãŒ¢ããŒ˜ãŒ§ãŒƒãŒ¶ã‘ã—ãŒãŒ¦ãŒ£ãŒ«ãŠãŒ»ãœããããã„ã¡"],
    ["addf", "ã»ã€ã€Ÿâ„–ãâ„¡ãŠ¤", 4, "ãˆ±ãˆ²ãˆ¹ã¾ã½ã¼â‰’â‰¡âˆ«âˆ®âˆ‘âˆšâŠ¥âˆ âˆŸâŠ¿âˆµâˆ©âˆª"],
    ["b0a1", "äºœå”–å¨ƒé˜¿å“€æ„›æŒ¨å§¶é€¢è‘µèŒœç©æ‚ªæ¡æ¸¥æ—­è‘¦èŠ¦é¯µæ¢“åœ§æ–¡æ‰±å®›å§è™»é£´çµ¢ç¶¾é®æˆ–ç²Ÿè¢·å®‰åºµæŒ‰æš—æ¡ˆé—‡éæä»¥ä¼Šä½ä¾å‰å›²å¤·å§”å¨å°‰æƒŸæ„æ…°æ˜“æ¤…ç‚ºç•ç•°ç§»ç¶­ç·¯èƒƒèè¡£è¬‚é•éºåŒ»äº•äº¥åŸŸè‚²éƒç£¯ä¸€å£±æº¢é€¸ç¨²èŒ¨èŠ‹é°¯å…å°å’½å“¡å› å§»å¼•é£²æ·«èƒ¤è”­"],
    ["b1a1", "é™¢é™°éš éŸ»å‹å³å®‡çƒç¾½è¿‚é›¨å¯éµœçªºä¸‘ç¢“è‡¼æ¸¦å˜˜å”„æ¬è”šé°»å§¥å©æµ¦ç“œé–å™‚äº‘é‹é›²èé¤Œå¡å–¶å¬°å½±æ˜ æ›³æ „æ°¸æ³³æ´©ç‘›ç›ˆç©é ´è‹±è¡›è© é‹­æ¶²ç–«ç›Šé§…æ‚¦è¬è¶Šé–²æ¦å­å††åœ’å °å¥„å®´å»¶æ€¨æ©æ´æ²¿æ¼”ç‚ç„”ç…™ç‡•çŒ¿ç¸è‰¶è‹‘è–—é é‰›é´›å¡©æ–¼æ±šç”¥å‡¹å¤®å¥¥å¾€å¿œ"],
    ["b2a1", "æŠ¼æ—ºæ¨ªæ¬§æ®´ç‹ç¿è¥–é´¬é´é»„å²¡æ²–è»å„„å±‹æ†¶è‡†æ¡¶ç‰¡ä¹™ä¿ºå¸æ©æ¸©ç©éŸ³ä¸‹åŒ–ä»®ä½•ä¼½ä¾¡ä½³åŠ å¯å˜‰å¤å«å®¶å¯¡ç§‘æš‡æœæ¶æ­Œæ²³ç«ç‚ç¦ç¦¾ç¨¼ç®‡èŠ±è‹›èŒ„è·è¯è“è¦èª²å˜©è²¨è¿¦ééœèšŠä¿„å³¨æˆ‘ç‰™ç”»è‡¥èŠ½è›¾è³€é›…é¤“é§•ä»‹ä¼šè§£å›å¡Šå£Šå»»å¿«æ€ªæ‚”æ¢æ‡æˆ’æ‹æ”¹"],
    ["b3a1", "é­æ™¦æ¢°æµ·ç°ç•Œçš†çµµèŠ¥èŸ¹é–‹éšè²å‡±åŠ¾å¤–å’³å®³å´–æ…¨æ¦‚æ¶¯ç¢è“‹è¡—è©²é§éª¸æµ¬é¦¨è›™å£æŸ¿è›éˆåŠƒåš‡å„å»“æ‹¡æ’¹æ ¼æ ¸æ®»ç²ç¢ºç©«è¦šè§’èµ«è¼ƒéƒ­é–£éš”é©å­¦å²³æ¥½é¡é¡æ›ç¬ æ¨«æ©¿æ¢¶é°æ½Ÿå‰²å–æ°æ‹¬æ´»æ¸‡æ»‘è‘›è¤è½„ä¸”é°¹å¶æ¤›æ¨ºé„æ ªå…œç«ƒè’²é‡œéŒå™›é´¨æ ¢èŒ…è±"],
    ["b4a1", "ç²¥åˆˆè‹…ç“¦ä¹¾ä¾ƒå† å¯’åˆŠå‹˜å‹§å·»å–šå ªå§¦å®Œå®˜å¯›å¹²å¹¹æ‚£æ„Ÿæ…£æ†¾æ›æ•¢æŸ‘æ¡“æ£ºæ¬¾æ­“æ±—æ¼¢æ¾—æ½…ç’°ç”˜ç›£çœ‹ç«¿ç®¡ç°¡ç·©ç¼¶ç¿°è‚è‰¦èè¦³è«Œè²«é‚„é‘‘é–“é–‘é–¢é™¥éŸ“é¤¨èˆ˜ä¸¸å«å²¸å·Œç©ç™Œçœ¼å²©ç¿«è´‹é›é ‘é¡”é¡˜ä¼ä¼å±å–œå™¨åŸºå¥‡å¬‰å¯„å²å¸Œå¹¾å¿Œæ®æœºæ——æ—¢æœŸæ£‹æ£„"],
    ["b5a1", "æ©Ÿå¸°æ¯…æ°—æ±½ç•¿ç¥ˆå­£ç¨€ç´€å¾½è¦è¨˜è²´èµ·è»Œè¼é£¢é¨é¬¼äº€å½å„€å¦“å®œæˆ¯æŠ€æ“¬æ¬ºçŠ ç–‘ç¥‡ç¾©èŸ»èª¼è­°æ¬èŠé å‰åƒå–«æ¡”æ©˜è©°ç §æµé»å´å®¢è„šè™é€†ä¸˜ä¹…ä»‡ä¼‘åŠå¸å®®å¼“æ€¥æ•‘æœ½æ±‚æ±²æ³£ç¸çƒç©¶çª®ç¬ˆç´šç³¾çµ¦æ—§ç‰›å»å±…å·¨æ‹’æ‹ æŒ™æ¸ è™šè¨±è·é‹¸æ¼ç¦¦é­šäº¨äº«äº¬"],
    ["b6a1", "ä¾›ä¾ åƒ‘å…‡ç«¶å…±å‡¶å”åŒ¡å¿å«å–¬å¢ƒå³¡å¼·å½Šæ€¯ææ­æŒŸæ•™æ©‹æ³ç‹‚ç‹­çŸ¯èƒ¸è„…èˆˆè•éƒ·é¡éŸ¿é¥—é©šä»°å‡å°­æšæ¥­å±€æ›²æ¥µç‰æ¡ç²åƒ…å‹¤å‡å·¾éŒ¦æ–¤æ¬£æ¬½ç´ç¦ç¦½ç­‹ç·ŠèŠ¹èŒè¡¿è¥Ÿè¬¹è¿‘é‡‘åŸéŠ€ä¹å€¶å¥åŒºç‹—ç–çŸ©è‹¦èº¯é§†é§ˆé§’å…·æ„šè™å–°ç©ºå¶å¯“é‡éš…ä¸²æ«›é‡§å±‘å±ˆ"],
    ["b7a1", "æ˜çªŸæ²“é´è½¡çªªç†Šéšˆç²‚æ —ç¹°æ¡‘é¬å‹²å›è–«è¨“ç¾¤è»éƒ¡å¦è¢ˆç¥ä¿‚å‚¾åˆ‘å…„å•“åœ­çªå‹å¥‘å½¢å¾„æµæ…¶æ…§æ†©æ²æºæ•¬æ™¯æ¡‚æ¸“ç•¦ç¨½ç³»çµŒç¶™ç¹‹ç½«èŒèŠè›è¨ˆè©£è­¦è»½é šé¶èŠ¸è¿é¯¨åŠ‡æˆŸæ’ƒæ¿€éš™æ¡å‚‘æ¬ æ±ºæ½”ç©´çµè¡€è¨£æœˆä»¶å€¹å€¦å¥å…¼åˆ¸å‰£å–§åœå …å«Œå»ºæ†²æ‡¸æ‹³æ²"],
    ["b8a1", "æ¤œæ¨©ç‰½çŠ¬çŒ®ç ”ç¡¯çµ¹çœŒè‚©è¦‹è¬™è³¢è»’é£éµé™ºé¡•é¨“é¹¸å…ƒåŸå³å¹»å¼¦æ¸›æºç„ç¾çµƒèˆ·è¨€è«ºé™ä¹å€‹å¤å‘¼å›ºå§‘å­¤å·±åº«å¼§æˆ¸æ•…æ¯æ¹–ç‹ç³Šè¢´è‚¡èƒ¡è°è™èª‡è·¨éˆ·é›‡é¡§é¼“äº”äº’ä¼åˆå‘‰å¾å¨¯å¾Œå¾¡æ‚Ÿæ¢§æªç‘šç¢èªèª¤è­·é†ä¹é¯‰äº¤ä½¼ä¾¯å€™å€–å…‰å…¬åŠŸåŠ¹å‹¾åšå£å‘"],
    ["b9a1", "åå–‰å‘å¢å¥½å­”å­å®å·¥å·§å··å¹¸åºƒåºšåº·å¼˜æ’æ…ŒæŠ—æ‹˜æ§æ”»æ˜‚æ™ƒæ›´æ­æ ¡æ¢—æ§‹æ±Ÿæ´ªæµ©æ¸¯æºç”²çš‡ç¡¬ç¨¿ç³ ç´…ç´˜çµç¶±è€•è€ƒè‚¯è‚±è…”è†èˆªè’è¡Œè¡¡è¬›è²¢è³¼éƒŠé…µé‰±ç ¿é‹¼é–¤é™é …é¦™é«˜é´»å‰›åŠ«å·åˆå£•æ‹·æ¿ è±ªè½Ÿéº¹å…‹åˆ»å‘Šå›½ç©€é…·éµ é»’ç„æ¼‰è…°ç”‘å¿½æƒšéª¨ç‹›è¾¼"],
    ["baa1", "æ­¤é ƒä»Šå›°å¤å¢¾å©šæ¨æ‡‡æ˜æ˜†æ ¹æ¢±æ··ç—•ç´ºè‰®é­‚äº›ä½å‰å”†åµ¯å·¦å·®æŸ»æ²™ç‘³ç ‚è©é–è£Ÿååº§æŒ«å‚µå‚¬å†æœ€å“‰å¡å¦»å®°å½©æ‰æ¡æ ½æ­³æ¸ˆç½é‡‡çŠ€ç •ç ¦ç¥­æ–ç´°èœè£è¼‰éš›å‰¤åœ¨æç½ªè²¡å†´å‚é˜ªå ºæ¦Šè‚´å’²å´åŸ¼ç¢•é·ºä½œå‰Šå’‹æ¾æ˜¨æœ”æŸµçª„ç­–ç´¢éŒ¯æ¡œé®­ç¬¹åŒ™å†Šåˆ·"],
    ["bba1", "å¯Ÿæ‹¶æ’®æ“¦æœ­æ®ºè–©é›‘çšé¯–æŒéŒ†é®«çš¿æ™’ä¸‰å‚˜å‚å±±æƒ¨æ’’æ•£æ¡Ÿç‡¦çŠç”£ç®—çº‚èš•è®ƒè³›é…¸é¤æ–¬æš«æ®‹ä»•ä»”ä¼ºä½¿åˆºå¸å²å—£å››å£«å§‹å§‰å§¿å­å±å¸‚å¸«å¿—æ€æŒ‡æ”¯å­œæ–¯æ–½æ—¨ææ­¢æ­»æ°ç…ç¥‰ç§ç³¸ç´™ç´«è‚¢è„‚è‡³è¦–è©è©©è©¦èªŒè«®è³‡è³œé›Œé£¼æ­¯äº‹ä¼¼ä¾å…å­—å¯ºæ…ˆæŒæ™‚"],
    ["bca1", "æ¬¡æ»‹æ²»çˆ¾ç’½ç—”ç£ç¤ºè€Œè€³è‡ªè’”è¾æ±é¹¿å¼è­˜é´«ç«ºè»¸å®é›«ä¸ƒå±åŸ·å¤±å«‰å®¤æ‚‰æ¹¿æ¼†ç–¾è³ªå®Ÿè”€ç¯ å²æŸ´èŠå±¡è•Šç¸èˆå†™å°„æ¨èµ¦æ–œç…®ç¤¾ç´—è€…è¬è»Šé®è›‡é‚ªå€Ÿå‹ºå°ºæ“ç¼çˆµé…Œé‡ˆéŒ«è‹¥å¯‚å¼±æƒ¹ä¸»å–å®ˆæ‰‹æœ±æ®Šç‹©ç ç¨®è…«è¶£é…’é¦–å„’å—å‘ªå¯¿æˆæ¨¹ç¶¬éœ€å›šåå‘¨"],
    ["bda1", "å®—å°±å·ä¿®æ„æ‹¾æ´²ç§€ç§‹çµ‚ç¹ç¿’è‡­èˆŸè’è¡†è¥²è®è¹´è¼¯é€±é…‹é…¬é›†é†œä»€ä½å……åå¾“æˆæŸ”æ±æ¸‹ç£ç¸¦é‡éŠƒå”å¤™å®¿æ·‘ç¥ç¸®ç²›å¡¾ç†Ÿå‡ºè¡“è¿°ä¿Šå³»æ˜¥ç¬ç«£èˆœé§¿å‡†å¾ªæ—¬æ¥¯æ®‰æ·³æº–æ½¤ç›¾ç´”å·¡éµé†‡é †å‡¦åˆæ‰€æš‘æ›™æ¸šåº¶ç·’ç½²æ›¸è–¯è—·è«¸åŠ©å™å¥³åºå¾æ•é‹¤é™¤å‚·å„Ÿ"],
    ["bea1", "å‹åŒ å‡å¬å“¨å•†å”±å˜—å¥¨å¦¾å¨¼å®µå°†å°å°‘å°šåº„åºŠå» å½°æ‰¿æŠ„æ‹›æŒæ·æ˜‡æ˜Œæ˜­æ™¶æ¾æ¢¢æ¨Ÿæ¨µæ²¼æ¶ˆæ¸‰æ¹˜ç„¼ç„¦ç…§ç—‡çœç¡ç¤ç¥¥ç§°ç« ç¬‘ç²§ç´¹è‚–è–è’‹è•‰è¡è£³è¨Ÿè¨¼è©”è©³è±¡è³é†¤é‰¦é¾é˜éšœé˜ä¸Šä¸ˆä¸ä¹—å†—å‰°åŸå ´å£Œå¬¢å¸¸æƒ…æ“¾æ¡æ–æµ„çŠ¶ç•³ç©£è’¸è­²é†¸éŒ å˜±åŸ´é£¾"],
    ["bfa1", "æ‹­æ¤æ®–ç‡­ç¹”è·è‰²è§¦é£Ÿè•è¾±å°»ä¼¸ä¿¡ä¾µå”‡å¨ å¯å¯©å¿ƒæ…æŒ¯æ–°æ™‹æ£®æ¦›æµ¸æ·±ç”³ç–¹çœŸç¥ç§¦ç´³è‡£èŠ¯è–ªè¦ªè¨ºèº«è¾›é€²é‡éœ‡äººä»åˆƒå¡µå£¬å°‹ç”šå°½è…è¨Šè¿…é™£é­ç¬¥è«é ˆé…¢å›³å¨é€—å¹å‚å¸¥æ¨æ°´ç‚Šç¡ç²‹ç¿ è¡°é‚é…”éŒéŒ˜éšç‘é«„å´‡åµ©æ•°æ¢è¶¨é››æ®æ‰æ¤™è…é —é›€è£¾"],
    ["c0a1", "æ¾„æ‘ºå¯¸ä¸–ç€¬ç•æ˜¯å‡„åˆ¶å‹¢å§“å¾æ€§æˆæ”¿æ•´æ˜Ÿæ™´æ£²æ –æ­£æ¸…ç‰²ç”Ÿç››ç²¾è–å£°è£½è¥¿èª èª“è«‹é€é†’é’é™æ–‰ç¨è„†éš»å¸­æƒœæˆšæ–¥æ˜”æçŸ³ç©ç±ç¸¾è„Šè²¬èµ¤è·¡è¹Ÿç¢©åˆ‡æ‹™æ¥æ‘‚æŠ˜è¨­çªƒç¯€èª¬é›ªçµ¶èˆŒè‰ä»™å…ˆåƒå å®£å°‚å°–å·æˆ¦æ‰‡æ’°æ “æ ´æ³‰æµ…æ´—æŸ“æ½œç…ç…½æ—‹ç©¿ç®­ç·š"],
    ["c1a1", "ç¹Šç¾¨è…ºèˆ›èˆ¹è–¦è©®è³è·µé¸é·éŠ­éŠ‘é–ƒé®®å‰å–„æ¼¸ç„¶å…¨ç¦…ç¹•è†³ç³å™Œå¡‘å²¨æªæ›¾æ›½æ¥šç‹™ç–ç–ç¤ç¥–ç§Ÿç²—ç´ çµ„è˜‡è¨´é˜»é¡é¼ åƒ§å‰µåŒå¢å€‰å–ªå£®å¥çˆ½å®‹å±¤åŒæƒ£æƒ³æœæƒæŒ¿æ»æ“æ—©æ›¹å·£æ§æ§½æ¼•ç‡¥äº‰ç—©ç›¸çª“ç³Ÿç·ç¶œè¡è‰è˜è‘¬è’¼è—»è£…èµ°é€é­é—éœœé¨’åƒå¢—æ†"],
    ["c2a1", "è‡“è”µè´ˆé€ ä¿ƒå´å‰‡å³æ¯æ‰æŸæ¸¬è¶³é€Ÿä¿—å±è³Šæ—ç¶šå’è¢–å…¶æƒå­˜å­«å°Šææ‘éœä»–å¤šå¤ªæ±°è©‘å”¾å •å¦¥æƒ°æ‰“æŸèˆµæ¥•é™€é§„é¨¨ä½“å †å¯¾è€å²±å¸¯å¾…æ€ æ…‹æˆ´æ›¿æ³°æ»èƒè…¿è‹”è¢‹è²¸é€€é€®éšŠé»›é¯›ä»£å°å¤§ç¬¬é†é¡Œé·¹æ»ç€§å“å•„å®…æ‰˜æŠæ‹“æ²¢æ¿¯ç¢è¨—é¸æ¿è«¾èŒ¸å‡§è›¸åª"],
    ["c3a1", "å©ä½†é”è¾°å¥ªè„±å·½ç«ªè¾¿æ£šè°·ç‹¸é±ˆæ¨½èª°ä¸¹å˜å˜†å¦æ‹…æ¢æ—¦æ­æ·¡æ¹›ç‚­çŸ­ç«¯ç®ªç¶»è€½èƒ†è›‹èª•é›å›£å£‡å¼¾æ–­æš–æª€æ®µç”·è«‡å€¤çŸ¥åœ°å¼›æ¥æ™ºæ± ç—´ç¨šç½®è‡´èœ˜é…é¦³ç¯‰ç•œç«¹ç­‘è“„é€ç§©çª’èŒ¶å«¡ç€ä¸­ä»²å®™å¿ æŠ½æ˜¼æŸ±æ³¨è™«è¡·è¨»é…é‹³é§æ¨—ç€¦çŒªè‹§è‘—è²¯ä¸å…†å‡‹å–‹å¯µ"],
    ["c4a1", "å¸–å¸³åºå¼”å¼µå½«å¾´æ‡²æŒ‘æš¢æœæ½®ç‰’ç”ºçœºè´è„¹è…¸è¶èª¿è«œè¶…è·³éŠšé•·é ‚é³¥å‹…æ—ç›´æœ•æ²ˆçè³ƒé®é™³æ´¥å¢œæ¤æ§Œè¿½éšç—›é€šå¡šæ ‚æ´æ§»ä½ƒæ¼¬æŸ˜è¾»è”¦ç¶´é”æ¤¿æ½°åªå£·å¬¬ç´¬çˆªåŠé‡£é¶´äº­ä½åœåµå‰ƒè²å‘ˆå ¤å®šå¸åº•åº­å»·å¼Ÿæ‚ŒæŠµæŒºææ¢¯æ±€ç¢‡ç¦ç¨‹ç· è‰‡è¨‚è«¦è¹„é€“"],
    ["c5a1", "é‚¸é„­é‡˜é¼æ³¥æ‘˜æ“¢æ•µæ»´çš„ç¬›é©é‘æººå“²å¾¹æ’¤è½è¿­é‰„å…¸å¡«å¤©å±•åº—æ·»çºç”œè²¼è»¢é¡›ç‚¹ä¼æ®¿æ¾±ç”°é›»å…åå µå¡—å¦¬å± å¾’æ–—æœæ¸¡ç™»èŸè³­é€”éƒ½éç ¥ç ºåŠªåº¦åœŸå¥´æ€’å€’å…šå†¬å‡åˆ€å”å¡”å¡˜å¥—å®•å³¶å¶‹æ‚¼æŠ•æ­æ±æ¡ƒæ¢¼æ£Ÿç›—æ·˜æ¹¯æ¶›ç¯ç‡ˆå½“ç—˜ç¥·ç­‰ç­”ç­’ç³–çµ±åˆ°"],
    ["c6a1", "è‘£è•©è—¤è¨è¬„è±†è¸é€ƒé€é™é™¶é ­é¨°é—˜åƒå‹•åŒå ‚å°æ†§æ’æ´ç³ç«¥èƒ´è„é“éŠ…å³ é´‡åŒ¿å¾—å¾³æ¶œç‰¹ç£ç¦¿ç¯¤æ¯’ç‹¬èª­æ ƒæ©¡å‡¸çªæ¤´å±Šé³¶è‹«å¯…é…‰ç€å™¸å±¯æƒ‡æ•¦æ²Œè±šéé “å‘‘æ›‡éˆå¥ˆé‚£å†…ä¹å‡ªè–™è¬ç˜æºé‹æ¥¢é¦´ç¸„ç•·å—æ¥ è»Ÿé›£æ±äºŒå°¼å¼è¿©åŒ‚è³‘è‚‰è™¹å»¿æ—¥ä¹³å…¥"],
    ["c7a1", "å¦‚å°¿éŸ®ä»»å¦Šå¿èªæ¿¡ç¦°ç¥¢å¯§è‘±çŒ«ç†±å¹´å¿µæ»æ’šç‡ƒç²˜ä¹ƒå»¼ä¹‹åŸœåš¢æ‚©æ¿ƒç´èƒ½è„³è†¿è¾²è¦—èš¤å·´æŠŠæ’­è¦‡æ·æ³¢æ´¾ç¶ç ´å©†ç½µèŠ­é¦¬ä¿³å»ƒæ‹æ’æ•—æ¯ç›ƒç‰ŒèƒŒè‚ºè¼©é…å€åŸ¹åª’æ¢…æ¥³ç…¤ç‹½è²·å£²è³ é™ªé€™è¿ç§¤çŸ§è©ä¼¯å‰¥åšæ‹æŸæ³Šç™½ç®”ç²•èˆ¶è–„è¿«æ›æ¼ çˆ†ç¸›è«é§éº¦"],
    ["c8a1", "å‡½ç®±ç¡²ç®¸è‚‡ç­ˆæ«¨å¹¡è‚Œç•‘ç• å…«é‰¢æºŒç™ºé†—é«ªä¼ç½°æŠœç­é–¥é³©å™ºå¡™è›¤éš¼ä¼´åˆ¤åŠåå›å¸†æ¬æ–‘æ¿æ°¾æ±ç‰ˆçŠ¯ç­ç•”ç¹èˆ¬è—©è²©ç¯„é‡†ç…©é ’é£¯æŒ½æ™©ç•ªç›¤ç£è•ƒè›®åŒªå‘å¦å¦ƒåº‡å½¼æ‚²æ‰‰æ‰¹æŠ«æ–æ¯”æ³Œç–²çš®ç¢‘ç§˜ç·‹ç½·è‚¥è¢«èª¹è²»é¿éé£›æ¨‹ç°¸å‚™å°¾å¾®æ‡æ¯˜çµçœ‰ç¾"],
    ["c9a1", "é¼»æŸŠç¨—åŒ¹ç–‹é«­å½¦è†è±è‚˜å¼¼å¿…ç•¢ç­†é€¼æ¡§å§«åª›ç´ç™¾è¬¬ä¿µå½ªæ¨™æ°·æ¼‚ç“¢ç¥¨è¡¨è©•è±¹å»Ÿæç—…ç§’è‹—éŒ¨é‹²è’œè›­é°­å“å½¬æ–Œæµœç€•è²§è³“é »æ•ç“¶ä¸ä»˜åŸ å¤«å©¦å¯Œå†¨å¸ƒåºœæ€–æ‰¶æ•·æ–§æ™®æµ®çˆ¶ç¬¦è…è†šèŠ™è­œè² è³¦èµ´é˜œé™„ä¾®æ’«æ­¦èˆè‘¡è•ªéƒ¨å°æ¥“é¢¨è‘ºè•—ä¼å‰¯å¾©å¹…æœ"],
    ["caa1", "ç¦è…¹è¤‡è¦†æ·µå¼—æ‰•æ²¸ä»ç‰©é®’åˆ†å»å™´å¢³æ†¤æ‰®ç„šå¥®ç²‰ç³ç´›é›°æ–‡èä¸™ä½µå…µå¡€å¹£å¹³å¼ŠæŸ„ä¸¦è”½é–‰é™›ç±³é åƒ»å£ç™–ç¢§åˆ¥ç¥è”‘ç®†åå¤‰ç‰‡ç¯‡ç·¨è¾ºè¿”éä¾¿å‹‰å¨©å¼é­ä¿èˆ—é‹ªåœƒæ•æ­©ç”«è£œè¼”ç©‚å‹Ÿå¢“æ…•æˆŠæš®æ¯ç°¿è©å€£ä¿¸åŒ…å‘†å ±å¥‰å®å³°å³¯å´©åº–æŠ±æ§æ”¾æ–¹æœ‹"],
    ["cba1", "æ³•æ³¡çƒ¹ç ²ç¸«èƒèŠ³èŒè“¬èœ‚è¤’è¨ªè±Šé‚¦é‹’é£½é³³éµ¬ä¹äº¡å‚å‰–åŠå¦¨å¸½å¿˜å¿™æˆ¿æš´æœ›æŸæ£’å†’ç´¡è‚ªè†¨è¬€è²Œè²¿é‰¾é˜²å é ¬åŒ—åƒ•åœå¢¨æ’²æœ´ç‰§ç¦ç©†é‡¦å‹ƒæ²¡æ®†å €å¹Œå¥”æœ¬ç¿»å‡¡ç›†æ‘©ç£¨é­”éº»åŸ‹å¦¹æ˜§æšæ¯å“©æ§™å¹•è†œæ•é®ªæŸ¾é±’æ¡äº¦ä¿£åˆæŠ¹æœ«æ²«è¿„ä¾­ç¹­éº¿ä¸‡æ…¢æº€"],
    ["cca1", "æ¼«è”“å‘³æœªé­…å·³ç®•å²¬å¯†èœœæ¹Šè“‘ç¨”è„ˆå¦™ç²æ°‘çœ å‹™å¤¢ç„¡ç‰ŸçŸ›éœ§éµ¡æ¤‹å©¿å¨˜å†¥åå‘½æ˜ç›Ÿè¿·éŠ˜é³´å§ªç‰æ»…å…æ£‰ç¶¿ç·¬é¢éººæ‘¸æ¨¡èŒ‚å¦„å­Ÿæ¯›çŒ›ç›²ç¶²è€—è’™å„²æœ¨é»™ç›®æ¢å‹¿é¤…å°¤æˆ»ç±¾è²°å•æ‚¶ç´‹é–€åŒä¹Ÿå†¶å¤œçˆºè€¶é‡å¼¥çŸ¢å„å½¹ç´„è–¬è¨³èºé–æŸ³è–®é‘“æ„‰æ„ˆæ²¹ç™’"],
    ["cda1", "è«­è¼¸å”¯ä½‘å„ªå‹‡å‹å®¥å¹½æ‚ æ†‚æ–æœ‰æŸšæ¹§æ¶ŒçŒ¶çŒ·ç”±ç¥è£•èª˜éŠé‚‘éƒµé›„èå¤•äºˆä½™ä¸èª‰è¼¿é å‚­å¹¼å¦–å®¹åº¸æšæºæ“æ›œæ¥Šæ§˜æ´‹æº¶ç†”ç”¨çª¯ç¾Šè€€è‘‰è“‰è¦è¬¡è¸Šé¥é™½é¤Šæ…¾æŠ‘æ¬²æ²ƒæµ´ç¿Œç¿¼æ·€ç¾…èºè£¸æ¥è±é ¼é›·æ´›çµ¡è½é…ªä¹±åµåµæ¬„æ¿«è—è˜­è¦§åˆ©åå±¥ææ¢¨ç†ç’ƒ"],
    ["cea1", "ç—¢è£è£¡é‡Œé›¢é™¸å¾‹ç‡ç«‹è‘æ ç•¥åŠ‰æµæºœç‰ç•™ç¡«ç²’éš†ç«œé¾ä¾¶æ…®æ—…è™œäº†äº®åƒšä¸¡å‡Œå¯®æ–™æ¢æ¶¼çŒŸç™‚ç­ç¨œç³§è‰¯è«’é¼é‡é™µé ˜åŠ›ç·‘å€«å˜æ—æ·‹ç‡ç³è‡¨è¼ªéš£é±—éºŸç‘ å¡æ¶™ç´¯é¡ä»¤ä¼¶ä¾‹å†·åŠ±å¶ºæ€œç²ç¤¼è‹“éˆ´éš·é›¶éœŠéº—é½¢æš¦æ­´åˆ—åŠ£çƒˆè£‚å»‰æ‹æ†æ¼£ç…‰ç°¾ç·´è¯"],
    ["cfa1", "è“®é€£éŒ¬å‘‚é­¯æ«“ç‚‰è³‚è·¯éœ²åŠ´å©å»Šå¼„æœ—æ¥¼æ¦”æµªæ¼ç‰¢ç‹¼ç¯­è€è¾è‹éƒå…­éº“ç¦„è‚‹éŒ²è«–å€­å’Œè©±æ­ªè³„è„‡æƒ‘æ é·²äº™äº˜é°è©«è—è•¨æ¤€æ¹¾ç¢—è…•"],
    ["d0a1", "å¼Œä¸ä¸•ä¸ªä¸±ä¸¶ä¸¼ä¸¿ä¹‚ä¹–ä¹˜äº‚äº…è±«äºŠèˆ’å¼äºäºäºŸäº äº¢äº°äº³äº¶ä»ä»ä»„ä»†ä»‚ä»—ä»ä»­ä»Ÿä»·ä¼‰ä½šä¼°ä½›ä½ä½—ä½‡ä½¶ä¾ˆä¾ä¾˜ä½»ä½©ä½°ä¾‘ä½¯ä¾†ä¾–å„˜ä¿”ä¿Ÿä¿ä¿˜ä¿›ä¿‘ä¿šä¿ä¿¤ä¿¥å€šå€¨å€”å€ªå€¥å€…ä¼œä¿¶å€¡å€©å€¬ä¿¾ä¿¯å€‘å€†åƒå‡æœƒå•ååˆåšå–å¬å¸å‚€å‚šå‚…å‚´å‚²"],
    ["d1a1", "åƒ‰åƒŠå‚³åƒ‚åƒ–åƒåƒ¥åƒ­åƒ£åƒ®åƒ¹åƒµå„‰å„å„‚å„–å„•å„”å„šå„¡å„ºå„·å„¼å„»å„¿å…€å…’å…Œå…”å…¢ç«¸å…©å…ªå…®å†€å†‚å›˜å†Œå†‰å†å†‘å†“å†•å†–å†¤å†¦å†¢å†©å†ªå†«å†³å†±å†²å†°å†µå†½å‡…å‡‰å‡›å‡ è™•å‡©å‡­å‡°å‡µå‡¾åˆ„åˆ‹åˆ”åˆåˆ§åˆªåˆ®åˆ³åˆ¹å‰å‰„å‰‹å‰Œå‰å‰”å‰ªå‰´å‰©å‰³å‰¿å‰½åŠåŠ”åŠ’å‰±åŠˆåŠ‘è¾¨"],
    ["d2a1", "è¾§åŠ¬åŠ­åŠ¼åŠµå‹å‹å‹—å‹å‹£å‹¦é£­å‹ å‹³å‹µå‹¸å‹¹åŒ†åŒˆç”¸åŒåŒåŒåŒ•åŒšåŒ£åŒ¯åŒ±åŒ³åŒ¸å€å†å…ä¸—å‰åå‡–åå©å®å¤˜å»å·å‚å–å å¦å¥å®å°å¶åƒç°’é›™åŸæ›¼ç‡®å®å¨å­åºåå½å‘€å¬å­å¼å®å¶å©åå‘å’å‘µå’å‘Ÿå‘±å‘·å‘°å’’å‘»å’€å‘¶å’„å’å’†å“‡å’¢å’¸å’¥å’¬å“„å“ˆå’¨"],
    ["d3a1", "å’«å“‚å’¤å’¾å’¼å“˜å“¥å“¦å”å””å“½å“®å“­å“ºå“¢å”¹å•€å•£å•Œå”®å•œå•…å•–å•—å”¸å”³å•å–™å–€å’¯å–Šå–Ÿå•»å•¾å–˜å–å–®å•¼å–ƒå–©å–‡å–¨å—šå—…å—Ÿå—„å—œå—¤å—”å˜”å—·å˜–å—¾å—½å˜›å—¹å™å™ç‡Ÿå˜´å˜¶å˜²å˜¸å™«å™¤å˜¯å™¬å™ªåš†åš€åšŠåš åš”åšåš¥åš®åš¶åš´å›‚åš¼å›å›ƒå›€å›ˆå›å›‘å›“å›—å›®å›¹åœ€å›¿åœ„åœ‰"],
    ["d4a1", "åœˆåœ‹åœåœ“åœ˜åœ–å—‡åœœåœ¦åœ·åœ¸ååœ»å€åå©åŸ€åˆå¡å¿å‰å“å å³å¤åªå°åŸƒåŸ†åŸ”åŸ’åŸ“å ŠåŸ–åŸ£å ‹å ™å å¡²å ¡å¡¢å¡‹å¡°æ¯€å¡’å ½å¡¹å¢…å¢¹å¢Ÿå¢«å¢ºå£å¢»å¢¸å¢®å£…å£“å£‘å£—å£™å£˜å£¥å£œå£¤å£Ÿå£¯å£ºå£¹å£»å£¼å£½å¤‚å¤Šå¤å¤›æ¢¦å¤¥å¤¬å¤­å¤²å¤¸å¤¾ç«’å¥•å¥å¥å¥šå¥˜å¥¢å¥ å¥§å¥¬å¥©"],
    ["d5a1", "å¥¸å¦å¦ä½ä¾«å¦£å¦²å§†å§¨å§œå¦å§™å§šå¨¥å¨Ÿå¨‘å¨œå¨‰å¨šå©€å©¬å©‰å¨µå¨¶å©¢å©ªåªšåª¼åª¾å«‹å«‚åª½å«£å«—å«¦å«©å«–å«ºå«»å¬Œå¬‹å¬–å¬²å«å¬ªå¬¶å¬¾å­ƒå­…å­€å­‘å­•å­šå­›å­¥å­©å­°å­³å­µå­¸æ–ˆå­ºå®€å®ƒå®¦å®¸å¯ƒå¯‡å¯‰å¯”å¯å¯¤å¯¦å¯¢å¯å¯¥å¯«å¯°å¯¶å¯³å°…å°‡å°ˆå°å°“å° å°¢å°¨å°¸å°¹å±å±†å±å±“"],
    ["d6a1", "å±å±å­±å±¬å±®ä¹¢å±¶å±¹å²Œå²‘å²”å¦›å²«å²»å²¶å²¼å²·å³…å²¾å³‡å³™å³©å³½å³ºå³­å¶Œå³ªå´‹å´•å´—åµœå´Ÿå´›å´‘å´”å´¢å´šå´™å´˜åµŒåµ’åµåµ‹åµ¬åµ³åµ¶å¶‡å¶„å¶‚å¶¢å¶å¶¬å¶®å¶½å¶å¶·å¶¼å·‰å·å·“å·’å·–å·›å·«å·²å·µå¸‹å¸šå¸™å¸‘å¸›å¸¶å¸·å¹„å¹ƒå¹€å¹å¹—å¹”å¹Ÿå¹¢å¹¤å¹‡å¹µå¹¶å¹ºéº¼å¹¿åº å»å»‚å»ˆå»å»"],
    ["d7a1", "å»–å»£å»å»šå»›å»¢å»¡å»¨å»©å»¬å»±å»³å»°å»´å»¸å»¾å¼ƒå¼‰å½å½œå¼‹å¼‘å¼–å¼©å¼­å¼¸å½å½ˆå½Œå½å¼¯å½‘å½–å½—å½™å½¡å½­å½³å½·å¾ƒå¾‚å½¿å¾Šå¾ˆå¾‘å¾‡å¾å¾™å¾˜å¾ å¾¨å¾­å¾¼å¿–å¿»å¿¤å¿¸å¿±å¿æ‚³å¿¿æ€¡æ æ€™æ€æ€©æ€æ€±æ€›æ€•æ€«æ€¦æ€æ€ºæšææªæ·æŸæŠæ†ææ£æƒæ¤æ‚æ¬æ«æ™æ‚æ‚æƒ§æ‚ƒæ‚š"],
    ["d8a1", "æ‚„æ‚›æ‚–æ‚—æ‚’æ‚§æ‚‹æƒ¡æ‚¸æƒ æƒ“æ‚´å¿°æ‚½æƒ†æ‚µæƒ˜æ…æ„•æ„†æƒ¶æƒ·æ„€æƒ´æƒºæ„ƒæ„¡æƒ»æƒ±æ„æ„æ…‡æ„¾æ„¨æ„§æ…Šæ„¿æ„¼æ„¬æ„´æ„½æ…‚æ…„æ…³æ…·æ…˜æ…™æ…šæ…«æ…´æ…¯æ…¥æ…±æ…Ÿæ…æ…“æ…µæ†™æ†–æ†‡æ†¬æ†”æ†šæ†Šæ†‘æ†«æ†®æ‡Œæ‡Šæ‡‰æ‡·æ‡ˆæ‡ƒæ‡†æ†ºæ‡‹ç½¹æ‡æ‡¦æ‡£æ‡¶æ‡ºæ‡´æ‡¿æ‡½æ‡¼æ‡¾æˆ€æˆˆæˆ‰æˆæˆŒæˆ”æˆ›"],
    ["d9a1", "æˆæˆ¡æˆªæˆ®æˆ°æˆ²æˆ³æ‰æ‰æ‰æ‰£æ‰›æ‰ æ‰¨æ‰¼æŠ‚æŠ‰æ‰¾æŠ’æŠ“æŠ–æ‹”æŠƒæŠ”æ‹—æ‹‘æŠ»æ‹æ‹¿æ‹†æ“”æ‹ˆæ‹œæ‹Œæ‹Šæ‹‚æ‹‡æŠ›æ‹‰æŒŒæ‹®æ‹±æŒ§æŒ‚æŒˆæ‹¯æ‹µææŒ¾ææœææ–ææ€æ«æ¶æ£ææ‰æŸæµæ«æ©æ¾æ©æ€æ†æ£æ‰æ’æ¶æ„æ–æ´æ†æ“æ¦æ¶æ”æ—æ¨ææ‘§æ‘¯æ‘¶æ‘æ”ªæ’•æ’“æ’¥æ’©æ’ˆæ’¼"],
    ["daa1", "æ“šæ“’æ“…æ“‡æ’»æ“˜æ“‚æ“±æ“§èˆ‰æ“ æ“¡æŠ¬æ“£æ“¯æ”¬æ“¶æ“´æ“²æ“ºæ”€æ“½æ”˜æ”œæ”…æ”¤æ”£æ”«æ”´æ”µæ”·æ”¶æ”¸ç•‹æ•ˆæ•–æ••æ•æ•˜æ•æ•æ•²æ•¸æ–‚æ–ƒè®Šæ–›æ–Ÿæ–«æ–·æ—ƒæ—†æ—æ—„æ—Œæ—’æ—›æ—™æ— æ—¡æ—±æ²æ˜Šæ˜ƒæ—»æ³æ˜µæ˜¶æ˜´æ˜œæ™æ™„æ™‰æ™æ™æ™æ™¤æ™§æ™¨æ™Ÿæ™¢æ™°æšƒæšˆæšæš‰æš„æš˜æšæ›æš¹æ›‰æš¾æš¼"],
    ["dba1", "æ›„æš¸æ›–æ›šæ› æ˜¿æ›¦æ›©æ›°æ›µæ›·æœæœ–æœæœ¦æœ§éœ¸æœ®æœ¿æœ¶ææœ¸æœ·æ†ææ æ™æ£æ¤æ‰æ°æ©æ¼æªæŒæ‹æ¦æ¡æ…æ·æŸ¯æ´æŸ¬æ³æŸ©æ¸æŸ¤æŸæŸæŸ¢æŸ®æ¹æŸæŸ†æŸ§æªœæ æ¡†æ ©æ¡€æ¡æ ²æ¡æ¢³æ «æ¡™æ¡£æ¡·æ¡¿æ¢Ÿæ¢æ¢­æ¢”æ¢æ¢›æ¢ƒæª®æ¢¹æ¡´æ¢µæ¢ æ¢ºæ¤æ¢æ¡¾æ¤æ£Šæ¤ˆæ£˜æ¤¢æ¤¦æ£¡æ¤Œæ£"],
    ["dca1", "æ£”æ£§æ£•æ¤¶æ¤’æ¤„æ£—æ££æ¤¥æ£¹æ£ æ£¯æ¤¨æ¤ªæ¤šæ¤£æ¤¡æ£†æ¥¹æ¥·æ¥œæ¥¸æ¥«æ¥”æ¥¾æ¥®æ¤¹æ¥´æ¤½æ¥™æ¤°æ¥¡æ¥æ¥æ¦æ¥ªæ¦²æ¦®æ§æ¦¿æ§æ§“æ¦¾æ§å¯¨æ§Šæ§æ¦»æ§ƒæ¦§æ¨®æ¦‘æ¦ æ¦œæ¦•æ¦´æ§æ§¨æ¨‚æ¨›æ§¿æ¬Šæ§¹æ§²æ§§æ¨…æ¦±æ¨æ§­æ¨”æ§«æ¨Šæ¨’æ«æ¨£æ¨“æ©„æ¨Œæ©²æ¨¶æ©¸æ©‡æ©¢æ©™æ©¦æ©ˆæ¨¸æ¨¢æªæªæª æª„æª¢æª£"],
    ["dda1", "æª—è˜—æª»æ«ƒæ«‚æª¸æª³æª¬æ«æ«‘æ«Ÿæªªæ«šæ«ªæ«»æ¬…è˜–æ«ºæ¬’æ¬–é¬±æ¬Ÿæ¬¸æ¬·ç›œæ¬¹é£®æ­‡æ­ƒæ­‰æ­æ­™æ­”æ­›æ­Ÿæ­¡æ­¸æ­¹æ­¿æ®€æ®„æ®ƒæ®æ®˜æ®•æ®æ®¤æ®ªæ®«æ®¯æ®²æ®±æ®³æ®·æ®¼æ¯†æ¯‹æ¯“æ¯Ÿæ¯¬æ¯«æ¯³æ¯¯éº¾æ°ˆæ°“æ°”æ°›æ°¤æ°£æ±æ±•æ±¢æ±ªæ²‚æ²æ²šæ²æ²›æ±¾æ±¨æ±³æ²’æ²æ³„æ³±æ³“æ²½æ³—æ³…æ³æ²®æ²±æ²¾"],
    ["dea1", "æ²ºæ³›æ³¯æ³™æ³ªæ´Ÿè¡æ´¶æ´«æ´½æ´¸æ´™æ´µæ´³æ´’æ´Œæµ£æ¶“æµ¤æµšæµ¹æµ™æ¶æ¶•æ¿¤æ¶…æ·¹æ¸•æ¸Šæ¶µæ·‡æ·¦æ¶¸æ·†æ·¬æ·æ·Œæ·¨æ·’æ·…æ·ºæ·™æ·¤æ·•æ·ªæ·®æ¸­æ¹®æ¸®æ¸™æ¹²æ¹Ÿæ¸¾æ¸£æ¹«æ¸«æ¹¶æ¹æ¸Ÿæ¹ƒæ¸ºæ¹æ¸¤æ»¿æ¸æ¸¸æº‚æºªæº˜æ»‰æº·æ»“æº½æº¯æ»„æº²æ»”æ»•æºæº¥æ»‚æºŸæ½æ¼‘çŒæ»¬æ»¸æ»¾æ¼¿æ»²æ¼±æ»¯æ¼²æ»Œ"],
    ["dfa1", "æ¼¾æ¼“æ»·æ¾†æ½ºæ½¸æ¾æ¾€æ½¯æ½›æ¿³æ½­æ¾‚æ½¼æ½˜æ¾æ¾‘æ¿‚æ½¦æ¾³æ¾£æ¾¡æ¾¤æ¾¹æ¿†æ¾ªæ¿Ÿæ¿•æ¿¬æ¿”æ¿˜æ¿±æ¿®æ¿›ç€‰ç€‹æ¿ºç€‘ç€ç€æ¿¾ç€›ç€šæ½´ç€ç€˜ç€Ÿç€°ç€¾ç€²ç‘ç£ç‚™ç‚’ç‚¯çƒ±ç‚¬ç‚¸ç‚³ç‚®çƒŸçƒ‹çƒçƒ™ç„‰çƒ½ç„œç„™ç…¥ç…•ç†ˆç…¦ç…¢ç…Œç…–ç…¬ç†ç‡»ç†„ç†•ç†¨ç†¬ç‡—ç†¹ç†¾ç‡’ç‡‰ç‡”ç‡ç‡ ç‡¬ç‡§ç‡µç‡¼"],
    ["e0a1", "ç‡¹ç‡¿çˆçˆçˆ›çˆ¨çˆ­çˆ¬çˆ°çˆ²çˆ»çˆ¼çˆ¿ç‰€ç‰†ç‰‹ç‰˜ç‰´ç‰¾çŠ‚çŠçŠ‡çŠ’çŠ–çŠ¢çŠ§çŠ¹çŠ²ç‹ƒç‹†ç‹„ç‹ç‹’ç‹¢ç‹ ç‹¡ç‹¹ç‹·å€çŒ—çŒŠçŒœçŒ–çŒçŒ´çŒ¯çŒ©çŒ¥çŒ¾ççé»˜ç—çªç¨ç°ç¸çµç»çºçˆç³çç»ç€ç¥ç®çç’¢ç…ç‘¯ç¥ç¸ç²çºç‘•ç¿ç‘Ÿç‘™ç‘ç‘œç‘©ç‘°ç‘£ç‘ªç‘¶ç‘¾ç’‹ç’ç’§ç“Šç“ç“”ç±"],
    ["e1a1", "ç“ ç“£ç“§ç“©ç“®ç“²ç“°ç“±ç“¸ç“·ç”„ç”ƒç”…ç”Œç”ç”ç”•ç”“ç”ç”¦ç”¬ç”¼ç•„ç•ç•Šç•‰ç•›ç•†ç•šç•©ç•¤ç•§ç•«ç•­ç•¸ç•¶ç–†ç–‡ç•´ç–Šç–‰ç–‚ç–”ç–šç–ç–¥ç–£ç—‚ç–³ç—ƒç–µç–½ç–¸ç–¼ç–±ç—ç—Šç—’ç—™ç—£ç—ç—¾ç—¿ç—¼ç˜ç—°ç—ºç—²ç—³ç˜‹ç˜ç˜‰ç˜Ÿç˜§ç˜ ç˜¡ç˜¢ç˜¤ç˜´ç˜°ç˜»ç™‡ç™ˆç™†ç™œç™˜ç™¡ç™¢ç™¨ç™©ç™ªç™§ç™¬ç™°"],
    ["e2a1", "ç™²ç™¶ç™¸ç™¼çš€çšƒçšˆçš‹çšçš–çš“çš™çššçš°çš´çš¸çš¹çšºç›‚ç›ç›–ç›’ç›ç›¡ç›¥ç›§ç›ªè˜¯ç›»çœˆçœ‡çœ„çœ©çœ¤çœçœ¥çœ¦çœ›çœ·çœ¸ç‡çšç¨ç«ç›ç¥ç¿ç¾ç¹çç‹ç‘ç çç°ç¶ç¹ç¿ç¼ç½ç»çŸ‡çŸçŸ—çŸšçŸœçŸ£çŸ®çŸ¼ç Œç ’ç¤¦ç  ç¤ªç¡…ç¢ç¡´ç¢†ç¡¼ç¢šç¢Œç¢£ç¢µç¢ªç¢¯ç£‘ç£†ç£‹ç£”ç¢¾ç¢¼ç£…ç£Šç£¬"],
    ["e3a1", "ç£§ç£šç£½ç£´ç¤‡ç¤’ç¤‘ç¤™ç¤¬ç¤«ç¥€ç¥ ç¥—ç¥Ÿç¥šç¥•ç¥“ç¥ºç¥¿ç¦Šç¦ç¦§é½‹ç¦ªç¦®ç¦³ç¦¹ç¦ºç§‰ç§•ç§§ç§¬ç§¡ç§£ç¨ˆç¨ç¨˜ç¨™ç¨ ç¨Ÿç¦€ç¨±ç¨»ç¨¾ç¨·ç©ƒç©—ç©‰ç©¡ç©¢ç©©é¾ç©°ç©¹ç©½çªˆçª—çª•çª˜çª–çª©ç«ˆçª°çª¶ç«…ç«„çª¿é‚ƒç«‡ç«Šç«ç«ç«•ç«“ç«™ç«šç«ç«¡ç«¢ç«¦ç«­ç«°ç¬‚ç¬ç¬Šç¬†ç¬³ç¬˜ç¬™ç¬ç¬µç¬¨ç¬¶ç­"],
    ["e4a1", "ç­ºç¬„ç­ç¬‹ç­Œç­…ç­µç­¥ç­´ç­§ç­°ç­±ç­¬ç­®ç®ç®˜ç®Ÿç®ç®œç®šç®‹ç®’ç®ç­ç®™ç¯‹ç¯ç¯Œç¯ç®´ç¯†ç¯ç¯©ç°‘ç°”ç¯¦ç¯¥ç± ç°€ç°‡ç°“ç¯³ç¯·ç°—ç°ç¯¶ç°£ç°§ç°ªç°Ÿç°·ç°«ç°½ç±Œç±ƒç±”ç±ç±€ç±ç±˜ç±Ÿç±¤ç±–ç±¥ç±¬ç±µç²ƒç²ç²¤ç²­ç²¢ç²«ç²¡ç²¨ç²³ç²²ç²±ç²®ç²¹ç²½ç³€ç³…ç³‚ç³˜ç³’ç³œç³¢é¬»ç³¯ç³²ç³´ç³¶ç³ºç´†"],
    ["e5a1", "ç´‚ç´œç´•ç´Šçµ…çµ‹ç´®ç´²ç´¿ç´µçµ†çµ³çµ–çµçµ²çµ¨çµ®çµçµ£ç¶“ç¶‰çµ›ç¶çµ½ç¶›ç¶ºç¶®ç¶£ç¶µç·‡ç¶½ç¶«ç¸½ç¶¢ç¶¯ç·œç¶¸ç¶Ÿç¶°ç·˜ç·ç·¤ç·ç·»ç·²ç·¡ç¸…ç¸Šç¸£ç¸¡ç¸’ç¸±ç¸Ÿç¸‰ç¸‹ç¸¢ç¹†ç¹¦ç¸»ç¸µç¸¹ç¹ƒç¸·ç¸²ç¸ºç¹§ç¹ç¹–ç¹ç¹™ç¹šç¹¹ç¹ªç¹©ç¹¼ç¹»çºƒç·•ç¹½è¾®ç¹¿çºˆçº‰çºŒçº’çºçº“çº”çº–çºçº›çºœç¼¸ç¼º"],
    ["e6a1", "ç½…ç½Œç½ç½ç½ç½‘ç½•ç½”ç½˜ç½Ÿç½ ç½¨ç½©ç½§ç½¸ç¾‚ç¾†ç¾ƒç¾ˆç¾‡ç¾Œç¾”ç¾ç¾ç¾šç¾£ç¾¯ç¾²ç¾¹ç¾®ç¾¶ç¾¸è­±ç¿…ç¿†ç¿Šç¿•ç¿”ç¿¡ç¿¦ç¿©ç¿³ç¿¹é£œè€†è€„è€‹è€’è€˜è€™è€œè€¡è€¨è€¿è€»èŠè†è’è˜èšèŸè¢è¨è³è²è°è¶è¹è½è¿è‚„è‚†è‚…è‚›è‚“è‚šè‚­å†è‚¬èƒ›èƒ¥èƒ™èƒèƒ„èƒšèƒ–è„‰èƒ¯èƒ±è„›è„©è„£è„¯è…‹"],
    ["e7a1", "éš‹è…†è„¾è…“è…‘èƒ¼è…±è…®è…¥è…¦è…´è†ƒè†ˆè†Šè†€è†‚è† è†•è†¤è†£è…Ÿè†“è†©è†°è†µè†¾è†¸è†½è‡€è‡‚è†ºè‡‰è‡è‡‘è‡™è‡˜è‡ˆè‡šè‡Ÿè‡ è‡§è‡ºè‡»è‡¾èˆèˆ‚èˆ…èˆ‡èˆŠèˆèˆèˆ–èˆ©èˆ«èˆ¸èˆ³è‰€è‰™è‰˜è‰è‰šè‰Ÿè‰¤è‰¢è‰¨è‰ªè‰«èˆ®è‰±è‰·è‰¸è‰¾èŠèŠ’èŠ«èŠŸèŠ»èŠ¬è‹¡è‹£è‹Ÿè‹’è‹´è‹³è‹ºè“èŒƒè‹»è‹¹è‹èŒ†è‹œèŒ‰è‹™"],
    ["e8a1", "èŒµèŒ´èŒ–èŒ²èŒ±è€èŒ¹èè…èŒ¯èŒ«èŒ—èŒ˜è…èšèªèŸè¢è–èŒ£èè‡èŠè¼èµè³èµè è‰è¨è´è“è«èè½èƒè˜è‹èè·è‡è è²èè¢è è½è¸è”†è»è‘­èªè¼è•šè’„è‘·è‘«è’­è‘®è’‚è‘©è‘†è¬è‘¯è‘¹èµè“Šè‘¢è’¹è’¿è’Ÿè“™è“è’»è“šè“è“è“†è“–è’¡è”¡è“¿è“´è”—è”˜è”¬è”Ÿè”•è””è“¼è•€è•£è•˜è•ˆ"],
    ["e9a1", "è•è˜‚è•‹è••è–€è–¤è–ˆè–‘è–Šè–¨è•­è–”è–›è—ªè–‡è–œè•·è•¾è–è—‰è–ºè—è–¹è—è—•è—è—¥è—œè—¹è˜Šè˜“è˜‹è—¾è—ºè˜†è˜¢è˜šè˜°è˜¿è™ä¹•è™”è™Ÿè™§è™±èš“èš£èš©èšªèš‹èšŒèš¶èš¯è›„è›†èš°è›‰è £èš«è›”è›è›©è›¬è›Ÿè››è›¯èœ’èœ†èœˆèœ€èœƒè›»èœ‘èœ‰èœè›¹èœŠèœ´èœ¿èœ·èœ»èœ¥èœ©èœšè èŸè¸èŒèè´è—è¨è®è™"],
    ["eaa1", "è“è£èªè …è¢èŸè‚è¯èŸ‹è½èŸ€èŸé›–è«èŸ„è³èŸ‡èŸ†è»èŸ¯èŸ²èŸ è è èŸ¾èŸ¶èŸ·è èŸ’è ‘è –è •è ¢è ¡è ±è ¶è ¹è §è »è¡„è¡‚è¡’è¡™è¡è¡¢è¡«è¢è¡¾è¢è¡µè¡½è¢µè¡²è¢‚è¢—è¢’è¢®è¢™è¢¢è¢è¢¤è¢°è¢¿è¢±è£ƒè£„è£”è£˜è£™è£è£¹è¤‚è£¼è£´è£¨è£²è¤„è¤Œè¤Šè¤“è¥ƒè¤è¤¥è¤ªè¤«è¥è¥„è¤»è¤¶è¤¸è¥Œè¤è¥ è¥"],
    ["eba1", "è¥¦è¥¤è¥­è¥ªè¥¯è¥´è¥·è¥¾è¦ƒè¦ˆè¦Šè¦“è¦˜è¦¡è¦©è¦¦è¦¬è¦¯è¦²è¦ºè¦½è¦¿è§€è§šè§œè§è§§è§´è§¸è¨ƒè¨–è¨è¨Œè¨›è¨è¨¥è¨¶è©è©›è©’è©†è©ˆè©¼è©­è©¬è©¢èª…èª‚èª„èª¨èª¡èª‘èª¥èª¦èªšèª£è«„è«è«‚è«šè««è«³è«§è«¤è«±è¬”è« è«¢è«·è«è«›è¬Œè¬‡è¬šè«¡è¬–è¬è¬—è¬ è¬³é«è¬¦è¬«è¬¾è¬¨è­è­Œè­è­è­‰è­–è­›è­šè­«"],
    ["eca1", "è­Ÿè­¬è­¯è­´è­½è®€è®Œè®è®’è®“è®–è®™è®šè°ºè±è°¿è±ˆè±Œè±è±è±•è±¢è±¬è±¸è±ºè²‚è²‰è²…è²Šè²è²è²”è±¼è²˜æˆè²­è²ªè²½è²²è²³è²®è²¶è³ˆè³è³¤è³£è³šè³½è³ºè³»è´„è´…è´Šè´‡è´è´è´é½è´“è³è´”è´–èµ§èµ­èµ±èµ³è¶è¶™è·‚è¶¾è¶ºè·è·šè·–è·Œè·›è·‹è·ªè·«è·Ÿè·£è·¼è¸ˆè¸‰è·¿è¸è¸è¸è¸Ÿè¹‚è¸µè¸°è¸´è¹Š"],
    ["eda1", "è¹‡è¹‰è¹Œè¹è¹ˆè¹™è¹¤è¹ è¸ªè¹£è¹•è¹¶è¹²è¹¼èºèº‡èº…èº„èº‹èºŠèº“èº‘èº”èº™èºªèº¡èº¬èº°è»†èº±èº¾è»…è»ˆè»‹è»›è»£è»¼è»»è»«è»¾è¼Šè¼…è¼•è¼’è¼™è¼“è¼œè¼Ÿè¼›è¼Œè¼¦è¼³è¼»è¼¹è½…è½‚è¼¾è½Œè½‰è½†è½è½—è½œè½¢è½£è½¤è¾œè¾Ÿè¾£è¾­è¾¯è¾·è¿šè¿¥è¿¢è¿ªè¿¯é‚‡è¿´é€…è¿¹è¿ºé€‘é€•é€¡é€é€é€–é€‹é€§é€¶é€µé€¹è¿¸"],
    ["eea1", "ééé‘é’é€é‰é€¾é–é˜éé¨é¯é¶éš¨é²é‚‚é½é‚é‚€é‚Šé‚‰é‚é‚¨é‚¯é‚±é‚µéƒ¢éƒ¤æ‰ˆéƒ›é„‚é„’é„™é„²é„°é…Šé…–é…˜é…£é…¥é…©é…³é…²é†‹é†‰é†‚é†¢é†«é†¯é†ªé†µé†´é†ºé‡€é‡é‡‰é‡‹é‡é‡–é‡Ÿé‡¡é‡›é‡¼é‡µé‡¶éˆé‡¿éˆ”éˆ¬éˆ•éˆ‘é‰é‰—é‰…é‰‰é‰¤é‰ˆéŠ•éˆ¿é‰‹é‰éŠœéŠ–éŠ“éŠ›é‰šé‹éŠ¹éŠ·é‹©éŒé‹ºé„éŒ®"],
    ["efa1", "éŒ™éŒ¢éŒšéŒ£éŒºéŒµéŒ»éœé é¼é®é–é°é¬é­é”é¹é–é—é¨é¥é˜éƒéééˆé¤éšé”é“éƒé‡éé¶é«éµé¡éºé‘é‘’é‘„é‘›é‘ é‘¢é‘é‘ªéˆ©é‘°é‘µé‘·é‘½é‘šé‘¼é‘¾é’é‘¿é–‚é–‡é–Šé–”é––é–˜é–™é– é–¨é–§é–­é–¼é–»é–¹é–¾é—Šæ¿¶é—ƒé—é—Œé—•é—”é—–é—œé—¡é—¥é—¢é˜¡é˜¨é˜®é˜¯é™‚é™Œé™é™‹é™·é™œé™"],
    ["f0a1", "é™é™Ÿé™¦é™²é™¬éšéš˜éš•éš—éšªéš§éš±éš²éš°éš´éš¶éš¸éš¹é›é›‹é›‰é›è¥é›œéœé›•é›¹éœ„éœ†éœˆéœ“éœéœ‘éœéœ–éœ™éœ¤éœªéœ°éœ¹éœ½éœ¾é„é†éˆé‚é‰éœé é¤é¦é¨å‹’é«é±é¹é…é¼ééºé†é‹éééœé¨é¦é£é³é´éŸƒéŸ†éŸˆéŸ‹éŸœéŸ­é½éŸ²ç«ŸéŸ¶éŸµé é Œé ¸é ¤é ¡é ·é ½é¡†é¡é¡‹é¡«é¡¯é¡°"],
    ["f1a1", "é¡±é¡´é¡³é¢ªé¢¯é¢±é¢¶é£„é£ƒé£†é£©é£«é¤ƒé¤‰é¤’é¤”é¤˜é¤¡é¤é¤é¤¤é¤ é¤¬é¤®é¤½é¤¾é¥‚é¥‰é¥…é¥é¥‹é¥‘é¥’é¥Œé¥•é¦—é¦˜é¦¥é¦­é¦®é¦¼é§Ÿé§›é§é§˜é§‘é§­é§®é§±é§²é§»é§¸é¨é¨é¨…é§¢é¨™é¨«é¨·é©…é©‚é©€é©ƒé¨¾é©•é©é©›é©—é©Ÿé©¢é©¥é©¤é©©é©«é©ªéª­éª°éª¼é«€é«é«‘é«“é«”é«é«Ÿé«¢é«£é«¦é«¯é««é«®é«´é«±é«·"],
    ["f2a1", "é«»é¬†é¬˜é¬šé¬Ÿé¬¢é¬£é¬¥é¬§é¬¨é¬©é¬ªé¬®é¬¯é¬²é­„é­ƒé­é­é­é­‘é­˜é­´é®“é®ƒé®‘é®–é®—é®Ÿé® é®¨é®´é¯€é¯Šé®¹é¯†é¯é¯‘é¯’é¯£é¯¢é¯¤é¯”é¯¡é°ºé¯²é¯±é¯°é°•é°”é°‰é°“é°Œé°†é°ˆé°’é°Šé°„é°®é°›é°¥é°¤é°¡é°°é±‡é°²é±†é°¾é±šé± é±§é±¶é±¸é³§é³¬é³°é´‰é´ˆé³«é´ƒé´†é´ªé´¦é¶¯é´£é´Ÿéµ„é´•é´’éµé´¿é´¾éµ†éµˆ"],
    ["f3a1", "éµéµéµ¤éµ‘éµéµ™éµ²é¶‰é¶‡é¶«éµ¯éµºé¶šé¶¤é¶©é¶²é·„é·é¶»é¶¸é¶ºé·†é·é·‚é·™é·“é·¸é·¦é·­é·¯é·½é¸šé¸›é¸é¹µé¹¹é¹½éºéºˆéº‹éºŒéº’éº•éº‘éºéº¥éº©éº¸éºªéº­é¡é»Œé»é»é»é»”é»œé»é»é» é»¥é»¨é»¯é»´é»¶é»·é»¹é»»é»¼é»½é¼‡é¼ˆçš·é¼•é¼¡é¼¬é¼¾é½Šé½’é½”é½£é½Ÿé½ é½¡é½¦é½§é½¬é½ªé½·é½²é½¶é¾•é¾œé¾ "],
    ["f4a1", "å ¯æ§‡é™ç‘¤å‡œç†™"],
    ["f9a1", "çºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€å†å°å‚å‚”åƒ´åƒ˜å…Šå…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²å“å²åï¨å’œå’Šå’©å“¿å–†å™å¥å¬åŸˆåŸ‡ï¨ï¨å¢å¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°å²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·"],
    ["faa1", "å¿ææ‚…æ‚Šæƒæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“æ•æ˜€æ˜•æ˜»æ˜‰æ˜®æ˜æ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœï¤©æ¦æ»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±"],
    ["fba1", "çŠ¾çŒ¤ï¨–ç·ç½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡ç¡¤ç¡ºç¤°ï¨˜ï¨™ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®ï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨èŒè¢è¿è‡è¶è‘ˆè’´è•“è•™è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒï¨¦é„•é„§é‡š"],
    ["fca1", "é‡—é‡é‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰é‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒé‹¿éŒéŒ‚é°é—é¤é†éé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦é©é«™é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘"],
    ["fcf1", "â…°", 9, "ï¿¢ï¿¤ï¼‡ï¼‚"],
    ["8fa2af", "Ë˜Ë‡Â¸Ë™ËÂ¯Ë›Ëšï½Î„Î…"],
    ["8fa2c2", "Â¡Â¦Â¿"],
    ["8fa2eb", "ÂºÂªÂ©Â®â„¢Â¤â„–"],
    ["8fa6e1", "Î†ÎˆÎ‰ÎŠÎª"],
    ["8fa6e7", "ÎŒ"],
    ["8fa6e9", "ÎÎ«"],
    ["8fa6ec", "Î"],
    ["8fa6f1", "Î¬Î­Î®Î¯ÏŠÎÏŒÏ‚ÏÏ‹Î°Ï"],
    ["8fa7c2", "Ğ‚", 10, "ĞĞ"],
    ["8fa7f2", "Ñ’", 10, "ÑÑŸ"],
    ["8fa9a1", "Ã†Ä"],
    ["8fa9a4", "Ä¦"],
    ["8fa9a6", "Ä²"],
    ["8fa9a8", "ÅÄ¿"],
    ["8fa9ab", "ÅŠÃ˜Å’"],
    ["8fa9af", "Å¦Ã"],
    ["8fa9c1", "Ã¦Ä‘Ã°Ä§Ä±Ä³Ä¸Å‚Å€Å‰Å‹Ã¸Å“ÃŸÅ§Ã¾"],
    ["8faaa1", "ÃÃ€Ã„Ã‚Ä‚ÇÄ€Ä„Ã…ÃƒÄ†ÄˆÄŒÃ‡ÄŠÄÃ‰ÃˆÃ‹ÃŠÄšÄ–Ä’Ä˜"],
    ["8faaba", "ÄœÄÄ¢Ä Ä¤ÃÃŒÃÃÇÄ°ÄªÄ®Ä¨Ä´Ä¶Ä¹Ä½Ä»ÅƒÅ‡Å…Ã‘Ã“Ã’Ã–Ã”Ç‘ÅÅŒÃ•Å”Å˜Å–ÅšÅœÅ ÅÅ¤Å¢ÃšÃ™ÃœÃ›Å¬Ç“Å°ÅªÅ²Å®Å¨Ç—Ç›Ç™Ç•Å´ÃÅ¸Å¶Å¹Å½Å»"],
    ["8faba1", "Ã¡Ã Ã¤Ã¢ÄƒÇÄÄ…Ã¥Ã£Ä‡Ä‰ÄÃ§Ä‹ÄÃ©Ã¨Ã«ÃªÄ›Ä—Ä“Ä™ÇµÄÄŸ"],
    ["8fabbd", "Ä¡Ä¥Ã­Ã¬Ã¯Ã®Ç"],
    ["8fabc5", "Ä«Ä¯Ä©ÄµÄ·ÄºÄ¾Ä¼Å„ÅˆÅ†Ã±Ã³Ã²Ã¶Ã´Ç’Å‘ÅÃµÅ•Å™Å—Å›ÅÅ¡ÅŸÅ¥Å£ÃºÃ¹Ã¼Ã»Å­Ç”Å±Å«Å³Å¯Å©Ç˜ÇœÇšÇ–ÅµÃ½Ã¿Å·ÅºÅ¾Å¼"],
    ["8fb0a1", "ä¸‚ä¸„ä¸…ä¸Œä¸’ä¸Ÿä¸£ä¸¤ä¸¨ä¸«ä¸®ä¸¯ä¸°ä¸µä¹€ä¹ä¹„ä¹‡ä¹‘ä¹šä¹œä¹£ä¹¨ä¹©ä¹´ä¹µä¹¹ä¹¿äºäº–äº—äºäº¯äº¹ä»ƒä»ä»šä»›ä» ä»¡ä»¢ä»¨ä»¯ä»±ä»³ä»µä»½ä»¾ä»¿ä¼€ä¼‚ä¼ƒä¼ˆä¼‹ä¼Œä¼’ä¼•ä¼–ä¼—ä¼™ä¼®ä¼±ä½ ä¼³ä¼µä¼·ä¼¹ä¼»ä¼¾ä½€ä½‚ä½ˆä½‰ä½‹ä½Œä½’ä½”ä½–ä½˜ä½Ÿä½£ä½ªä½¬ä½®ä½±ä½·ä½¸ä½¹ä½ºä½½ä½¾ä¾ä¾‚ä¾„"],
    ["8fb1a1", "ä¾…ä¾‰ä¾Šä¾Œä¾ä¾ä¾’ä¾“ä¾”ä¾—ä¾™ä¾šä¾ä¾Ÿä¾²ä¾·ä¾¹ä¾»ä¾¼ä¾½ä¾¾ä¿€ä¿ä¿…ä¿†ä¿ˆä¿‰ä¿‹ä¿Œä¿ä¿ä¿’ä¿œä¿ ä¿¢ä¿°ä¿²ä¿¼ä¿½ä¿¿å€€å€å€„å€‡å€Šå€Œå€å€å€“å€—å€˜å€›å€œå€å€å€¢å€§å€®å€°å€²å€³å€µå€åå‚å…å†åŠåŒåå‘å’å“å—å™åŸå å¢å£å¦å§åªå­å°å±å€»å‚å‚ƒå‚„å‚†å‚Šå‚å‚å‚"],
    ["8fb2a1", "å‚’å‚“å‚”å‚–å‚›å‚œå‚", 4, "å‚ªå‚¯å‚°å‚¹å‚ºå‚½åƒ€åƒƒåƒ„åƒ‡åƒŒåƒåƒåƒ“åƒ”åƒ˜åƒœåƒåƒŸåƒ¢åƒ¤åƒ¦åƒ¨åƒ©åƒ¯åƒ±åƒ¶åƒºåƒ¾å„ƒå„†å„‡å„ˆå„‹å„Œå„å„åƒ²å„å„—å„™å„›å„œå„å„å„£å„§å„¨å„¬å„­å„¯å„±å„³å„´å„µå„¸å„¹å…‚å…Šå…å…“å…•å…—å…˜å…Ÿå…¤å…¦å…¾å†ƒå†„å†‹å†å†˜å†å†¡å†£å†­å†¸å†ºå†¼å†¾å†¿å‡‚"],
    ["8fb3a1", "å‡ˆå‡å‡‘å‡’å‡“å‡•å‡˜å‡å‡¢å‡¥å‡®å‡²å‡³å‡´å‡·åˆåˆ‚åˆ…åˆ’åˆ“åˆ•åˆ–åˆ˜åˆ¢åˆ¨åˆ±åˆ²åˆµåˆ¼å‰…å‰‰å‰•å‰—å‰˜å‰šå‰œå‰Ÿå‰ å‰¡å‰¦å‰®å‰·å‰¸å‰¹åŠ€åŠ‚åŠ…åŠŠåŠŒåŠ“åŠ•åŠ–åŠ—åŠ˜åŠšåŠœåŠ¤åŠ¥åŠ¦åŠ§åŠ¯åŠ°åŠ¶åŠ·åŠ¸åŠºåŠ»åŠ½å‹€å‹„å‹†å‹ˆå‹Œå‹å‹‘å‹”å‹–å‹›å‹œå‹¡å‹¥å‹¨å‹©å‹ªå‹¬å‹°å‹±å‹´å‹¶å‹·åŒ€åŒƒåŒŠåŒ‹"],
    ["8fb4a1", "åŒŒåŒ‘åŒ“åŒ˜åŒ›åŒœåŒåŒŸåŒ¥åŒ§åŒ¨åŒ©åŒ«åŒ¬åŒ­åŒ°åŒ²åŒµåŒ¼åŒ½åŒ¾å‚åŒå‹å™å›å¡å£å¥å¬å­å²å¹å¾åƒå‡åˆåå“å”å™åå¡å¤åªå«å¯å²å´åµå·å¸åºå½å€å…åå’å“å•åšååå å¦å§åµå‚å“åšå¡å§å¨åªå¯å±å´åµå‘ƒå‘„å‘‡å‘å‘å‘å‘¢å‘¤å‘¦å‘§å‘©å‘«å‘­å‘®å‘´å‘¿"],
    ["8fb5a1", "å’å’ƒå’…å’ˆå’‰å’å’‘å’•å’–å’œå’Ÿå’¡å’¦å’§å’©å’ªå’­å’®å’±å’·å’¹å’ºå’»å’¿å“†å“Šå“å“å“ å“ªå“¬å“¯å“¶å“¼å“¾å“¿å”€å”å”…å”ˆå”‰å”Œå”å”å”•å”ªå”«å”²å”µå”¶å”»å”¼å”½å•å•‡å•‰å•Šå•å•å•‘å•˜å•šå•›å•å• å•¡å•¤å•¦å•¿å–å–‚å–†å–ˆå–å–å–‘å–’å–“å–”å–—å–£å–¤å–­å–²å–¿å—å—ƒå—†å—‰å—‹å—Œå—å—‘å—’"],
    ["8fb6a1", "å—“å——å—˜å—›å—å—¢å—©å—¶å—¿å˜…å˜ˆå˜Šå˜", 5, "å˜™å˜¬å˜°å˜³å˜µå˜·å˜¹å˜»å˜¼å˜½å˜¿å™€å™å™ƒå™„å™†å™‰å™‹å™å™å™”å™å™ å™¡å™¢å™£å™¦å™©å™­å™¯å™±å™²å™µåš„åš…åšˆåš‹åšŒåš•åš™åššåšåšåšŸåš¦åš§åš¨åš©åš«åš¬åš­åš±åš³åš·åš¾å›…å›‰å›Šå›‹å›å›å›Œå›å›™å›œå›å›Ÿå›¡å›¤", 4, "å›±å›«å›­"],
    ["8fb7a1", "å›¶å›·åœåœ‚åœ‡åœŠåœŒåœ‘åœ•åœšåœ›åœåœ åœ¢åœ£åœ¤åœ¥åœ©åœªåœ¬åœ®åœ¯åœ³åœ´åœ½åœ¾åœ¿å…å†åŒåå’å¢å¥å§å¨å«å­", 4, "å³å´åµå·å¹åºå»å¼å¾ååƒåŒå”å—å™åšåœåååŸå¡å•å§å¨å©å¬å¸å½åŸ‡åŸˆåŸŒåŸåŸ•åŸåŸåŸ¤åŸ¦åŸ§åŸ©åŸ­åŸ°åŸµåŸ¶åŸ¸åŸ½åŸ¾åŸ¿å ƒå „å ˆå ‰åŸ¡"],
    ["8fb8a1", "å Œå å ›å å Ÿå  å ¦å §å ­å ²å ¹å ¿å¡‰å¡Œå¡å¡å¡å¡•å¡Ÿå¡¡å¡¤å¡§å¡¨å¡¸å¡¼å¡¿å¢€å¢å¢‡å¢ˆå¢‰å¢Šå¢Œå¢å¢å¢å¢”å¢–å¢å¢ å¢¡å¢¢å¢¦å¢©å¢±å¢²å£„å¢¼å£‚å£ˆå£å£å£å£’å£”å£–å£šå£å£¡å£¢å£©å£³å¤…å¤†å¤‹å¤Œå¤’å¤“å¤”è™å¤å¤¡å¤£å¤¤å¤¨å¤¯å¤°å¤³å¤µå¤¶å¤¿å¥ƒå¥†å¥’å¥“å¥™å¥›å¥å¥å¥Ÿå¥¡å¥£å¥«å¥­"],
    ["8fb9a1", "å¥¯å¥²å¥µå¥¶å¥¹å¥»å¥¼å¦‹å¦Œå¦å¦’å¦•å¦—å¦Ÿå¦¤å¦§å¦­å¦®å¦¯å¦°å¦³å¦·å¦ºå¦¼å§å§ƒå§„å§ˆå§Šå§å§’å§å§å§Ÿå§£å§¤å§§å§®å§¯å§±å§²å§´å§·å¨€å¨„å¨Œå¨å¨å¨’å¨“å¨å¨£å¨¤å¨§å¨¨å¨ªå¨­å¨°å©„å©…å©‡å©ˆå©Œå©å©•å©å©£å©¥å©§å©­å©·å©ºå©»å©¾åª‹åªåª“åª–åª™åªœåªåªŸåª åª¢åª§åª¬åª±åª²åª³åªµåª¸åªºåª»åª¿"],
    ["8fbaa1", "å«„å«†å«ˆå«å«šå«œå« å«¥å«ªå«®å«µå«¶å«½å¬€å¬å¬ˆå¬—å¬´å¬™å¬›å¬å¬¡å¬¥å¬­å¬¸å­å­‹å­Œå­’å­–å­å­¨å­®å­¯å­¼å­½å­¾å­¿å®å®„å®†å®Šå®å®å®‘å®“å®”å®–å®¨å®©å®¬å®­å®¯å®±å®²å®·å®ºå®¼å¯€å¯å¯å¯å¯–", 4, "å¯ å¯¯å¯±å¯´å¯½å°Œå°—å°å°Ÿå°£å°¦å°©å°«å°¬å°®å°°å°²å°µå°¶å±™å±šå±œå±¢å±£å±§å±¨å±©"],
    ["8fbba1", "å±­å±°å±´å±µå±ºå±»å±¼å±½å²‡å²ˆå²Šå²å²’å²å²Ÿå² å²¢å²£å²¦å²ªå²²å²´å²µå²ºå³‰å³‹å³’å³å³—å³®å³±å³²å³´å´å´†å´å´’å´«å´£å´¤å´¦å´§å´±å´´å´¹å´½å´¿åµ‚åµƒåµ†åµˆåµ•åµ‘åµ™åµŠåµŸåµ åµ¡åµ¢åµ¤åµªåµ­åµ°åµ¹åµºåµ¾åµ¿å¶å¶ƒå¶ˆå¶Šå¶’å¶“å¶”å¶•å¶™å¶›å¶Ÿå¶ å¶§å¶«å¶°å¶´å¶¸å¶¹å·ƒå·‡å·‹å·å·å·˜å·™å· å·¤"],
    ["8fbca1", "å·©å·¸å·¹å¸€å¸‡å¸å¸’å¸”å¸•å¸˜å¸Ÿå¸ å¸®å¸¨å¸²å¸µå¸¾å¹‹å¹å¹‰å¹‘å¹–å¹˜å¹›å¹œå¹å¹¨å¹ª", 4, "å¹°åº€åº‹åºåº¢åº¤åº¥åº¨åºªåº¬åº±åº³åº½åº¾åº¿å»†å»Œå»‹å»å»‘å»’å»”å»•å»œå»å»¥å»«å¼‚å¼†å¼‡å¼ˆå¼å¼™å¼œå¼å¼¡å¼¢å¼£å¼¤å¼¨å¼«å¼¬å¼®å¼°å¼´å¼¶å¼»å¼½å¼¿å½€å½„å½…å½‡å½å½å½”å½˜å½›å½ å½£å½¤å½§"],
    ["8fbda1", "å½¯å½²å½´å½µå½¸å½ºå½½å½¾å¾‰å¾å¾å¾–å¾œå¾å¾¢å¾§å¾«å¾¤å¾¬å¾¯å¾°å¾±å¾¸å¿„å¿‡å¿ˆå¿‰å¿‹å¿", 4, "å¿å¿¡å¿¢å¿¨å¿©å¿ªå¿¬å¿­å¿®å¿¯å¿²å¿³å¿¶å¿ºå¿¼æ€‡æ€Šæ€æ€“æ€”æ€—æ€˜æ€šæ€Ÿæ€¤æ€­æ€³æ€µæ€æ‡æˆæ‰æŒæ‘æ”æ–æ—ææ¡æ§æ±æ¾æ¿æ‚‚æ‚†æ‚ˆæ‚Šæ‚æ‚‘æ‚“æ‚•æ‚˜æ‚æ‚æ‚¢æ‚¤æ‚¥æ‚¨æ‚°æ‚±æ‚·"],
    ["8fbea1", "æ‚»æ‚¾æƒ‚æƒ„æƒˆæƒ‰æƒŠæƒ‹æƒæƒæƒ”æƒ•æƒ™æƒ›æƒæƒæƒ¢æƒ¥æƒ²æƒµæƒ¸æƒ¼æƒ½æ„‚æ„‡æ„Šæ„Œæ„", 4, "æ„–æ„—æ„™æ„œæ„æ„¢æ„ªæ„«æ„°æ„±æ„µæ„¶æ„·æ„¹æ…æ……æ…†æ…‰æ…æ… æ…¬æ…²æ…¸æ…»æ…¼æ…¿æ†€æ†æ†ƒæ†„æ†‹æ†æ†’æ†“æ†—æ†˜æ†œæ†æ†Ÿæ† æ†¥æ†¨æ†ªæ†­æ†¸æ†¹æ†¼æ‡€æ‡æ‡‚æ‡æ‡æ‡•æ‡œæ‡æ‡æ‡Ÿæ‡¡æ‡¢æ‡§æ‡©æ‡¥"],
    ["8fbfa1", "æ‡¬æ‡­æ‡¯æˆæˆƒæˆ„æˆ‡æˆ“æˆ•æˆœæˆ æˆ¢æˆ£æˆ§æˆ©æˆ«æˆ¹æˆ½æ‰‚æ‰ƒæ‰„æ‰†æ‰Œæ‰æ‰‘æ‰’æ‰”æ‰–æ‰šæ‰œæ‰¤æ‰­æ‰¯æ‰³æ‰ºæ‰½æŠæŠæŠæŠæŠ¦æŠ¨æŠ³æŠ¶æŠ·æŠºæŠ¾æŠ¿æ‹„æ‹æ‹•æ‹–æ‹šæ‹ªæ‹²æ‹´æ‹¼æ‹½æŒƒæŒ„æŒŠæŒ‹æŒæŒæŒ“æŒ–æŒ˜æŒ©æŒªæŒ­æŒµæŒ¶æŒ¹æŒ¼ææ‚æƒæ„æ†æŠæ‹ææ’æ“æ”æ˜æ›æ¥æ¦æ¬æ­æ±æ´æµ"],
    ["8fc0a1", "æ¸æ¼æ½æ¿æ‚æ„æ‡æŠææ”æ•æ™æšææ¤æ¦æ­æ®æ¯æ½ææ…æˆææ‘æ“æ”æ•æœæ æ¥æªæ¬æ²æ³æµæ¸æ¹æ‰æŠææ’æ”æ˜ææ æ¢æ¤æ¥æ©æªæ¯æ°æµæ½æ¿æ‘‹æ‘æ‘‘æ‘’æ‘“æ‘”æ‘šæ‘›æ‘œæ‘æ‘Ÿæ‘ æ‘¡æ‘£æ‘­æ‘³æ‘´æ‘»æ‘½æ’…æ’‡æ’æ’æ’‘æ’˜æ’™æ’›æ’æ’Ÿæ’¡æ’£æ’¦æ’¨æ’¬æ’³æ’½æ’¾æ’¿"],
    ["8fc1a1", "æ“„æ“‰æ“Šæ“‹æ“Œæ“æ“æ“‘æ“•æ“—æ“¤æ“¥æ“©æ“ªæ“­æ“°æ“µæ“·æ“»æ“¿æ”æ”„æ”ˆæ”‰æ”Šæ”æ”“æ””æ”–æ”™æ”›æ”æ”Ÿæ”¢æ”¦æ”©æ”®æ”±æ”ºæ”¼æ”½æ•ƒæ•‡æ•‰æ•æ•’æ•”æ•Ÿæ• æ•§æ•«æ•ºæ•½æ–æ–…æ–Šæ–’æ–•æ–˜æ–æ– æ–£æ–¦æ–®æ–²æ–³æ–´æ–¿æ—‚æ—ˆæ—‰æ—æ—æ—”æ—–æ—˜æ—Ÿæ—°æ—²æ—´æ—µæ—¹æ—¾æ—¿æ˜€æ˜„æ˜ˆæ˜‰æ˜æ˜‘æ˜’æ˜•æ˜–æ˜"],
    ["8fc2a1", "æ˜æ˜¡æ˜¢æ˜£æ˜¤æ˜¦æ˜©æ˜ªæ˜«æ˜¬æ˜®æ˜°æ˜±æ˜³æ˜¹æ˜·æ™€æ™…æ™†æ™Šæ™Œæ™‘æ™æ™—æ™˜æ™™æ™›æ™œæ™ æ™¡æ›»æ™ªæ™«æ™¬æ™¾æ™³æ™µæ™¿æ™·æ™¸æ™¹æ™»æš€æ™¼æš‹æšŒæšæšæš’æš™æššæš›æšœæšŸæš æš¤æš­æš±æš²æšµæš»æš¿æ›€æ›‚æ›ƒæ›ˆæ›Œæ›æ›æ›”æ››æ›Ÿæ›¨æ›«æ›¬æ›®æ›ºæœ…æœ‡æœæœ“æœ™æœœæœ æœ¢æœ³æœ¾æ…æ‡æˆæŒæ”æ•æ"],
    ["8fc3a1", "æ¦æ¬æ®æ´æ¶æ»ææ„æææ‘æ“æ–æ˜æ™æ›æ°æ±æ²æµæ»æ¼æ½æŸ¹æŸ€æŸ‚æŸƒæŸ…æŸˆæŸ‰æŸ’æŸ—æŸ™æŸœæŸ¡æŸ¦æŸ°æŸ²æŸ¶æŸ·æ¡’æ ”æ ™æ æ Ÿæ ¨æ §æ ¬æ ­æ ¯æ °æ ±æ ³æ »æ ¿æ¡„æ¡…æ¡Šæ¡Œæ¡•æ¡—æ¡˜æ¡›æ¡«æ¡®", 4, "æ¡µæ¡¹æ¡ºæ¡»æ¡¼æ¢‚æ¢„æ¢†æ¢ˆæ¢–æ¢˜æ¢šæ¢œæ¢¡æ¢£æ¢¥æ¢©æ¢ªæ¢®æ¢²æ¢»æ£…æ£ˆæ£Œæ£"],
    ["8fc4a1", "æ£æ£‘æ£“æ£–æ£™æ£œæ£æ£¥æ£¨æ£ªæ£«æ£¬æ£­æ£°æ£±æ£µæ£¶æ£»æ£¼æ£½æ¤†æ¤‰æ¤Šæ¤æ¤‘æ¤“æ¤–æ¤—æ¤±æ¤³æ¤µæ¤¸æ¤»æ¥‚æ¥…æ¥‰æ¥æ¥—æ¥›æ¥£æ¥¤æ¥¥æ¥¦æ¥¨æ¥©æ¥¬æ¥°æ¥±æ¥²æ¥ºæ¥»æ¥¿æ¦€æ¦æ¦’æ¦–æ¦˜æ¦¡æ¦¥æ¦¦æ¦¨æ¦«æ¦­æ¦¯æ¦·æ¦¸æ¦ºæ¦¼æ§…æ§ˆæ§‘æ§–æ§—æ§¢æ§¥æ§®æ§¯æ§±æ§³æ§µæ§¾æ¨€æ¨æ¨ƒæ¨æ¨‘æ¨•æ¨šæ¨æ¨ æ¨¤æ¨¨æ¨°æ¨²"],
    ["8fc5a1", "æ¨´æ¨·æ¨»æ¨¾æ¨¿æ©…æ©†æ©‰æ©Šæ©æ©æ©‘æ©’æ©•æ©–æ©›æ©¤æ©§æ©ªæ©±æ©³æ©¾æªæªƒæª†æª‡æª‰æª‹æª‘æª›æªæªæªŸæª¥æª«æª¯æª°æª±æª´æª½æª¾æª¿æ«†æ«‰æ«ˆæ«Œæ«æ«”æ«•æ«–æ«œæ«æ«¤æ«§æ«¬æ«°æ«±æ«²æ«¼æ«½æ¬‚æ¬ƒæ¬†æ¬‡æ¬‰æ¬æ¬æ¬‘æ¬—æ¬›æ¬æ¬¤æ¬¨æ¬«æ¬¬æ¬¯æ¬µæ¬¶æ¬»æ¬¿æ­†æ­Šæ­æ­’æ­–æ­˜æ­æ­ æ­§æ­«æ­®æ­°æ­µæ­½"],
    ["8fc6a1", "æ­¾æ®‚æ®…æ®—æ®›æ®Ÿæ® æ®¢æ®£æ®¨æ®©æ®¬æ®­æ®®æ®°æ®¸æ®¹æ®½æ®¾æ¯ƒæ¯„æ¯‰æ¯Œæ¯–æ¯šæ¯¡æ¯£æ¯¦æ¯§æ¯®æ¯±æ¯·æ¯¹æ¯¿æ°‚æ°„æ°…æ°‰æ°æ°æ°æ°’æ°™æ°Ÿæ°¦æ°§æ°¨æ°¬æ°®æ°³æ°µæ°¶æ°ºæ°»æ°¿æ±Šæ±‹æ±æ±æ±’æ±”æ±™æ±›æ±œæ±«æ±­æ±¯æ±´æ±¶æ±¸æ±¹æ±»æ²…æ²†æ²‡æ²‰æ²”æ²•æ²—æ²˜æ²œæ²Ÿæ²°æ²²æ²´æ³‚æ³†æ³æ³æ³æ³‘æ³’æ³”æ³–"],
    ["8fc7a1", "æ³šæ³œæ³ æ³§æ³©æ³«æ³¬æ³®æ³²æ³´æ´„æ´‡æ´Šæ´æ´æ´‘æ´“æ´šæ´¦æ´§æ´¨æ±§æ´®æ´¯æ´±æ´¹æ´¼æ´¿æµ—æµæµŸæµ¡æµ¥æµ§æµ¯æµ°æµ¼æ¶‚æ¶‡æ¶‘æ¶’æ¶”æ¶–æ¶—æ¶˜æ¶ªæ¶¬æ¶´æ¶·æ¶¹æ¶½æ¶¿æ·„æ·ˆæ·Šæ·æ·æ·–æ·›æ·æ·Ÿæ· æ·¢æ·¥æ·©æ·¯æ·°æ·´æ·¶æ·¼æ¸€æ¸„æ¸æ¸¢æ¸§æ¸²æ¸¶æ¸¹æ¸»æ¸¼æ¹„æ¹…æ¹ˆæ¹‰æ¹‹æ¹æ¹‘æ¹’æ¹“æ¹”æ¹—æ¹œæ¹æ¹"],
    ["8fc8a1", "æ¹¢æ¹£æ¹¨æ¹³æ¹»æ¹½æºæº“æº™æº æº§æº­æº®æº±æº³æº»æº¿æ»€æ»æ»ƒæ»‡æ»ˆæ»Šæ»æ»æ»æ»«æ»­æ»®æ»¹æ»»æ»½æ¼„æ¼ˆæ¼Šæ¼Œæ¼æ¼–æ¼˜æ¼šæ¼›æ¼¦æ¼©æ¼ªæ¼¯æ¼°æ¼³æ¼¶æ¼»æ¼¼æ¼­æ½æ½‘æ½’æ½“æ½—æ½™æ½šæ½æ½æ½¡æ½¢æ½¨æ½¬æ½½æ½¾æ¾ƒæ¾‡æ¾ˆæ¾‹æ¾Œæ¾æ¾æ¾’æ¾“æ¾”æ¾–æ¾šæ¾Ÿæ¾ æ¾¥æ¾¦æ¾§æ¾¨æ¾®æ¾¯æ¾°æ¾µæ¾¶æ¾¼æ¿…æ¿‡æ¿ˆæ¿Š"],
    ["8fc9a1", "æ¿šæ¿æ¿¨æ¿©æ¿°æ¿µæ¿¹æ¿¼æ¿½ç€€ç€…ç€†ç€‡ç€ç€—ç€ ç€£ç€¯ç€´ç€·ç€¹ç€¼çƒç„çˆç‰çŠç‹ç”ç•çççç¤ç¥ç¬ç®çµç¶ç¾ç‚ç‚…ç‚†ç‚”", 4, "ç‚›ç‚¤ç‚«ç‚°ç‚±ç‚´ç‚·çƒŠçƒ‘çƒ“çƒ”çƒ•çƒ–çƒ˜çƒœçƒ¤çƒºç„ƒ", 4, "ç„‹ç„Œç„ç„ç„ ç„«ç„­ç„¯ç„°ç„±ç„¸ç…ç……ç…†ç…‡ç…Šç…‹ç…ç…’ç…—ç…šç…œç…ç… "],
    ["8fcaa1", "ç…¨ç…¹ç†€ç†…ç†‡ç†Œç†’ç†šç†›ç† ç†¢ç†¯ç†°ç†²ç†³ç†ºç†¿ç‡€ç‡ç‡„ç‡‹ç‡Œç‡“ç‡–ç‡™ç‡šç‡œç‡¸ç‡¾çˆ€çˆ‡çˆˆçˆ‰çˆ“çˆ—çˆšçˆçˆŸçˆ¤çˆ«çˆ¯çˆ´çˆ¸çˆ¹ç‰ç‰‚ç‰ƒç‰…ç‰ç‰ç‰ç‰“ç‰•ç‰–ç‰šç‰œç‰ç‰ ç‰£ç‰¨ç‰«ç‰®ç‰¯ç‰±ç‰·ç‰¸ç‰»ç‰¼ç‰¿çŠ„çŠ‰çŠçŠçŠ“çŠ›çŠ¨çŠ­çŠ®çŠ±çŠ´çŠ¾ç‹ç‹‡ç‹‰ç‹Œç‹•ç‹–ç‹˜ç‹Ÿç‹¥ç‹³ç‹´ç‹ºç‹»"],
    ["8fcba1", "ç‹¾çŒ‚çŒ„çŒ…çŒ‡çŒ‹çŒçŒ’çŒ“çŒ˜çŒ™çŒçŒ¢çŒ¤çŒ§çŒ¨çŒ¬çŒ±çŒ²çŒµçŒºçŒ»çŒ½çƒççç’ç–ç˜çççŸç ç¦ç§ç©ç«ç¬ç®ç¯ç±ç·ç¹ç¼ç€ççƒç…ç†ççç“ç•ç—ç˜çœççŸç ç¢ç¥ç¦çªç«ç­çµç·ç¹ç¼ç½ç¿ç…ç†ç‰ç‹çŒçç’ç“ç–ç™çç¡ç£ç¦ç§ç©ç´çµç·ç¹çºç»ç½"],
    ["8fcca1", "ç¿ç€çç„ç‡çŠç‘çšç›ç¤ç¦ç¨", 9, "ç¹ç‘€ç‘ƒç‘„ç‘†ç‘‡ç‘‹ç‘ç‘‘ç‘’ç‘—ç‘ç‘¢ç‘¦ç‘§ç‘¨ç‘«ç‘­ç‘®ç‘±ç‘²ç’€ç’ç’…ç’†ç’‡ç’‰ç’ç’ç’‘ç’’ç’˜ç’™ç’šç’œç’Ÿç’ ç’¡ç’£ç’¦ç’¨ç’©ç’ªç’«ç’®ç’¯ç’±ç’²ç’µç’¹ç’»ç’¿ç“ˆç“‰ç“Œç“ç““ç“˜ç“šç“›ç“ç“Ÿç“¤ç“¨ç“ªç“«ç“¯ç“´ç“ºç“»ç“¼ç“¿ç”†"],
    ["8fcda1", "ç”’ç”–ç”—ç” ç”¡ç”¤ç”§ç”©ç”ªç”¯ç”¶ç”¹ç”½ç”¾ç”¿ç•€ç•ƒç•‡ç•ˆç•ç•ç•’ç•—ç•ç•Ÿç•¡ç•¯ç•±ç•¹", 5, "ç–ç–…ç–ç–’ç–“ç–•ç–™ç–œç–¢ç–¤ç–´ç–ºç–¿ç—€ç—ç—„ç—†ç—Œç—ç—ç——ç—œç—Ÿç— ç—¡ç—¤ç—§ç—¬ç—®ç—¯ç—±ç—¹ç˜€ç˜‚ç˜ƒç˜„ç˜‡ç˜ˆç˜Šç˜Œç˜ç˜’ç˜“ç˜•ç˜–ç˜™ç˜›ç˜œç˜ç˜ç˜£ç˜¥ç˜¦ç˜©ç˜­ç˜²ç˜³ç˜µç˜¸ç˜¹"],
    ["8fcea1", "ç˜ºç˜¼ç™Šç™€ç™ç™ƒç™„ç™…ç™‰ç™‹ç™•ç™™ç™Ÿç™¤ç™¥ç™­ç™®ç™¯ç™±ç™´çšçš…çšŒçšçš•çš›çšœçšçšŸçš çš¢", 6, "çšªçš­çš½ç›ç›…ç›‰ç›‹ç›Œç›ç›”ç›™ç› ç›¦ç›¨ç›¬ç›°ç›±ç›¶ç›¹ç›¼çœ€çœ†çœŠçœçœ’çœ”çœ•çœ—çœ™çœšçœœçœ¢çœ¨çœ­çœ®çœ¯çœ´çœµçœ¶çœ¹çœ½çœ¾ç‚ç…ç†çŠçççç’ç–ç—çœççŸç ç¢"],
    ["8fcfa1", "ç¤ç§çªç¬ç°ç²ç³ç´çºç½ç€ç„çŒçç”ç•ç–çšçŸç¢ç§çªç®ç¯ç±çµç¾çŸƒçŸ‰çŸ‘çŸ’çŸ•çŸ™çŸçŸŸçŸ çŸ¤çŸ¦çŸªçŸ¬çŸ°çŸ±çŸ´çŸ¸çŸ»ç …ç †ç ‰ç ç ç ‘ç ç ¡ç ¢ç £ç ­ç ®ç °ç µç ·ç¡ƒç¡„ç¡‡ç¡ˆç¡Œç¡ç¡’ç¡œç¡ç¡ ç¡¡ç¡£ç¡¤ç¡¨ç¡ªç¡®ç¡ºç¡¾ç¢Šç¢ç¢”ç¢˜ç¢¡ç¢ç¢ç¢Ÿç¢¤ç¢¨ç¢¬ç¢­ç¢°ç¢±ç¢²ç¢³"],
    ["8fd0a1", "ç¢»ç¢½ç¢¿ç£‡ç£ˆç£‰ç£Œç£ç£’ç£“ç£•ç£–ç£¤ç£›ç£Ÿç£ ç£¡ç£¦ç£ªç£²ç£³ç¤€ç£¶ç£·ç£ºç£»ç£¿ç¤†ç¤Œç¤ç¤šç¤œç¤ç¤Ÿç¤ ç¤¥ç¤§ç¤©ç¤­ç¤±ç¤´ç¤µç¤»ç¤½ç¤¿ç¥„ç¥…ç¥†ç¥Šç¥‹ç¥ç¥‘ç¥”ç¥˜ç¥›ç¥œç¥§ç¥©ç¥«ç¥²ç¥¹ç¥»ç¥¼ç¥¾ç¦‹ç¦Œç¦‘ç¦“ç¦”ç¦•ç¦–ç¦˜ç¦›ç¦œç¦¡ç¦¨ç¦©ç¦«ç¦¯ç¦±ç¦´ç¦¸ç¦»ç§‚ç§„ç§‡ç§ˆç§Šç§ç§”ç§–ç§šç§ç§"],
    ["8fd1a1", "ç§ ç§¢ç§¥ç§ªç§«ç§­ç§±ç§¸ç§¼ç¨‚ç¨ƒç¨‡ç¨‰ç¨Šç¨Œç¨‘ç¨•ç¨›ç¨ç¨¡ç¨§ç¨«ç¨­ç¨¯ç¨°ç¨´ç¨µç¨¸ç¨¹ç¨ºç©„ç©…ç©‡ç©ˆç©Œç©•ç©–ç©™ç©œç©ç©Ÿç© ç©¥ç©§ç©ªç©­ç©µç©¸ç©¾çª€çª‚çª…çª†çªŠçª‹çªçª‘çª”çªçª çª£çª¬çª³çªµçª¹çª»çª¼ç«†ç«‰ç«Œç«ç«‘ç«›ç«¨ç«©ç««ç«¬ç«±ç«´ç«»ç«½ç«¾ç¬‡ç¬”ç¬Ÿç¬£ç¬§ç¬©ç¬ªç¬«ç¬­ç¬®ç¬¯ç¬°"],
    ["8fd2a1", "ç¬±ç¬´ç¬½ç¬¿ç­€ç­ç­‡ç­ç­•ç­ ç­¤ç­¦ç­©ç­ªç­­ç­¯ç­²ç­³ç­·ç®„ç®‰ç®ç®ç®‘ç®–ç®›ç®ç® ç®¥ç®¬ç®¯ç®°ç®²ç®µç®¶ç®ºç®»ç®¼ç®½ç¯‚ç¯…ç¯ˆç¯Šç¯”ç¯–ç¯—ç¯™ç¯šç¯›ç¯¨ç¯ªç¯²ç¯´ç¯µç¯¸ç¯¹ç¯ºç¯¼ç¯¾ç°ç°‚ç°ƒç°„ç°†ç°‰ç°‹ç°Œç°ç°ç°™ç°›ç° ç°¥ç°¦ç°¨ç°¬ç°±ç°³ç°´ç°¶ç°¹ç°ºç±†ç±Šç±•ç±‘ç±’ç±“ç±™", 5],
    ["8fd3a1", "ç±¡ç±£ç±§ç±©ç±­ç±®ç±°ç±²ç±¹ç±¼ç±½ç²†ç²‡ç²ç²”ç²ç² ç²¦ç²°ç²¶ç²·ç²ºç²»ç²¼ç²¿ç³„ç³‡ç³ˆç³‰ç³ç³ç³“ç³”ç³•ç³—ç³™ç³šç³ç³¦ç³©ç³«ç³µç´ƒç´‡ç´ˆç´‰ç´ç´‘ç´’ç´“ç´–ç´ç´ç´£ç´¦ç´ªç´­ç´±ç´¼ç´½ç´¾çµ€çµçµ‡çµˆçµçµ‘çµ“çµ—çµ™çµšçµœçµçµ¥çµ§çµªçµ°çµ¸çµºçµ»çµ¿ç¶ç¶‚ç¶ƒç¶…ç¶†ç¶ˆç¶‹ç¶Œç¶ç¶‘ç¶–ç¶—ç¶"],
    ["8fd4a1", "ç¶ç¶¦ç¶§ç¶ªç¶³ç¶¶ç¶·ç¶¹ç·‚", 4, "ç·Œç·ç·ç·—ç·™ç¸€ç·¢ç·¥ç·¦ç·ªç·«ç·­ç·±ç·µç·¶ç·¹ç·ºç¸ˆç¸ç¸‘ç¸•ç¸—ç¸œç¸ç¸ ç¸§ç¸¨ç¸¬ç¸­ç¸¯ç¸³ç¸¶ç¸¿ç¹„ç¹…ç¹‡ç¹ç¹ç¹’ç¹˜ç¹Ÿç¹¡ç¹¢ç¹¥ç¹«ç¹®ç¹¯ç¹³ç¹¸ç¹¾çºçº†çº‡çºŠçºçº‘çº•çº˜çºšçºçºç¼¼ç¼»ç¼½ç¼¾ç¼¿ç½ƒç½„ç½‡ç½ç½’ç½“ç½›ç½œç½ç½¡ç½£ç½¤ç½¥ç½¦ç½­"],
    ["8fd5a1", "ç½±ç½½ç½¾ç½¿ç¾€ç¾‹ç¾ç¾ç¾ç¾‘ç¾–ç¾—ç¾œç¾¡ç¾¢ç¾¦ç¾ªç¾­ç¾´ç¾¼ç¾¿ç¿€ç¿ƒç¿ˆç¿ç¿ç¿›ç¿Ÿç¿£ç¿¥ç¿¨ç¿¬ç¿®ç¿¯ç¿²ç¿ºç¿½ç¿¾ç¿¿è€‡è€ˆè€Šè€è€è€è€‘è€“è€”è€–è€è€è€Ÿè€ è€¤è€¦è€¬è€®è€°è€´è€µè€·è€¹è€ºè€¼è€¾è€è„è è¤è¦è­è±èµè‚è‚ˆè‚è‚œè‚è‚¦è‚§è‚«è‚¸è‚¹èƒˆèƒèƒèƒ’èƒ”èƒ•èƒ—èƒ˜èƒ èƒ­èƒ®"],
    ["8fd6a1", "èƒ°èƒ²èƒ³èƒ¶èƒ¹èƒºèƒ¾è„ƒè„‹è„–è„—è„˜è„œè„è„ è„¤è„§è„¬è„°è„µè„ºè„¼è……è…‡è…Šè…Œè…’è…—è… è…¡è…§è…¨è…©è…­è…¯è…·è†è†è†„è†…è††è†‹è†è†–è†˜è†›è†è†¢è†®è†²è†´è†»è‡‹è‡ƒè‡…è‡Šè‡è‡è‡•è‡—è‡›è‡è‡è‡¡è‡¤è‡«è‡¬è‡°è‡±è‡²è‡µè‡¶è‡¸è‡¹è‡½è‡¿èˆ€èˆƒèˆèˆ“èˆ”èˆ™èˆšèˆèˆ¡èˆ¢èˆ¨èˆ²èˆ´èˆºè‰ƒè‰„è‰…è‰†"],
    ["8fd7a1", "è‰‹è‰è‰è‰‘è‰–è‰œè‰ è‰£è‰§è‰­è‰´è‰»è‰½è‰¿èŠ€èŠèŠƒèŠ„èŠ‡èŠ‰èŠŠèŠèŠ‘èŠ”èŠ–èŠ˜èŠšèŠ›èŠ èŠ¡èŠ£èŠ¤èŠ§èŠ¨èŠ©èŠªèŠ®èŠ°èŠ²èŠ´èŠ·èŠºèŠ¼èŠ¾èŠ¿è‹†è‹è‹•è‹šè‹ è‹¢è‹¤è‹¨è‹ªè‹­è‹¯è‹¶è‹·è‹½è‹¾èŒ€èŒèŒ‡èŒˆèŒŠèŒ‹è”èŒ›èŒèŒèŒŸèŒ¡èŒ¢èŒ¬èŒ­èŒ®èŒ°èŒ³èŒ·èŒºèŒ¼èŒ½è‚èƒè„è‡èèè‘è•è–è—è°è¸"],
    ["8fd8a1", "è½è¿è€è‚è„è†èè’è”è•è˜è™è›èœèè¦è§è©è¬è¾è¿è€è‡è‰èèè‘è”èè“è¨èªè¶è¸è¹è¼èè†èŠèè‘è•è™è­è¯è¹è‘…è‘‡è‘ˆè‘Šè‘è‘è‘‘è‘’è‘–è‘˜è‘™è‘šè‘œè‘ è‘¤è‘¥è‘§è‘ªè‘°è‘³è‘´è‘¶è‘¸è‘¼è‘½è’è’…è’’è’“è’•è’è’¦è’¨è’©è’ªè’¯è’±è’´è’ºè’½è’¾è“€è“‚è“‡è“ˆè“Œè“è““"],
    ["8fd9a1", "è“œè“§è“ªè“¯è“°è“±è“²è“·è”²è“ºè“»è“½è”‚è”ƒè”‡è”Œè”è”è”œè”è”¢è”£è”¤è”¥è”§è”ªè”«è”¯è”³è”´è”¶è”¿è•†è•", 4, "è•–è•™è•œ", 6, "è•¤è•«è•¯è•¹è•ºè•»è•½è•¿è–è–…è–†è–‰è–‹è–Œè–è–“è–˜è–è–Ÿè– è–¢è–¥è–§è–´è–¶è–·è–¸è–¼è–½è–¾è–¿è—‚è—‡è—Šè—‹è—è–­è—˜è—šè—Ÿè— è—¦è—¨è—­è—³è—¶è—¼"],
    ["8fdaa1", "è—¿è˜€è˜„è˜…è˜è˜è˜è˜‘è˜’è˜˜è˜™è˜›è˜è˜¡è˜§è˜©è˜¶è˜¸è˜ºè˜¼è˜½è™€è™‚è™†è™’è™“è™–è™—è™˜è™™è™è™ ", 4, "è™©è™¬è™¯è™µè™¶è™·è™ºèšèš‘èš–èš˜èššèšœèš¡èš¦èš§èš¨èš­èš±èš³èš´èšµèš·èš¸èš¹èš¿è›€è›è›ƒè›…è›‘è›’è›•è›—è›šè›œè› è›£è›¥è›§èšˆè›ºè›¼è›½èœ„èœ…èœ‡èœ‹èœèœèœèœ“èœ”èœ™èœèœŸèœ¡èœ£"],
    ["8fdba1", "èœ¨èœ®èœ¯èœ±èœ²èœ¹èœºèœ¼èœ½èœ¾è€èƒè…èè˜èè¡è¤è¥è¯è±è²è»èƒ", 6, "è‹èŒèè“è•è—è˜è™èè è£è§è¬è­è®è±èµè¾è¿èŸèŸˆèŸ‰èŸŠèŸèŸ•èŸ–èŸ™èŸšèŸœèŸŸèŸ¢èŸ£èŸ¤èŸªèŸ«èŸ­èŸ±èŸ³èŸ¸èŸºèŸ¿è è ƒè †è ‰è Šè ‹è è ™è ’è “è ”è ˜è šè ›è œè è Ÿè ¨è ­è ®è °è ²è µ"],
    ["8fdca1", "è ºè ¼è¡è¡ƒè¡…è¡ˆè¡‰è¡Šè¡‹è¡è¡‘è¡•è¡–è¡˜è¡šè¡œè¡Ÿè¡ è¡¤è¡©è¡±è¡¹è¡»è¢€è¢˜è¢šè¢›è¢œè¢Ÿè¢ è¢¨è¢ªè¢ºè¢½è¢¾è£€è£Š", 4, "è£‘è£’è£“è£›è£è£§è£¯è£°è£±è£µè£·è¤è¤†è¤è¤è¤è¤•è¤–è¤˜è¤™è¤šè¤œè¤ è¤¦è¤§è¤¨è¤°è¤±è¤²è¤µè¤¹è¤ºè¤¾è¥€è¥‚è¥…è¥†è¥‰è¥è¥’è¥—è¥šè¥›è¥œè¥¡è¥¢è¥£è¥«è¥®è¥°è¥³è¥µè¥º"],
    ["8fdda1", "è¥»è¥¼è¥½è¦‰è¦è¦è¦”è¦•è¦›è¦œè¦Ÿè¦ è¦¥è¦°è¦´è¦µè¦¶è¦·è¦¼è§”", 4, "è§¥è§©è§«è§­è§±è§³è§¶è§¹è§½è§¿è¨„è¨…è¨‡è¨è¨‘è¨’è¨”è¨•è¨è¨ è¨¢è¨¤è¨¦è¨«è¨¬è¨¯è¨µè¨·è¨½è¨¾è©€è©ƒè©…è©‡è©‰è©è©è©“è©–è©—è©˜è©œè©è©¡è©¥è©§è©µè©¶è©·è©¹è©ºè©»è©¾è©¿èª€èªƒèª†èª‹èªèªèª’èª–èª—èª™èªŸèª§èª©èª®èª¯èª³"],
    ["8fdea1", "èª¶èª·èª»èª¾è«ƒè«†è«ˆè«‰è«Šè«‘è«“è«”è«•è«—è«è«Ÿè«¬è«°è«´è«µè«¶è«¼è«¿è¬…è¬†è¬‹è¬‘è¬œè¬è¬Ÿè¬Šè¬­è¬°è¬·è¬¼è­‚", 4, "è­ˆè­’è­“è­”è­™è­è­è­£è­­è­¶è­¸è­¹è­¼è­¾è®è®„è®…è®‹è®è®è®”è®•è®œè®è®Ÿè°¸è°¹è°½è°¾è±…è±‡è±‰è±‹è±è±‘è±“è±”è±—è±˜è±›è±è±™è±£è±¤è±¦è±¨è±©è±­è±³è±µè±¶è±»è±¾è²†"],
    ["8fdfa1", "è²‡è²‹è²è²’è²“è²™è²›è²œè²¤è²¹è²ºè³…è³†è³‰è³‹è³è³–è³•è³™è³è³¡è³¨è³¬è³¯è³°è³²è³µè³·è³¸è³¾è³¿è´è´ƒè´‰è´’è´—è´›èµ¥èµ©èµ¬èµ®èµ¿è¶‚è¶„è¶ˆè¶è¶è¶‘è¶•è¶è¶Ÿè¶ è¶¦è¶«è¶¬è¶¯è¶²è¶µè¶·è¶¹è¶»è·€è·…è·†è·‡è·ˆè·Šè·è·‘è·”è·•è·—è·™è·¤è·¥è·§è·¬è·°è¶¼è·±è·²è·´è·½è¸è¸„è¸…è¸†è¸‹è¸‘è¸”è¸–è¸ è¸¡è¸¢"],
    ["8fe0a1", "è¸£è¸¦è¸§è¸±è¸³è¸¶è¸·è¸¸è¸¹è¸½è¹€è¹è¹‹è¹è¹è¹è¹”è¹›è¹œè¹è¹è¹¡è¹¢è¹©è¹¬è¹­è¹¯è¹°è¹±è¹¹è¹ºè¹»èº‚èºƒèº‰èºèº’èº•èºšèº›èºèºèº¢èº§èº©èº­èº®èº³èºµèººèº»è»€è»è»ƒè»„è»‡è»è»‘è»”è»œè»¨è»®è»°è»±è»·è»¹è»ºè»­è¼€è¼‚è¼‡è¼ˆè¼è¼è¼–è¼—è¼˜è¼è¼ è¼¡è¼£è¼¥è¼§è¼¨è¼¬è¼­è¼®è¼´è¼µè¼¶è¼·è¼ºè½€è½"],
    ["8fe1a1", "è½ƒè½‡è½è½‘", 4, "è½˜è½è½è½¥è¾è¾ è¾¡è¾¤è¾¥è¾¦è¾µè¾¶è¾¸è¾¾è¿€è¿è¿†è¿Šè¿‹è¿è¿è¿’è¿“è¿•è¿ è¿£è¿¤è¿¨è¿®è¿±è¿µè¿¶è¿»è¿¾é€‚é€„é€ˆé€Œé€˜é€›é€¨é€©é€¯é€ªé€¬é€­é€³é€´é€·é€¿éƒé„éŒé›éé¢é¦é§é¬é°é´é¹é‚…é‚ˆé‚‹é‚Œé‚é‚é‚•é‚—é‚˜é‚™é‚›é‚ é‚¡é‚¢é‚¥é‚°é‚²é‚³é‚´é‚¶é‚½éƒŒé‚¾éƒƒ"],
    ["8fe2a1", "éƒ„éƒ…éƒ‡éƒˆéƒ•éƒ—éƒ˜éƒ™éƒœéƒéƒŸéƒ¥éƒ’éƒ¶éƒ«éƒ¯éƒ°éƒ´éƒ¾éƒ¿é„€é„„é„…é„†é„ˆé„é„é„”é„–é„—é„˜é„šé„œé„é„ é„¥é„¢é„£é„§é„©é„®é„¯é„±é„´é„¶é„·é„¹é„ºé„¼é„½é…ƒé…‡é…ˆé…é…“é…—é…™é…šé…›é…¡é…¤é…§é…­é…´é…¹é…ºé…»é†é†ƒé†…é††é†Šé†é†‘é†“é†”é†•é†˜é†é†¡é†¦é†¨é†¬é†­é†®é†°é†±é†²é†³é†¶é†»é†¼é†½é†¿"],
    ["8fe3a1", "é‡‚é‡ƒé‡…é‡“é‡”é‡—é‡™é‡šé‡é‡¤é‡¥é‡©é‡ªé‡¬", 5, "é‡·é‡¹é‡»é‡½éˆ€éˆéˆ„éˆ…éˆ†éˆ‡éˆ‰éˆŠéˆŒéˆéˆ’éˆ“éˆ–éˆ˜éˆœéˆéˆ£éˆ¤éˆ¥éˆ¦éˆ¨éˆ®éˆ¯éˆ°éˆ³éˆµéˆ¶éˆ¸éˆ¹éˆºéˆ¼éˆ¾é‰€é‰‚é‰ƒé‰†é‰‡é‰Šé‰é‰é‰é‰‘é‰˜é‰™é‰œé‰é‰ é‰¡é‰¥é‰§é‰¨é‰©é‰®é‰¯é‰°é‰µ", 4, "é‰»é‰¼é‰½é‰¿éŠˆéŠ‰éŠŠéŠéŠéŠ’éŠ—"],
    ["8fe4a1", "éŠ™éŠŸéŠ éŠ¤éŠ¥éŠ§éŠ¨éŠ«éŠ¯éŠ²éŠ¶éŠ¸éŠºéŠ»éŠ¼éŠ½éŠ¿", 4, "é‹…é‹†é‹‡é‹ˆé‹‹é‹Œé‹é‹é‹é‹“é‹•é‹—é‹˜é‹™é‹œé‹é‹Ÿé‹ é‹¡é‹£é‹¥é‹§é‹¨é‹¬é‹®é‹°é‹¹é‹»é‹¿éŒ€éŒ‚éŒˆéŒéŒ‘éŒ”éŒ•éŒœéŒéŒéŒŸéŒ¡éŒ¤éŒ¥éŒ§éŒ©éŒªéŒ³éŒ´éŒ¶éŒ·é‡éˆé‰éé‘é’é•é—é˜éšéé¤é¥é§é©éªé­é¯é°é±é³é´é¶"],
    ["8fe5a1", "éºé½é¿é€éé‚éˆéŠé‹ééé’é•é˜é›éé¡é£é¤é¦é¨é«é´éµé¶éºé©éé„é…é†é‡é‰", 4, "é“é™éœééŸé¢é¦é§é¹é·é¸éºé»é½éé‚é„éˆé‰éééé•é–é—éŸé®é¯é±é²é³é´é»é¿é½é‘ƒé‘…é‘ˆé‘Šé‘Œé‘•é‘™é‘œé‘Ÿé‘¡é‘£é‘¨é‘«é‘­é‘®é‘¯é‘±é‘²é’„é’ƒé•¸é•¹"],
    ["8fe6a1", "é•¾é–„é–ˆé–Œé–é–é–é–é–Ÿé–¡é–¦é–©é–«é–¬é–´é–¶é–ºé–½é–¿é—†é—ˆé—‰é—‹é—é—‘é—’é—“é—™é—šé—é—é—Ÿé— é—¤é—¦é˜é˜é˜¢é˜¤é˜¥é˜¦é˜¬é˜±é˜³é˜·é˜¸é˜¹é˜ºé˜¼é˜½é™é™’é™”é™–é™—é™˜é™¡é™®é™´é™»é™¼é™¾é™¿éšéš‚éšƒéš„éš‰éš‘éš–éššéšéšŸéš¤éš¥éš¦éš©éš®éš¯éš³éšºé›Šé›’å¶²é›˜é›šé›é›é›Ÿé›©é›¯é›±é›ºéœ‚"],
    ["8fe7a1", "éœƒéœ…éœ‰éœšéœ›éœéœ¡éœ¢éœ£éœ¨éœ±éœ³ééƒéŠééé•é—é˜éšé›é£é§éªé®é³é¶é·é¸é»é½é¿é€é‰é•é–é—é™éšééŸé¢é¬é®é±é²éµé¶é¸é¹éºé¼é¾é¿éŸéŸ„éŸ…éŸ‡éŸ‰éŸŠéŸŒéŸéŸéŸéŸ‘éŸ”éŸ—éŸ˜éŸ™éŸéŸéŸ éŸ›éŸ¡éŸ¤éŸ¯éŸ±éŸ´éŸ·éŸ¸éŸºé ‡é Šé ™é é é ”é –é œé é  é £é ¦"],
    ["8fe8a1", "é «é ®é ¯é °é ²é ³é µé ¥é ¾é¡„é¡‡é¡Šé¡‘é¡’é¡“é¡–é¡—é¡™é¡šé¡¢é¡£é¡¥é¡¦é¡ªé¡¬é¢«é¢­é¢®é¢°é¢´é¢·é¢¸é¢ºé¢»é¢¿é£‚é£…é£ˆé£Œé£¡é££é£¥é£¦é£§é£ªé£³é£¶é¤‚é¤‡é¤ˆé¤‘é¤•é¤–é¤—é¤šé¤›é¤œé¤Ÿé¤¢é¤¦é¤§é¤«é¤±", 4, "é¤¹é¤ºé¤»é¤¼é¥€é¥é¥†é¥‡é¥ˆé¥é¥é¥”é¥˜é¥™é¥›é¥œé¥é¥Ÿé¥ é¦›é¦é¦Ÿé¦¦é¦°é¦±é¦²é¦µ"],
    ["8fe9a1", "é¦¹é¦ºé¦½é¦¿é§ƒé§‰é§“é§”é§™é§šé§œé§é§§é§ªé§«é§¬é§°é§´é§µé§¹é§½é§¾é¨‚é¨ƒé¨„é¨‹é¨Œé¨é¨‘é¨–é¨é¨ é¨¢é¨£é¨¤é¨§é¨­é¨®é¨³é¨µé¨¶é¨¸é©‡é©é©„é©Šé©‹é©Œé©é©‘é©”é©–é©éªªéª¬éª®éª¯éª²éª´éªµéª¶éª¹éª»éª¾éª¿é«é«ƒé«†é«ˆé«é«é«’é«•é«–é«—é«›é«œé« é«¤é«¥é«§é«©é«¬é«²é«³é«µé«¹é«ºé«½é«¿", 4],
    ["8feaa1", "é¬„é¬…é¬ˆé¬‰é¬‹é¬Œé¬é¬é¬é¬’é¬–é¬™é¬›é¬œé¬ é¬¦é¬«é¬­é¬³é¬´é¬µé¬·é¬¹é¬ºé¬½é­ˆé­‹é­Œé­•é­–é­—é­›é­é­¡é­£é­¥é­¦é­¨é­ª", 4, "é­³é­µé­·é­¸é­¹é­¿é®€é®„é®…é®†é®‡é®‰é®Šé®‹é®é®é®é®”é®šé®é®é®¦é®§é®©é®¬é®°é®±é®²é®·é®¸é®»é®¼é®¾é®¿é¯é¯‡é¯ˆé¯é¯é¯—é¯˜é¯é¯Ÿé¯¥é¯§é¯ªé¯«é¯¯é¯³é¯·é¯¸"],
    ["8feba1", "é¯¹é¯ºé¯½é¯¿é°€é°‚é°‹é°é°‘é°–é°˜é°™é°šé°œé°é°¢é°£é°¦", 4, "é°±é°µé°¶é°·é°½é±é±ƒé±„é±…é±‰é±Šé±é±é±é±“é±”é±–é±˜é±›é±é±é±Ÿé±£é±©é±ªé±œé±«é±¨é±®é±°é±²é±µé±·é±»é³¦é³²é³·é³¹é´‹é´‚é´‘é´—é´˜é´œé´é´é´¯é´°é´²é´³é´´é´ºé´¼éµ…é´½éµ‚éµƒéµ‡éµŠéµ“éµ”éµŸéµ£éµ¢éµ¥éµ©éµªéµ«éµ°éµ¶éµ·éµ»"],
    ["8feca1", "éµ¼éµ¾é¶ƒé¶„é¶†é¶Šé¶é¶é¶’é¶“é¶•é¶–é¶—é¶˜é¶¡é¶ªé¶¬é¶®é¶±é¶µé¶¹é¶¼é¶¿é·ƒé·‡é·‰é·Šé·”é·•é·–é·—é·šé·é·Ÿé· é·¥é·§é·©é·«é·®é·°é·³é·´é·¾é¸Šé¸‚é¸‡é¸é¸é¸‘é¸’é¸•é¸–é¸™é¸œé¸é¹ºé¹»é¹¼éº€éº‚éºƒéº„éº…éº‡éºéºéº–éº˜éº›éºéº¤éº¨éº¬éº®éº¯éº°éº³éº´éºµé»†é»ˆé»‹é»•é»Ÿé»¤é»§é»¬é»­é»®é»°é»±é»²é»µ"],
    ["8feda1", "é»¸é»¿é¼‚é¼ƒé¼‰é¼é¼é¼‘é¼’é¼”é¼–é¼—é¼™é¼šé¼›é¼Ÿé¼¢é¼¦é¼ªé¼«é¼¯é¼±é¼²é¼´é¼·é¼¹é¼ºé¼¼é¼½é¼¿é½é½ƒ", 4, "é½“é½•é½–é½—é½˜é½šé½é½é½¨é½©é½­", 4, "é½³é½µé½ºé½½é¾é¾é¾‘é¾’é¾”é¾–é¾—é¾é¾¡é¾¢é¾£é¾¥"]
  ];
});

// node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\0", 127, "â‚¬"],
    ["8140", "ä¸‚ä¸„ä¸…ä¸†ä¸ä¸’ä¸—ä¸Ÿä¸ ä¸¡ä¸£ä¸¦ä¸©ä¸®ä¸¯ä¸±ä¸³ä¸µä¸·ä¸¼ä¹€ä¹ä¹‚ä¹„ä¹†ä¹Šä¹‘ä¹•ä¹—ä¹šä¹›ä¹¢ä¹£ä¹¤ä¹¥ä¹§ä¹¨ä¹ª", 5, "ä¹²ä¹´", 9, "ä¹¿", 6, "äº‡äºŠ"],
    ["8180", "äºäº–äº—äº™äºœäºäºäº£äºªäº¯äº°äº±äº´äº¶äº·äº¸äº¹äº¼äº½äº¾ä»ˆä»Œä»ä»ä»’ä»šä»›ä»œä» ä»¢ä»¦ä»§ä»©ä»­ä»®ä»¯ä»±ä»´ä»¸ä»¹ä»ºä»¼ä»¾ä¼€ä¼‚", 6, "ä¼‹ä¼Œä¼’", 4, "ä¼œä¼ä¼¡ä¼£ä¼¨ä¼©ä¼¬ä¼­ä¼®ä¼±ä¼³ä¼µä¼·ä¼¹ä¼»ä¼¾", 4, "ä½„ä½…ä½‡", 5, "ä½’ä½”ä½–ä½¡ä½¢ä½¦ä½¨ä½ªä½«ä½­ä½®ä½±ä½²ä½µä½·ä½¸ä½¹ä½ºä½½ä¾€ä¾ä¾‚ä¾…ä¾†ä¾‡ä¾Šä¾Œä¾ä¾ä¾’ä¾“ä¾•ä¾–ä¾˜ä¾™ä¾šä¾œä¾ä¾Ÿä¾¡ä¾¢"],
    ["8240", "ä¾¤ä¾«ä¾­ä¾°", 4, "ä¾¶", 8, "ä¿€ä¿ä¿‚ä¿†ä¿‡ä¿ˆä¿‰ä¿‹ä¿Œä¿ä¿’", 4, "ä¿™ä¿›ä¿ ä¿¢ä¿¤ä¿¥ä¿§ä¿«ä¿¬ä¿°ä¿²ä¿´ä¿µä¿¶ä¿·ä¿¹ä¿»ä¿¼ä¿½ä¿¿", 11],
    ["8280", "å€‹å€å€å€‘å€“å€•å€–å€—å€›å€å€å€ å€¢å€£å€¤å€§å€«å€¯", 10, "å€»å€½å€¿å€åå‚å„å…å†å‰åŠå‹åå", 4, "å–å—å˜å™å›å", 7, "å¦", 5, "å­", 8, "å¸å¹åºå¼å½å‚å‚‚å‚ƒå‚„å‚†å‚‡å‚‰å‚Šå‚‹å‚Œå‚", 20, "å‚¤å‚¦å‚ªå‚«å‚­", 4, "å‚³", 6, "å‚¼"],
    ["8340", "å‚½", 17, "åƒ", 5, "åƒ—åƒ˜åƒ™åƒ›", 10, "åƒ¨åƒ©åƒªåƒ«åƒ¯åƒ°åƒ±åƒ²åƒ´åƒ¶", 4, "åƒ¼", 9, "å„ˆ"],
    ["8380", "å„‰å„Šå„Œ", 5, "å„“", 13, "å„¢", 28, "å…‚å…‡å…Šå…Œå…å…å…å…’å…“å…—å…˜å…™å…›å…", 4, "å…£å…¤å…¦å…§å…©å…ªå…¯å…²å…ºå…¾å…¿å†ƒå†„å††å†‡å†Šå†‹å†å†å†å†‘å†“å†”å†˜å†šå†å†å†Ÿå†¡å†£å†¦", 4, "å†­å†®å†´å†¸å†¹å†ºå†¾å†¿å‡å‡‚å‡ƒå‡…å‡ˆå‡Šå‡å‡å‡å‡’", 5],
    ["8440", "å‡˜å‡™å‡šå‡œå‡å‡Ÿå‡¢å‡£å‡¥", 5, "å‡¬å‡®å‡±å‡²å‡´å‡·å‡¾åˆ„åˆ…åˆ‰åˆ‹åˆŒåˆåˆåˆ“åˆ”åˆ•åˆœåˆåˆŸåˆ¡åˆ¢åˆ£åˆ¥åˆ¦åˆ§åˆªåˆ¬åˆ¯åˆ±åˆ²åˆ´åˆµåˆ¼åˆ¾å‰„", 5, "å‰‹å‰å‰å‰’å‰“å‰•å‰—å‰˜"],
    ["8480", "å‰™å‰šå‰›å‰å‰Ÿå‰ å‰¢å‰£å‰¤å‰¦å‰¨å‰«å‰¬å‰­å‰®å‰°å‰±å‰³", 9, "å‰¾åŠ€åŠƒ", 4, "åŠ‰", 6, "åŠ‘åŠ’åŠ”", 6, "åŠœåŠ¤åŠ¥åŠ¦åŠ§åŠ®åŠ¯åŠ°åŠ´", 9, "å‹€å‹å‹‚å‹„å‹…å‹†å‹ˆå‹Šå‹Œå‹å‹å‹å‹‘å‹“å‹”å‹•å‹—å‹™", 5, "å‹ å‹¡å‹¢å‹£å‹¥", 10, "å‹±", 7, "å‹»å‹¼å‹½åŒåŒ‚åŒƒåŒ„åŒ‡åŒ‰åŒŠåŒ‹åŒŒåŒ"],
    ["8540", "åŒ‘åŒ’åŒ“åŒ”åŒ˜åŒ›åŒœåŒåŒŸåŒ¢åŒ¤åŒ¥åŒ§åŒ¨åŒ©åŒ«åŒ¬åŒ­åŒ¯", 9, "åŒ¼åŒ½å€å‚å„å†å‹åŒååå”å˜å™å›åå¥å¨åªå¬å­å²å¶å¹å»å¼å½å¾å€ååƒå‡åˆåŠåå"],
    ["8580", "å", 4, "å–å—å™å›åœåå å¡å¤å§åªå«å¬å­å¯", 6, "å·å¸å¹åºå¼å½å¾å€åƒ", 4, "åååå’å“å•åšåœååå¡å¢å§å´åºå¾å¿å€å‚å…å‡å‹å”å˜å™åšåœå¢å¤å¥åªå°å³å¶å·åºå½å¿å‘å‘‚å‘„å‘…å‘‡å‘‰å‘Œå‘å‘å‘å‘‘å‘šå‘", 4, "å‘£å‘¥å‘§å‘©", 7, "å‘´å‘¹å‘ºå‘¾å‘¿å’å’ƒå’…å’‡å’ˆå’‰å’Šå’å’‘å’“å’—å’˜å’œå’å’Ÿå’ å’¡"],
    ["8640", "å’¢å’¥å’®å’°å’²å’µå’¶å’·å’¹å’ºå’¼å’¾å“ƒå“…å“Šå“‹å“–å“˜å“›å“ ", 4, "å“«å“¬å“¯å“°å“±å“´", 5, "å“»å“¾å”€å”‚å”ƒå”„å”…å”ˆå”Š", 4, "å”’å”“å”•", 5, "å”œå”å”å”Ÿå”¡å”¥å”¦"],
    ["8680", "å”¨å”©å”«å”­å”²å”´å”µå”¶å”¸å”¹å”ºå”»å”½å•€å•‚å•…å•‡å•ˆå•‹", 4, "å•‘å•’å•“å•”å•—", 4, "å•å•å•Ÿå• å•¢å•£å•¨å•©å•«å•¯", 5, "å•¹å•ºå•½å•¿å–…å–†å–Œå–å–å–å–’å–“å–•å––å–—å–šå–›å–å– ", 6, "å–¨", 8, "å–²å–´å–¶å–¸å–ºå–¼å–¿", 4, "å—†å—‡å—ˆå—Šå—‹å—å—å—å—•å——", 4, "å—å— å—¢å—§å—©å—­å—®å—°å—±å—´å—¶å—¸", 4, "å—¿å˜‚å˜ƒå˜„å˜…"],
    ["8740", "å˜†å˜‡å˜Šå˜‹å˜å˜", 7, "å˜™å˜šå˜œå˜å˜ å˜¡å˜¢å˜¥å˜¦å˜¨å˜©å˜ªå˜«å˜®å˜¯å˜°å˜³å˜µå˜·å˜¸å˜ºå˜¼å˜½å˜¾å™€", 11, "å™", 4, "å™•å™–å™šå™›å™", 4],
    ["8780", "å™£å™¥å™¦å™§å™­å™®å™¯å™°å™²å™³å™´å™µå™·å™¸å™¹å™ºå™½", 7, "åš‡", 6, "åšåš‘åš’åš”", 14, "åš¤", 10, "åš°", 6, "åš¸åš¹åšºåš»åš½", 12, "å›‹", 8, "å›•å›–å›˜å›™å›œå›£å›¥", 5, "å›¬å›®å›¯å›²å›³å›¶å›·å›¸å›»å›¼åœ€åœåœ‚åœ…åœ‡åœ‹", 6],
    ["8840", "åœ’", 9, "åœåœåœ åœ¡åœ¢åœ¤åœ¥åœ¦åœ§åœ«åœ±åœ²åœ´", 4, "åœ¼åœ½åœ¿ååƒå„å…å†åˆå‰å‹å’", 4, "å˜å™å¢å£å¥å§å¬å®å°å±å²å´åµå¸å¹åºå½å¾å¿å€"],
    ["8880", "åå‡åˆå‰åŠå", 4, "å”", 6, "åœåååŸå¥å¨åªå¬å¯å°å±å³åµå¶å·å¹", 8, "åŸ„", 6, "åŸŒåŸåŸåŸ‘åŸ“åŸ–åŸ—åŸ›åŸœåŸåŸ¡åŸ¢åŸ£åŸ¥", 7, "åŸ®åŸ°åŸ±åŸ²åŸ³åŸµåŸ¶åŸ·åŸ»åŸ¼åŸ¾åŸ¿å å ƒå „å …å ˆå ‰å Šå Œå å å å ’å “å ”å –å —å ˜å šå ›å œå å Ÿå ¢å £å ¥", 4, "å «", 4, "å ±å ²å ³å ´å ¶", 7],
    ["8940", "å ¾", 5, "å¡…", 6, "å¡å¡å¡å¡’å¡“å¡•å¡–å¡—å¡™", 4, "å¡Ÿ", 5, "å¡¦", 4, "å¡­", 16, "å¡¿å¢‚å¢„å¢†å¢‡å¢ˆå¢Šå¢‹å¢Œ"],
    ["8980", "å¢", 4, "å¢”", 4, "å¢›å¢œå¢å¢ ", 7, "å¢ª", 17, "å¢½å¢¾å¢¿å£€å£‚å£ƒå£„å£†", 10, "å£’å£“å£”å£–", 13, "å£¥", 5, "å£­å£¯å£±å£²å£´å£µå£·å£¸å£º", 7, "å¤ƒå¤…å¤†å¤ˆ", 4, "å¤å¤å¤‘å¤’å¤“å¤—å¤˜å¤›å¤å¤å¤ å¤¡å¤¢å¤£å¤¦å¤¨å¤¬å¤°å¤²å¤³å¤µå¤¶å¤»"],
    ["8a40", "å¤½å¤¾å¤¿å¥€å¥ƒå¥…å¥†å¥Šå¥Œå¥å¥å¥’å¥“å¥™å¥›", 4, "å¥¡å¥£å¥¤å¥¦", 12, "å¥µå¥·å¥ºå¥»å¥¼å¥¾å¥¿å¦€å¦…å¦‰å¦‹å¦Œå¦å¦å¦å¦‘å¦”å¦•å¦˜å¦šå¦›å¦œå¦å¦Ÿå¦ å¦¡å¦¢å¦¦"],
    ["8a80", "å¦§å¦¬å¦­å¦°å¦±å¦³", 5, "å¦ºå¦¼å¦½å¦¿", 6, "å§‡å§ˆå§‰å§Œå§å§å§å§•å§–å§™å§›å§", 4, "å§¤å§¦å§§å§©å§ªå§«å§­", 11, "å§ºå§¼å§½å§¾å¨€å¨‚å¨Šå¨‹å¨å¨å¨å¨å¨’å¨”å¨•å¨–å¨—å¨™å¨šå¨›å¨å¨å¨¡å¨¢å¨¤å¨¦å¨§å¨¨å¨ª", 6, "å¨³å¨µå¨·", 4, "å¨½å¨¾å¨¿å©", 4, "å©‡å©ˆå©‹", 9, "å©–å©—å©˜å©™å©›", 5],
    ["8b40", "å©¡å©£å©¤å©¥å©¦å©¨å©©å©«", 8, "å©¸å©¹å©»å©¼å©½å©¾åª€", 17, "åª“", 6, "åªœ", 13, "åª«åª¬"],
    ["8b80", "åª­", 4, "åª´åª¶åª·åª¹", 4, "åª¿å«€å«ƒ", 5, "å«Šå«‹å«", 4, "å«“å«•å«—å«™å«šå«›å«å«å«Ÿå«¢å«¤å«¥å«§å«¨å«ªå«¬", 4, "å«²", 22, "å¬Š", 11, "å¬˜", 25, "å¬³å¬µå¬¶å¬¸", 7, "å­", 6],
    ["8c40", "å­ˆ", 7, "å­’å­–å­å­ å­¡å­§å­¨å­«å­­å­®å­¯å­²å­´å­¶å­·å­¸å­¹å­»å­¼å­¾å­¿å®‚å®†å®Šå®å®å®å®‘å®’å®”å®–å®Ÿå®§å®¨å®©å®¬å®­å®®å®¯å®±å®²å®·å®ºå®»å®¼å¯€å¯å¯ƒå¯ˆå¯‰å¯Šå¯‹å¯å¯å¯"],
    ["8c80", "å¯‘å¯”", 8, "å¯ å¯¢å¯£å¯¦å¯§å¯©", 4, "å¯¯å¯±", 6, "å¯½å¯¾å°€å°‚å°ƒå°…å°‡å°ˆå°‹å°Œå°å°å°å°’å°“å°—å°™å°›å°å°Ÿå° å°¡å°£å°¦å°¨å°©å°ªå°«å°­å°®å°¯å°°å°²å°³å°µå°¶å°·å±ƒå±„å±†å±‡å±Œå±å±’å±“å±”å±–å±—å±˜å±šå±›å±œå±å±Ÿå±¢å±¤å±§", 6, "å±°å±²", 6, "å±»å±¼å±½å±¾å²€å²ƒ", 4, "å²‰å²Šå²‹å²å²å²’å²“å²•å²", 4, "å²¤", 4],
    ["8d40", "å²ªå²®å²¯å²°å²²å²´å²¶å²¹å²ºå²»å²¼å²¾å³€å³‚å³ƒå³…", 5, "å³Œ", 5, "å³“", 5, "å³š", 6, "å³¢å³£å³§å³©å³«å³¬å³®å³¯å³±", 9, "å³¼", 4],
    ["8d80", "å´å´„å´…å´ˆ", 5, "å´", 4, "å´•å´—å´˜å´™å´šå´œå´å´Ÿ", 4, "å´¥å´¨å´ªå´«å´¬å´¯", 4, "å´µ", 7, "å´¿", 7, "åµˆåµ‰åµ", 10, "åµ™åµšåµœåµ", 10, "åµªåµ­åµ®åµ°åµ±åµ²åµ³åµµ", 12, "å¶ƒ", 21, "å¶šå¶›å¶œå¶å¶Ÿå¶ "],
    ["8e40", "å¶¡", 21, "å¶¸", 12, "å·†", 6, "å·", 12, "å·œå·Ÿå· å·£å·¤å·ªå·¬å·­"],
    ["8e80", "å·°å·µå·¶å·¸", 4, "å·¿å¸€å¸„å¸‡å¸‰å¸Šå¸‹å¸å¸å¸’å¸“å¸—å¸", 7, "å¸¨", 4, "å¸¯å¸°å¸²", 4, "å¸¹å¸ºå¸¾å¸¿å¹€å¹å¹ƒå¹†", 5, "å¹", 6, "å¹–", 4, "å¹œå¹å¹Ÿå¹ å¹£", 14, "å¹µå¹·å¹¹å¹¾åºåº‚åºƒåº…åºˆåº‰åºŒåºåºåº’åº˜åº›åºåº¡åº¢åº£åº¤åº¨", 4, "åº®", 4, "åº´åººåº»åº¼åº½åº¿", 6],
    ["8f40", "å»†å»‡å»ˆå»‹", 5, "å»”å»•å»—å»˜å»™å»šå»œ", 11, "å»©å»«", 8, "å»µå»¸å»¹å»»å»¼å»½å¼…å¼†å¼‡å¼‰å¼Œå¼å¼å¼å¼’å¼”å¼–å¼™å¼šå¼œå¼å¼å¼¡å¼¢å¼£å¼¤"],
    ["8f80", "å¼¨å¼«å¼¬å¼®å¼°å¼²", 6, "å¼»å¼½å¼¾å¼¿å½", 14, "å½‘å½”å½™å½šå½›å½œå½å½Ÿå½ å½£å½¥å½§å½¨å½«å½®å½¯å½²å½´å½µå½¶å½¸å½ºå½½å½¾å½¿å¾ƒå¾†å¾å¾å¾å¾‘å¾“å¾”å¾–å¾šå¾›å¾å¾å¾Ÿå¾ å¾¢", 5, "å¾©å¾«å¾¬å¾¯", 5, "å¾¶å¾¸å¾¹å¾ºå¾»å¾¾", 4, "å¿‡å¿ˆå¿Šå¿‹å¿å¿“å¿”å¿•å¿šå¿›å¿œå¿å¿Ÿå¿¢å¿£å¿¥å¿¦å¿¨å¿©å¿¬å¿¯å¿°å¿²å¿³å¿´å¿¶å¿·å¿¹å¿ºå¿¼æ€‡"],
    ["9040", "æ€ˆæ€‰æ€‹æ€Œæ€æ€‘æ€“æ€—æ€˜æ€šæ€æ€Ÿæ€¢æ€£æ€¤æ€¬æ€­æ€®æ€°", 4, "æ€¶", 4, "æ€½æ€¾æ€æ„", 6, "æŒæææ‘æ“æ”æ–æ—æ˜æ›æœææŸæ æ¡æ¥æ¦æ®æ±æ²æ´æµæ·æ¾æ‚€"],
    ["9080", "æ‚æ‚‚æ‚…æ‚†æ‚‡æ‚ˆæ‚Šæ‚‹æ‚æ‚æ‚æ‚‘æ‚“æ‚•æ‚—æ‚˜æ‚™æ‚œæ‚æ‚¡æ‚¢æ‚¤æ‚¥æ‚§æ‚©æ‚ªæ‚®æ‚°æ‚³æ‚µæ‚¶æ‚·æ‚¹æ‚ºæ‚½", 7, "æƒ‡æƒˆæƒ‰æƒŒ", 4, "æƒ’æƒ“æƒ”æƒ–æƒ—æƒ™æƒ›æƒæƒ¡", 4, "æƒªæƒ±æƒ²æƒµæƒ·æƒ¸æƒ»", 4, "æ„‚æ„ƒæ„„æ„…æ„‡æ„Šæ„‹æ„Œæ„", 4, "æ„–æ„—æ„˜æ„™æ„›æ„œæ„æ„æ„¡æ„¢æ„¥æ„¨æ„©æ„ªæ„¬", 18, "æ…€", 6],
    ["9140", "æ…‡æ…‰æ…‹æ…æ…æ…æ…’æ…“æ…”æ…–", 6, "æ…æ…Ÿæ… æ…¡æ…£æ…¤æ…¥æ…¦æ…©", 6, "æ…±æ…²æ…³æ…´æ…¶æ…¸", 18, "æ†Œæ†æ†", 4, "æ†•"],
    ["9180", "æ†–", 6, "æ†", 8, "æ†ªæ†«æ†­", 9, "æ†¸", 5, "æ†¿æ‡€æ‡æ‡ƒ", 4, "æ‡‰æ‡Œ", 4, "æ‡“æ‡•", 16, "æ‡§", 13, "æ‡¶", 8, "æˆ€", 5, "æˆ‡æˆ‰æˆ“æˆ”æˆ™æˆœæˆæˆæˆ æˆ£æˆ¦æˆ§æˆ¨æˆ©æˆ«æˆ­æˆ¯æˆ°æˆ±æˆ²æˆµæˆ¶æˆ¸", 4, "æ‰‚æ‰„æ‰…æ‰†æ‰Š"],
    ["9240", "æ‰æ‰æ‰•æ‰–æ‰—æ‰™æ‰šæ‰œ", 6, "æ‰¤æ‰¥æ‰¨æ‰±æ‰²æ‰´æ‰µæ‰·æ‰¸æ‰ºæ‰»æ‰½æŠæŠ‚æŠƒæŠ…æŠ†æŠ‡æŠˆæŠ‹", 5, "æŠ”æŠ™æŠœæŠæŠæŠ£æŠ¦æŠ§æŠ©æŠªæŠ­æŠ®æŠ¯æŠ°æŠ²æŠ³æŠ´æŠ¶æŠ·æŠ¸æŠºæŠ¾æ‹€æ‹"],
    ["9280", "æ‹ƒæ‹‹æ‹æ‹‘æ‹•æ‹æ‹æ‹ æ‹¡æ‹¤æ‹ªæ‹«æ‹°æ‹²æ‹µæ‹¸æ‹¹æ‹ºæ‹»æŒ€æŒƒæŒ„æŒ…æŒ†æŒŠæŒ‹æŒŒæŒæŒæŒæŒ’æŒ“æŒ”æŒ•æŒ—æŒ˜æŒ™æŒœæŒ¦æŒ§æŒ©æŒ¬æŒ­æŒ®æŒ°æŒ±æŒ³", 5, "æŒ»æŒ¼æŒ¾æŒ¿æ€ææ„æ‡æˆæŠæ‘æ’æ“æ”æ–", 7, "æ æ¤æ¥æ¦æ¨æªæ«æ¬æ¯æ°æ²æ³æ´æµæ¸æ¹æ¼æ½æ¾æ¿ææƒæ„æ…æ†æ‹ææ‘æ“æ”æ•æ—æ™", 6, "æ¡æ¤æ¦æ«æ¯æ±æ²æµæ¶æ¹æ»æ½æ¿æ€"],
    ["9340", "ææ‚æƒæ…æ‡æˆæŠæ‹æŒæ‘æ“æ”æ•æ—", 6, "æŸæ¢æ¤", 4, "æ«æ¬æ®æ¯æ°æ±æ³æµæ·æ¹æºæ»æ¼æ¾æƒæ„æ†", 4, "æææ‘æ’æ•", 5, "ææŸæ¢æ£æ¤"],
    ["9380", "æ¥æ§æ¨æ©æ«æ®", 5, "æµ", 4, "æ»æ¼æ¾æ‘€æ‘‚æ‘ƒæ‘‰æ‘‹", 6, "æ‘“æ‘•æ‘–æ‘—æ‘™", 4, "æ‘Ÿ", 7, "æ‘¨æ‘ªæ‘«æ‘¬æ‘®", 9, "æ‘»", 6, "æ’ƒæ’†æ’ˆ", 8, "æ’“æ’”æ’—æ’˜æ’šæ’›æ’œæ’æ’Ÿ", 4, "æ’¥æ’¦æ’§æ’¨æ’ªæ’«æ’¯æ’±æ’²æ’³æ’´æ’¶æ’¹æ’»æ’½æ’¾æ’¿æ“æ“ƒæ“„æ“†", 6, "æ“æ“‘æ““æ“”æ“•æ“–æ“™æ“š"],
    ["9440", "æ“›æ“œæ“æ“Ÿæ“ æ“¡æ“£æ“¥æ“§", 24, "æ”", 7, "æ”Š", 7, "æ”“", 4, "æ”™", 8],
    ["9480", "æ”¢æ”£æ”¤æ”¦", 4, "æ”¬æ”­æ”°æ”±æ”²æ”³æ”·æ”ºæ”¼æ”½æ•€", 4, "æ•†æ•‡æ•Šæ•‹æ•æ•æ•æ•’æ•“æ•”æ•—æ•˜æ•šæ•œæ•Ÿæ• æ•¡æ•¤æ•¥æ•§æ•¨æ•©æ•ªæ•­æ•®æ•¯æ•±æ•³æ•µæ•¶æ•¸", 14, "æ–ˆæ–‰æ–Šæ–æ–æ–æ–’æ–”æ–•æ––æ–˜æ–šæ–æ–æ– æ–¢æ–£æ–¦æ–¨æ–ªæ–¬æ–®æ–±", 7, "æ–ºæ–»æ–¾æ–¿æ—€æ—‚æ—‡æ—ˆæ—‰æ—Šæ—æ—æ—‘æ—“æ—”æ—•æ—˜", 7, "æ—¡æ—£æ—¤æ—ªæ—«"],
    ["9540", "æ—²æ—³æ—´æ—µæ—¸æ—¹æ—»", 4, "æ˜æ˜„æ˜…æ˜‡æ˜ˆæ˜‰æ˜‹æ˜æ˜æ˜‘æ˜’æ˜–æ˜—æ˜˜æ˜šæ˜›æ˜œæ˜æ˜¡æ˜¢æ˜£æ˜¤æ˜¦æ˜©æ˜ªæ˜«æ˜¬æ˜®æ˜°æ˜²æ˜³æ˜·", 4, "æ˜½æ˜¿æ™€æ™‚æ™„", 6, "æ™æ™æ™æ™‘æ™˜"],
    ["9580", "æ™™æ™›æ™œæ™æ™æ™ æ™¢æ™£æ™¥æ™§æ™©", 4, "æ™±æ™²æ™³æ™µæ™¸æ™¹æ™»æ™¼æ™½æ™¿æš€æšæšƒæš…æš†æšˆæš‰æšŠæš‹æšæšæšæšæš’æš“æš”æš•æš˜", 4, "æš", 8, "æš©", 4, "æš¯", 4, "æšµæš¶æš·æš¸æšºæš»æš¼æš½æš¿", 25, "æ›šæ›", 7, "æ›§æ›¨æ›ª", 5, "æ›±æ›µæ›¶æ›¸æ›ºæ›»æ›½æœæœ‚æœƒ"],
    ["9640", "æœ„æœ…æœ†æœ‡æœŒæœæœæœ‘æœ’æœ“æœ–æœ˜æœ™æœšæœœæœæœ ", 5, "æœ§æœ©æœ®æœ°æœ²æœ³æœ¶æœ·æœ¸æœ¹æœ»æœ¼æœ¾æœ¿ææ„æ…æ‡æŠæ‹ææ’æ”æ•æ—", 4, "ææ¢æ£æ¤æ¦æ§æ«æ¬æ®æ±æ´æ¶"],
    ["9680", "æ¸æ¹æºæ»æ½æ€æ‚æƒæ…æ†æˆæŠæŒææææ‘æ’æ“æ”æ–æ™æ›æŸæ æ¡æ¤æ¦æ©æ¬æ®æ±æ²æ´æ¹", 7, "æŸ‚æŸ…", 9, "æŸ•æŸ–æŸ—æŸ›æŸŸæŸ¡æŸ£æŸ¤æŸ¦æŸ§æŸ¨æŸªæŸ«æŸ­æŸ®æŸ²æŸµ", 7, "æŸ¾æ æ ‚æ ƒæ „æ †æ æ æ ’æ ”æ •æ ˜", 4, "æ æ Ÿæ  æ ¢", 6, "æ «", 6, "æ ´æ µæ ¶æ ºæ »æ ¿æ¡‡æ¡‹æ¡æ¡æ¡’æ¡–", 5],
    ["9740", "æ¡œæ¡æ¡æ¡Ÿæ¡ªæ¡¬", 7, "æ¡µæ¡¸", 8, "æ¢‚æ¢„æ¢‡", 7, "æ¢æ¢‘æ¢’æ¢”æ¢•æ¢–æ¢˜", 9, "æ¢£æ¢¤æ¢¥æ¢©æ¢ªæ¢«æ¢¬æ¢®æ¢±æ¢²æ¢´æ¢¶æ¢·æ¢¸"],
    ["9780", "æ¢¹", 6, "æ£æ£ƒ", 5, "æ£Šæ£Œæ£æ£æ£æ£‘æ£“æ£”æ£–æ£—æ£™æ£›", 4, "æ£¡æ£¢æ£¤", 9, "æ£¯æ£²æ£³æ£´æ£¶æ£·æ£¸æ£»æ£½æ£¾æ£¿æ¤€æ¤‚æ¤ƒæ¤„æ¤†", 4, "æ¤Œæ¤æ¤‘æ¤“", 11, "æ¤¡æ¤¢æ¤£æ¤¥", 7, "æ¤®æ¤¯æ¤±æ¤²æ¤³æ¤µæ¤¶æ¤·æ¤¸æ¤ºæ¤»æ¤¼æ¤¾æ¥€æ¥æ¥ƒ", 16, "æ¥•æ¥–æ¥˜æ¥™æ¥›æ¥œæ¥Ÿ"],
    ["9840", "æ¥¡æ¥¢æ¥¤æ¥¥æ¥§æ¥¨æ¥©æ¥ªæ¥¬æ¥­æ¥¯æ¥°æ¥²", 4, "æ¥ºæ¥»æ¥½æ¥¾æ¥¿æ¦æ¦ƒæ¦…æ¦Šæ¦‹æ¦Œæ¦", 5, "æ¦–æ¦—æ¦™æ¦šæ¦", 9, "æ¦©æ¦ªæ¦¬æ¦®æ¦¯æ¦°æ¦²æ¦³æ¦µæ¦¶æ¦¸æ¦¹æ¦ºæ¦¼æ¦½"],
    ["9880", "æ¦¾æ¦¿æ§€æ§‚", 7, "æ§‹æ§æ§æ§‘æ§’æ§“æ§•", 5, "æ§œæ§æ§æ§¡", 11, "æ§®æ§¯æ§°æ§±æ§³", 9, "æ§¾æ¨€", 9, "æ¨‹", 11, "æ¨™", 5, "æ¨ æ¨¢", 5, "æ¨©æ¨«æ¨¬æ¨­æ¨®æ¨°æ¨²æ¨³æ¨´æ¨¶", 6, "æ¨¿", 4, "æ©…æ©†æ©ˆ", 7, "æ©‘", 6, "æ©š"],
    ["9940", "æ©œ", 4, "æ©¢æ©£æ©¤æ©¦", 10, "æ©²", 6, "æ©ºæ©»æ©½æ©¾æ©¿æªæª‚æªƒæª…", 8, "æªæª’", 4, "æª˜", 7, "æª¡", 5],
    ["9980", "æª§æª¨æªªæª­", 114, "æ¬¥æ¬¦æ¬¨", 6],
    ["9a40", "æ¬¯æ¬°æ¬±æ¬³æ¬´æ¬µæ¬¶æ¬¸æ¬»æ¬¼æ¬½æ¬¿æ­€æ­æ­‚æ­„æ­…æ­ˆæ­Šæ­‹æ­", 11, "æ­š", 7, "æ­¨æ­©æ­«", 13, "æ­ºæ­½æ­¾æ­¿æ®€æ®…æ®ˆ"],
    ["9a80", "æ®Œæ®æ®æ®æ®‘æ®”æ®•æ®—æ®˜æ®™æ®œ", 4, "æ®¢", 7, "æ®«", 7, "æ®¶æ®¸", 6, "æ¯€æ¯ƒæ¯„æ¯†", 4, "æ¯Œæ¯æ¯æ¯‘æ¯˜æ¯šæ¯œ", 4, "æ¯¢", 7, "æ¯¬æ¯­æ¯®æ¯°æ¯±æ¯²æ¯´æ¯¶æ¯·æ¯¸æ¯ºæ¯»æ¯¼æ¯¾", 6, "æ°ˆ", 4, "æ°æ°’æ°—æ°œæ°æ°æ° æ°£æ°¥æ°«æ°¬æ°­æ°±æ°³æ°¶æ°·æ°¹æ°ºæ°»æ°¼æ°¾æ°¿æ±ƒæ±„æ±…æ±ˆæ±‹", 4, "æ±‘æ±’æ±“æ±–æ±˜"],
    ["9b40", "æ±™æ±šæ±¢æ±£æ±¥æ±¦æ±§æ±«", 4, "æ±±æ±³æ±µæ±·æ±¸æ±ºæ±»æ±¼æ±¿æ²€æ²„æ²‡æ²Šæ²‹æ²æ²æ²‘æ²’æ²•æ²–æ²—æ²˜æ²šæ²œæ²æ²æ² æ²¢æ²¨æ²¬æ²¯æ²°æ²´æ²µæ²¶æ²·æ²ºæ³€æ³æ³‚æ³ƒæ³†æ³‡æ³ˆæ³‹æ³æ³æ³æ³‘æ³’æ³˜"],
    ["9b80", "æ³™æ³šæ³œæ³æ³Ÿæ³¤æ³¦æ³§æ³©æ³¬æ³­æ³²æ³´æ³¹æ³¿æ´€æ´‚æ´ƒæ´…æ´†æ´ˆæ´‰æ´Šæ´æ´æ´æ´‘æ´“æ´”æ´•æ´–æ´˜æ´œæ´æ´Ÿ", 5, "æ´¦æ´¨æ´©æ´¬æ´­æ´¯æ´°æ´´æ´¶æ´·æ´¸æ´ºæ´¿æµ€æµ‚æµ„æµ‰æµŒæµæµ•æµ–æµ—æµ˜æµ›æµæµŸæµ¡æµ¢æµ¤æµ¥æµ§æµ¨æµ«æµ¬æµ­æµ°æµ±æµ²æµ³æµµæµ¶æµ¹æµºæµ»æµ½", 4, "æ¶ƒæ¶„æ¶†æ¶‡æ¶Šæ¶‹æ¶æ¶æ¶æ¶’æ¶–", 4, "æ¶œæ¶¢æ¶¥æ¶¬æ¶­æ¶°æ¶±æ¶³æ¶´æ¶¶æ¶·æ¶¹", 5, "æ·æ·‚æ·ƒæ·ˆæ·‰æ·Š"],
    ["9c40", "æ·æ·æ·æ·æ·’æ·“æ·”æ·•æ·—æ·šæ·›æ·œæ·Ÿæ·¢æ·£æ·¥æ·§æ·¨æ·©æ·ªæ·­æ·¯æ·°æ·²æ·´æ·µæ·¶æ·¸æ·ºæ·½", 7, "æ¸†æ¸‡æ¸ˆæ¸‰æ¸‹æ¸æ¸’æ¸“æ¸•æ¸˜æ¸™æ¸›æ¸œæ¸æ¸Ÿæ¸¢æ¸¦æ¸§æ¸¨æ¸ªæ¸¬æ¸®æ¸°æ¸±æ¸³æ¸µ"],
    ["9c80", "æ¸¶æ¸·æ¸¹æ¸»", 7, "æ¹…", 7, "æ¹æ¹æ¹‘æ¹’æ¹•æ¹—æ¹™æ¹šæ¹œæ¹æ¹æ¹ ", 10, "æ¹¬æ¹­æ¹¯", 14, "æº€æºæº‚æº„æº‡æºˆæºŠ", 4, "æº‘", 6, "æº™æºšæº›æºæºæº æº¡æº£æº¤æº¦æº¨æº©æº«æº¬æº­æº®æº°æº³æºµæº¸æº¹æº¼æº¾æº¿æ»€æ»ƒæ»„æ»…æ»†æ»ˆæ»‰æ»Šæ»Œæ»æ»æ»æ»’æ»–æ»˜æ»™æ»›æ»œæ»æ»£æ»§æ»ª", 5],
    ["9d40", "æ»°æ»±æ»²æ»³æ»µæ»¶æ»·æ»¸æ»º", 7, "æ¼ƒæ¼„æ¼…æ¼‡æ¼ˆæ¼Š", 4, "æ¼æ¼‘æ¼’æ¼–", 9, "æ¼¡æ¼¢æ¼£æ¼¥æ¼¦æ¼§æ¼¨æ¼¬æ¼®æ¼°æ¼²æ¼´æ¼µæ¼·", 6, "æ¼¿æ½€æ½æ½‚"],
    ["9d80", "æ½ƒæ½„æ½…æ½ˆæ½‰æ½Šæ½Œæ½", 9, "æ½™æ½šæ½›æ½æ½Ÿæ½ æ½¡æ½£æ½¤æ½¥æ½§", 5, "æ½¯æ½°æ½±æ½³æ½µæ½¶æ½·æ½¹æ½»æ½½", 6, "æ¾…æ¾†æ¾‡æ¾Šæ¾‹æ¾", 12, "æ¾æ¾æ¾Ÿæ¾ æ¾¢", 4, "æ¾¨", 10, "æ¾´æ¾µæ¾·æ¾¸æ¾º", 5, "æ¿æ¿ƒ", 5, "æ¿Š", 6, "æ¿“", 10, "æ¿Ÿæ¿¢æ¿£æ¿¤æ¿¥"],
    ["9e40", "æ¿¦", 7, "æ¿°", 32, "ç€’", 7, "ç€œ", 6, "ç€¤", 6],
    ["9e80", "ç€«", 9, "ç€¶ç€·ç€¸ç€º", 17, "ççç", 13, "çŸ", 11, "ç®ç±ç²ç³ç´ç·ç¹çºç»ç½ç‚ç‚‚ç‚ƒç‚„ç‚†ç‚‡ç‚ˆç‚‹ç‚Œç‚ç‚ç‚ç‚‘ç‚“ç‚—ç‚˜ç‚šç‚›ç‚", 12, "ç‚°ç‚²ç‚´ç‚µç‚¶ç‚ºç‚¾ç‚¿çƒ„çƒ…çƒ†çƒ‡çƒ‰çƒ‹", 12, "çƒš"],
    ["9f40", "çƒœçƒçƒçƒ çƒ¡çƒ¢çƒ£çƒ¥çƒªçƒ®çƒ°", 6, "çƒ¸çƒºçƒ»çƒ¼çƒ¾", 10, "ç„‹", 4, "ç„‘ç„’ç„”ç„—ç„›", 10, "ç„§", 7, "ç„²ç„³ç„´"],
    ["9f80", "ç„µç„·", 13, "ç…†ç…‡ç…ˆç…‰ç…‹ç…ç…", 12, "ç…ç…Ÿ", 4, "ç…¥ç…©", 4, "ç…¯ç…°ç…±ç…´ç…µç…¶ç…·ç…¹ç…»ç…¼ç…¾", 5, "ç†…", 4, "ç†‹ç†Œç†ç†ç†ç†‘ç†’ç†“ç†•ç†–ç†—ç†š", 4, "ç†¡", 6, "ç†©ç†ªç†«ç†­", 5, "ç†´ç†¶ç†·ç†¸ç†º", 8, "ç‡„", 9, "ç‡", 4],
    ["a040", "ç‡–", 9, "ç‡¡ç‡¢ç‡£ç‡¤ç‡¦ç‡¨", 5, "ç‡¯", 9, "ç‡º", 11, "çˆ‡", 19],
    ["a080", "çˆ›çˆœçˆ", 9, "çˆ©çˆ«çˆ­çˆ®çˆ¯çˆ²çˆ³çˆ´çˆºçˆ¼çˆ¾ç‰€", 6, "ç‰‰ç‰Šç‰‹ç‰ç‰ç‰ç‰‘ç‰“ç‰”ç‰•ç‰—ç‰˜ç‰šç‰œç‰ç‰ ç‰£ç‰¤ç‰¥ç‰¨ç‰ªç‰«ç‰¬ç‰­ç‰°ç‰±ç‰³ç‰´ç‰¶ç‰·ç‰¸ç‰»ç‰¼ç‰½çŠ‚çŠƒçŠ…", 4, "çŠŒçŠçŠçŠ‘çŠ“", 11, "çŠ ", 11, "çŠ®çŠ±çŠ²çŠ³çŠµçŠº", 6, "ç‹…ç‹†ç‹‡ç‹‰ç‹Šç‹‹ç‹Œç‹ç‹‘ç‹“ç‹”ç‹•ç‹–ç‹˜ç‹šç‹›"],
    ["a1a1", "ã€€ã€ã€‚Â·Ë‰Ë‡Â¨ã€ƒã€…â€”ï½â€–â€¦â€˜â€™â€œâ€ã€”ã€•ã€ˆ", 7, "ã€–ã€—ã€ã€‘Â±Ã—Ã·âˆ¶âˆ§âˆ¨âˆ‘âˆâˆªâˆ©âˆˆâˆ·âˆšâŠ¥âˆ¥âˆ âŒ’âŠ™âˆ«âˆ®â‰¡â‰Œâ‰ˆâˆ½âˆâ‰ â‰®â‰¯â‰¤â‰¥âˆâˆµâˆ´â™‚â™€Â°â€²â€³â„ƒï¼„Â¤ï¿ ï¿¡â€°Â§â„–â˜†â˜…â—‹â—â—â—‡â—†â–¡â– â–³â–²â€»â†’â†â†‘â†“ã€“"],
    ["a2a1", "â…°", 9],
    ["a2b1", "â’ˆ", 19, "â‘´", 19, "â‘ ", 9],
    ["a2e5", "ãˆ ", 9],
    ["a2f1", "â… ", 11],
    ["a3a1", "ï¼ï¼‚ï¼ƒï¿¥ï¼…", 88, "ï¿£"],
    ["a4a1", "ã", 82],
    ["a5a1", "ã‚¡", 85],
    ["a6a1", "Î‘", 16, "Î£", 6],
    ["a6c1", "Î±", 16, "Ïƒ", 6],
    ["a6e0", "ï¸µï¸¶ï¸¹ï¸ºï¸¿ï¹€ï¸½ï¸¾ï¹ï¹‚ï¹ƒï¹„"],
    ["a6ee", "ï¸»ï¸¼ï¸·ï¸¸ï¸±"],
    ["a6f4", "ï¸³ï¸´"],
    ["a7a1", "Ğ", 5, "ĞĞ–", 25],
    ["a7d1", "Ğ°", 5, "Ñ‘Ğ¶", 25],
    ["a840", "ËŠË‹Ë™â€“â€•â€¥â€µâ„…â„‰â†–â†—â†˜â†™âˆ•âˆŸâˆ£â‰’â‰¦â‰§âŠ¿â•", 35, "â–", 6],
    ["a880", "â–ˆ", 7, "â–“â–”â–•â–¼â–½â—¢â—£â—¤â—¥â˜‰âŠ•ã€’ã€ã€"],
    ["a8a1", "ÄÃ¡ÇÃ Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜ÇšÇœÃ¼ÃªÉ‘"],
    ["a8bd", "Å„Åˆ"],
    ["a8c0", "É¡"],
    ["a8c5", "ã„…", 36],
    ["a940", "ã€¡", 8, "ãŠ£ãããœããã¡ã„ãã‘ã’ã•ï¸°ï¿¢ï¿¤"],
    ["a959", "â„¡ãˆ±"],
    ["a95c", "â€"],
    ["a960", "ãƒ¼ã‚›ã‚œãƒ½ãƒ¾ã€†ã‚ã‚ï¹‰", 9, "ï¹”ï¹•ï¹–ï¹—ï¹™", 8],
    ["a980", "ï¹¢", 4, "ï¹¨ï¹©ï¹ªï¹«"],
    ["a996", "ã€‡"],
    ["a9a4", "â”€", 75],
    ["aa40", "ç‹œç‹ç‹Ÿç‹¢", 5, "ç‹ªç‹«ç‹µç‹¶ç‹¹ç‹½ç‹¾ç‹¿çŒ€çŒ‚çŒ„", 5, "çŒ‹çŒŒçŒçŒçŒçŒ‘çŒ’çŒ”çŒ˜çŒ™çŒšçŒŸçŒ çŒ£çŒ¤çŒ¦çŒ§çŒ¨çŒ­çŒ¯çŒ°çŒ²çŒ³çŒµçŒ¶çŒºçŒ»çŒ¼çŒ½ç€", 8],
    ["aa80", "ç‰çŠç‹çŒççç‘ç“ç”ç•ç–ç˜", 7, "ç¡", 10, "ç®ç°ç±"],
    ["ab40", "ç²", 11, "ç¿", 4, "ç…ç†çˆçŠçŒçççç’ç“ç”ç•ç—ç˜ç™çšçœççç ç¡ç£", 5, "çªç¬ç­ç±ç´çµç¶ç¸ç¹ç¼ç½ç¾ç¿ççƒ", 4],
    ["ab80", "ç‹çŒçç’", 6, "çšç›çœççŸç¡ç¢ç£ç¤ç¦ç¨çªç«ç¬ç®ç¯ç°ç±ç³", 4],
    ["ac40", "ç¸", 10, "ç„ç‡çˆç‹çŒççç‘", 8, "çœ", 5, "ç£ç¤ç§ç©ç«ç­ç¯ç±ç²ç·", 4, "ç½ç¾ç¿ç‘€ç‘‚", 11],
    ["ac80", "ç‘", 6, "ç‘–ç‘˜ç‘ç‘ ", 12, "ç‘®ç‘¯ç‘±", 4, "ç‘¸ç‘¹ç‘º"],
    ["ad40", "ç‘»ç‘¼ç‘½ç‘¿ç’‚ç’„ç’…ç’†ç’ˆç’‰ç’Šç’Œç’ç’ç’‘", 10, "ç’ç’Ÿ", 7, "ç’ª", 15, "ç’»", 12],
    ["ad80", "ç“ˆ", 9, "ç““", 8, "ç“ç“Ÿç“¡ç“¥ç“§", 6, "ç“°ç“±ç“²"],
    ["ae40", "ç“³ç“µç“¸", 6, "ç”€ç”ç”‚ç”ƒç”…", 7, "ç”ç”ç”’ç””ç”•ç”–ç”—ç”›ç”ç”ç” ", 4, "ç”¦ç”§ç”ªç”®ç”´ç”¶ç”¹ç”¼ç”½ç”¿ç•ç•‚ç•ƒç•„ç•†ç•‡ç•‰ç•Šç•ç•ç•‘ç•’ç•“ç••ç•–ç•—ç•˜"],
    ["ae80", "ç•", 7, "ç•§ç•¨ç•©ç•«", 6, "ç•³ç•µç•¶ç•·ç•º", 4, "ç–€ç–ç–‚ç–„ç–…ç–‡"],
    ["af40", "ç–ˆç–‰ç–Šç–Œç–ç–ç–ç–“ç–•ç–˜ç–›ç–œç–ç–¢ç–¦", 4, "ç–­ç–¶ç–·ç–ºç–»ç–¿ç—€ç—ç—†ç—‹ç—Œç—ç—ç—ç—‘ç—“ç——ç—™ç—šç—œç—ç—Ÿç— ç—¡ç—¥ç—©ç—¬ç—­ç—®ç—¯ç—²ç—³ç—µç—¶ç—·ç—¸ç—ºç—»ç—½ç—¾ç˜‚ç˜„ç˜†ç˜‡"],
    ["af80", "ç˜ˆç˜‰ç˜‹ç˜ç˜ç˜ç˜‘ç˜’ç˜“ç˜”ç˜–ç˜šç˜œç˜ç˜ç˜¡ç˜£ç˜§ç˜¨ç˜¬ç˜®ç˜¯ç˜±ç˜²ç˜¶ç˜·ç˜¹ç˜ºç˜»ç˜½ç™ç™‚ç™„"],
    ["b040", "ç™…", 6, "ç™", 5, "ç™•ç™—", 4, "ç™ç™Ÿç™ ç™¡ç™¢ç™¤", 6, "ç™¬ç™­ç™®ç™°", 7, "ç™¹ç™ºç™¼ç™¿çš€çšçšƒçš…çš‰çšŠçšŒçšçšçšçš’çš”çš•çš—çš˜çššçš›"],
    ["b080", "çšœ", 7, "çš¥", 8, "çš¯çš°çš³çšµ", 9, "ç›€ç›ç›ƒå•Šé˜¿åŸƒæŒ¨å“å”‰å“€çš‘ç™Œè”¼çŸ®è‰¾ç¢çˆ±éš˜éæ°¨å®‰ä¿ºæŒ‰æš—å²¸èƒºæ¡ˆè‚®æ˜‚ç›å‡¹æ•–ç†¬ç¿±è¢„å‚²å¥¥æ‡Šæ¾³èŠ­æŒæ‰’å­å§ç¬†å…«ç–¤å·´æ‹”è·‹é¶æŠŠè€™åéœ¸ç½¢çˆ¸ç™½æŸç™¾æ‘†ä½°è´¥æ‹œç¨—æ–‘ç­æ¬æ‰³èˆ¬é¢æ¿ç‰ˆæ‰®æ‹Œä¼´ç“£åŠåŠç»Šé‚¦å¸®æ¢†æ¦œè†€ç»‘æ£’ç£…èšŒé•‘å‚è°¤è‹èƒåŒ…è¤’å‰¥"],
    ["b140", "ç›„ç›‡ç›‰ç›‹ç›Œç›“ç›•ç›™ç›šç›œç›ç›ç› ", 4, "ç›¦", 7, "ç›°ç›³ç›µç›¶ç›·ç›ºç›»ç›½ç›¿çœ€çœ‚çœƒçœ…çœ†çœŠçœŒçœ", 10, "çœ›çœœçœçœçœ¡çœ£çœ¤çœ¥çœ§çœªçœ«"],
    ["b180", "çœ¬çœ®çœ°", 4, "çœ¹çœ»çœ½çœ¾çœ¿ç‚ç„ç…ç†çˆ", 7, "ç’", 7, "çœè–„é›¹ä¿å ¡é¥±å®æŠ±æŠ¥æš´è±¹é²çˆ†æ¯ç¢‘æ‚²å‘åŒ—è¾ˆèƒŒè´é’¡å€ç‹ˆå¤‡æƒ«ç„™è¢«å¥”è‹¯æœ¬ç¬¨å´©ç»·ç”­æ³µè¹¦è¿¸é€¼é¼»æ¯”é„™ç¬”å½¼ç¢§è“–è”½æ¯•æ¯™æ¯–å¸åº‡ç—¹é—­æ•å¼Šå¿…è¾Ÿå£è‡‚é¿é™›é­è¾¹ç¼–è´¬æ‰ä¾¿å˜åè¾¨è¾©è¾«éæ ‡å½ªè†˜è¡¨é³–æ†‹åˆ«ç˜ªå½¬æ–Œæ¿’æ»¨å®¾æ‘ˆå…µå†°æŸ„ä¸™ç§‰é¥¼ç‚³"],
    ["b240", "çççŸç ç¤ç§ç©çªç­", 11, "çºç»ç¼çç‚çƒç†", 5, "ççç“", 11, "ç¡ç£ç¤ç¦ç¨ç«ç­ç®ç¯ç±ç²ç´ç¶", 4],
    ["b280", "ç¼ç¾çŸ€", 12, "çŸ", 8, "çŸ˜çŸ™çŸšçŸ", 4, "çŸ¤ç—…å¹¶ç»è æ’­æ‹¨é’µæ³¢åšå‹ƒæé“‚ç®”ä¼¯å¸›èˆ¶è„–è†Šæ¸¤æ³Šé©³æ•åœå“ºè¡¥åŸ ä¸å¸ƒæ­¥ç°¿éƒ¨æ€–æ“¦çŒœè£ææ‰è´¢ç¬è¸©é‡‡å½©èœè”¡é¤å‚èš•æ®‹æƒ­æƒ¨ç¿è‹èˆ±ä»“æ²§è—æ“ç³™æ§½æ›¹è‰å•ç­–ä¾§å†Œæµ‹å±‚è¹­æ’å‰èŒ¬èŒ¶æŸ¥ç¢´æ½å¯Ÿå²”å·®è¯§æ‹†æŸ´è±ºæ€æºè‰é¦‹è°—ç¼ é“²äº§é˜é¢¤æ˜ŒçŒ–"],
    ["b340", "çŸ¦çŸ¨çŸªçŸ¯çŸ°çŸ±çŸ²çŸ´çŸµçŸ·çŸ¹çŸºçŸ»çŸ¼ç ƒ", 5, "ç Šç ‹ç ç ç ç “ç •ç ™ç ›ç ç  ç ¡ç ¢ç ¤ç ¨ç ªç «ç ®ç ¯ç ±ç ²ç ³ç µç ¶ç ½ç ¿ç¡ç¡‚ç¡ƒç¡„ç¡†ç¡ˆç¡‰ç¡Šç¡‹ç¡ç¡ç¡‘ç¡“ç¡”ç¡˜ç¡™ç¡š"],
    ["b380", "ç¡›ç¡œç¡", 11, "ç¡¯", 7, "ç¡¸ç¡¹ç¡ºç¡»ç¡½", 6, "åœºå°å¸¸é•¿å¿è‚ å‚æ•ç•…å”±å€¡è¶…æŠ„é’æœå˜²æ½®å·¢åµç‚’è½¦æ‰¯æ’¤æ£å½»æ¾ˆéƒ´è‡£è¾°å°˜æ™¨å¿±æ²‰é™ˆè¶è¡¬æ’‘ç§°åŸæ©™æˆå‘ˆä¹˜ç¨‹æƒ©æ¾„è¯šæ‰¿é€éª‹ç§¤åƒç—´æŒåŒ™æ± è¿Ÿå¼›é©°è€»é½¿ä¾ˆå°ºèµ¤ç¿…æ–¥ç‚½å……å†²è™«å´‡å® æŠ½é…¬ç•´è¸Œç¨ æ„ç­¹ä»‡ç»¸ç…ä¸‘è‡­åˆå‡ºæ©±å¨èº‡é”„é›æ»é™¤æ¥š"],
    ["b440", "ç¢„ç¢…ç¢†ç¢ˆç¢Šç¢‹ç¢ç¢ç¢’ç¢”ç¢•ç¢–ç¢™ç¢ç¢ç¢ ç¢¢ç¢¤ç¢¦ç¢¨", 7, "ç¢µç¢¶ç¢·ç¢¸ç¢ºç¢»ç¢¼ç¢½ç¢¿ç£€ç£‚ç£ƒç£„ç£†ç£‡ç£ˆç£Œç£ç£ç£ç£‘ç£’ç£“ç£–ç£—ç£˜ç£š", 9],
    ["b480", "ç£¤ç£¥ç£¦ç£§ç£©ç£ªç£«ç£­", 4, "ç£³ç£µç£¶ç£¸ç£¹ç£»", 5, "ç¤‚ç¤ƒç¤„ç¤†", 6, "ç¡€å‚¨çŸ—æè§¦å¤„æ£å·ç©¿æ¤½ä¼ èˆ¹å–˜ä¸²ç–®çª—å¹¢åºŠé—¯åˆ›å¹ç‚Šæ¶é”¤å‚æ˜¥æ¤¿é†‡å”‡æ·³çº¯è ¢æˆ³ç»°ç–µèŒ¨ç£é›Œè¾æ…ˆç“·è¯æ­¤åˆºèµæ¬¡èªè‘±å›±åŒ†ä»ä¸›å‡‘ç²—é†‹ç°‡ä¿ƒè¹¿ç¯¡çªœæ‘§å´”å‚¬è„†ç˜ç²¹æ·¬ç¿ æ‘å­˜å¯¸ç£‹æ’®æ“æªæŒ«é”™æ­è¾¾ç­”ç˜©æ‰“å¤§å‘†æ­¹å‚£æˆ´å¸¦æ®†ä»£è´·è¢‹å¾…é€®"],
    ["b540", "ç¤", 5, "ç¤”", 9, "ç¤Ÿ", 4, "ç¤¥", 14, "ç¤µ", 4, "ç¤½ç¤¿ç¥‚ç¥ƒç¥„ç¥…ç¥‡ç¥Š", 8, "ç¥”ç¥•ç¥˜ç¥™ç¥¡ç¥£"],
    ["b580", "ç¥¤ç¥¦ç¥©ç¥ªç¥«ç¥¬ç¥®ç¥°", 6, "ç¥¹ç¥»", 4, "ç¦‚ç¦ƒç¦†ç¦‡ç¦ˆç¦‰ç¦‹ç¦Œç¦ç¦ç¦ç¦‘ç¦’æ€ è€½æ‹…ä¸¹å•éƒ¸æ¸èƒ†æ—¦æ°®ä½†æƒ®æ·¡è¯å¼¹è›‹å½“æŒ¡å…šè¡æ¡£åˆ€æ£è¹ˆå€’å²›ç¥·å¯¼åˆ°ç¨»æ‚¼é“ç›—å¾·å¾—çš„è¹¬ç¯ç™»ç­‰çªå‡³é‚“å ¤ä½æ»´è¿ªæ•Œç¬›ç‹„æ¶¤ç¿Ÿå«¡æŠµåº•åœ°è’‚ç¬¬å¸å¼Ÿé€’ç¼”é¢ æ‚æ»‡ç¢˜ç‚¹å…¸é›å«ç”µä½ƒç”¸åº—æƒ¦å¥ æ·€æ®¿ç¢‰å¼é›•å‡‹åˆæ‰åŠé’“è°ƒè·Œçˆ¹ç¢Ÿè¶è¿­è°å "],
    ["b640", "ç¦“", 6, "ç¦›", 11, "ç¦¨", 10, "ç¦´", 4, "ç¦¼ç¦¿ç§‚ç§„ç§…ç§‡ç§ˆç§Šç§Œç§ç§ç§ç§“ç§”ç§–ç§—ç§™", 5, "ç§ ç§¡ç§¢ç§¥ç§¨ç§ª"],
    ["b680", "ç§¬ç§®ç§±", 6, "ç§¹ç§ºç§¼ç§¾ç§¿ç¨ç¨„ç¨…ç¨‡ç¨ˆç¨‰ç¨Šç¨Œç¨", 4, "ç¨•ç¨–ç¨˜ç¨™ç¨›ç¨œä¸ç›¯å®é’‰é¡¶é¼é”­å®šè®¢ä¸¢ä¸œå†¬è‘£æ‡‚åŠ¨æ ‹ä¾—æ«å†»æ´å…œæŠ–æ–—é™¡è±†é€—ç—˜éƒ½ç£æ¯’çŠŠç‹¬è¯»å µç¹èµŒæœé•€è‚šåº¦æ¸¡å¦’ç«¯çŸ­é”»æ®µæ–­ç¼å †å…‘é˜Ÿå¯¹å¢©å¨è¹²æ•¦é¡¿å›¤é’ç›¾éæ‡å“†å¤šå¤ºå›èº²æœµè·ºèˆµå‰æƒ°å •è›¾å³¨é¹…ä¿„é¢è®¹å¨¥æ¶å„æ‰¼éé„‚é¥¿æ©è€Œå„¿è€³å°”é¥µæ´±äºŒ"],
    ["b740", "ç¨ç¨Ÿç¨¡ç¨¢ç¨¤", 14, "ç¨´ç¨µç¨¶ç¨¸ç¨ºç¨¾ç©€", 5, "ç©‡", 9, "ç©’", 4, "ç©˜", 16],
    ["b780", "ç©©", 6, "ç©±ç©²ç©³ç©µç©»ç©¼ç©½ç©¾çª‚çª…çª‡çª‰çªŠçª‹çªŒçªçªçªçª“çª”çª™çªšçª›çªçª¡çª¢è´°å‘ç½šç­ä¼ä¹é˜€æ³•çè—©å¸†ç•ªç¿»æ¨ŠçŸ¾é’’ç¹å‡¡çƒ¦åè¿”èŒƒè´©çŠ¯é¥­æ³›åŠèŠ³æ–¹è‚ªæˆ¿é˜²å¦¨ä»¿è®¿çººæ”¾è²éå•¡é£è‚¥åŒªè¯½å è‚ºåºŸæ²¸è´¹èŠ¬é…šå©æ°›åˆ†çº·åŸç„šæ±¾ç²‰å¥‹ä»½å¿¿æ„¤ç²ªä¸°å°æ«èœ‚å³°é”‹é£ç–¯çƒ½é€¢å†¯ç¼è®½å¥‰å‡¤ä½›å¦å¤«æ•·è‚¤å­µæ‰¶æ‹‚è¾å¹…æ°Ÿç¬¦ä¼ä¿˜æœ"],
    ["b840", "çª£çª¤çª§çª©çªªçª«çª®", 4, "çª´", 10, "ç«€", 10, "ç«Œ", 9, "ç«—ç«˜ç«šç«›ç«œç«ç«¡ç«¢ç«¤ç«§", 5, "ç«®ç«°ç«±ç«²ç«³"],
    ["b880", "ç«´", 4, "ç«»ç«¼ç«¾ç¬€ç¬ç¬‚ç¬…ç¬‡ç¬‰ç¬Œç¬ç¬ç¬ç¬’ç¬“ç¬–ç¬—ç¬˜ç¬šç¬œç¬ç¬Ÿç¬¡ç¬¢ç¬£ç¬§ç¬©ç¬­æµ®æ¶ªç¦è¢±å¼—ç”«æŠšè¾…ä¿¯é‡œæ–§è„¯è…‘åºœè…èµ´å‰¯è¦†èµ‹å¤å‚…ä»˜é˜œçˆ¶è…¹è´Ÿå¯Œè®£é™„å¦‡ç¼šå’å™¶å˜è¯¥æ”¹æ¦‚é’™ç›–æº‰å¹²ç”˜æ†æŸ‘ç«¿è‚èµ¶æ„Ÿç§†æ•¢èµ£å†ˆåˆšé’¢ç¼¸è‚›çº²å²—æ¸¯æ ç¯™çš‹é«˜è†ç¾”ç³•æé•ç¨¿å‘Šå“¥æ­Œææˆˆé¸½èƒ³ç–™å‰²é©è‘›æ ¼è›¤é˜éš”é“¬ä¸ªå„ç»™æ ¹è·Ÿè€•æ›´åºšç¾¹"],
    ["b940", "ç¬¯ç¬°ç¬²ç¬´ç¬µç¬¶ç¬·ç¬¹ç¬»ç¬½ç¬¿", 5, "ç­†ç­ˆç­Šç­ç­ç­“ç­•ç­—ç­™ç­œç­ç­Ÿç­¡ç­£", 10, "ç­¯ç­°ç­³ç­´ç­¶ç­¸ç­ºç­¼ç­½ç­¿ç®ç®‚ç®ƒç®„ç®†", 6, "ç®ç®"],
    ["b980", "ç®‘ç®’ç®“ç®–ç®˜ç®™ç®šç®›ç®ç®Ÿç® ç®£ç®¤ç®¥ç®®ç®¯ç®°ç®²ç®³ç®µç®¶ç®·ç®¹", 7, "ç¯‚ç¯ƒç¯„åŸ‚è€¿æ¢—å·¥æ”»åŠŸæ­é¾šä¾›èº¬å…¬å®«å¼“å·©æ±æ‹±è´¡å…±é’©å‹¾æ²Ÿè‹Ÿç‹—å¢æ„è´­å¤Ÿè¾œè‡å’•ç®ä¼°æ²½å­¤å§‘é¼“å¤è›Šéª¨è°·è‚¡æ•…é¡¾å›ºé›‡åˆ®ç“œå‰å¯¡æŒ‚è¤‚ä¹–æ‹æ€ªæ£ºå…³å®˜å† è§‚ç®¡é¦†ç½æƒ¯çŒè´¯å…‰å¹¿é€›ç‘°è§„åœ­ç¡…å½’é¾Ÿé—ºè½¨é¬¼è¯¡ç™¸æ¡‚æŸœè·ªè´µåˆ½è¾Šæ»šæ£é”…éƒ­å›½æœè£¹è¿‡å“ˆ"],
    ["ba40", "ç¯…ç¯ˆç¯‰ç¯Šç¯‹ç¯ç¯ç¯ç¯ç¯’ç¯”", 4, "ç¯›ç¯œç¯ç¯Ÿç¯ ç¯¢ç¯£ç¯¤ç¯§ç¯¨ç¯©ç¯«ç¯¬ç¯­ç¯¯ç¯°ç¯²", 4, "ç¯¸ç¯¹ç¯ºç¯»ç¯½ç¯¿", 7, "ç°ˆç°‰ç°Šç°ç°ç°", 5, "ç°—ç°˜ç°™"],
    ["ba80", "ç°š", 4, "ç° ", 5, "ç°¨ç°©ç°«", 12, "ç°¹", 5, "ç±‚éª¸å­©æµ·æ°¦äº¥å®³éª‡é…£æ†¨é‚¯éŸ©å«æ¶µå¯’å‡½å–Šç½•ç¿°æ’¼ææ—±æ†¾æ‚ç„Šæ±—æ±‰å¤¯æ­èˆªå£•åšè±ªæ¯«éƒå¥½è€—å·æµ©å‘µå–è·èæ ¸ç¦¾å’Œä½•åˆç›’è²‰é˜‚æ²³æ¶¸èµ«è¤é¹¤è´ºå˜¿é»‘ç—•å¾ˆç‹ æ¨å“¼äº¨æ¨ªè¡¡æ’è½°å“„çƒ˜è™¹é¸¿æ´ªå®å¼˜çº¢å–‰ä¾¯çŒ´å¼åšå€™åå‘¼ä¹å¿½ç‘šå£¶è‘«èƒ¡è´ç‹ç³Šæ¹–"],
    ["bb40", "ç±ƒ", 9, "ç±", 36, "ç±µ", 5, "ç±¾", 9],
    ["bb80", "ç²ˆç²Š", 6, "ç²“ç²”ç²–ç²™ç²šç²›ç² ç²¡ç²£ç²¦ç²§ç²¨ç²©ç²«ç²¬ç²­ç²¯ç²°ç²´", 4, "ç²ºç²»å¼§è™å”¬æŠ¤äº’æ²ªæˆ·èŠ±å“—åçŒ¾æ»‘ç”»åˆ’åŒ–è¯æ§å¾Šæ€€æ·®åæ¬¢ç¯æ¡“è¿˜ç¼“æ¢æ‚£å”¤ç—ªè±¢ç„•æ¶£å®¦å¹»è’æ…Œé»„ç£ºè—ç°§çš‡å‡°æƒ¶ç…Œæ™ƒå¹Œæè°ç°æŒ¥è¾‰å¾½æ¢è›”å›æ¯æ‚”æ…§å‰æƒ æ™¦è´¿ç§½ä¼šçƒ©æ±‡è®³è¯²ç»˜è¤æ˜å©šé­‚æµ‘æ··è±æ´»ä¼™ç«è·æˆ–æƒ‘éœè´§ç¥¸å‡»åœ¾åŸºæœºç•¸ç¨½ç§¯ç®•"],
    ["bc40", "ç²¿ç³€ç³‚ç³ƒç³„ç³†ç³‰ç³‹ç³", 6, "ç³˜ç³šç³›ç³ç³ç³¡", 6, "ç³©", 5, "ç³°", 7, "ç³¹ç³ºç³¼", 13, "ç´‹", 5],
    ["bc80", "ç´‘", 14, "ç´¡ç´£ç´¤ç´¥ç´¦ç´¨ç´©ç´ªç´¬ç´­ç´®ç´°", 6, "è‚Œé¥¥è¿¹æ¿€è®¥é¸¡å§¬ç»©ç¼‰å‰ææ£˜è¾‘ç±é›†åŠæ€¥ç–¾æ±²å³å«‰çº§æŒ¤å‡ è„Šå·±è“ŸæŠ€å†€å­£ä¼ç¥­å‰‚æ‚¸æµå¯„å¯‚è®¡è®°æ—¢å¿Œé™…å¦“ç»§çºªå˜‰æ·å¤¹ä½³å®¶åŠ èšé¢Šè´¾ç”²é’¾å‡ç¨¼ä»·æ¶é©¾å«æ­¼ç›‘åšå°–ç¬ºé—´ç…å…¼è‚©è‰°å¥¸ç¼„èŒ§æ£€æŸ¬ç¢±ç¡·æ‹£æ¡ç®€ä¿­å‰ªå‡èæ§›é‰´è·µè´±è§é”®ç®­ä»¶"],
    ["bd40", "ç´·", 54, "çµ¯", 7],
    ["bd80", "çµ¸", 32, "å¥èˆ°å‰‘é¥¯æ¸æº…æ¶§å»ºåƒµå§œå°†æµ†æ±Ÿç–†è’‹æ¡¨å¥–è®²åŒ é…±é™è•‰æ¤’ç¤ç„¦èƒ¶äº¤éƒŠæµ‡éª„å¨‡åš¼æ…é“°çŸ«ä¾¥è„šç‹¡è§’é¥ºç¼´ç»å‰¿æ•™é…µè½¿è¾ƒå«çª–æ­æ¥çš†ç§¸è¡—é˜¶æˆªåŠ«èŠ‚æ¡”æ°æ·ç«ç«­æ´ç»“è§£å§æˆ’è—‰èŠ¥ç•Œå€Ÿä»‹ç–¥è¯«å±Šå·¾ç­‹æ–¤é‡‘ä»Šæ´¥è¥Ÿç´§é”¦ä»…è°¨è¿›é³æ™‹ç¦è¿‘çƒ¬æµ¸"],
    ["be40", "ç¶™", 12, "ç¶§", 6, "ç¶¯", 42],
    ["be80", "ç·š", 32, "å°½åŠ²è†å…¢èŒç›æ™¶é²¸äº¬æƒŠç²¾ç²³ç»äº•è­¦æ™¯é¢ˆé™å¢ƒæ•¬é•œå¾„ç—‰é–ç«Ÿç«å‡€ç‚¯çª˜æªç©¶çº ç–éŸ­ä¹…ç¸ä¹é…’å©æ•‘æ—§è‡¼èˆ…å’å°±ç–šé æ‹˜ç‹™ç–½å±…é©¹èŠå±€å’€çŸ©ä¸¾æ²®èšæ‹’æ®å·¨å…·è·è¸é”¯ä¿±å¥æƒ§ç‚¬å‰§æé¹ƒå¨Ÿå€¦çœ·å·ç»¢æ’…æ”«æŠ‰æ˜å€”çˆµè§‰å†³è¯€ç»å‡èŒé’§å†›å›å³»"],
    ["bf40", "ç·»", 62],
    ["bf80", "ç¸ºç¸¼", 4, "ç¹‚", 4, "ç¹ˆ", 21, "ä¿Šç«£æµšéƒ¡éªå–€å’–å¡å’¯å¼€æ©æ¥·å‡¯æ…¨åˆŠå ªå‹˜åç çœ‹åº·æ…·ç³ æ‰›æŠ—äº¢ç‚•è€ƒæ‹·çƒ¤é å·è‹›æŸ¯æ£µç£•é¢—ç§‘å£³å’³å¯æ¸´å…‹åˆ»å®¢è¯¾è‚¯å•ƒå¦æ³å‘å­ç©ºæå­”æ§æŠ å£æ‰£å¯‡æ¯å“­çªŸè‹¦é…·åº“è£¤å¤¸å®æŒè·¨èƒ¯å—ç­·ä¾©å¿«å®½æ¬¾åŒ¡ç­ç‹‚æ¡†çŸ¿çœ¶æ—·å†µäºç›”å²¿çª¥è‘µå¥é­å‚€"],
    ["c040", "ç¹", 35, "çºƒ", 23, "çºœçºçº"],
    ["c080", "çº®çº´çº»çº¼ç»–ç»¤ç»¬ç»¹ç¼Šç¼ç¼ç¼·ç¼¹ç¼»", 6, "ç½ƒç½†", 9, "ç½’ç½“é¦ˆæ„§æºƒå¤æ˜†æ†å›°æ‹¬æ‰©å»“é˜”åƒæ‹‰å–‡èœ¡è…Šè¾£å•¦è±æ¥èµ–è“å©ªæ æ‹¦ç¯®é˜‘å…°æ¾œè°°æ½è§ˆæ‡’ç¼†çƒ‚æ»¥ç…æ¦”ç‹¼å»Šéƒæœ—æµªæåŠ³ç‰¢è€ä½¬å§¥é…ªçƒ™æ¶å‹’ä¹é›·é•­è•¾ç£Šç´¯å„¡å’æ“‚è‚‹ç±»æ³ªæ£±æ¥å†·å˜æ¢¨çŠé»ç¯±ç‹¸ç¦»æ¼“ç†æé‡Œé²¤ç¤¼è‰è”åæ —ä¸½å‰åŠ±ç ¾å†åˆ©å‚ˆä¾‹ä¿"],
    ["c140", "ç½–ç½™ç½›ç½œç½ç½ç½ ç½£", 4, "ç½«ç½¬ç½­ç½¯ç½°ç½³ç½µç½¶ç½·ç½¸ç½ºç½»ç½¼ç½½ç½¿ç¾€ç¾‚", 7, "ç¾‹ç¾ç¾", 4, "ç¾•", 4, "ç¾›ç¾œç¾ ç¾¢ç¾£ç¾¥ç¾¦ç¾¨", 6, "ç¾±"],
    ["c180", "ç¾³", 4, "ç¾ºç¾»ç¾¾ç¿€ç¿‚ç¿ƒç¿„ç¿†ç¿‡ç¿ˆç¿‰ç¿‹ç¿ç¿", 4, "ç¿–ç¿—ç¿™", 5, "ç¿¢ç¿£ç—¢ç«‹ç²’æ²¥éš¶åŠ›ç’ƒå“©ä¿©è”è²è¿é•°å»‰æ€œæ¶Ÿå¸˜æ•›è„¸é“¾æ‹ç‚¼ç»ƒç²®å‡‰æ¢ç²±è‰¯ä¸¤è¾†é‡æ™¾äº®è°…æ’©èŠåƒšç–—ç‡å¯¥è¾½æ½¦äº†æ’‚é•£å»–æ–™åˆ—è£‚çƒˆåŠ£çŒç³æ—ç£·éœ–ä¸´é‚»é³æ·‹å‡›èµåæ‹ç²è±é›¶é¾„é“ƒä¼¶ç¾šå‡Œçµé™µå²­é¢†å¦ä»¤æºœç‰æ¦´ç¡«é¦ç•™åˆ˜ç˜¤æµæŸ³å…­é¾™è‹å’™ç¬¼çª¿"],
    ["c240", "ç¿¤ç¿§ç¿¨ç¿ªç¿«ç¿¬ç¿­ç¿¯ç¿²ç¿´", 6, "ç¿½ç¿¾ç¿¿è€‚è€‡è€ˆè€‰è€Šè€è€è€‘è€“è€šè€›è€è€è€Ÿè€¡è€£è€¤è€«", 5, "è€²è€´è€¹è€ºè€¼è€¾è€èè„è…è‡èˆè‰èèèè‘è“è•è–è—"],
    ["c280", "è™è›", 13, "è«", 5, "è²", 11, "éš†å„æ‹¢é™‡æ¥¼å¨„æ‚ç¯“æ¼é™‹èŠ¦å¢é¢…åºç‚‰æ³å¤è™é²éº“ç¢Œéœ²è·¯èµ‚é¹¿æ½ç¦„å½•é™†æˆ®é©´å•é“ä¾£æ—…å±¥å±¡ç¼•è™‘æ°¯å¾‹ç‡æ»¤ç»¿å³¦æŒ›å­ªæ»¦åµä¹±æ ç•¥æŠ¡è½®ä¼¦ä»‘æ²¦çº¶è®ºèèºç½—é€»é”£ç®©éª¡è£¸è½æ´›éª†ç»œå¦ˆéº»ç›ç èš‚é©¬éª‚å˜›å—åŸ‹ä¹°éº¦å–è¿ˆè„‰ç’é¦’è›®æ»¡è”“æ›¼æ…¢æ¼«"],
    ["c340", "è¾è‚è‚‚è‚…è‚ˆè‚Šè‚", 5, "è‚”è‚•è‚—è‚™è‚è‚£è‚¦è‚§è‚¨è‚¬è‚°è‚³è‚µè‚¶è‚¸è‚¹è‚»èƒ…èƒ‡", 4, "èƒ", 6, "èƒ˜èƒŸèƒ èƒ¢èƒ£èƒ¦èƒ®èƒµèƒ·èƒ¹èƒ»èƒ¾èƒ¿è„€è„è„ƒè„„è„…è„‡è„ˆè„‹"],
    ["c380", "è„Œè„•è„—è„™è„›è„œè„è„Ÿ", 12, "è„­è„®è„°è„³è„´è„µè„·è„¹", 4, "è„¿è°©èŠ’èŒ«ç›²æ°“å¿™è½çŒ«èŒ…é”šæ¯›çŸ›é“†å¯èŒ‚å†’å¸½è²Œè´¸ä¹ˆç«æšæ¢…é…¶éœ‰ç…¤æ²¡çœ‰åª’é•æ¯ç¾æ˜§å¯å¦¹åªšé—¨é—·ä»¬èŒè’™æª¬ç›Ÿé”°çŒ›æ¢¦å­Ÿçœ¯é†šé¡ç³œè¿·è°œå¼¥ç±³ç§˜è§…æ³Œèœœå¯†å¹‚æ£‰çœ ç»µå†•å…å‹‰å¨©ç¼…é¢è‹—æç„è—ç§’æ¸ºåº™å¦™è”‘ç­æ°‘æŠ¿çš¿æ•æ‚¯é—½æ˜èŸé¸£é“­åå‘½è°¬æ‘¸"],
    ["c440", "è…€", 5, "è…‡è…‰è…è…è…è…’è…–è…—è…˜è…›", 4, "è…¡è…¢è…£è…¤è…¦è…¨è…ªè…«è…¬è…¯è…²è…³è…µè…¶è…·è…¸è†è†ƒ", 4, "è†‰è†‹è†Œè†è†è†è†’", 5, "è†™è†šè†", 4, "è†¤è†¥"],
    ["c480", "è†§è†©è†«", 7, "è†´", 5, "è†¼è†½è†¾è†¿è‡„è‡…è‡‡è‡ˆè‡‰è‡‹è‡", 6, "æ‘¹è˜‘æ¨¡è†œç£¨æ‘©é­”æŠ¹æœ«è«å¢¨é»˜æ²«æ¼ å¯é™Œè°‹ç‰ŸæŸæ‹‡ç‰¡äº©å§†æ¯å¢“æš®å¹•å‹Ÿæ…•æœ¨ç›®ç¦ç‰§ç©†æ‹¿å“ªå‘é’ é‚£å¨œçº³æ°–ä¹ƒå¥¶è€å¥ˆå—ç”·éš¾å›ŠæŒ è„‘æ¼é—¹æ·–å‘¢é¦å†…å«©èƒ½å¦®éœ“å€ªæ³¥å°¼æ‹Ÿä½ åŒ¿è…»é€†æººè”«æ‹ˆå¹´ç¢¾æ’µæ»å¿µå¨˜é…¿é¸Ÿå°¿æè‚å­½å•®é•Šé•æ¶…æ‚¨æŸ ç‹å‡å®"],
    ["c540", "è‡”", 14, "è‡¤è‡¥è‡¦è‡¨è‡©è‡«è‡®", 4, "è‡µ", 5, "è‡½è‡¿èˆƒèˆ‡", 4, "èˆèˆèˆ‘èˆ“èˆ•", 5, "èˆèˆ èˆ¤èˆ¥èˆ¦èˆ§èˆ©èˆ®èˆ²èˆºèˆ¼èˆ½èˆ¿"],
    ["c580", "è‰€è‰è‰‚è‰ƒè‰…è‰†è‰ˆè‰Šè‰Œè‰è‰è‰", 7, "è‰™è‰›è‰œè‰è‰è‰ ", 7, "è‰©æ‹§æ³ç‰›æ‰­é’®çº½è„“æµ“å†œå¼„å¥´åŠªæ€’å¥³æš–è™ç–ŸæŒªæ‡¦ç³¯è¯ºå“¦æ¬§é¸¥æ®´è—•å‘•å¶æ²¤å•ªè¶´çˆ¬å¸•æ€•ç¶æ‹æ’ç‰Œå¾˜æ¹ƒæ´¾æ”€æ½˜ç›˜ç£ç›¼ç•”åˆ¤å›ä¹“åºæ—è€ªèƒ–æŠ›å’†åˆ¨ç‚®è¢è·‘æ³¡å‘¸èƒšåŸ¹è£´èµ”é™ªé…ä½©æ²›å–·ç›†ç °æŠ¨çƒ¹æ¾å½­è“¬æ£šç¡¼ç¯·è†¨æœ‹é¹æ§ç¢°å¯ç ’éœ¹æ‰¹æŠ«åŠˆçµæ¯—"],
    ["c640", "è‰ªè‰«è‰¬è‰­è‰±è‰µè‰¶è‰·è‰¸è‰»è‰¼èŠ€èŠèŠƒèŠ…èŠ†èŠ‡èŠ‰èŠŒèŠèŠ“èŠ”èŠ•èŠ–èŠšèŠ›èŠèŠ èŠ¢èŠ£èŠ§èŠ²èŠµèŠ¶èŠºèŠ»èŠ¼èŠ¿è‹€è‹‚è‹ƒè‹…è‹†è‹‰è‹è‹–è‹™è‹šè‹è‹¢è‹§è‹¨è‹©è‹ªè‹¬è‹­è‹®è‹°è‹²è‹³è‹µè‹¶è‹¸"],
    ["c680", "è‹ºè‹¼", 4, "èŒŠèŒ‹èŒèŒèŒ’èŒ“èŒ–èŒ˜èŒ™èŒ", 9, "èŒ©èŒªèŒ®èŒ°èŒ²èŒ·èŒ»èŒ½å•¤è„¾ç–²çš®åŒ¹ç—åƒ»å±è­¬ç¯‡åç‰‡éª—é£˜æ¼‚ç“¢ç¥¨æ’‡ç¥æ‹¼é¢‘è´«å“è˜ä¹’åªè‹¹èå¹³å‡­ç“¶è¯„å±å¡æ³¼é¢‡å©†ç ´é­„è¿«ç²•å‰–æ‰‘é“ºä»†è†è‘¡è©è’²åŸ”æœ´åœƒæ™®æµ¦è°±æ›ç€‘æœŸæ¬ºæ –æˆšå¦»ä¸ƒå‡„æ¼†æŸ’æ²å…¶æ£‹å¥‡æ­§ç•¦å´è„é½æ——ç¥ˆç¥éª‘èµ·å²‚ä¹ä¼å¯å¥‘ç Œå™¨æ°”è¿„å¼ƒæ±½æ³£è®«æ"],
    ["c740", "èŒ¾èŒ¿èè‚è„è…èˆèŠ", 4, "è“è•", 4, "èè¢è°", 6, "è¹èºè¾", 6, "è‡èˆèŠè‹èŒèèèè‘è”è•è–è—è™èšèèŸè¡", 6, "è¬è­è®"],
    ["c780", "è¯èµè»è¾è¿è‚èƒè„è†èˆè‰è‹èèèè‘è’è“è•è—è™èšè›èè¢è£è¤è¦è§è¨è«è¬è­æ°æ´½ç‰µæ‰¦é’é“…åƒè¿ç­¾ä»Ÿè°¦ä¹¾é»”é’±é’³å‰æ½œé£æµ…è°´å ‘åµŒæ¬ æ­‰æªå‘›è…”ç¾Œå¢™è”·å¼ºæŠ¢æ©‡é”¹æ•²æ‚„æ¡¥ç§ä¹”ä¾¨å·§é˜æ’¬ç¿˜å³­ä¿çªåˆ‡èŒ„ä¸”æ€¯çªƒé’¦ä¾µäº²ç§¦ç´å‹¤èŠ¹æ“’ç¦½å¯æ²é’è½»æ°¢å€¾å¿æ¸…æ“æ™´æ°°æƒ…é¡·è¯·åº†ç¼ç©·ç§‹ä¸˜é‚±çƒæ±‚å›šé…‹æ³…è¶‹åŒºè›†æ›²èº¯å±ˆé©±æ¸ "],
    ["c840", "è®è¯è³", 4, "èºè»è¼è¾è¿è€è‚è…è‡èˆè‰èŠèè’", 5, "è™èšè›è", 5, "è©", 7, "è²", 5, "è¹èºè»è¾", 7, "è‘‡è‘ˆè‘‰"],
    ["c880", "è‘Š", 6, "è‘’", 4, "è‘˜è‘è‘è‘Ÿè‘ è‘¢è‘¤", 4, "è‘ªè‘®è‘¯è‘°è‘²è‘´è‘·è‘¹è‘»è‘¼å–å¨¶é¾‹è¶£å»åœˆé¢§æƒé†›æ³‰å…¨ç—Šæ‹³çŠ¬åˆ¸åŠç¼ºç‚”ç˜¸å´é¹Šæ¦·ç¡®é›€è£™ç¾¤ç„¶ç‡ƒå†‰æŸ“ç“¤å£¤æ”˜åš·è®©é¥¶æ‰°ç»•æƒ¹çƒ­å£¬ä»äººå¿éŸ§ä»»è®¤åˆƒå¦Šçº«æ‰”ä»æ—¥æˆèŒ¸è“‰è£èç†”æº¶å®¹ç»’å†—æ‰æŸ”è‚‰èŒ¹è •å„’å­ºå¦‚è¾±ä¹³æ±å…¥è¤¥è½¯é˜®è•Šç‘é”é—°æ¶¦è‹¥å¼±æ’’æ´’è¨è…®é³ƒå¡èµ›ä¸‰å"],
    ["c940", "è‘½", 4, "è’ƒè’„è’…è’†è’Šè’è’", 7, "è’˜è’šè’›è’è’è’Ÿè’ è’¢", 12, "è’°è’±è’³è’µè’¶è’·è’»è’¼è’¾è“€è“‚è“ƒè“…è“†è“‡è“ˆè“‹è“Œè“è“è“’è“”è“•è“—"],
    ["c980", "è“˜", 4, "è“è“¡è“¢è“¤è“§", 4, "è“­è“®è“¯è“±", 10, "è“½è“¾è”€è”è”‚ä¼æ•£æ¡‘å—“ä¸§æ”éªšæ‰«å«‚ç‘Ÿè‰²æ¶©æ£®åƒ§èç ‚æ€åˆ¹æ²™çº±å‚»å•¥ç…ç­›æ™’çŠè‹«æ‰å±±åˆ ç…½è¡«é—ªé™•æ“…èµ¡è†³å–„æ±•æ‰‡ç¼®å¢’ä¼¤å•†èµæ™Œä¸Šå°šè£³æ¢¢æç¨çƒ§èŠå‹ºéŸ¶å°‘å“¨é‚µç»å¥¢èµŠè›‡èˆŒèˆèµ¦æ‘„å°„æ…‘æ¶‰ç¤¾è®¾ç ·ç”³å‘»ä¼¸èº«æ·±å¨ ç»…ç¥æ²ˆå®¡å©¶ç”šè‚¾æ…æ¸—å£°ç”Ÿç”¥ç‰²å‡ç»³"],
    ["ca40", "è”ƒ", 8, "è”è”è”è”è”’è””è”•è”–è”˜è”™è”›è”œè”è”è” è”¢", 8, "è”­", 9, "è”¾", 4, "è•„è•…è•†è•‡è•‹", 10],
    ["ca80", "è•—è•˜è•šè•›è•œè•è•Ÿ", 4, "è•¥è•¦è•§è•©", 8, "è•³è•µè•¶è•·è•¸è•¼è•½è•¿è–€è–çœç››å‰©èƒœåœ£å¸ˆå¤±ç‹®æ–½æ¹¿è¯—å°¸è™±åçŸ³æ‹¾æ—¶ä»€é£Ÿèš€å®è¯†å²çŸ¢ä½¿å±é©¶å§‹å¼ç¤ºå£«ä¸–æŸ¿äº‹æ‹­èª“é€åŠ¿æ˜¯å—œå™¬é€‚ä»•ä¾é‡Šé¥°æ°å¸‚æƒå®¤è§†è¯•æ”¶æ‰‹é¦–å®ˆå¯¿æˆå”®å—ç˜¦å…½è”¬æ¢æ¢³æ®ŠæŠ’è¾“å”èˆ’æ·‘ç–ä¹¦èµå­°ç†Ÿè–¯æš‘æ›™ç½²èœ€é»é¼ å±æœ¯è¿°æ ‘æŸæˆç«–å¢…åº¶æ•°æ¼±"],
    ["cb40", "è–‚è–ƒè–†è–ˆ", 6, "è–", 10, "è–", 6, "è–¥è–¦è–§è–©è–«è–¬è–­è–±", 5, "è–¸è–º", 6, "è—‚", 6, "è—Š", 4, "è—‘è—’"],
    ["cb80", "è—”è—–", 5, "è—", 6, "è—¥è—¦è—§è—¨è—ª", 14, "æ•åˆ·è€æ‘”è¡°ç”©å¸…æ “æ‹´éœœåŒçˆ½è°æ°´ç¡ç¨å®ç¬é¡ºèˆœè¯´ç¡•æœ”çƒæ–¯æ’•å˜¶æ€ç§å¸ä¸æ­»è‚†å¯ºå—£å››ä¼ºä¼¼é¥²å·³æ¾è€¸æ€‚é¢‚é€å®‹è®¼è¯µæœè‰˜æ“å—½è‹é…¥ä¿—ç´ é€Ÿç²Ÿåƒ³å¡‘æº¯å®¿è¯‰è‚ƒé…¸è’œç®—è™½éš‹éšç»¥é«“ç¢å²ç©—é‚éš§ç¥Ÿå­™æŸç¬‹è“‘æ¢­å”†ç¼©çç´¢é”æ‰€å¡Œä»–å®ƒå¥¹å¡”"],
    ["cc40", "è—¹è—ºè—¼è—½è—¾è˜€", 4, "è˜†", 10, "è˜’è˜“è˜”è˜•è˜—", 15, "è˜¨è˜ª", 13, "è˜¹è˜ºè˜»è˜½è˜¾è˜¿è™€"],
    ["cc80", "è™", 11, "è™’è™“è™•", 4, "è™›è™œè™è™Ÿè™ è™¡è™£", 7, "ç­æŒè¹‹è¸èƒè‹”æŠ¬å°æ³°é…å¤ªæ€æ±°åæ‘Šè´ªç˜«æ»©å›æª€ç—°æ½­è°­è°ˆå¦æ¯¯è¢’ç¢³æ¢å¹ç‚­æ±¤å¡˜æªå ‚æ£ è†›å”ç³–å€˜èººæ·Œè¶Ÿçƒ«ææ¶›æ»”ç»¦è„æ¡ƒé€ƒæ·˜é™¶è®¨å¥—ç‰¹è—¤è…¾ç–¼èªŠæ¢¯å‰”è¸¢é”‘æé¢˜è¹„å•¼ä½“æ›¿åšæƒ•æ¶•å‰ƒå±‰å¤©æ·»å¡«ç”°ç”œæ¬èˆ”è…†æŒ‘æ¡è¿¢çœºè·³è´´é“å¸–å…å¬çƒƒ"],
    ["cd40", "è™­è™¯è™°è™²", 6, "èšƒ", 6, "èš", 4, "èš”èš–", 5, "èš", 4, "èš¥èš¦èš«èš­èš®èš²èš³èš·èš¸èš¹èš»", 4, "è›è›‚è›ƒè›…è›ˆè›Œè›è›’è›“è›•è›–è›—è›šè›œ"],
    ["cd80", "è›è› è›¡è›¢è›£è›¥è›¦è›§è›¨è›ªè›«è›¬è›¯è›µè›¶è›·è›ºè›»è›¼è›½è›¿èœèœ„èœ…èœ†èœ‹èœŒèœèœèœèœ‘èœ”èœ–æ±€å»·åœäº­åº­æŒºè‰‡é€šæ¡é…®ç³åŒé“œå½¤ç«¥æ¡¶æ…ç­’ç»Ÿç—›å·æŠ•å¤´é€å‡¸ç§ƒçªå›¾å¾’é€”æ¶‚å± åœŸåå…”æ¹å›¢æ¨é¢“è…¿èœ•è¤ªé€€åå±¯è‡€æ‹–æ‰˜è„±é¸µé™€é©®é©¼æ¤­å¦¥æ‹“å”¾æŒ–å“‡è›™æ´¼å¨ƒç“¦è¢œæ­ªå¤–è±Œå¼¯æ¹¾ç©é¡½ä¸¸çƒ·å®Œç¢—æŒ½æ™šçš–æƒ‹å®›å©‰ä¸‡è…•æ±ªç‹äº¡æ‰ç½‘å¾€æ—ºæœ›å¿˜å¦„å¨"],
    ["ce40", "èœ™èœ›èœèœŸèœ èœ¤èœ¦èœ§èœ¨èœªèœ«èœ¬èœ­èœ¯èœ°èœ²èœ³èœµèœ¶èœ¸èœ¹èœºèœ¼èœ½è€", 6, "èŠè‹èèèè‘è’è”è•è–è˜èš", 5, "è¡è¢è¦", 7, "è¯è±è²è³èµ"],
    ["ce80", "è·è¸è¹èºè¿è€èè„è†è‡è‰èŠèŒè", 4, "è”è•è–è˜", 6, "è ", 4, "å·å¾®å±éŸ¦è¿æ¡…å›´å”¯æƒŸä¸ºæ½ç»´è‹‡èå§”ä¼Ÿä¼ªå°¾çº¬æœªè”šå‘³ç•èƒƒå–‚é­ä½æ¸­è°“å°‰æ…°å«ç˜Ÿæ¸©èšŠæ–‡é—»çº¹å»ç¨³ç´Šé—®å—¡ç¿ç“®æŒèœ—æ¶¡çªæˆ‘æ–¡å§æ¡æ²ƒå·«å‘œé’¨ä¹Œæ±¡è¯¬å±‹æ— èŠœæ¢§å¾å´æ¯‹æ­¦äº”æ‚åˆèˆä¼ä¾®åæˆŠé›¾æ™¤ç‰©å‹¿åŠ¡æ‚Ÿè¯¯æ˜”ç†™æè¥¿ç¡’çŸ½æ™°å˜»å¸é”¡ç‰º"],
    ["cf40", "è¥è¦è§è©èªè®è°è±è²è´è¶è·è¸è¹è»è¼è¾è¿èŸ", 4, "èŸ‡èŸˆèŸ‰èŸŒ", 4, "èŸ”", 6, "èŸœèŸèŸèŸŸèŸ¡èŸ¢èŸ£èŸ¤èŸ¦èŸ§èŸ¨èŸ©èŸ«èŸ¬èŸ­èŸ¯", 9],
    ["cf80", "èŸºèŸ»èŸ¼èŸ½èŸ¿è €è è ‚è „", 5, "è ‹", 7, "è ”è —è ˜è ™è šè œ", 4, "è £ç¨€æ¯å¸Œæ‚‰è†å¤•æƒœç†„çƒ¯æºªæ±çŠ€æª„è¢­å¸­ä¹ åª³å–œé“£æ´—ç³»éš™æˆç»†çè™¾åŒ£éœè¾–æš‡å³¡ä¾ ç‹­ä¸‹å¦å¤å“æ€é”¨å…ˆä»™é²œçº¤å’¸è´¤è¡”èˆ·é—²æ¶å¼¦å«Œæ˜¾é™©ç°çŒ®å¿è…ºé¦…ç¾¡å®ªé™·é™çº¿ç›¸å¢é•¶é¦™ç®±è¥„æ¹˜ä¹¡ç¿”ç¥¥è¯¦æƒ³å“äº«é¡¹å··æ©¡åƒå‘è±¡è§ç¡éœ„å‰Šå“®åš£é”€æ¶ˆå®µæ·†æ™“"],
    ["d040", "è ¤", 13, "è ³", 5, "è ºè »è ½è ¾è ¿è¡è¡‚è¡ƒè¡†", 5, "è¡", 5, "è¡•è¡–è¡˜è¡š", 6, "è¡¦è¡§è¡ªè¡­è¡¯è¡±è¡³è¡´è¡µè¡¶è¡¸è¡¹è¡º"],
    ["d080", "è¡»è¡¼è¢€è¢ƒè¢†è¢‡è¢‰è¢Šè¢Œè¢è¢è¢è¢‘è¢“è¢”è¢•è¢—", 4, "è¢", 4, "è¢£è¢¥", 5, "å°å­æ ¡è‚–å•¸ç¬‘æ•ˆæ¥”äº›æ­‡èé‹åæŒŸæºé‚ªæ–œèƒè°å†™æ¢°å¸èŸ¹æ‡ˆæ³„æ³»è°¢å±‘è–ªèŠ¯é”Œæ¬£è¾›æ–°å¿»å¿ƒä¿¡è¡…æ˜Ÿè…¥çŒ©æƒºå…´åˆ‘å‹å½¢é‚¢è¡Œé†’å¹¸ææ€§å§“å…„å‡¶èƒ¸åŒˆæ±¹é›„ç†Šä¼‘ä¿®ç¾æœ½å—…é”ˆç§€è¢–ç»£å¢ŸæˆŒéœ€è™šå˜˜é¡»å¾è®¸è“„é…—å™æ—­åºç•œæ¤çµ®å©¿ç»ªç»­è½©å–§å®£æ‚¬æ—‹ç„"],
    ["d140", "è¢¬è¢®è¢¯è¢°è¢²", 4, "è¢¸è¢¹è¢ºè¢»è¢½è¢¾è¢¿è£€è£ƒè£„è£‡è£ˆè£Šè£‹è£Œè£è£è£è£‘è£“è£–è£—è£š", 4, "è£ è£¡è£¦è£§è£©", 6, "è£²è£µè£¶è£·è£ºè£»è£½è£¿è¤€è¤è¤ƒ", 5],
    ["d180", "è¤‰è¤‹", 4, "è¤‘è¤”", 4, "è¤œ", 4, "è¤¢è¤£è¤¤è¤¦è¤§è¤¨è¤©è¤¬è¤­è¤®è¤¯è¤±è¤²è¤³è¤µè¤·é€‰ç™£çœ©ç»šé´è–›å­¦ç©´é›ªè¡€å‹‹ç†å¾ªæ—¬è¯¢å¯»é©¯å·¡æ®‰æ±›è®­è®¯é€Šè¿…å‹æŠ¼é¸¦é¸­å‘€ä¸«èŠ½ç‰™èšœå´–è¡™æ¶¯é›…å“‘äºšè®¶ç„‰å’½é˜‰çƒŸæ·¹ç›ä¸¥ç ”èœ’å²©å»¶è¨€é¢œé˜ç‚æ²¿å¥„æ©çœ¼è¡æ¼”è‰³å °ç‡•åŒç šé›å”å½¦ç„°å®´è°šéªŒæ®ƒå¤®é¸¯ç§§æ¨æ‰¬ä½¯ç–¡ç¾Šæ´‹é˜³æ°§ä»°ç—’å…»æ ·æ¼¾é‚€è…°å¦–ç‘¶"],
    ["d240", "è¤¸", 8, "è¥‚è¥ƒè¥…", 24, "è¥ ", 5, "è¥§", 19, "è¥¼"],
    ["d280", "è¥½è¥¾è¦€è¦‚è¦„è¦…è¦‡", 26, "æ‘‡å°§é¥çª‘è°£å§šå’¬èˆ€è¯è¦è€€æ¤°å™è€¶çˆ·é‡å†¶ä¹Ÿé¡µæ–ä¸šå¶æ›³è…‹å¤œæ¶²ä¸€å£¹åŒ»æ–é“±ä¾ä¼Šè¡£é¢å¤·é—ç§»ä»ªèƒ°ç–‘æ²‚å®œå§¨å½æ¤…èšå€šå·²ä¹™çŸ£ä»¥è‰ºæŠ‘æ˜“é‚‘å±¹äº¿å½¹è‡†é€¸è‚„ç–«äº¦è£”æ„æ¯…å¿†ä¹‰ç›Šæº¢è¯£è®®è°Šè¯‘å¼‚ç¿¼ç¿Œç»èŒµè«å› æ®·éŸ³é˜´å§»åŸé“¶æ·«å¯…é¥®å°¹å¼•éš"],
    ["d340", "è¦¢", 30, "è§ƒè§è§“è§”è§•è§—è§˜è§™è§›è§è§Ÿè§ è§¡è§¢è§¤è§§è§¨è§©è§ªè§¬è§­è§®è§°è§±è§²è§´", 6],
    ["d380", "è§»", 4, "è¨", 5, "è¨ˆ", 21, "å°è‹±æ¨±å©´é¹°åº”ç¼¨è¹è¤è¥è§è‡è¿èµ¢ç›ˆå½±é¢–ç¡¬æ˜ å“Ÿæ‹¥ä½£è‡ƒç—ˆåº¸é›è¸Šè›¹å’æ³³æ¶Œæ°¸æ¿å‹‡ç”¨å¹½ä¼˜æ‚ å¿§å°¤ç”±é‚®é“€çŠ¹æ²¹æ¸¸é…‰æœ‰å‹å³ä½‘é‡‰è¯±åˆå¹¼è¿‚æ·¤äºç›‚æ¦†è™æ„šèˆ†ä½™ä¿é€¾é±¼æ„‰æ¸æ¸”éš…äºˆå¨±é›¨ä¸å±¿ç¦¹å®‡è¯­ç¾½ç‰åŸŸèŠ‹éƒåé‡å–»å³ªå¾¡æ„ˆæ¬²ç‹±è‚²èª‰"],
    ["d440", "è¨", 31, "è¨¿", 8, "è©‰", 21],
    ["d480", "è©Ÿ", 25, "è©º", 6, "æµ´å¯“è£•é¢„è±«é©­é¸³æ¸Šå†¤å…ƒå£è¢åŸæ´è¾•å›­å‘˜åœ†çŒ¿æºç¼˜è¿œè‹‘æ„¿æ€¨é™¢æ›°çº¦è¶Šè·ƒé’¥å²³ç²¤æœˆæ‚¦é˜…è€˜äº‘éƒ§åŒ€é™¨å…è¿è•´é…æ™•éŸµå­•åŒç ¸æ‚æ ½å“‰ç¾å®°è½½å†åœ¨å’±æ”’æš‚èµèµƒè„è‘¬é­ç³Ÿå‡¿è—»æ£æ—©æ¾¡èš¤èºå™ªé€ çš‚ç¶ç‡¥è´£æ‹©åˆ™æ³½è´¼æ€å¢æ†æ›¾èµ æ‰å–³æ¸£æœ­è½§"],
    ["d540", "èª", 7, "èª‹", 7, "èª”", 46],
    ["d580", "è«ƒ", 32, "é“¡é—¸çœ¨æ …æ¦¨å’‹ä¹ç‚¸è¯ˆæ‘˜æ–‹å®…çª„å€ºå¯¨ç»æ¯¡è©¹ç²˜æ²¾ç›æ–©è¾—å´­å±•è˜¸æ ˆå æˆ˜ç«™æ¹›ç»½æ¨Ÿç« å½°æ¼³å¼ æŒæ¶¨æ–ä¸ˆå¸è´¦ä»—èƒ€ç˜´éšœæ‹›æ˜­æ‰¾æ²¼èµµç…§ç½©å…†è‚‡å¬é®æŠ˜å“²è›°è¾™è€…é”—è”—è¿™æµ™çæ–ŸçœŸç”„ç §è‡»è´é’ˆä¾¦æ•ç–¹è¯Šéœ‡æŒ¯é•‡é˜µè’¸æŒ£çå¾ç‹°äº‰æ€”æ•´æ‹¯æ­£æ”¿"],
    ["d640", "è«¤", 34, "è¬ˆ", 27],
    ["d680", "è¬¤è¬¥è¬§", 30, "å¸§ç—‡éƒ‘è¯èŠææ”¯å±èœ˜çŸ¥è‚¢è„‚æ±ä¹‹ç»‡èŒç›´æ¤æ®–æ‰§å€¼ä¾„å€æŒ‡æ­¢è¶¾åªæ—¨çº¸å¿—æŒšæ·è‡³è‡´ç½®å¸œå³™åˆ¶æ™ºç§©ç¨šè´¨ç‚™ç—”æ»æ²»çª’ä¸­ç›…å¿ é’Ÿè¡·ç»ˆç§è‚¿é‡ä»²ä¼—èˆŸå‘¨å·æ´²è¯Œç²¥è½´è‚˜å¸šå’’çš±å®™æ˜¼éª¤ç æ ªè››æœ±çŒªè¯¸è¯›é€ç«¹çƒ›ç…®æ‹„ç©å˜±ä¸»è‘—æŸ±åŠ©è›€è´®é“¸ç­‘"],
    ["d740", "è­†", 31, "è­§", 4, "è­­", 25],
    ["d780", "è®‡", 24, "è®¬è®±è®»è¯‡è¯è¯ªè°‰è°ä½æ³¨ç¥é©»æŠ“çˆªæ‹½ä¸“ç –è½¬æ’°èµšç¯†æ¡©åº„è£…å¦†æ’å£®çŠ¶æ¤é”¥è¿½èµ˜å ç¼€è°†å‡†æ‰æ‹™å“æ¡Œç¢èŒé…Œå•„ç€ç¼æµŠå…¹å’¨èµ„å§¿æ»‹æ·„å­œç´«ä»”ç±½æ»“å­è‡ªæ¸å­—é¬ƒæ£•è¸ªå®—ç»¼æ€»çºµé‚¹èµ°å¥æç§Ÿè¶³å’æ—ç¥–è¯…é˜»ç»„é’»çº‚å˜´é†‰æœ€ç½ªå°Šéµæ˜¨å·¦ä½æŸåšä½œååº§"],
    ["d840", "è°¸", 8, "è±‚è±ƒè±„è±…è±ˆè±Šè±‹è±", 7, "è±–è±—è±˜è±™è±›", 5, "è±£", 6, "è±¬", 6, "è±´è±µè±¶è±·è±»", 6, "è²ƒè²„è²†è²‡"],
    ["d880", "è²ˆè²‹è²", 6, "è²•è²–è²—è²™", 20, "äºä¸Œå…€ä¸å»¿å…ä¸•äº˜ä¸é¬²å­¬å™©ä¸¨ç¦ºä¸¿åŒ•ä¹‡å¤­çˆ»å®æ°å›Ÿèƒ¤é¦—æ¯“ç¾é¼—ä¸¶äºŸé¼ä¹œä¹©äº“èŠˆå­›å•¬å˜ä»„ååå£å¥å®é¥èµåŒšåµåŒ¦åŒ®åŒ¾èµœå¦å£åˆ‚åˆˆåˆåˆ­åˆ³åˆ¿å‰€å‰Œå‰å‰¡å‰œè’¯å‰½åŠ‚åŠåŠåŠ“å†‚ç½”äº»ä»ƒä»‰ä»‚ä»¨ä»¡ä»«ä»ä¼›ä»³ä¼¢ä½¤ä»µä¼¥ä¼§ä¼‰ä¼«ä½ä½§æ”¸ä½šä½"],
    ["d940", "è²®", 62],
    ["d980", "è³­", 32, "ä½Ÿä½—ä¼²ä¼½ä½¶ä½´ä¾‘ä¾‰ä¾ƒä¾ä½¾ä½»ä¾ªä½¼ä¾¬ä¾”ä¿¦ä¿¨ä¿ªä¿…ä¿šä¿£ä¿œä¿‘ä¿Ÿä¿¸å€©åŒä¿³å€¬å€å€®å€­ä¿¾å€œå€Œå€¥å€¨å¾åƒå•åˆåå¬å»å‚¥å‚§å‚©å‚ºåƒ–å„†åƒ­åƒ¬åƒ¦åƒ®å„‡å„‹ä»æ°½ä½˜ä½¥ä¿é¾ æ±†ç±´å…®å·½é»‰é¦˜å†å¤”å‹¹åŒè¨‡åŒå‡«å¤™å…•äº å…–äº³è¡®è¢¤äºµè„”è£’ç¦€å¬´è ƒç¾¸å†«å†±å†½å†¼"],
    ["da40", "è´", 14, "è´ èµ‘èµ’èµ—èµŸèµ¥èµ¨èµ©èµªèµ¬èµ®èµ¯èµ±èµ²èµ¸", 8, "è¶‚è¶ƒè¶†è¶‡è¶ˆè¶‰è¶Œ", 4, "è¶’è¶“è¶•", 9, "è¶ è¶¡"],
    ["da80", "è¶¢è¶¤", 12, "è¶²è¶¶è¶·è¶¹è¶»è¶½è·€è·è·‚è·…è·‡è·ˆè·‰è·Šè·è·è·’è·“è·”å‡‡å†–å†¢å†¥è® è®¦è®§è®ªè®´è®µè®·è¯‚è¯ƒè¯‹è¯è¯è¯’è¯“è¯”è¯–è¯˜è¯™è¯œè¯Ÿè¯ è¯¤è¯¨è¯©è¯®è¯°è¯³è¯¶è¯¹è¯¼è¯¿è°€è°‚è°„è°‡è°Œè°è°‘è°’è°”è°•è°–è°™è°›è°˜è°è°Ÿè° è°¡è°¥è°§è°ªè°«è°®è°¯è°²è°³è°µè°¶å©åºé˜é˜¢é˜¡é˜±é˜ªé˜½é˜¼é™‚é™‰é™”é™Ÿé™§é™¬é™²é™´éšˆéšéš—éš°é‚—é‚›é‚é‚™é‚¬é‚¡é‚´é‚³é‚¶é‚º"],
    ["db40", "è·•è·˜è·™è·œè· è·¡è·¢è·¥è·¦è·§è·©è·­è·®è·°è·±è·²è·´è·¶è·¼è·¾", 6, "è¸†è¸‡è¸ˆè¸‹è¸è¸è¸è¸‘è¸’è¸“è¸•", 7, "è¸ è¸¡è¸¤", 4, "è¸«è¸­è¸°è¸²è¸³è¸´è¸¶è¸·è¸¸è¸»è¸¼è¸¾"],
    ["db80", "è¸¿è¹ƒè¹…è¹†è¹Œ", 4, "è¹“", 5, "è¹š", 11, "è¹§è¹¨è¹ªè¹«è¹®è¹±é‚¸é‚°éƒéƒ…é‚¾éƒéƒ„éƒ‡éƒ“éƒ¦éƒ¢éƒœéƒ—éƒ›éƒ«éƒ¯éƒ¾é„„é„¢é„é„£é„±é„¯é„¹é…ƒé…†åˆå¥‚åŠ¢åŠ¬åŠ­åŠ¾å“¿å‹å‹–å‹°åŸç‡®çŸå»´å‡µå‡¼é¬¯å¶å¼ç•šå·¯åŒå©å¡å¡¾å¢¼å£…å£‘åœ©åœ¬åœªåœ³åœ¹åœ®åœ¯åœåœ»å‚å©å…å«å†å¼å»å¨å­å¶å³å­å¤åŒå²åŸå§å´å“å åŸ•åŸ˜åŸšåŸ™åŸ’å¸åŸ´åŸ¯åŸ¸åŸ¤åŸ"],
    ["dc40", "è¹³è¹µè¹·", 4, "è¹½è¹¾èº€èº‚èºƒèº„èº†èºˆ", 6, "èº‘èº’èº“èº•", 6, "èºèºŸ", 11, "èº­èº®èº°èº±èº³", 6, "èº»", 7],
    ["dc80", "è»ƒ", 10, "è»", 21, "å ‹å åŸ½åŸ­å €å å ™å¡„å  å¡¥å¡¬å¢å¢‰å¢šå¢€é¦¨é¼™æ‡¿è‰¹è‰½è‰¿èŠèŠŠèŠ¨èŠ„èŠèŠ‘èŠ—èŠ™èŠ«èŠ¸èŠ¾èŠ°è‹ˆè‹Šè‹£èŠ˜èŠ·èŠ®è‹‹è‹Œè‹èŠ©èŠ´èŠ¡èŠªèŠŸè‹„è‹èŠ¤è‹¡èŒ‰è‹·è‹¤èŒèŒ‡è‹œè‹´è‹’è‹˜èŒŒè‹»è‹“èŒ‘èŒšèŒ†èŒ”èŒ•è‹ è‹•èŒœè‘è›èœèŒˆè’èŒ¼èŒ´èŒ±è›èèŒ¯èè‡èƒèŸè€èŒ—è èŒ­èŒºèŒ³è¦è¥"],
    ["dd40", "è»¥", 62],
    ["dd80", "è¼¤", 32, "è¨èŒ›è©è¬èªè­è®è°è¸è³è´è èªè“èœè…è¼è¶è©è½è¸è»è˜èè¨èºè¼èèè¥è˜å ‡è˜è‹èè½è–èœè¸è‘è†è”èŸèèƒè¸è¹èªè…è€è¦è°è¡è‘œè‘‘è‘šè‘™è‘³è’‡è’ˆè‘ºè’‰è‘¸è¼è‘†è‘©è‘¶è’Œè’è±è‘­è“è“è“è“¦è’½è““è“Šè’¿è’ºè“ è’¡è’¹è’´è’—è“¥è“£è”Œç”è”¸è“°è”¹è”Ÿè”º"],
    ["de40", "è½…", 32, "è½ªè¾€è¾Œè¾’è¾è¾ è¾¡è¾¢è¾¤è¾¥è¾¦è¾§è¾ªè¾¬è¾­è¾®è¾¯è¾²è¾³è¾´è¾µè¾·è¾¸è¾ºè¾»è¾¼è¾¿è¿€è¿ƒè¿†"],
    ["de80", "è¿‰", 4, "è¿è¿’è¿–è¿—è¿šè¿ è¿¡è¿£è¿§è¿¬è¿¯è¿±è¿²è¿´è¿µè¿¶è¿ºè¿»è¿¼è¿¾è¿¿é€‡é€ˆé€Œé€é€“é€•é€˜è•–è”»è“¿è“¼è•™è•ˆè•¨è•¤è•è•ºç¢è•ƒè•²è•»è–¤è–¨è–‡è–è•¹è–®è–œè–…è–¹è–·è–°è—“è—è—œè—¿è˜§è˜…è˜©è˜–è˜¼å»¾å¼ˆå¤¼å¥è€·å¥•å¥šå¥˜åŒå°¢å°¥å°¬å°´æ‰Œæ‰ªæŠŸæŠ»æ‹Šæ‹šæ‹—æ‹®æŒ¢æ‹¶æŒ¹æ‹æƒæ­æ¶æ±æºææ´æ­æ¬æŠæ©æ®æ¼æ²æ¸æ æ¿æ„æææ‘’æ†æ¾æ‘…æ‘æ‹æ›æ æŒæ¦æ¡æ‘æ’„æ‘­æ’–"],
    ["df40", "é€™é€œé€£é€¤é€¥é€§", 5, "é€°", 4, "é€·é€¹é€ºé€½é€¿é€éƒé…é†éˆ", 4, "éé”é•é–é™éšéœ", 5, "é¤é¦é§é©éªé«é¬é¯", 4, "é¶", 6, "é¾é‚"],
    ["df80", "é‚„é‚…é‚†é‚‡é‚‰é‚Šé‚Œ", 4, "é‚’é‚”é‚–é‚˜é‚šé‚œé‚é‚Ÿé‚ é‚¤é‚¥é‚§é‚¨é‚©é‚«é‚­é‚²é‚·é‚¼é‚½é‚¿éƒ€æ‘ºæ’·æ’¸æ’™æ’ºæ“€æ“æ“—æ“¤æ“¢æ”‰æ”¥æ”®å¼‹å¿’ç”™å¼‘åŸå±å½å©å¨å»å’å–å†å‘‹å‘’å‘“å‘”å‘–å‘ƒå¡å‘—å‘™å£å²å’‚å’”å‘·å‘±å‘¤å’šå’›å’„å‘¶å‘¦å’å“å’­å“‚å’´å“’å’§å’¦å““å“”å‘²å’£å“•å’»å’¿å“Œå“™å“šå“œå’©å’ªå’¤å“å“å“å”›å“§å” å“½å””å“³å”¢å”£å”å”‘å”§å”ªå•§å–å–µå•‰å•­å•å••å”¿å•å”¼"],
    ["e040", "éƒ‚éƒƒéƒ†éƒˆéƒ‰éƒ‹éƒŒéƒéƒ’éƒ”éƒ•éƒ–éƒ˜éƒ™éƒšéƒéƒŸéƒ éƒ£éƒ¤éƒ¥éƒ©éƒªéƒ¬éƒ®éƒ°éƒ±éƒ²éƒ³éƒµéƒ¶éƒ·éƒ¹éƒºéƒ»éƒ¼éƒ¿é„€é„é„ƒé„…", 19, "é„šé„›é„œ"],
    ["e080", "é„é„Ÿé„ é„¡é„¤", 10, "é„°é„²", 6, "é„º", 8, "é…„å”·å•–å•µå•¶å•·å”³å”°å•œå–‹å—’å–ƒå–±å–¹å–ˆå–å–Ÿå•¾å—–å–‘å•»å—Ÿå–½å–¾å–”å–™å—ªå—·å—‰å˜Ÿå—‘å—«å—¬å—”å—¦å—å—„å—¯å—¥å—²å—³å—Œå—å—¨å—µå—¤è¾”å˜å˜ˆå˜Œå˜å˜¤å˜£å—¾å˜€å˜§å˜­å™˜å˜¹å™—å˜¬å™å™¢å™™å™œå™Œå™”åš†å™¤å™±å™«å™»å™¼åš…åš“åš¯å›”å›—å›å›¡å›µå›«å›¹å›¿åœ„åœŠåœ‰åœœå¸å¸™å¸”å¸‘å¸±å¸»å¸¼"],
    ["e140", "é……é…‡é…ˆé…‘é…“é…”é…•é…–é…˜é…™é…›é…œé…Ÿé… é…¦é…§é…¨é…«é…­é…³é…ºé…»é…¼é†€", 4, "é††é†ˆé†Šé†é†é†“", 6, "é†œ", 5, "é†¤", 5, "é†«é†¬é†°é†±é†²é†³é†¶é†·é†¸é†¹é†»"],
    ["e180", "é†¼", 10, "é‡ˆé‡‹é‡é‡’", 9, "é‡", 8, "å¸·å¹„å¹”å¹›å¹å¹¡å²Œå±ºå²å²å²–å²ˆå²˜å²™å²‘å²šå²œå²µå²¢å²½å²¬å²«å²±å²£å³å²·å³„å³’å³¤å³‹å³¥å´‚å´ƒå´§å´¦å´®å´¤å´å´†å´›åµ˜å´¾å´´å´½åµ¬åµ›åµ¯åµåµ«åµ‹åµŠåµ©åµ´å¶‚å¶™å¶è±³å¶·å·…å½³å½·å¾‚å¾‡å¾‰å¾Œå¾•å¾™å¾œå¾¨å¾­å¾µå¾¼è¡¢å½¡çŠ­çŠ°çŠ´çŠ·çŠ¸ç‹ƒç‹ç‹ç‹ç‹’ç‹¨ç‹¯ç‹©ç‹²ç‹´ç‹·çŒç‹³çŒƒç‹º"],
    ["e240", "é‡¦", 62],
    ["e280", "éˆ¥", 32, "ç‹»çŒ—çŒ“çŒ¡çŒŠçŒçŒçŒ•çŒ¢çŒ¹çŒ¥çŒ¬çŒ¸çŒ±ççç—ç ç¬ç¯ç¾èˆ›å¤¥é£§å¤¤å¤‚é¥£é¥§", 5, "é¥´é¥·é¥½é¦€é¦„é¦‡é¦Šé¦é¦é¦‘é¦“é¦”é¦•åº€åº‘åº‹åº–åº¥åº åº¹åºµåº¾åº³èµ“å»’å»‘å»›å»¨å»ªè†ºå¿„å¿‰å¿–å¿æ€ƒå¿®æ€„å¿¡å¿¤å¿¾æ€…æ€†å¿ªå¿­å¿¸æ€™æ€µæ€¦æ€›æ€æ€æ€©æ€«æ€Šæ€¿æ€¡æ¸æ¹æ»æºæ‚"],
    ["e340", "é‰†", 45, "é‰µ", 16],
    ["e380", "éŠ†", 7, "éŠ", 24, "æªæ½æ‚–æ‚šæ‚­æ‚æ‚ƒæ‚’æ‚Œæ‚›æƒ¬æ‚»æ‚±æƒæƒ˜æƒ†æƒšæ‚´æ„ æ„¦æ„•æ„£æƒ´æ„€æ„æ„«æ…Šæ…µæ†¬æ†”æ†§æ†·æ‡”æ‡µå¿éš³é—©é—«é—±é—³é—µé—¶é—¼é—¾é˜ƒé˜„é˜†é˜ˆé˜Šé˜‹é˜Œé˜é˜é˜’é˜•é˜–é˜—é˜™é˜šä¸¬çˆ¿æˆ•æ°µæ±”æ±œæ±Šæ²£æ²…æ²æ²”æ²Œæ±¨æ±©æ±´æ±¶æ²†æ²©æ³æ³”æ²­æ³·æ³¸æ³±æ³—æ²²æ³ æ³–æ³ºæ³«æ³®æ²±æ³“æ³¯æ³¾"],
    ["e440", "éŠ¨", 5, "éŠ¯", 24, "é‹‰", 31],
    ["e480", "é‹©", 32, "æ´¹æ´§æ´Œæµƒæµˆæ´‡æ´„æ´™æ´æ´«æµæ´®æ´µæ´šæµæµ’æµ”æ´³æ¶‘æµ¯æ¶æ¶ æµæ¶“æ¶”æµœæµ æµ¼æµ£æ¸šæ·‡æ·…æ·æ¸æ¶¿æ· æ¸‘æ·¦æ·æ·™æ¸–æ¶«æ¸Œæ¶®æ¸«æ¹®æ¹æ¹«æº²æ¹Ÿæº†æ¹“æ¹”æ¸²æ¸¥æ¹„æ»Ÿæº±æº˜æ» æ¼­æ»¢æº¥æº§æº½æº»æº·æ»—æº´æ»æºæ»‚æºŸæ½¢æ½†æ½‡æ¼¤æ¼•æ»¹æ¼¯æ¼¶æ½‹æ½´æ¼ªæ¼‰æ¼©æ¾‰æ¾æ¾Œæ½¸æ½²æ½¼æ½ºæ¿‘"],
    ["e540", "éŒŠ", 51, "éŒ¿", 10],
    ["e580", "éŠ", 31, "é«æ¿‰æ¾§æ¾¹æ¾¶æ¿‚æ¿¡æ¿®æ¿æ¿ æ¿¯ç€šç€£ç€›ç€¹ç€µççå®€å®„å®•å®“å®¥å®¸ç”¯éªæ´å¯¤å¯®è¤°å¯°è¹‡è¬‡è¾¶è¿“è¿•è¿¥è¿®è¿¤è¿©è¿¦è¿³è¿¨é€…é€„é€‹é€¦é€‘é€é€–é€¡é€µé€¶é€­é€¯é„é‘é’éé¨é˜é¢é›æš¹é´é½é‚‚é‚ˆé‚ƒé‚‹å½å½—å½–å½˜å°»å’«å±å±™å­±å±£å±¦ç¾¼å¼ªå¼©å¼­è‰´å¼¼é¬»å±®å¦å¦ƒå¦å¦©å¦ªå¦£"],
    ["e640", "é¬", 34, "é", 27],
    ["e680", "é¬", 29, "é‹éŒéå¦—å§Šå¦«å¦å¦¤å§’å¦²å¦¯å§—å¦¾å¨…å¨†å§å¨ˆå§£å§˜å§¹å¨Œå¨‰å¨²å¨´å¨‘å¨£å¨“å©€å©§å©Šå©•å¨¼å©¢å©µèƒ¬åªªåª›å©·å©ºåª¾å««åª²å«’å«”åª¸å« å«£å«±å«–å«¦å«˜å«œå¬‰å¬—å¬–å¬²å¬·å­€å°•å°œå­šå­¥å­³å­‘å­“å­¢é©µé©·é©¸é©ºé©¿é©½éª€éªéª…éªˆéªŠéªéª’éª“éª–éª˜éª›éªœéªéªŸéª éª¢éª£éª¥éª§çºŸçº¡çº£çº¥çº¨çº©"],
    ["e740", "é", 7, "é—", 54],
    ["e780", "é", 32, "çº­çº°çº¾ç»€ç»ç»‚ç»‰ç»‹ç»Œç»ç»”ç»—ç»›ç» ç»¡ç»¨ç»«ç»®ç»¯ç»±ç»²ç¼ç»¶ç»ºç»»ç»¾ç¼ç¼‚ç¼ƒç¼‡ç¼ˆç¼‹ç¼Œç¼ç¼‘ç¼’ç¼—ç¼™ç¼œç¼›ç¼Ÿç¼¡", 6, "ç¼ªç¼«ç¼¬ç¼­ç¼¯", 4, "ç¼µå¹ºç•¿å·›ç”¾é‚•çç‘ç®ç¢çŸçç‚ç‘ç·ç³ç€ç‰çˆç¥ç™é¡¼çŠç©ç§ççºç²ççªç‘›ç¦ç¥ç¨ç°ç®ç¬"],
    ["e840", "é¯", 14, "é¿", 43, "é‘¬é‘­é‘®é‘¯"],
    ["e880", "é‘°", 20, "é’‘é’–é’˜é“‡é“é““é“”é“šé“¦é“»é”œé” ç›çšç‘ç‘œç‘—ç‘•ç‘™ç‘·ç‘­ç‘¾ç’œç’ç’€ç’ç’‡ç’‹ç’ç’¨ç’©ç’ç’§ç“’ç’ºéŸªéŸ«éŸ¬æŒæ“ææˆæ©æ¥æ‡æªæ³æ˜æ§æµæ¨ææ­æ‹æ·æ¼æŸ°æ ‰æŸ˜æ ŠæŸ©æ°æ ŒæŸ™æµæŸšæ³æŸæ €æŸƒæ¸æŸ¢æ æŸæŸ½æ ²æ ³æ¡ æ¡¡æ¡æ¡¢æ¡„æ¡¤æ¢ƒæ æ¡•æ¡¦æ¡æ¡§æ¡€æ ¾æ¡Šæ¡‰æ ©æ¢µæ¢æ¡´æ¡·æ¢“æ¡«æ£‚æ¥®æ£¼æ¤Ÿæ¤ æ£¹"],
    ["e940", "é”§é”³é”½é•ƒé•ˆé•‹é••é•šé• é•®é•´é•µé•·", 7, "é–€", 42],
    ["e980", "é–«", 32, "æ¤¤æ£°æ¤‹æ¤æ¥—æ££æ¤æ¥±æ¤¹æ¥ æ¥‚æ¥æ¦„æ¥«æ¦€æ¦˜æ¥¸æ¤´æ§Œæ¦‡æ¦ˆæ§æ¦‰æ¥¦æ¥£æ¥¹æ¦›æ¦§æ¦»æ¦«æ¦­æ§”æ¦±æ§æ§Šæ§Ÿæ¦•æ§ æ¦æ§¿æ¨¯æ§­æ¨—æ¨˜æ©¥æ§²æ©„æ¨¾æª æ©æ©›æ¨µæªæ©¹æ¨½æ¨¨æ©˜æ©¼æª‘æªæª©æª—æª«çŒ·ç’æ®æ®‚æ®‡æ®„æ®’æ®“æ®æ®šæ®›æ®¡æ®ªè½«è½­è½±è½²è½³è½µè½¶è½¸è½·è½¹è½ºè½¼è½¾è¾è¾‚è¾„è¾‡è¾‹"],
    ["ea40", "é—Œ", 27, "é—¬é—¿é˜‡é˜“é˜˜é˜›é˜é˜ é˜£", 6, "é˜«é˜¬é˜­é˜¯é˜°é˜·é˜¸é˜¹é˜ºé˜¾é™é™ƒé™Šé™é™é™‘é™’é™“é™–é™—"],
    ["ea80", "é™˜é™™é™šé™œé™é™é™ é™£é™¥é™¦é™«é™­", 4, "é™³é™¸", 12, "éš‡éš‰éšŠè¾è¾è¾è¾˜è¾šè»æˆ‹æˆ—æˆ›æˆŸæˆ¢æˆ¡æˆ¥æˆ¤æˆ¬è‡§ç“¯ç“´ç“¿ç”ç”‘ç”“æ”´æ—®æ—¯æ—°æ˜Šæ˜™æ²æ˜ƒæ˜•æ˜€ç‚…æ›·æ˜æ˜´æ˜±æ˜¶æ˜µè€†æ™Ÿæ™”æ™æ™æ™–æ™¡æ™—æ™·æš„æšŒæš§æšæš¾æ››æ›œæ›¦æ›©è´²è´³è´¶è´»è´½èµ€èµ…èµ†èµˆèµ‰èµ‡èµèµ•èµ™è§‡è§Šè§‹è§Œè§è§è§è§‘ç‰®çŠŸç‰ç‰¦ç‰¯ç‰¾ç‰¿çŠ„çŠ‹çŠçŠçŠ’æŒˆæŒ²æ°"],
    ["eb40", "éšŒéšéš‘éš’éš“éš•éš–éššéš›éš", 9, "éš¨", 7, "éš±éš²éš´éšµéš·éš¸éšºéš»éš¿é›‚é›ƒé›ˆé›Šé›‹é›é›‘é›“é›”é›–", 9, "é›¡", 6, "é›«"],
    ["eb80", "é›¬é›­é›®é›°é›±é›²é›´é›µé›¸é›ºé›»é›¼é›½é›¿éœ‚éœƒéœ…éœŠéœ‹éœŒéœéœ‘éœ’éœ”éœ•éœ—", 4, "éœéœŸéœ æ¿æ“˜è€„æ¯ªæ¯³æ¯½æ¯µæ¯¹æ°…æ°‡æ°†æ°æ°•æ°˜æ°™æ°šæ°¡æ°©æ°¤æ°ªæ°²æ”µæ••æ•«ç‰ç‰’ç‰–çˆ°è™¢åˆ–è‚Ÿè‚œè‚“è‚¼æœŠè‚½è‚±è‚«è‚­è‚´è‚·èƒ§èƒ¨èƒ©èƒªèƒ›èƒ‚èƒ„èƒ™èƒèƒ—æœèƒèƒ«èƒ±èƒ´èƒ­è„è„èƒ²èƒ¼æœ•è„’è±šè„¶è„è„¬è„˜è„²è…ˆè…Œè…“è…´è…™è…šè…±è… è…©è…¼è…½è…­è…§å¡åªµè†ˆè†‚è†‘æ»•è†£è†ªè‡Œæœ¦è‡Šè†»"],
    ["ec40", "éœ¡", 8, "éœ«éœ¬éœ®éœ¯éœ±éœ³", 4, "éœºéœ»éœ¼éœ½éœ¿", 18, "é”é•é—é˜éšéœééŸé£é¤é¦é§é¨éª", 7],
    ["ec80", "é²éµé·", 4, "é½", 7, "é†", 4, "éŒéééé“é•é–é—é™", 4, "è‡è†¦æ¬¤æ¬·æ¬¹æ­ƒæ­†æ­™é£‘é£’é£“é£•é£™é£šæ®³å½€æ¯‚è§³æ–é½‘æ–“æ–¼æ—†æ—„æ—ƒæ—Œæ—æ—’æ—–ç‚€ç‚œç‚–ç‚ç‚»çƒ€ç‚·ç‚«ç‚±çƒ¨çƒŠç„ç„“ç„–ç„¯ç„±ç…³ç…œç…¨ç……ç…²ç…Šç…¸ç…ºç†˜ç†³ç†µç†¨ç† ç‡ ç‡”ç‡§ç‡¹çˆçˆ¨ç¬ç„˜ç…¦ç†¹æˆ¾æˆ½æ‰ƒæ‰ˆæ‰‰ç¤»ç¥€ç¥†ç¥‰ç¥›ç¥œç¥“ç¥šç¥¢ç¥—ç¥ ç¥¯ç¥§ç¥ºç¦…ç¦Šç¦šç¦§ç¦³å¿‘å¿"],
    ["ed40", "ééŸé¡é¢é¤", 6, "é¬é®é°é±é³éµ", 46],
    ["ed80", "éŸ¤éŸ¥éŸ¨éŸ®", 4, "éŸ´éŸ·", 23, "æ€¼ææšæ§ææ™æ£æ‚«æ„†æ„æ…æ†©æ†æ‡‹æ‡‘æˆ†è‚€è¿æ²“æ³¶æ·¼çŸ¶çŸ¸ç €ç ‰ç —ç ˜ç ‘æ–«ç ­ç œç ç ¹ç ºç »ç Ÿç ¼ç ¥ç ¬ç £ç ©ç¡ç¡­ç¡–ç¡—ç ¦ç¡ç¡‡ç¡Œç¡ªç¢›ç¢“ç¢šç¢‡ç¢œç¢¡ç¢£ç¢²ç¢¹ç¢¥ç£”ç£™ç£‰ç£¬ç£²ç¤…ç£´ç¤“ç¤¤ç¤ç¤´é¾›é»¹é»»é»¼ç›±çœ„çœç›¹çœ‡çœˆçœšçœ¢çœ™çœ­çœ¦çœµçœ¸çç‘ç‡çƒçšç¨"],
    ["ee40", "é ", 62],
    ["ee80", "é¡", 32, "ç¢ç¥ç¿çç½ç€çŒç‘çŸç ç°çµç½ç”ºç•€ç•ç•‹ç•ˆç•›ç•²ç•¹ç–ƒç½˜ç½¡ç½Ÿè©ˆç½¨ç½´ç½±ç½¹ç¾ç½¾ç›ç›¥è ²é’…é’†é’‡é’‹é’Šé’Œé’é’é’é’”é’—é’•é’šé’›é’œé’£é’¤é’«é’ªé’­é’¬é’¯é’°é’²é’´é’¶", 4, "é’¼é’½é’¿é“„é“ˆ", 6, "é“é“‘é“’é“•é“–é“—é“™é“˜é“›é“é“Ÿé“ é“¢é“¤é“¥é“§é“¨é“ª"],
    ["ef40", "é¡¯", 5, "é¢‹é¢é¢’é¢•é¢™é¢£é¢¨", 37, "é£é£é£”é£–é£—é£›é£œé£é£ ", 4],
    ["ef80", "é£¥é£¦é£©", 30, "é“©é“«é“®é“¯é“³é“´é“µé“·é“¹é“¼é“½é“¿é”ƒé”‚é”†é”‡é”‰é”Šé”é”é”é”’", 4, "é”˜é”›é”é”é”Ÿé”¢é”ªé”«é”©é”¬é”±é”²é”´é”¶é”·é”¸é”¼é”¾é”¿é•‚é”µé•„é•…é•†é•‰é•Œé•é•é•’é•“é•”é•–é•—é•˜é•™é•›é•é•Ÿé•é•¡é•¢é•¤", 8, "é•¯é•±é•²é•³é”ºçŸ§çŸ¬é›‰ç§•ç§­ç§£ç§«ç¨†åµ‡ç¨ƒç¨‚ç¨ç¨”"],
    ["f040", "é¤ˆ", 4, "é¤é¤é¤‘", 28, "é¤¯", 26],
    ["f080", "é¥Š", 9, "é¥–", 12, "é¥¤é¥¦é¥³é¥¸é¥¹é¥»é¥¾é¦‚é¦ƒé¦‰ç¨¹ç¨·ç©‘é»é¦¥ç©°çšˆçšçš“çš™çš¤ç“ç“ ç”¬é¸ é¸¢é¸¨", 4, "é¸²é¸±é¸¶é¸¸é¸·é¸¹é¸ºé¸¾é¹é¹‚é¹„é¹†é¹‡é¹ˆé¹‰é¹‹é¹Œé¹é¹‘é¹•é¹—é¹šé¹›é¹œé¹é¹£é¹¦", 6, "é¹±é¹­é¹³ç–’ç–”ç––ç– ç–ç–¬ç–£ç–³ç–´ç–¸ç—„ç–±ç–°ç—ƒç—‚ç—–ç—ç—£ç—¨ç—¦ç—¤ç—«ç—§ç˜ƒç—±ç—¼ç—¿ç˜ç˜€ç˜…ç˜Œç˜—ç˜Šç˜¥ç˜˜ç˜•ç˜™"],
    ["f140", "é¦Œé¦é¦š", 10, "é¦¦é¦§é¦©", 47],
    ["f180", "é§™", 32, "ç˜›ç˜¼ç˜¢ç˜ ç™€ç˜­ç˜°ç˜¿ç˜µç™ƒç˜¾ç˜³ç™ç™ç™”ç™œç™–ç™«ç™¯ç¿Šç«¦ç©¸ç©¹çª€çª†çªˆçª•çª¦çª çª¬çª¨çª­çª³è¡¤è¡©è¡²è¡½è¡¿è¢‚è¢¢è£†è¢·è¢¼è£‰è£¢è£è££è£¥è£±è¤šè£¼è£¨è£¾è£°è¤¡è¤™è¤“è¤›è¤Šè¤´è¤«è¤¶è¥è¥¦è¥»ç–‹èƒ¥çš²çš´çŸœè€’è€”è€–è€œè€ è€¢è€¥è€¦è€§è€©è€¨è€±è€‹è€µèƒè†èè’è©è±è¦ƒé¡¸é¢€é¢ƒ"],
    ["f240", "é§º", 62],
    ["f280", "é¨¹", 32, "é¢‰é¢Œé¢é¢é¢”é¢šé¢›é¢é¢Ÿé¢¡é¢¢é¢¥é¢¦è™è™”è™¬è™®è™¿è™ºè™¼è™»èš¨èšèš‹èš¬èšèš§èš£èšªèš“èš©èš¶è›„èšµè›èš°èšºèš±èš¯è›‰è›èš´è›©è›±è›²è›­è›³è›èœ“è›è›´è›Ÿè›˜è›‘èœƒèœ‡è›¸èœˆèœŠèœèœ‰èœ£èœ»èœèœ¥èœ®èœšèœ¾èˆèœ´èœ±èœ©èœ·èœ¿è‚èœ¢è½è¾è»è è°èŒè®è‹è“è£è¼è¤è™è¥è“è¯è¨èŸ’"],
    ["f340", "é©š", 17, "é©²éªƒéª‰éªéªéª”éª•éª™éª¦éª©", 6, "éª²éª³éª´éªµéª¹éª»éª½éª¾éª¿é«ƒé«„é«†", 4, "é«é«é«é«é«’é«”é«•é«–é«—é«™é«šé«›é«œ"],
    ["f380", "é«é«é« é«¢é«£é«¤é«¥é«§é«¨é«©é«ªé«¬é«®é«°", 8, "é«ºé«¼", 6, "é¬„é¬…é¬†èŸ†èˆè…è­è—èƒè«èŸ¥è¬èµè³èŸ‹èŸ“è½èŸ‘èŸ€èŸŠèŸ›èŸªèŸ èŸ®è –è “èŸ¾è Šè ›è ¡è ¹è ¼ç¼¶ç½‚ç½„ç½…èˆç«ºç«½ç¬ˆç¬ƒç¬„ç¬•ç¬Šç¬«ç¬ç­‡ç¬¸ç¬ªç¬™ç¬®ç¬±ç¬ ç¬¥ç¬¤ç¬³ç¬¾ç¬ç­˜ç­šç­…ç­µç­Œç­ç­ ç­®ç­»ç­¢ç­²ç­±ç®ç®¦ç®§ç®¸ç®¬ç®ç®¨ç®…ç®ªç®œç®¢ç®«ç®´ç¯‘ç¯ç¯Œç¯ç¯šç¯¥ç¯¦ç¯ªç°Œç¯¾ç¯¼ç°ç°–ç°‹"],
    ["f440", "é¬‡é¬‰", 5, "é¬é¬‘é¬’é¬”", 10, "é¬ é¬¡é¬¢é¬¤", 10, "é¬°é¬±é¬³", 7, "é¬½é¬¾é¬¿é­€é­†é­Šé­‹é­Œé­é­é­’é­“é­•", 5],
    ["f480", "é­›", 32, "ç°Ÿç°ªç°¦ç°¸ç±ç±€è‡¾èˆèˆ‚èˆ„è‡¬è¡„èˆ¡èˆ¢èˆ£èˆ­èˆ¯èˆ¨èˆ«èˆ¸èˆ»èˆ³èˆ´èˆ¾è‰„è‰‰è‰‹è‰è‰šè‰Ÿè‰¨è¡¾è¢…è¢ˆè£˜è£Ÿè¥ç¾ç¾Ÿç¾§ç¾¯ç¾°ç¾²ç±¼æ•‰ç²‘ç²ç²œç²ç²¢ç²²ç²¼ç²½ç³ç³‡ç³Œç³ç³ˆç³…ç³—ç³¨è‰®æš¨ç¾¿ç¿ç¿•ç¿¥ç¿¡ç¿¦ç¿©ç¿®ç¿³ç³¸çµ·ç¶¦ç¶®ç¹‡çº›éº¸éº´èµ³è¶„è¶”è¶‘è¶±èµ§èµ­è±‡è±‰é…Šé…é…é…é…¤"],
    ["f540", "é­¼", 62],
    ["f580", "é®»", 32, "é…¢é…¡é…°é…©é…¯é…½é…¾é…²é…´é…¹é†Œé†…é†é†é†‘é†¢é†£é†ªé†­é†®é†¯é†µé†´é†ºè±•é¹¾è¶¸è·«è¸…è¹™è¹©è¶µè¶¿è¶¼è¶ºè·„è·–è·—è·šè·è·è·è·›è·†è·¬è··è·¸è·£è·¹è·»è·¤è¸‰è·½è¸”è¸è¸Ÿè¸¬è¸®è¸£è¸¯è¸ºè¹€è¸¹è¸µè¸½è¸±è¹‰è¹è¹‚è¹‘è¹’è¹Šè¹°è¹¶è¹¼è¹¯è¹´èº…èºèº”èºèºœèºè±¸è²‚è²Šè²…è²˜è²”æ–›è§–è§è§šè§œ"],
    ["f640", "é¯œ", 62],
    ["f680", "é°›", 32, "è§¥è§«è§¯è¨¾è¬¦é“é›©é›³é›¯éœ†éœéœˆéœéœéœªéœ­éœ°éœ¾é¾€é¾ƒé¾…", 5, "é¾Œé»¾é¼‹é¼éš¹éš¼éš½é›é›’ç¿é› éŠéŠ®é‹ˆéŒ¾éªéŠéé¾é‘«é±¿é²‚é²…é²†é²‡é²ˆç¨£é²‹é²é²é²‘é²’é²”é²•é²šé²›é²", 5, "é²¥", 4, "é²«é²­é²®é²°", 7, "é²ºé²»é²¼é²½é³„é³…é³†é³‡é³Šé³‹"],
    ["f740", "é°¼", 62],
    ["f780", "é±»é±½é±¾é²€é²ƒé²„é²‰é²Šé²Œé²é²“é²–é²—é²˜é²™é²é²ªé²¬é²¯é²¹é²¾", 4, "é³ˆé³‰é³‘é³’é³šé³›é³ é³¡é³Œ", 4, "é³“é³”é³•é³—é³˜é³™é³œé³é³Ÿé³¢é¼é…é‘é’é”é¯é«é£é²é´éª±éª°éª·é¹˜éª¶éªºéª¼é«é«€é«…é«‚é«‹é«Œé«‘é­…é­ƒé­‡é­‰é­ˆé­é­‘é£¨é¤é¤®é¥•é¥”é«Ÿé«¡é«¦é«¯é««é«»é«­é«¹é¬ˆé¬é¬“é¬Ÿé¬£éº½éº¾ç¸»éº‚éº‡éºˆéº‹éº’é–éºéºŸé»›é»œé»é» é»Ÿé»¢é»©é»§é»¥é»ªé»¯é¼¢é¼¬é¼¯é¼¹é¼·é¼½é¼¾é½„"],
    ["f840", "é³£", 62],
    ["f880", "é´¢", 32],
    ["f940", "éµƒ", 62],
    ["f980", "é¶‚", 32],
    ["fa40", "é¶£", 62],
    ["fa80", "é·¢", 32],
    ["fb40", "é¸ƒ", 27, "é¸¤é¸§é¸®é¸°é¸´é¸»é¸¼é¹€é¹é¹é¹’é¹“é¹”é¹–é¹™é¹é¹Ÿé¹ é¹¡é¹¢é¹¥é¹®é¹¯é¹²é¹´", 9, "éº€"],
    ["fb80", "éºéºƒéº„éº…éº†éº‰éºŠéºŒ", 5, "éº”", 8, "éºéº ", 5, "éº§éº¨éº©éºª"],
    ["fc40", "éº«", 8, "éºµéº¶éº·éº¹éººéº¼éº¿", 4, "é»…é»†é»‡é»ˆé»Šé»‹é»Œé»é»’é»“é»•é»–é»—é»™é»šé»é»¡é»£é»¤é»¦é»¨é»«é»¬é»­é»®é»°", 8, "é»ºé»½é»¿", 6],
    ["fc80", "é¼†", 4, "é¼Œé¼é¼‘é¼’é¼”é¼•é¼–é¼˜é¼š", 5, "é¼¡é¼£", 8, "é¼­é¼®é¼°é¼±"],
    ["fd40", "é¼²", 4, "é¼¸é¼ºé¼¼é¼¿", 4, "é½…", 10, "é½’", 38],
    ["fd80", "é½¹", 5, "é¾é¾‚é¾", 11, "é¾œé¾é¾é¾¡", 4, "ï¤¬ï¥¹ï¦•ï§§ï§±"],
    ["fe40", "ï¨Œï¨ï¨ï¨ï¨‘ï¨“ï¨”ï¨˜ï¨Ÿï¨ ï¨¡ï¨£ï¨¤ï¨§ï¨¨ï¨©"]
  ];
});

// node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = __commonJS((exports, module) => {
  module.exports = [
    ["a140", "î“†", 62],
    ["a180", "î”…", 32],
    ["a240", "î”¦", 62],
    ["a280", "î•¥", 32],
    ["a2ab", "î¦", 5],
    ["a2e3", "â‚¬î­"],
    ["a2ef", "î®î¯"],
    ["a2fd", "î°î±"],
    ["a340", "î–†", 62],
    ["a380", "î—…", 31, "ã€€"],
    ["a440", "î—¦", 62],
    ["a480", "î˜¥", 32],
    ["a4f4", "î²", 10],
    ["a540", "î™†", 62],
    ["a580", "îš…", 32],
    ["a5f7", "î½", 7],
    ["a640", "îš¦", 62],
    ["a680", "î›¥", 32],
    ["a6b9", "î…", 7],
    ["a6d9", "î", 6],
    ["a6ec", "î”î•"],
    ["a6f3", "î–"],
    ["a6f6", "î—", 8],
    ["a740", "îœ†", 62],
    ["a780", "î…", 32],
    ["a7c2", "î ", 14],
    ["a7f2", "î¯", 12],
    ["a896", "î¼", 10],
    ["a8bc", "á¸¿"],
    ["a8bf", "Ç¹"],
    ["a8c1", "îŸ‰îŸŠîŸ‹îŸŒ"],
    ["a8ea", "îŸ", 20],
    ["a958", "îŸ¢"],
    ["a95b", "îŸ£"],
    ["a95d", "îŸ¤îŸ¥îŸ¦"],
    ["a989", "ã€¾â¿°", 11],
    ["a997", "îŸ´", 12],
    ["a9f0", "î ", 14],
    ["aaa1", "î€€", 93],
    ["aba1", "î", 93],
    ["aca1", "î‚¼", 93],
    ["ada1", "î„š", 93],
    ["aea1", "î…¸", 93],
    ["afa1", "î‡–", 93],
    ["d7fa", "î ", 4],
    ["f8a1", "îˆ´", 93],
    ["f9a1", "îŠ’", 93],
    ["faa1", "î‹°", 93],
    ["fba1", "î", 93],
    ["fca1", "î¬", 93],
    ["fda1", "îŠ", 93],
    ["fe50", "âºî –î —î ˜âº„ã‘³ã‘‡âºˆâº‹î ã–ã˜šã˜âºŒâº—ã¥®ã¤˜î ¦ã§ã§Ÿã©³ã§î «î ¬ã­ã±®ã³ âº§î ±î ²âºªä–ä…Ÿâº®äŒ·âº³âº¶âº·î »ä±ä¬âº»ää“–ä™¡ä™Œî¡ƒ"],
    ["fe80", "äœ£äœ©ä¼äâ»Šä¥‡ä¥ºä¥½ä¦‚ä¦ƒä¦…ä¦†ä¦Ÿä¦›ä¦·ä¦¶î¡”î¡•ä²£ä²Ÿä² ä²¡ä±·ä²¢ä´“", 6, "ä¶®î¡¤î‘¨", 93],
    ["8135f437", "îŸ‡"]
  ];
});

// node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = __commonJS((exports, module) => {
  module.exports = {uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3]};
});

// node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\0", 127],
    ["8141", "ê°‚ê°ƒê°…ê°†ê°‹", 4, "ê°˜ê°ê°Ÿê°¡ê°¢ê°£ê°¥", 6, "ê°®ê°²ê°³ê°´"],
    ["8161", "ê°µê°¶ê°·ê°ºê°»ê°½ê°¾ê°¿ê±", 9, "ê±Œê±", 5, "ê±•"],
    ["8181", "ê±–ê±—ê±™ê±šê±›ê±", 18, "ê±²ê±³ê±µê±¶ê±¹ê±»", 4, "ê²‚ê²‡ê²ˆê²ê²ê²ê²‘ê²’ê²“ê²•", 6, "ê²ê²¢", 5, "ê²«ê²­ê²®ê²±", 6, "ê²ºê²¾ê²¿ê³€ê³‚ê³ƒê³…ê³†ê³‡ê³‰ê³Šê³‹ê³", 7, "ê³–ê³˜", 7, "ê³¢ê³£ê³¥ê³¦ê³©ê³«ê³­ê³®ê³²ê³´ê³·", 4, "ê³¾ê³¿ê´ê´‚ê´ƒê´…ê´‡", 4, "ê´ê´ê´’ê´“"],
    ["8241", "ê´”ê´•ê´–ê´—ê´™ê´šê´›ê´ê´ê´Ÿê´¡", 7, "ê´ªê´«ê´®", 5],
    ["8261", "ê´¶ê´·ê´¹ê´ºê´»ê´½", 6, "êµ†êµˆêµŠ", 5, "êµ‘êµ’êµ“êµ•êµ–êµ—"],
    ["8281", "êµ™", 7, "êµ¢êµ¤", 7, "êµ®êµ¯êµ±êµ²êµ·êµ¸êµ¹êµºêµ¾ê¶€ê¶ƒ", 4, "ê¶Šê¶‹ê¶ê¶ê¶ê¶‘", 10, "ê¶", 5, "ê¶¥", 17, "ê¶¸", 7, "ê·‚ê·ƒê·…ê·†ê·‡ê·‰", 6, "ê·’ê·”", 7, "ê·ê·ê·Ÿê·¡ê·¢ê·£ê·¥", 18],
    ["8341", "ê·ºê·»ê·½ê·¾ê¸‚", 5, "ê¸Šê¸Œê¸", 5, "ê¸•", 7],
    ["8361", "ê¸", 18, "ê¸²ê¸³ê¸µê¸¶ê¸¹ê¸»ê¸¼"],
    ["8381", "ê¸½ê¸¾ê¸¿ê¹‚ê¹„ê¹‡ê¹ˆê¹‰ê¹‹ê¹ê¹‘ê¹’ê¹“ê¹•ê¹—", 4, "ê¹ê¹¢ê¹£ê¹¤ê¹¦ê¹§ê¹ªê¹«ê¹­ê¹®ê¹¯ê¹±", 6, "ê¹ºê¹¾", 5, "êº†", 5, "êº", 46, "êº¿ê»ê»‚ê»ƒê»…", 6, "ê»ê»’", 5, "ê»šê»›ê»", 8],
    ["8441", "ê»¦ê»§ê»©ê»ªê»¬ê»®", 5, "ê»µê»¶ê»·ê»¹ê»ºê»»ê»½", 8],
    ["8461", "ê¼†ê¼‰ê¼Šê¼‹ê¼Œê¼ê¼ê¼‘", 18],
    ["8481", "ê¼¤", 7, "ê¼®ê¼¯ê¼±ê¼³ê¼µ", 6, "ê¼¾ê½€ê½„ê½…ê½†ê½‡ê½Š", 5, "ê½‘", 10, "ê½", 5, "ê½¦", 18, "ê½º", 5, "ê¾ê¾‚ê¾ƒê¾…ê¾†ê¾‡ê¾‰", 6, "ê¾’ê¾“ê¾”ê¾–", 5, "ê¾", 26, "ê¾ºê¾»ê¾½ê¾¾"],
    ["8541", "ê¾¿ê¿", 5, "ê¿Šê¿Œê¿", 4, "ê¿•", 6, "ê¿", 4],
    ["8561", "ê¿¢", 5, "ê¿ª", 5, "ê¿²ê¿³ê¿µê¿¶ê¿·ê¿¹", 6, "ë€‚ë€ƒ"],
    ["8581", "ë€…", 6, "ë€ë€ë€ë€‘ë€’ë€“ë€•", 6, "ë€", 9, "ë€©", 26, "ë†ë‡ë‰ë‹ëëëë‘ë’ë–ë˜ëšë›ëœë", 29, "ë¾ë¿ë‚ë‚‚ë‚ƒë‚…", 6, "ë‚ë‚ë‚’", 5, "ë‚›ë‚ë‚ë‚£ë‚¤"],
    ["8641", "ë‚¥ë‚¦ë‚§ë‚ªë‚°ë‚²ë‚¶ë‚·ë‚¹ë‚ºë‚»ë‚½", 6, "ëƒ†ëƒŠ", 5, "ëƒ’"],
    ["8661", "ëƒ“ëƒ•ëƒ–ëƒ—ëƒ™", 6, "ëƒ¡ëƒ¢ëƒ£ëƒ¤ëƒ¦", 10],
    ["8681", "ëƒ±", 22, "ë„Šë„ë„ë„ë„‘ë„”ë„•ë„–ë„—ë„šë„", 4, "ë„¦ë„§ë„©ë„ªë„«ë„­", 6, "ë„¶ë„º", 5, "ë…‚ë…ƒë……ë…†ë…‡ë…‰", 6, "ë…’ë…“ë…–ë…—ë…™ë…šë…›ë…ë…ë…Ÿë…¡", 22, "ë…ºë…»ë…½ë…¾ë…¿ë†ë†ƒ", 4, "ë†Šë†Œë†ë†ë†ë†‘ë†•ë†–ë†—ë†™ë†šë†›ë†"],
    ["8741", "ë†", 9, "ë†©", 15],
    ["8761", "ë†¹", 18, "ë‡ë‡ë‡ë‡‘ë‡’ë‡“ë‡•"],
    ["8781", "ë‡–", 5, "ë‡ë‡ ", 7, "ë‡ªë‡«ë‡­ë‡®ë‡¯ë‡±", 7, "ë‡ºë‡¼ë‡¾", 5, "ëˆ†ëˆ‡ëˆ‰ëˆŠëˆ", 6, "ëˆ–ëˆ˜ëˆš", 5, "ëˆ¡", 18, "ëˆµ", 6, "ëˆ½", 26, "ë‰™ë‰šë‰›ë‰ë‰ë‰Ÿë‰¡", 6, "ë‰ª", 4],
    ["8841", "ë‰¯", 4, "ë‰¶", 5, "ë‰½", 6, "ëŠ†ëŠ‡ëŠˆëŠŠ", 4],
    ["8861", "ëŠëŠ’ëŠ“ëŠ•ëŠ–ëŠ—ëŠ›", 4, "ëŠ¢ëŠ¤ëŠ§ëŠ¨ëŠ©ëŠ«ëŠ­ëŠ®ëŠ¯ëŠ±ëŠ²ëŠ³ëŠµëŠ¶ëŠ·"],
    ["8881", "ëŠ¸", 15, "ë‹Šë‹‹ë‹ë‹ë‹ë‹‘ë‹“", 4, "ë‹šë‹œë‹ë‹Ÿë‹ ë‹¡ë‹£ë‹§ë‹©ë‹ªë‹°ë‹±ë‹²ë‹¶ë‹¼ë‹½ë‹¾ëŒ‚ëŒƒëŒ…ëŒ†ëŒ‡ëŒ‰", 6, "ëŒ’ëŒ–", 5, "ëŒ", 54, "ë—ë™ëšëë ë¡ë¢ë£"],
    ["8941", "ë¦ë¨ëªë¬ë­ë¯ë²ë³ëµë¶ë·ë¹", 6, "ë‚ë†", 5, "ë"],
    ["8961", "ëëë‘ë’ë“ë•", 10, "ë¢", 5, "ë©ëªë«ë­"],
    ["8981", "ë®", 21, "ë†ë‡ë‰ëŠëëë‘ë’ë“ë–ë˜ëšëœëëŸë¡ë¢ë£ë¥ë¦ë§ë©", 18, "ë½", 18, "ë‘", 6, "ë™ëšë›ëëëŸë¡", 6, "ëªë¬", 7, "ëµ", 15],
    ["8a41", "ë‘…", 10, "ë‘’ë‘“ë‘•ë‘–ë‘—ë‘™", 6, "ë‘¢ë‘¤ë‘¦"],
    ["8a61", "ë‘§", 4, "ë‘­", 18, "ë’ë’‚"],
    ["8a81", "ë’ƒ", 4, "ë’‰", 19, "ë’", 5, "ë’¥ë’¦ë’§ë’©ë’ªë’«ë’­", 7, "ë’¶ë’¸ë’º", 5, "ë“ë“‚ë“ƒë“…ë“†ë“‡ë“‰", 6, "ë“‘ë“’ë““ë“”ë“–", 5, "ë“ë“Ÿë“¡ë“¢ë“¥ë“§", 4, "ë“®ë“°ë“²", 5, "ë“¹", 26, "ë”–ë”—ë”™ë”šë”"],
    ["8b41", "ë”", 5, "ë”¦ë”«", 4, "ë”²ë”³ë”µë”¶ë”·ë”¹", 6, "ë•‚ë•†"],
    ["8b61", "ë•‡ë•ˆë•‰ë•Šë•ë•ë•‘ë•’ë•“ë••", 6, "ë•ë•¢", 8],
    ["8b81", "ë•«", 52, "ë–¢ë–£ë–¥ë–¦ë–§ë–©ë–¬ë–­ë–®ë–¯ë–²ë–¶", 4, "ë–¾ë–¿ë—ë—‚ë—ƒë—…", 6, "ë—ë—’", 5, "ë—™", 18, "ë—­", 18],
    ["8c41", "ë˜€", 15, "ë˜’ë˜“ë˜•ë˜–ë˜—ë˜™", 4],
    ["8c61", "ë˜", 6, "ë˜¦", 5, "ë˜­", 6, "ë˜µ", 5],
    ["8c81", "ë˜»", 12, "ë™‰", 26, "ë™¥ë™¦ë™§ë™©", 50, "ëšëšŸëš¡ëš¢ëš£ëš¥", 5, "ëš­ëš®ëš¯ëš°ëš²", 16],
    ["8d41", "ë›ƒ", 16, "ë›•", 8],
    ["8d61", "ë›", 17, "ë›±ë›²ë›³ë›µë›¶ë›·ë›¹ë›º"],
    ["8d81", "ë›»", 4, "ëœ‚ëœƒëœ„ëœ†", 33, "ëœªëœ«ëœ­ëœ®ëœ±", 6, "ëœºëœ¼", 7, "ë…ë†ë‡ë‰ëŠë‹ë", 6, "ë–", 9, "ë¡ë¢ë£ë¥ë¦ë§ë©", 6, "ë²ë´ë¶", 5, "ë¾ë¿ëë‚ëƒë…", 6, "ëë“ë”ë•ëšë›ëë"],
    ["8e41", "ëŸë¡", 6, "ëªë®", 5, "ë¶ë·ë¹", 8],
    ["8e61", "ëŸ‚", 4, "ëŸˆëŸŠ", 19],
    ["8e81", "ëŸ", 13, "ëŸ®ëŸ¯ëŸ±ëŸ²ëŸ³ëŸµ", 6, "ëŸ¾ë ‚", 4, "ë Šë ‹ë ë ë ë ‘", 6, "ë šë œë ", 5, "ë ¦ë §ë ©ë ªë «ë ­", 6, "ë ¶ë º", 5, "ë¡ë¡‚ë¡ƒë¡…", 11, "ë¡’ë¡”", 7, "ë¡ë¡Ÿë¡¡ë¡¢ë¡£ë¡¥", 6, "ë¡®ë¡°ë¡²", 5, "ë¡¹ë¡ºë¡»ë¡½", 7],
    ["8f41", "ë¢…", 7, "ë¢", 17],
    ["8f61", "ë¢ ", 7, "ë¢©", 6, "ë¢±ë¢²ë¢³ë¢µë¢¶ë¢·ë¢¹", 4],
    ["8f81", "ë¢¾ë¢¿ë£‚ë£„ë£†", 5, "ë£ë£ë£ë£‘ë£’ë£“ë£•", 7, "ë£ë£ ë£¢", 5, "ë£ªë£«ë£­ë£®ë£¯ë£±", 6, "ë£ºë£¼ë£¾", 5, "ë¤…", 18, "ë¤™", 6, "ë¤¡", 26, "ë¤¾ë¤¿ë¥ë¥‚ë¥ƒë¥…", 6, "ë¥ë¥ë¥ë¥’", 5],
    ["9041", "ë¥šë¥›ë¥ë¥ë¥Ÿë¥¡", 6, "ë¥ªë¥¬ë¥®", 5, "ë¥¶ë¥·ë¥¹ë¥ºë¥»ë¥½"],
    ["9061", "ë¥¾", 5, "ë¦†ë¦ˆë¦‹ë¦Œë¦", 15],
    ["9081", "ë¦Ÿ", 12, "ë¦®ë¦¯ë¦±ë¦²ë¦³ë¦µ", 6, "ë¦¾ë§€ë§‚", 5, "ë§Šë§‹ë§ë§“", 4, "ë§šë§œë§Ÿë§ ë§¢ë§¦ë§§ë§©ë§ªë§«ë§­", 6, "ë§¶ë§»", 4, "ë¨‚", 5, "ë¨‰", 11, "ë¨–", 33, "ë¨ºë¨»ë¨½ë¨¾ë¨¿ë©ë©ƒë©„ë©…ë©†"],
    ["9141", "ë©‡ë©Šë©Œë©ë©ë©‘ë©’ë©–ë©—ë©™ë©šë©›ë©", 6, "ë©¦ë©ª", 5],
    ["9161", "ë©²ë©³ë©µë©¶ë©·ë©¹", 9, "ëª†ëªˆëª‰ëªŠëª‹ëª", 5],
    ["9181", "ëª“", 20, "ëªªëª­ëª®ëª¯ëª±ëª³", 4, "ëªºëª¼ëª¾", 5, "ë«…ë«†ë«‡ë«‰", 14, "ë«š", 33, "ë«½ë«¾ë«¿ë¬ë¬‚ë¬ƒë¬…", 7, "ë¬ë¬ë¬’", 5, "ë¬™ë¬šë¬›ë¬ë¬ë¬Ÿë¬¡", 6],
    ["9241", "ë¬¨ë¬ªë¬¬", 7, "ë¬·ë¬¹ë¬ºë¬¿", 4, "ë­†ë­ˆë­Šë­‹ë­Œë­ë­‘ë­’"],
    ["9261", "ë­“ë­•ë­–ë­—ë­™", 7, "ë­¢ë­¤", 7, "ë­­", 4],
    ["9281", "ë­²", 21, "ë®‰ë®Šë®‹ë®ë®ë®ë®‘", 18, "ë®¥ë®¦ë®§ë®©ë®ªë®«ë®­", 6, "ë®µë®¶ë®¸", 7, "ë¯ë¯‚ë¯ƒë¯…ë¯†ë¯‡ë¯‰", 6, "ë¯‘ë¯’ë¯”", 35, "ë¯ºë¯»ë¯½ë¯¾ë°"],
    ["9341", "ë°ƒ", 4, "ë°Šë°ë°ë°’ë°“ë°™ë°šë° ë°¡ë°¢ë°£ë°¦ë°¨ë°ªë°«ë°¬ë°®ë°¯ë°²ë°³ë°µ"],
    ["9361", "ë°¶ë°·ë°¹", 6, "ë±‚ë±†ë±‡ë±ˆë±Šë±‹ë±ë±ë±‘", 8],
    ["9381", "ë±šë±›ë±œë±", 37, "ë²†ë²‡ë²‰ë²Šë²ë²", 4, "ë²–ë²˜ë²›", 4, "ë²¢ë²£ë²¥ë²¦ë²©", 6, "ë²²ë²¶", 5, "ë²¾ë²¿ë³ë³‚ë³ƒë³…", 7, "ë³ë³’ë³“ë³”ë³–ë³—ë³™ë³šë³›ë³", 22, "ë³·ë³¹ë³ºë³»ë³½"],
    ["9441", "ë³¾", 5, "ë´†ë´ˆë´Š", 5, "ë´‘ë´’ë´“ë´•", 8],
    ["9461", "ë´", 5, "ë´¥", 6, "ë´­", 12],
    ["9481", "ë´º", 5, "ëµ", 6, "ëµŠëµ‹ëµëµëµëµ‘", 6, "ëµš", 9, "ëµ¥ëµ¦ëµ§ëµ©", 22, "ë¶‚ë¶ƒë¶…ë¶†ë¶‹", 4, "ë¶’ë¶”ë¶–ë¶—ë¶˜ë¶›ë¶", 6, "ë¶¥", 10, "ë¶±", 6, "ë¶¹", 24],
    ["9541", "ë·’ë·“ë·–ë·—ë·™ë·šë·›ë·", 11, "ë·ª", 5, "ë·±"],
    ["9561", "ë·²ë·³ë·µë·¶ë··ë·¹", 6, "ë¸ë¸‚ë¸„ë¸†", 5, "ë¸ë¸ë¸‘ë¸’ë¸“"],
    ["9581", "ë¸•", 6, "ë¸ë¸ ", 35, "ë¹†ë¹‡ë¹‰ë¹Šë¹‹ë¹ë¹", 4, "ë¹–ë¹˜ë¹œë¹ë¹ë¹Ÿë¹¢ë¹£ë¹¥ë¹¦ë¹§ë¹©ë¹«", 4, "ë¹²ë¹¶", 4, "ë¹¾ë¹¿ëºëº‚ëºƒëº…", 6, "ëºëº’", 5, "ëºš", 13, "ëº©", 14],
    ["9641", "ëº¸", 23, "ë»’ë»“"],
    ["9661", "ë»•ë»–ë»™", 6, "ë»¡ë»¢ë»¦", 5, "ë»­", 8],
    ["9681", "ë»¶", 10, "ë¼‚", 5, "ë¼Š", 13, "ë¼šë¼", 33, "ë½‚ë½ƒë½…ë½†ë½‡ë½‰", 6, "ë½’ë½“ë½”ë½–", 44],
    ["9741", "ë¾ƒ", 16, "ë¾•", 8],
    ["9761", "ë¾", 17, "ë¾±", 7],
    ["9781", "ë¾¹", 11, "ë¿†", 5, "ë¿ë¿ë¿‘ë¿’ë¿“ë¿•", 6, "ë¿ë¿ë¿ ë¿¢", 89, "ì€½ì€¾ì€¿"],
    ["9841", "ì€", 16, "ì’", 5, "ì™ìšì›"],
    ["9861", "ìììŸì¡", 6, "ìª", 15],
    ["9881", "ìº", 21, "ì‚’ì‚“ì‚•ì‚–ì‚—ì‚™", 6, "ì‚¢ì‚¤ì‚¦", 5, "ì‚®ì‚±ì‚²ì‚·", 4, "ì‚¾ìƒ‚ìƒƒìƒ„ìƒ†ìƒ‡ìƒŠìƒ‹ìƒìƒìƒìƒ‘", 6, "ìƒšìƒ", 5, "ìƒ¦ìƒ§ìƒ©ìƒªìƒ«ìƒ­", 6, "ìƒ¶ìƒ¸ìƒº", 5, "ì„ì„‚ì„ƒì„…ì„†ì„‡ì„‰", 6, "ì„‘ì„’ì„“ì„”ì„–", 5, "ì„¡ì„¢ì„¥ì„¨ì„©ì„ªì„«ì„®"],
    ["9941", "ì„²ì„³ì„´ì„µì„·ì„ºì„»ì„½ì„¾ì„¿ì…", 6, "ì…Šì…", 5, "ì…–ì…—"],
    ["9961", "ì…™ì…šì…›ì…", 6, "ì…¦ì…ª", 5, "ì…±ì…²ì…³ì…µì…¶ì…·ì…¹ì…ºì…»"],
    ["9981", "ì…¼", 8, "ì††", 5, "ì†ì†‘ì†’ì†“ì†•ì†—", 4, "ì†ì† ì†¢ì†£ì†¤ì†¦ì†§ì†ªì†«ì†­ì†®ì†¯ì†±", 11, "ì†¾", 5, "ì‡…ì‡†ì‡‡ì‡‰ì‡Šì‡‹ì‡", 6, "ì‡•ì‡–ì‡™", 6, "ì‡¡ì‡¢ì‡£ì‡¥ì‡¦ì‡§ì‡©", 6, "ì‡²ì‡´", 7, "ì‡¾ì‡¿ìˆìˆ‚ìˆƒìˆ…", 6, "ìˆìˆìˆ’", 5, "ìˆšìˆ›ìˆìˆìˆ¡ìˆ¢ìˆ£"],
    ["9a41", "ìˆ¤ìˆ¥ìˆ¦ìˆ§ìˆªìˆ¬ìˆ®ìˆ°ìˆ³ìˆµ", 16],
    ["9a61", "ì‰†ì‰‡ì‰‰", 6, "ì‰’ì‰“ì‰•ì‰–ì‰—ì‰™", 6, "ì‰¡ì‰¢ì‰£ì‰¤ì‰¦"],
    ["9a81", "ì‰§", 4, "ì‰®ì‰¯ì‰±ì‰²ì‰³ì‰µ", 6, "ì‰¾ìŠ€ìŠ‚", 5, "ìŠŠ", 5, "ìŠ‘", 6, "ìŠ™ìŠšìŠœìŠ", 5, "ìŠ¦ìŠ§ìŠ©ìŠªìŠ«ìŠ®", 5, "ìŠ¶ìŠ¸ìŠº", 33, "ì‹ì‹Ÿì‹¡ì‹¢ì‹¥", 5, "ì‹®ì‹°ì‹²ì‹³ì‹´ì‹µì‹·ì‹ºì‹½ì‹¾ì‹¿ìŒ", 6, "ìŒŠìŒ‹ìŒìŒ"],
    ["9b41", "ìŒìŒ‘ìŒ’ìŒ–ìŒ—ìŒ™ìŒšìŒ›ìŒ", 6, "ìŒ¦ìŒ§ìŒª", 8],
    ["9b61", "ìŒ³", 17, "ì†", 7],
    ["9b81", "ì", 25, "ìªì«ì­ì®ì¯ì±ì³", 4, "ìºì»ì¾", 5, "ì…ì†ì‡ì‰ìŠì‹ì", 50, "ì", 22, "ìš"],
    ["9c41", "ì›ììì¡ì£", 4, "ìªì«ì¬ì®", 5, "ì¶ì·ì¹", 5],
    ["9c61", "ì¿", 8, "ì‰", 6, "ì‘", 9],
    ["9c81", "ì›", 8, "ì¥", 6, "ì­ì®ì¯ì±ì²ì³ìµ", 6, "ì¾", 9, "ì‘‰", 26, "ì‘¦ì‘§ì‘©ì‘ªì‘«ì‘­", 6, "ì‘¶ì‘·ì‘¸ì‘º", 5, "ì’", 18, "ì’•", 6, "ì’", 12],
    ["9d41", "ì’ª", 13, "ì’¹ì’ºì’»ì’½", 8],
    ["9d61", "ì“†", 25],
    ["9d81", "ì“ ", 8, "ì“ª", 5, "ì“²ì“³ì“µì“¶ì“·ì“¹ì“»ì“¼ì“½ì“¾ì”‚", 9, "ì”ì”ì”ì”‘ì”’ì”“ì”•", 6, "ì”", 10, "ì”ªì”«ì”­ì”®ì”¯ì”±", 6, "ì”ºì”¼ì”¾", 5, "ì•†ì•‡ì•‹ì•ì•ì•‘ì•’ì•–ì•šì•›ì•œì•Ÿì•¢ì•£ì•¥ì•¦ì•§ì•©", 6, "ì•²ì•¶", 5, "ì•¾ì•¿ì–ì–‚ì–ƒì–…ì–†ì–ˆì–‰ì–Šì–‹ì–ì–ì–’ì–“ì–”"],
    ["9e41", "ì––ì–™ì–šì–›ì–ì–ì–Ÿì–¡", 7, "ì–ª", 9, "ì–¶"],
    ["9e61", "ì–·ì–ºì–¿", 4, "ì—‹ì—ì—ì—’ì—“ì—•ì—–ì——ì—™", 6, "ì—¢ì—¤ì—¦ì—§"],
    ["9e81", "ì—¨ì—©ì—ªì—«ì—¯ì—±ì—²ì—³ì—µì—¸ì—¹ì—ºì—»ì˜‚ì˜ƒì˜„ì˜‰ì˜Šì˜‹ì˜ì˜ì˜ì˜‘", 6, "ì˜šì˜", 6, "ì˜¦ì˜§ì˜©ì˜ªì˜«ì˜¯ì˜±ì˜²ì˜¶ì˜¸ì˜ºì˜¼ì˜½ì˜¾ì˜¿ì™‚ì™ƒì™…ì™†ì™‡ì™‰", 6, "ì™’ì™–", 5, "ì™ì™Ÿì™¡", 10, "ì™­ì™®ì™°ì™²", 5, "ì™ºì™»ì™½ì™¾ì™¿ìš", 6, "ìšŠìšŒìš", 5, "ìš–ìš—ìš™ìššìš›ìš", 6, "ìš¦"],
    ["9f41", "ìš¨ìšª", 5, "ìš²ìš³ìšµìš¶ìš·ìš»", 4, "ì›‚ì›„ì›†", 5, "ì›"],
    ["9f61", "ì›ì›‘ì›’ì›“ì›•", 6, "ì›ì›Ÿì›¢", 5, "ì›ªì›«ì›­ì›®ì›¯ì›±ì›²"],
    ["9f81", "ì›³", 4, "ì›ºì›»ì›¼ì›¾", 5, "ìœ†ìœ‡ìœ‰ìœŠìœ‹ìœ", 6, "ìœ–ìœ˜ìœš", 5, "ìœ¢ìœ£ìœ¥ìœ¦ìœ§ìœ©", 6, "ìœ²ìœ´ìœ¶ìœ¸ìœ¹ìœºìœ»ìœ¾ìœ¿ìì‚ìƒì…", 4, "ì‹ììì™ìšì›ìììŸì¡", 6, "ì©ìªì¬", 7, "ì¶ì·ì¹ìºì»ì¿ì€ìì‚ì†ì‹ìŒììì’ì“ì•ì™ì›", 4, "ì¢ì§", 4, "ì®ì¯ì±ì²ì³ìµì¶ì·"],
    ["a041", "ì¸ì¹ìºì»ì¾ìŸ‚", 5, "ìŸŠìŸ‹ìŸìŸìŸ‘", 6, "ìŸ™ìŸšìŸ›ìŸœ"],
    ["a061", "ìŸ", 5, "ìŸ¥ìŸ¦ìŸ§ìŸ©ìŸªìŸ«ìŸ­", 13],
    ["a081", "ìŸ»", 4, "ì ‚ì ƒì …ì †ì ‡ì ‰ì ‹", 4, "ì ’ì ”ì —", 4, "ì ì Ÿì ¡ì ¢ì £ì ¥", 6, "ì ®ì °ì ²", 5, "ì ¹ì ºì »ì ½ì ¾ì ¿ì¡", 6, "ì¡Šì¡‹ì¡", 5, "ì¡•", 26, "ì¡²ì¡³ì¡µì¡¶ì¡·ì¡¹ì¡»", 4, "ì¢‚ì¢„ì¢ˆì¢‰ì¢Šì¢", 5, "ì¢•", 7, "ì¢ì¢ ì¢¢ì¢£ì¢¤"],
    ["a141", "ì¢¥ì¢¦ì¢§ì¢©", 18, "ì¢¾ì¢¿ì£€ì£"],
    ["a161", "ì£‚ì£ƒì£…ì£†ì£‡ì£‰ì£Šì£‹ì£", 6, "ì£–ì£˜ì£š", 5, "ì£¢ì££ì£¥"],
    ["a181", "ì£¦", 14, "ì£¶", 5, "ì£¾ì£¿ì¤ì¤‚ì¤ƒì¤‡", 4, "ì¤ã€€ã€ã€‚Â·â€¥â€¦Â¨ã€ƒÂ­â€•âˆ¥ï¼¼âˆ¼â€˜â€™â€œâ€ã€”ã€•ã€ˆ", 9, "Â±Ã—Ã·â‰ â‰¤â‰¥âˆâˆ´Â°â€²â€³â„ƒâ„«ï¿ ï¿¡ï¿¥â™‚â™€âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’Â§â€»â˜†â˜…â—‹â—â—â—‡â—†â–¡â– â–³â–²â–½â–¼â†’â†â†‘â†“â†”ã€“â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©âˆ§âˆ¨ï¿¢"],
    ["a241", "ì¤ì¤’", 5, "ì¤™", 18],
    ["a261", "ì¤­", 6, "ì¤µ", 18],
    ["a281", "ì¥ˆ", 7, "ì¥’ì¥“ì¥•ì¥–ì¥—ì¥™", 6, "ì¥¢ì¥¤", 7, "ì¥­ì¥®ì¥¯â‡’â‡”âˆ€âˆƒÂ´ï½Ë‡Ë˜ËËšË™Â¸Ë›Â¡Â¿Ëâˆ®âˆ‘âˆÂ¤â„‰â€°â—â—€â–·â–¶â™¤â™ â™¡â™¥â™§â™£âŠ™â—ˆâ–£â—â—‘â–’â–¤â–¥â–¨â–§â–¦â–©â™¨â˜â˜â˜œâ˜Â¶â€ â€¡â†•â†—â†™â†–â†˜â™­â™©â™ªâ™¬ã‰¿ãˆœâ„–ã‡â„¢ã‚ã˜â„¡â‚¬Â®"],
    ["a341", "ì¥±ì¥²ì¥³ì¥µ", 6, "ì¥½", 10, "ì¦Šì¦‹ì¦ì¦ì¦"],
    ["a361", "ì¦‘", 6, "ì¦šì¦œì¦", 16],
    ["a381", "ì¦¯", 16, "ì§‚ì§ƒì§…ì§†ì§‰ì§‹", 4, "ì§’ì§”ì§—ì§˜ì§›ï¼", 58, "ï¿¦ï¼½", 32, "ï¿£"],
    ["a441", "ì§ì§Ÿì§¡ì§£ì§¥ì§¦ì§¨ì§©ì§ªì§«ì§®ì§²", 5, "ì§ºì§»ì§½ì§¾ì§¿ì¨ì¨‚ì¨ƒì¨„"],
    ["a461", "ì¨…ì¨†ì¨‡ì¨Šì¨", 5, "ì¨•ì¨–ì¨—ì¨™", 12],
    ["a481", "ì¨¦ì¨§ì¨¨ì¨ª", 28, "ã„±", 93],
    ["a541", "ì©‡", 4, "ì©ì©ì©‘ì©’ì©“ì©•", 6, "ì©ì©¢", 5, "ì©©ì©ª"],
    ["a561", "ì©«", 17, "ì©¾", 5, "ìª…ìª†"],
    ["a581", "ìª‡", 16, "ìª™", 14, "â…°", 9],
    ["a5b0", "â… ", 9],
    ["a5c1", "Î‘", 16, "Î£", 6],
    ["a5e1", "Î±", 16, "Ïƒ", 6],
    ["a641", "ìª¨", 19, "ìª¾ìª¿ì«ì«‚ì«ƒì«…"],
    ["a661", "ì«†", 5, "ì«ì«ì«’ì«”ì«•ì«–ì«—ì«š", 5, "ì«¡", 6],
    ["a681", "ì«¨ì«©ì«ªì««ì«­", 6, "ì«µ", 18, "ì¬‰ì¬Šâ”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚â”’â”‘â”šâ”™â”–â”•â”â”â”â”Ÿâ”¡â”¢â”¦â”§â”©â”ªâ”­â”®â”±â”²â”µâ”¶â”¹â”ºâ”½â”¾â•€â•â•ƒ", 7],
    ["a741", "ì¬‹", 4, "ì¬‘ì¬’ì¬“ì¬•ì¬–ì¬—ì¬™", 6, "ì¬¢", 7],
    ["a761", "ì¬ª", 22, "ì­‚ì­ƒì­„"],
    ["a781", "ì­…ì­†ì­‡ì­Šì­‹ì­ì­ì­ì­‘", 6, "ì­šì­›ì­œì­", 5, "ì­¥", 7, "ã•ã–ã—â„“ã˜ã„ã£ã¤ã¥ã¦ã™", 9, "ãŠãããããˆã‰ãˆã§ã¨ã°", 9, "ã€", 4, "ãº", 5, "ã", 4, "â„¦ã€ããŠã‹ãŒã–ã…ã­ã®ã¯ã›ã©ãªã«ã¬ããã“ãƒã‰ãœã†"],
    ["a841", "ì­­", 10, "ì­º", 14],
    ["a861", "ì®‰", 18, "ì®", 6],
    ["a881", "ì®¤", 19, "ì®¹", 11, "Ã†ÃÂªÄ¦"],
    ["a8a6", "Ä²"],
    ["a8a8", "Ä¿ÅÃ˜Å’ÂºÃÅ¦ÅŠ"],
    ["a8b1", "ã‰ ", 27, "â“", 25, "â‘ ", 14, "Â½â…“â…”Â¼Â¾â…›â…œâ…â…"],
    ["a941", "ì¯…", 14, "ì¯•", 10],
    ["a961", "ì¯ ì¯¡ì¯¢ì¯£ì¯¥ì¯¦ì¯¨ì¯ª", 18],
    ["a981", "ì¯½", 14, "ì°ì°ì°‘ì°’ì°“ì°•", 6, "ì°ì°Ÿì° ì°£ì°¤Ã¦Ä‘Ã°Ä§Ä±Ä³Ä¸Å€Å‚Ã¸Å“ÃŸÃ¾Å§Å‹Å‰ãˆ€", 27, "â’œ", 25, "â‘´", 14, "Â¹Â²Â³â´â¿â‚â‚‚â‚ƒâ‚„"],
    ["aa41", "ì°¥ì°¦ì°ªì°«ì°­ì°¯ì°±", 6, "ì°ºì°¿", 4, "ì±†ì±‡ì±‰ì±Šì±‹ì±ì±"],
    ["aa61", "ì±", 4, "ì±–ì±š", 5, "ì±¡ì±¢ì±£ì±¥ì±§ì±©", 6, "ì±±ì±²"],
    ["aa81", "ì±³ì±´ì±¶", 29, "ã", 82],
    ["ab41", "ì²”ì²•ì²–ì²—ì²šì²›ì²ì²ì²Ÿì²¡", 6, "ì²ªì²®", 5, "ì²¶ì²·ì²¹"],
    ["ab61", "ì²ºì²»ì²½", 6, "ì³†ì³ˆì³Š", 5, "ì³‘ì³’ì³“ì³•", 5],
    ["ab81", "ì³›", 8, "ì³¥", 6, "ì³­ì³®ì³¯ì³±", 12, "ã‚¡", 85],
    ["ac41", "ì³¾ì³¿ì´€ì´‚", 5, "ì´Šì´‹ì´ì´ì´ì´‘", 6, "ì´šì´œì´ì´Ÿì´ "],
    ["ac61", "ì´¡ì´¢ì´£ì´¥ì´¦ì´§ì´©ì´ªì´«ì´­", 11, "ì´º", 4],
    ["ac81", "ì´¿", 28, "ìµìµìµŸĞ", 5, "ĞĞ–", 25],
    ["acd1", "Ğ°", 5, "Ñ‘Ğ¶", 25],
    ["ad41", "ìµ¡ìµ¢ìµ£ìµ¥", 6, "ìµ®ìµ°ìµ²", 5, "ìµ¹", 7],
    ["ad61", "ì¶", 6, "ì¶‰", 10, "ì¶–ì¶—ì¶™ì¶šì¶›ì¶ì¶ì¶Ÿ"],
    ["ad81", "ì¶ ì¶¡ì¶¢ì¶£ì¶¦ì¶¨ì¶ª", 5, "ì¶±", 18, "ì·…"],
    ["ae41", "ì·†", 5, "ì·ì·ì·ì·‘", 16],
    ["ae61", "ì·¢", 5, "ì·©ì·ªì·«ì·­ì·®ì·¯ì·±", 6, "ì·ºì·¼ì·¾", 4],
    ["ae81", "ì¸ƒì¸…ì¸†ì¸‡ì¸‰ì¸Šì¸‹ì¸", 6, "ì¸•ì¸–ì¸—ì¸˜ì¸š", 5, "ì¸¢ì¸£ì¸¥ì¸¦ì¸§ì¸©ì¸ªì¸«"],
    ["af41", "ì¸¬ì¸­ì¸®ì¸¯ì¸²ì¸´ì¸¶", 19],
    ["af61", "ì¹Š", 13, "ì¹šì¹›ì¹ì¹ì¹¢", 5, "ì¹ªì¹¬"],
    ["af81", "ì¹®", 5, "ì¹¶ì¹·ì¹¹ì¹ºì¹»ì¹½", 6, "ìº†ìºˆìºŠ", 5, "ìº’ìº“ìº•ìº–ìº—ìº™"],
    ["b041", "ìºš", 5, "ìº¢ìº¦", 5, "ìº®", 12],
    ["b061", "ìº»", 5, "ì»‚", 19],
    ["b081", "ì»–", 13, "ì»¦ì»§ì»©ì»ªì»­", 6, "ì»¶ì»º", 5, "ê°€ê°ê°„ê°‡ê°ˆê°‰ê°Šê°", 7, "ê°™", 4, "ê° ê°¤ê°¬ê°­ê°¯ê°°ê°±ê°¸ê°¹ê°¼ê±€ê±‹ê±ê±”ê±˜ê±œê±°ê±±ê±´ê±·ê±¸ê±ºê²€ê²ê²ƒê²„ê²…ê²†ê²‰ê²Šê²‹ê²Œê²ê²”ê²œê²ê²Ÿê² ê²¡ê²¨ê²©ê²ªê²¬ê²¯ê²°ê²¸ê²¹ê²»ê²¼ê²½ê³ê³„ê³ˆê³Œê³•ê³—ê³ ê³¡ê³¤ê³§ê³¨ê³ªê³¬ê³¯ê³°ê³±ê³³ê³µê³¶ê³¼ê³½ê´€ê´„ê´†"],
    ["b141", "ì¼‚ì¼ƒì¼…ì¼†ì¼‡ì¼‰", 6, "ì¼’ì¼”ì¼–", 5, "ì¼ì¼ì¼Ÿì¼¡ì¼¢ì¼£"],
    ["b161", "ì¼¥", 6, "ì¼®ì¼²", 5, "ì¼¹", 11],
    ["b181", "ì½…", 14, "ì½–ì½—ì½™ì½šì½›ì½", 6, "ì½¦ì½¨ì½ªì½«ì½¬ê´Œê´ê´ê´‘ê´˜ê´œê´ ê´©ê´¬ê´­ê´´ê´µê´¸ê´¼êµ„êµ…êµ‡êµ‰êµêµ”êµ˜êµ¡êµ£êµ¬êµ­êµ°êµ³êµ´êµµêµ¶êµ»êµ¼êµ½êµ¿ê¶ê¶‚ê¶ˆê¶‰ê¶Œê¶ê¶œê¶ê¶¤ê¶·ê·€ê·ê·„ê·ˆê·ê·‘ê·“ê·œê· ê·¤ê·¸ê·¹ê·¼ê·¿ê¸€ê¸ê¸ˆê¸‰ê¸‹ê¸ê¸”ê¸°ê¸±ê¸´ê¸·ê¸¸ê¸ºê¹€ê¹ê¹ƒê¹…ê¹†ê¹Šê¹Œê¹ê¹ê¹ê¹”ê¹–ê¹œê¹ê¹Ÿê¹ ê¹¡ê¹¥ê¹¨ê¹©ê¹¬ê¹°ê¹¸"],
    ["b241", "ì½­ì½®ì½¯ì½²ì½³ì½µì½¶ì½·ì½¹", 6, "ì¾ì¾‚ì¾ƒì¾„ì¾†", 5, "ì¾"],
    ["b261", "ì¾", 18, "ì¾¢", 5, "ì¾©"],
    ["b281", "ì¾ª", 5, "ì¾±", 18, "ì¿…", 6, "ê¹¹ê¹»ê¹¼ê¹½êº„êº…êºŒêº¼êº½êº¾ê»€ê»„ê»Œê»ê»ê»ê»‘ê»˜ê»™ê»œê»¨ê»«ê»­ê»´ê»¸ê»¼ê¼‡ê¼ˆê¼ê¼ê¼¬ê¼­ê¼°ê¼²ê¼´ê¼¼ê¼½ê¼¿ê½ê½‚ê½ƒê½ˆê½‰ê½ê½œê½ê½¤ê½¥ê½¹ê¾€ê¾„ê¾ˆê¾ê¾‘ê¾•ê¾œê¾¸ê¾¹ê¾¼ê¿€ê¿‡ê¿ˆê¿‰ê¿‹ê¿ê¿ê¿”ê¿œê¿¨ê¿©ê¿°ê¿±ê¿´ê¿¸ë€€ë€ë€„ë€Œë€ë€”ë€œë€ë€¨ë„ë…ëˆëŠëŒëë“ë”ë•ë—ë™"],
    ["b341", "ì¿Œ", 19, "ì¿¢ì¿£ì¿¥ì¿¦ì¿§ì¿©"],
    ["b361", "ì¿ª", 5, "ì¿²ì¿´ì¿¶", 5, "ì¿½ì¿¾ì¿¿í€í€‚í€ƒí€…", 5],
    ["b381", "í€‹", 5, "í€’", 5, "í€™", 19, "ëë¼ë½ë‚€ë‚„ë‚Œë‚ë‚ë‚‘ë‚˜ë‚™ë‚šë‚œë‚Ÿë‚ ë‚¡ë‚¢ë‚¨ë‚©ë‚«", 4, "ë‚±ë‚³ë‚´ë‚µë‚¸ë‚¼ëƒ„ëƒ…ëƒ‡ëƒˆëƒ‰ëƒëƒ‘ëƒ”ëƒ˜ëƒ ëƒ¥ë„ˆë„‰ë„‹ë„Œë„ë„’ë„“ë„˜ë„™ë„›ë„œë„ë„£ë„¤ë„¥ë„¨ë„¬ë„´ë„µë„·ë„¸ë„¹ë…€ë…ë…„ë…ˆë…ë…‘ë…”ë…•ë…˜ë…œë… ë…¸ë…¹ë…¼ë†€ë†‚ë†ˆë†‰ë†‹ë†ë†’ë†“ë†”ë†˜ë†œë†¨ë‡Œë‡ë‡”ë‡œë‡"],
    ["b441", "í€®", 5, "í€¶í€·í€¹í€ºí€»í€½", 6, "í†íˆíŠ", 5],
    ["b461", "í‘í’í“í•í–í—í™", 6, "í¡", 10, "í®í¯"],
    ["b481", "í±í²í³íµ", 6, "í¾í¿í‚€í‚‚", 18, "ë‡Ÿë‡¨ë‡©ë‡¬ë‡°ë‡¹ë‡»ë‡½ëˆ„ëˆ…ëˆˆëˆ‹ëˆŒëˆ”ëˆ•ëˆ—ëˆ™ëˆ ëˆ´ëˆ¼ë‰˜ë‰œë‰ ë‰¨ë‰©ë‰´ë‰µë‰¼ëŠ„ëŠ…ëŠ‰ëŠëŠ‘ëŠ”ëŠ˜ëŠ™ëŠšëŠ ëŠ¡ëŠ£ëŠ¥ëŠ¦ëŠªëŠ¬ëŠ°ëŠ´ë‹ˆë‹‰ë‹Œë‹ë‹’ë‹˜ë‹™ë‹›ë‹ë‹¢ë‹¤ë‹¥ë‹¦ë‹¨ë‹«", 4, "ë‹³ë‹´ë‹µë‹·", 4, "ë‹¿ëŒ€ëŒëŒ„ëŒˆëŒëŒ‘ëŒ“ëŒ”ëŒ•ëŒœë”ë•ë–ë˜ë›ëœëëŸë¤ë¥"],
    ["b541", "í‚•", 14, "í‚¦í‚§í‚©í‚ªí‚«í‚­", 5],
    ["b561", "í‚³í‚¶í‚¸í‚º", 5, "íƒ‚íƒƒíƒ…íƒ†íƒ‡íƒŠ", 5, "íƒ’íƒ–", 4],
    ["b581", "íƒ›íƒíƒŸíƒ¡íƒ¢íƒ£íƒ¥", 6, "íƒ®íƒ²", 5, "íƒ¹", 11, "ë§ë©ë«ë®ë°ë±ë´ë¸ë€ëëƒë„ë…ëŒëë”ë ë¡ë¨ë¬ë„ë…ëˆë‹ëŒëëë”ë•ë—ë™ë›ëë ë¤ë¨ë¼ëë˜ëœë ë¨ë©ë«ë´ë‘ë‘‘ë‘”ë‘˜ë‘ ë‘¡ë‘£ë‘¥ë‘¬ë’€ë’ˆë’ë’¤ë’¨ë’¬ë’µë’·ë’¹ë“€ë“„ë“ˆë“ë“•ë“œë“ë“ ë“£ë“¤ë“¦ë“¬ë“­ë“¯ë“±ë“¸ë””ë”•ë”˜ë”›ë”œë”¤ë”¥ë”§ë”¨ë”©ë”ªë”°ë”±ë”´ë”¸"],
    ["b641", "í„…", 7, "í„", 17],
    ["b661", "í„ ", 15, "í„²í„³í„µí„¶í„·í„¹í„»í„¼í„½í„¾"],
    ["b681", "í„¿í…‚í…†", 5, "í…í…í…‘í…’í…“í…•", 6, "í…í… í…¢", 5, "í…©í…ªí…«í…­ë•€ë•ë•ƒë•„ë•…ë•‹ë•Œë•ë•ë•”ë•œë•ë•Ÿë• ë•¡ë– ë–¡ë–¤ë–¨ë–ªë–«ë–°ë–±ë–³ë–´ë–µë–»ë–¼ë–½ë—€ë—„ë—Œë—ë—ë—ë—‘ë—˜ë—¬ë˜ë˜‘ë˜”ë˜˜ë˜¥ë˜¬ë˜´ë™ˆë™¤ë™¨ëšœëšëš ëš¤ëš«ëš¬ëš±ë›”ë›°ë›´ë›¸ëœ€ëœëœ…ëœ¨ëœ©ëœ¬ëœ¯ëœ°ëœ¸ëœ¹ëœ»ë„ëˆëŒë”ë•ë ë¤ë¨ë°ë±ë³ëµë¼ë½ë€ë„ëŒëëëë‘ë’ë–ë—"],
    ["b741", "í…®", 13, "í…½", 6, "í†…í††í†‡í†‰í†Š"],
    ["b761", "í†‹", 20, "í†¢í†£í†¥í†¦í†§"],
    ["b781", "í†©", 6, "í†²í†´í†¶í†·í†¸í†¹í†»í†½í†¾í†¿í‡", 14, "ë˜ë™ëœë ë¨ë©ë«ë¬ë­ë´ëµë¸ëŸ‡ëŸ‰ëŸ¬ëŸ­ëŸ°ëŸ´ëŸ¼ëŸ½ëŸ¿ë €ë ë ‡ë ˆë ‰ë Œë ë ˜ë ™ë ›ë ë ¤ë ¥ë ¨ë ¬ë ´ë µë ·ë ¸ë ¹ë¡€ë¡„ë¡‘ë¡“ë¡œë¡ë¡ ë¡¤ë¡¬ë¡­ë¡¯ë¡±ë¡¸ë¡¼ë¢ë¢¨ë¢°ë¢´ë¢¸ë£€ë£ë£ƒë£…ë£Œë£ë£”ë£ë£Ÿë£¡ë£¨ë£©ë£¬ë£°ë£¸ë£¹ë£»ë£½ë¤„ë¤˜ë¤ ë¤¼ë¤½ë¥€ë¥„ë¥Œë¥ë¥‘ë¥˜ë¥™ë¥œë¥ ë¥¨ë¥©"],
    ["b841", "í‡", 7, "í‡™", 17],
    ["b861", "í‡«", 8, "í‡µí‡¶í‡·í‡¹", 13],
    ["b881", "íˆˆíˆŠ", 5, "íˆ‘", 24, "ë¥«ë¥­ë¥´ë¥µë¥¸ë¥¼ë¦„ë¦…ë¦‡ë¦‰ë¦Šë¦ë¦ë¦¬ë¦­ë¦°ë¦´ë¦¼ë¦½ë¦¿ë§ë§ˆë§‰ë§Œë§", 4, "ë§˜ë§™ë§›ë§ë§ë§¡ë§£ë§¤ë§¥ë§¨ë§¬ë§´ë§µë§·ë§¸ë§¹ë§ºë¨€ë¨ë¨ˆë¨•ë¨¸ë¨¹ë¨¼ë©€ë©‚ë©ˆë©‰ë©‹ë©ë©ë©“ë©”ë©•ë©˜ë©œë©¤ë©¥ë©§ë©¨ë©©ë©°ë©±ë©´ë©¸ëªƒëª„ëª…ëª‡ëªŒëª¨ëª©ëª«ëª¬ëª°ëª²ëª¸ëª¹ëª»ëª½ë«„ë«ˆë«˜ë«™ë«¼"],
    ["b941", "íˆªíˆ«íˆ®íˆ¯íˆ±íˆ²íˆ³íˆµ", 6, "íˆ¾í‰€í‰‚", 5, "í‰‰í‰Ší‰‹í‰Œ"],
    ["b961", "í‰", 14, "í‰", 6, "í‰¥í‰¦í‰§í‰¨"],
    ["b981", "í‰©", 22, "íŠ‚íŠƒíŠ…íŠ†íŠ‡íŠ‰íŠŠíŠ‹íŠŒë¬€ë¬„ë¬ë¬ë¬‘ë¬˜ë¬œë¬ ë¬©ë¬«ë¬´ë¬µë¬¶ë¬¸ë¬»ë¬¼ë¬½ë¬¾ë­„ë­…ë­‡ë­‰ë­ë­ë­ë­”ë­˜ë­¡ë­£ë­¬ë®ˆë®Œë®ë®¤ë®¨ë®¬ë®´ë®·ë¯€ë¯„ë¯ˆë¯ë¯“ë¯¸ë¯¹ë¯¼ë¯¿ë°€ë°‚ë°ˆë°‰ë°‹ë°Œë°ë°ë°‘ë°”", 4, "ë°›", 4, "ë°¤ë°¥ë°§ë°©ë°­ë°°ë°±ë°´ë°¸ë±€ë±ë±ƒë±„ë±…ë±‰ë±Œë±ë±ë±ë²„ë²…ë²ˆë²‹ë²Œë²ë²”ë²•ë²—"],
    ["ba41", "íŠíŠíŠíŠ’íŠ“íŠ”íŠ–", 5, "íŠíŠíŠŸíŠ¡íŠ¢íŠ£íŠ¥", 6, "íŠ­"],
    ["ba61", "íŠ®íŠ¯íŠ°íŠ²", 5, "íŠºíŠ»íŠ½íŠ¾í‹í‹ƒ", 4, "í‹Ší‹Œ", 5],
    ["ba81", "í‹’í‹“í‹•í‹–í‹—í‹™í‹ší‹›í‹", 6, "í‹¦", 9, "í‹²í‹³í‹µí‹¶í‹·í‹¹í‹ºë²™ë²šë² ë²¡ë²¤ë²§ë²¨ë²°ë²±ë²³ë²´ë²µë²¼ë²½ë³€ë³„ë³ë³ë³ë³‘ë³•ë³˜ë³œë³´ë³µë³¶ë³¸ë³¼ë´„ë´…ë´‡ë´‰ë´ë´”ë´¤ë´¬ëµ€ëµˆëµ‰ëµŒëµëµ˜ëµ™ëµ¤ëµ¨ë¶€ë¶ë¶„ë¶‡ë¶ˆë¶‰ë¶Šë¶ë¶‘ë¶“ë¶•ë¶™ë¶šë¶œë¶¤ë¶°ë¶¸ë·”ë·•ë·˜ë·œë·©ë·°ë·´ë·¸ë¸€ë¸ƒë¸…ë¸Œë¸ë¸ë¸”ë¸œë¸ë¸Ÿë¹„ë¹…ë¹ˆë¹Œë¹ë¹”ë¹•ë¹—ë¹™ë¹šë¹›ë¹ ë¹¡ë¹¤"],
    ["bb41", "í‹»", 4, "íŒ‚íŒ„íŒ†", 5, "íŒíŒ‘íŒ’íŒ“íŒ•íŒ—", 4, "íŒíŒ¢íŒ£"],
    ["bb61", "íŒ¤íŒ¦íŒ§íŒªíŒ«íŒ­íŒ®íŒ¯íŒ±", 6, "íŒºíŒ¾", 5, "í†í‡íˆí‰"],
    ["bb81", "íŠ", 31, "ë¹¨ë¹ªë¹°ë¹±ë¹³ë¹´ë¹µë¹»ë¹¼ë¹½ëº€ëº„ëºŒëºëºëºëº‘ëº˜ëº™ëº¨ë»ë»‘ë»”ë»—ë»˜ë» ë»£ë»¤ë»¥ë»¬ë¼ë¼ˆë¼‰ë¼˜ë¼™ë¼›ë¼œë¼ë½€ë½ë½„ë½ˆë½ë½‘ë½•ë¾”ë¾°ë¿…ë¿Œë¿ë¿ë¿”ë¿œë¿Ÿë¿¡ì€¼ì‘ì˜ìœì ì¨ì©ì‚ì‚‘ì‚”ì‚˜ì‚ ì‚¡ì‚£ì‚¥ì‚¬ì‚­ì‚¯ì‚°ì‚³ì‚´ì‚µì‚¶ì‚¼ì‚½ì‚¿ìƒ€ìƒìƒ…ìƒˆìƒ‰ìƒŒìƒìƒ˜ìƒ™ìƒ›ìƒœìƒìƒ¤"],
    ["bc41", "íª", 17, "í¾í¿íí‚íƒí…í†í‡"],
    ["bc61", "íˆí‰íŠí‹íí’", 5, "íší›íííŸí¡", 6, "íªí¬í®"],
    ["bc81", "í¯", 4, "íµí¶í·í¹íºí»í½", 6, "í†í‡íŠ", 5, "í‘", 5, "ìƒ¥ìƒ¨ìƒ¬ìƒ´ìƒµìƒ·ìƒ¹ì„€ì„„ì„ˆì„ì„•ì„œ", 4, "ì„£ì„¤ì„¦ì„§ì„¬ì„­ì„¯ì„°ì„±ì„¶ì„¸ì„¹ì„¼ì…€ì…ˆì…‰ì…‹ì…Œì…ì…”ì…•ì…˜ì…œì…¤ì…¥ì…§ì…¨ì…©ì…°ì…´ì…¸ì†…ì†Œì†ì†ì†ì†”ì†–ì†œì†ì†Ÿì†¡ì†¥ì†¨ì†©ì†¬ì†°ì†½ì‡„ì‡ˆì‡Œì‡”ì‡—ì‡˜ì‡ ì‡¤ì‡¨ì‡°ì‡±ì‡³ì‡¼ì‡½ìˆ€ìˆ„ìˆŒìˆìˆìˆ‘ìˆ˜ìˆ™ìˆœìˆŸìˆ ìˆ¨ìˆ©ìˆ«ìˆ­"],
    ["bd41", "í—í™", 7, "í¢í¤", 7, "í®í¯í±í²í³íµí¶í·"],
    ["bd61", "í¸í¹íºí»í¾í€í‚", 5, "í‰", 13],
    ["bd81", "í—", 5, "í", 25, "ìˆ¯ìˆ±ìˆ²ìˆ´ì‰ˆì‰ì‰‘ì‰”ì‰˜ì‰ ì‰¥ì‰¬ì‰­ì‰°ì‰´ì‰¼ì‰½ì‰¿ìŠìŠˆìŠ‰ìŠìŠ˜ìŠ›ìŠìŠ¤ìŠ¥ìŠ¨ìŠ¬ìŠ­ìŠ´ìŠµìŠ·ìŠ¹ì‹œì‹ì‹ ì‹£ì‹¤ì‹«ì‹¬ì‹­ì‹¯ì‹±ì‹¶ì‹¸ì‹¹ì‹»ì‹¼ìŒ€ìŒˆìŒ‰ìŒŒìŒìŒ“ìŒ”ìŒ•ìŒ˜ìŒœìŒ¤ìŒ¥ìŒ¨ìŒ©ì…ì¨ì©ì¬ì°ì²ì¸ì¹ì¼ì½ì„ìˆìŒì€ì˜ì™ìœìŸì ì¢ì¨ì©ì­ì´ìµì¸ìˆìì¤ì¬ì°"],
    ["be41", "í¸", 7, "í‘í‘‚í‘ƒí‘…", 14],
    ["be61", "í‘”", 7, "í‘í‘í‘Ÿí‘¡í‘¢í‘£í‘¥", 7, "í‘®í‘°í‘±í‘²"],
    ["be81", "í‘³", 4, "í‘ºí‘»í‘½í‘¾í’í’ƒ", 4, "í’Ší’Œí’", 5, "í’•", 8, "ì´ì¼ì½ì‘ˆì‘¤ì‘¥ì‘¨ì‘¬ì‘´ì‘µì‘¹ì’€ì’”ì’œì’¸ì’¼ì“©ì“°ì“±ì“´ì“¸ì“ºì“¿ì”€ì”ì”Œì”ì””ì”œì”¨ì”©ì”¬ì”°ì”¸ì”¹ì”»ì”½ì•„ì•…ì•ˆì•‰ì•Šì•Œì•ì•ì•“ì•”ì••ì•—ì•˜ì•™ì•ì•ì• ì•¡ì•¤ì•¨ì•°ì•±ì•³ì•´ì•µì•¼ì•½ì–€ì–„ì–‡ì–Œì–ì–ì–‘ì–•ì–—ì–˜ì–œì– ì–©ì–´ì–µì–¸ì–¹ì–»ì–¼ì–½ì–¾ì—„", 6, "ì—Œì—"],
    ["bf41", "í’", 10, "í’ª", 14],
    ["bf61", "í’¹", 18, "í“í“í“í“‘í“’í““í“•"],
    ["bf81", "í“–", 5, "í“í“í“ ", 7, "í“©í“ªí“«í“­í“®í“¯í“±", 6, "í“¹í“ºí“¼ì—ì—‘ì—”ì—˜ì— ì—¡ì—£ì—¥ì—¬ì—­ì—®ì—°ì—´ì—¶ì—·ì—¼", 5, "ì˜…ì˜†ì˜‡ì˜ˆì˜Œì˜ì˜˜ì˜™ì˜›ì˜œì˜¤ì˜¥ì˜¨ì˜¬ì˜­ì˜®ì˜°ì˜³ì˜´ì˜µì˜·ì˜¹ì˜»ì™€ì™ì™„ì™ˆì™ì™‘ì™“ì™”ì™•ì™œì™ì™ ì™¬ì™¯ì™±ì™¸ì™¹ì™¼ìš€ìšˆìš‰ìš‹ìšìš”ìš•ìš˜ìšœìš¤ìš¥ìš§ìš©ìš°ìš±ìš´ìš¸ìš¹ìšºì›€ì›ì›ƒì›…ì›Œì›ì›ì›”ì›œì›ì› ì›¡ì›¨"],
    ["c041", "í“¾", 5, "í”…í”†í”‡í”‰í”Ší”‹í”", 6, "í”–í”˜", 5],
    ["c061", "í”", 25],
    ["c081", "í”¸í”¹í”ºí”»í”¾í”¿í•í•‚í•ƒí•…", 6, "í•í•í•’", 5, "í•ší•›í•í•í•Ÿí•¡í•¢í•£ì›©ì›¬ì›°ì›¸ì›¹ì›½ìœ„ìœ…ìœˆìœŒìœ”ìœ•ìœ—ìœ™ìœ ìœ¡ìœ¤ìœ¨ìœ°ìœ±ìœ³ìœµìœ·ìœ¼ìœ½ì€ì„ìŠìŒììì‘", 7, "ìœì ì¨ì«ì´ìµì¸ì¼ì½ì¾ìƒì„ì…ì‡ìˆì‰ìŠììì‘ì”ì–ì—ì˜ìšì ì¡ì£ì¤ì¥ì¦ì¬ì­ì°ì´ì¼ì½ì¿ìŸ€ìŸìŸˆìŸ‰ìŸŒìŸìŸìŸ˜ìŸìŸ¤ìŸ¨ìŸ¬ì €ì ì „ì ˆì Š"],
    ["c141", "í•¤í•¦í•§í•ªí•¬í•®", 5, "í•¶í•·í•¹í•ºí•»í•½", 6, "í–†í–Ší–‹"],
    ["c161", "í–Œí–í–í–í–‘", 19, "í–¦í–§"],
    ["c181", "í–¨", 31, "ì ì ‘ì “ì •ì –ì œì ì  ì ¤ì ¬ì ­ì ¯ì ±ì ¸ì ¼ì¡€ì¡ˆì¡‰ì¡Œì¡ì¡”ì¡°ì¡±ì¡´ì¡¸ì¡ºì¢€ì¢ì¢ƒì¢…ì¢†ì¢‡ì¢‹ì¢Œì¢ì¢”ì¢ì¢Ÿì¢¡ì¢¨ì¢¼ì¢½ì£„ì£ˆì£Œì£”ì£•ì£—ì£™ì£ ì£¡ì£¤ì£µì£¼ì£½ì¤€ì¤„ì¤…ì¤†ì¤Œì¤ì¤ì¤‘ì¤˜ì¤¬ì¤´ì¥ì¥‘ì¥”ì¥˜ì¥ ì¥¡ì¥£ì¥¬ì¥°ì¥´ì¥¼ì¦ˆì¦‰ì¦Œì¦ì¦˜ì¦™ì¦›ì¦ì§€ì§ì§„ì§‡ì§ˆì§Šì§ì§‘ì§“"],
    ["c241", "í—Ší—‹í—í—í—í—‘í—“", 4, "í—ší—œí—", 5, "í—¦í—§í—©í—ªí—«í—­í—®"],
    ["c261", "í—¯", 4, "í—¶í—¸í—º", 5, "í˜‚í˜ƒí˜…í˜†í˜‡í˜‰", 6, "í˜’"],
    ["c281", "í˜–", 5, "í˜í˜í˜Ÿí˜¡í˜¢í˜£í˜¥", 7, "í˜®", 9, "í˜ºí˜»ì§•ì§–ì§™ì§šì§œì§ì§ ì§¢ì§¤ì§§ì§¬ì§­ì§¯ì§°ì§±ì§¸ì§¹ì§¼ì¨€ì¨ˆì¨‰ì¨‹ì¨Œì¨ì¨”ì¨˜ì¨©ì©Œì©ì©ì©”ì©œì©ì©Ÿì© ì©¡ì©¨ì©½ìª„ìª˜ìª¼ìª½ì«€ì«„ì«Œì«ì«ì«‘ì«“ì«˜ì«™ì« ì«¬ì«´ì¬ˆì¬ì¬”ì¬˜ì¬ ì¬¡ì­ì­ˆì­‰ì­Œì­ì­˜ì­™ì­ì­¤ì­¸ì­¹ì®œì®¸ì¯”ì¯¤ì¯§ì¯©ì°Œì°ì°ì°”ì°œì°ì°¡ì°¢ì°§ì°¨ì°©ì°¬ì°®ì°°ì°¸ì°¹ì°»"],
    ["c341", "í˜½í˜¾í˜¿í™í™‚í™ƒí™„í™†í™‡í™Ší™Œí™í™í™í™’í™“í™–í™—í™™í™ší™›í™", 4],
    ["c361", "í™¢", 4, "í™¨í™ª", 5, "í™²í™³í™µ", 11],
    ["c381", "íšíš‚íš„íš†", 5, "íšíšíš‘íš’íš“íš•", 7, "íšíš íš¢", 5, "íš©íšªì°¼ì°½ì°¾ì±„ì±…ì±ˆì±Œì±”ì±•ì±—ì±˜ì±™ì± ì±¤ì±¦ì±¨ì±°ì±µì²˜ì²™ì²œì² ì²¨ì²©ì²«ì²¬ì²­ì²´ì²µì²¸ì²¼ì³„ì³…ì³‡ì³‰ì³ì³”ì³¤ì³¬ì³°ì´ì´ˆì´‰ì´Œì´ì´˜ì´™ì´›ì´ì´¤ì´¨ì´¬ì´¹ìµœìµ ìµ¤ìµ¬ìµ­ìµ¯ìµ±ìµ¸ì¶ˆì¶”ì¶•ì¶˜ì¶œì¶¤ì¶¥ì¶§ì¶©ì¶°ì·„ì·Œì·ì·¨ì·¬ì·°ì·¸ì·¹ì·»ì·½ì¸„ì¸ˆì¸Œì¸”ì¸™ì¸ ì¸¡ì¸¤ì¸¨ì¸°ì¸±ì¸³ì¸µ"],
    ["c441", "íš«íš­íš®íš¯íš±", 7, "íšºíš¼", 7, "í›†í›‡í›‰í›Ší›‹"],
    ["c461", "í›í›í›í›í›’í›“í›•í›–í›˜í›š", 5, "í›¡í›¢í›£í›¥í›¦í›§í›©", 4],
    ["c481", "í›®í›¯í›±í›²í›³í›´í›¶", 5, "í›¾í›¿íœíœ‚íœƒíœ…", 11, "íœ’íœ“íœ”ì¹˜ì¹™ì¹œì¹Ÿì¹ ì¹¡ì¹¨ì¹©ì¹«ì¹­ì¹´ì¹µì¹¸ì¹¼ìº„ìº…ìº‡ìº‰ìºìº‘ìº”ìº˜ìº ìº¡ìº£ìº¤ìº¥ìº¬ìº­ì»ì»¤ì»¥ì»¨ì»«ì»¬ì»´ì»µì»·ì»¸ì»¹ì¼€ì¼ì¼„ì¼ˆì¼ì¼‘ì¼“ì¼•ì¼œì¼ ì¼¤ì¼¬ì¼­ì¼¯ì¼°ì¼±ì¼¸ì½”ì½•ì½˜ì½œì½¤ì½¥ì½§ì½©ì½°ì½±ì½´ì½¸ì¾€ì¾…ì¾Œì¾¡ì¾¨ì¾°ì¿„ì¿ ì¿¡ì¿¤ì¿¨ì¿°ì¿±ì¿³ì¿µì¿¼í€€í€„í€‘í€˜í€­í€´í€µí€¸í€¼"],
    ["c541", "íœ•íœ–íœ—íœšíœ›íœíœíœŸíœ¡", 6, "íœªíœ¬íœ®", 5, "íœ¶íœ·íœ¹"],
    ["c561", "íœºíœ»íœ½", 6, "í…í†íˆíŠ", 5, "í’í“í•íš", 4],
    ["c581", "íŸí¢í¤í¦í§í¨íªí«í­í®í¯í±í²í³íµ", 6, "í¾í¿í€í‚", 5, "íŠí‹í„í…í‡í‰íí”í˜í í¬í­í°í´í¼í½í‚í‚¤í‚¥í‚¨í‚¬í‚´í‚µí‚·í‚¹íƒ€íƒíƒ„íƒˆíƒ‰íƒíƒ‘íƒ“íƒ”íƒ•íƒœíƒíƒ íƒ¤íƒ¬íƒ­íƒ¯íƒ°íƒ±íƒ¸í„í„°í„±í„´í„¸í„ºí…€í…í…ƒí…„í……í…Œí…í…í…”í…œí…í…Ÿí…¡í…¨í…¬í…¼í†„í†ˆí† í†¡í†¤í†¨í†°í†±í†³í†µí†ºí†¼í‡€í‡˜í‡´í‡¸íˆ‡íˆ‰íˆíˆ¬íˆ­íˆ°íˆ´íˆ¼íˆ½íˆ¿í‰í‰ˆí‰œ"],
    ["c641", "íííí‘", 6, "íšíœí", 5],
    ["c6a1", "í‰¤íŠ€íŠíŠ„íŠˆíŠíŠ‘íŠ•íŠœíŠ íŠ¤íŠ¬íŠ±íŠ¸íŠ¹íŠ¼íŠ¿í‹€í‹‚í‹ˆí‹‰í‹‹í‹”í‹˜í‹œí‹¤í‹¥í‹°í‹±í‹´í‹¸íŒ€íŒíŒƒíŒ…íŒŒíŒíŒíŒíŒ”íŒ–íŒœíŒíŒŸíŒ íŒ¡íŒ¥íŒ¨íŒ©íŒ¬íŒ°íŒ¸íŒ¹íŒ»íŒ¼íŒ½í„í…í¼í½í€í„íŒíííí‘í˜í™íœí í¨í©í«í­í´í¸í¼í„í…íˆí‰íí˜í¡í£í¬í­í°í´í¼í½í¿í"],
    ["c7a1", "íˆíí‘€í‘„í‘œí‘ í‘¤í‘­í‘¯í‘¸í‘¹í‘¼í‘¿í’€í’‚í’ˆí’‰í’‹í’í’”í’©í“Œí“í“”í“œí“Ÿí“¨í“¬í“°í“¸í“»í“½í”„í”ˆí”Œí””í”•í”—í”¼í”½í•€í•„í•Œí•í•í•‘í•˜í•™í•œí• í•¥í•¨í•©í•«í•­í•´í•µí•¸í•¼í–„í–…í–‡í–ˆí–‰í–í–¥í—ˆí—‰í—Œí—í—’í—˜í—™í—›í—í—¤í—¥í—¨í—¬í—´í—µí—·í—¹í˜€í˜í˜„í˜ˆí˜í˜‘í˜“í˜”í˜•í˜œí˜ "],
    ["c8a1", "í˜¤í˜­í˜¸í˜¹í˜¼í™€í™…í™ˆí™‰í™‹í™í™‘í™”í™•í™˜í™œí™§í™©í™°í™±í™´íšƒíš…íšŒíšíšíš”íšíšŸíš¡íš¨íš¬íš°íš¹íš»í›„í›…í›ˆí›Œí›‘í›”í›—í›™í› í›¤í›¨í›°í›µí›¼í›½íœ€íœ„íœ‘íœ˜íœ™íœœíœ íœ¨íœ©íœ«íœ­íœ´íœµíœ¸íœ¼í„í‡í‰íí‘í”í–í—í˜í™í í¡í£í¥í©í¬í°í´í¼í½ííˆí‰íŒíí˜í™í›í"],
    ["caa1", "ä¼½ä½³å‡åƒ¹åŠ å¯å‘µå“¥å˜‰å«å®¶æš‡æ¶æ·æŸ¯æ­Œç‚ç—‚ç¨¼è‹›èŒ„è¡—è¢ˆè¨¶è³ˆè·è»»è¿¦é§•åˆ»å´å„æªæ…¤æ®¼çè„šè¦ºè§’é–£ä¾ƒåˆŠå¢¾å¥¸å§¦å¹²å¹¹æ‡‡æ€æ†æŸ¬æ¡¿æ¾—ç™çœ‹ç£µç¨ˆç«¿ç°¡è‚è‰®è‰±è««é–“ä¹«å–æ›·æ¸´ç¢£ç«­è‘›è¤èé¨å‹˜åå ªåµŒæ„Ÿæ†¾æˆ¡æ•¢æŸ‘æ©„æ¸›ç”˜ç–³ç›£ç°ç´ºé‚¯é‘‘é‘’é¾•"],
    ["cba1", "åŒ£å²¬ç”²èƒ›é‰€é–˜å‰›å ˆå§œå²¡å´—åº·å¼ºå½Šæ…·æ±Ÿç•ºç–†ç³ çµ³ç¶±ç¾Œè…”èˆ¡è–‘è¥è¬›é‹¼é™é±‡ä»‹ä»·å€‹å‡±å¡æ„·æ„¾æ…¨æ”¹æ§ªæ¼‘ç–¥çš†ç›–ç®‡èŠ¥è“‹ï¤€é§é–‹å–€å®¢å‘ï¤ç²³ç¾¹é†µå€¨å»å±…å·¨æ‹’æ®æ“šæ“§æ¸ ç‚¬ç¥›è·è¸ï¤‚é½é‰…é‹¸ä¹¾ä»¶å¥å·¾å»ºæ„†æ¥—è…±è™”è¹‡éµé¨«ä¹å‚‘æ°æ¡€å„‰åŠåŠ’æª¢"],
    ["cca1", "ç¼éˆé»”åŠ«æ€¯è¿²åˆæ†©æ­æ“Šæ ¼æª„æ¿€è†ˆè¦¡éš”å …ç‰½çŠ¬ç”„çµ¹ç¹­è‚©è¦‹è­´é£éµ‘æŠ‰æ±ºæ½”çµç¼ºè¨£å…¼æ…Šç®è¬™é‰—éŒäº¬ä¿“å€å‚¾å„†å‹å‹å¿å°å¢ƒåºšå¾‘æ…¶æ†¬æ“æ•¬æ™¯æš»æ›´æ¢—æ¶‡ç‚…çƒ±ç’Ÿç’¥ç“Šç—™ç¡¬ç£¬ç«Ÿç«¶çµ…ç¶“è€•è€¿è„›è–è­¦è¼•é€•é¡é ƒé ¸é©šé¯¨ä¿‚å•“å ºå¥‘å­£å±†æ‚¸æˆ’æ¡‚æ¢°"],
    ["cda1", "æ£¨æºªç•Œç™¸ç£ç¨½ç³»ç¹«ç¹¼è¨ˆèª¡è°¿éšé·„å¤å©å‘Šå‘±å›ºå§‘å­¤å°»åº«æ‹·æ”·æ•…æ•²æš æ¯æ§æ²½ç—¼çšç¾ç¨¿ç¾”è€ƒè‚¡è†è‹¦è‹½è°è—è ±è¢´èª¥ï¤ƒè¾œéŒ®é›‡é¡§é«˜é¼“å“­æ–›æ›²æ¢ç©€è°·éµ å›°å¤å´‘æ˜†æ¢±æ£æ»¾ç¨è¢é¯¤æ±¨ï¤„éª¨ä¾›å…¬å…±åŠŸå­”å·¥ææ­æ‹±æ§æ”»ç™ç©ºèš£è²¢éä¸²å¯¡æˆˆæœç“œ"],
    ["cea1", "ç§‘è“èª‡èª²è·¨éé‹é¡†å»“æ§¨è—¿éƒ­ï¤…å† å®˜å¯¬æ…£æ£ºæ¬¾çŒç¯ç“˜ç®¡ç½è…è§€è²«é—œé¤¨åˆ®ææ‹¬é€‚ä¾Šå…‰åŒ¡å£™å»£æ› æ´¸ç‚šç‹‚ç–ç­èƒ±é‘›å¦æ›ç½«ä¹–å‚€å¡Šå£æ€ªæ„§æ‹æ§é­å®ç´˜è‚±è½Ÿäº¤åƒ‘å’¬å–¬å¬Œå¶ å·§æ”ªæ•æ ¡æ©‹ç‹¡çšçŸ¯çµç¿¹è† è•è›Ÿè¼ƒè½éƒŠé¤ƒé©•é®«ä¸˜ä¹…ä¹ä»‡ä¿±å…·å‹¾"],
    ["cfa1", "å€å£å¥å’å˜”åµå¢å¯‡å¶‡å»æ‡¼æ‹˜æ•‘æ¸æŸ©æ§‹æ­æ¯†æ¯¬æ±‚æºç¸ç‹—ç–çƒç¿çŸ©ç©¶çµ¿è€‰è‡¼èˆ…èˆŠè‹Ÿè¡¢è¬³è³¼è»€é€‘é‚±é‰¤éŠ¶é§’é©…é³©é·—é¾œåœ‹å±€èŠé é«éº´å›çª˜ç¾¤è£™è»éƒ¡å €å±ˆæ˜çªŸå®®å¼“ç©¹çª®èŠèº¬å€¦åˆ¸å‹¸å·åœˆæ‹³æ²æ¬Šæ·ƒçœ·å¥ç—è•¨è¹¶é—•æœºæ«ƒæ½°è©­è»Œé¥‹ï¤†æ™·æ­¸è²´"],
    ["d0a1", "é¬¼ï¤‡å«åœ­å¥æ†æ§»çªç¡…çªºç«…ç³¾è‘µè¦èµ³é€µé–¨å‹»å‡ç•‡ç­ èŒéˆï¤ˆæ©˜å…‹å‰‹åŠ‡æˆŸæ£˜æ¥µéš™åƒ…åŠ¤å‹¤æ‡ƒæ–¤æ ¹æ§¿ç‘¾ç­‹èŠ¹è«è¦²è¬¹è¿‘é¥‰ï¤‰ä»Šå¦—æ“’æ˜‘æªç´ç¦ç¦½èŠ©è¡¾è¡¿è¥Ÿï¤ŠéŒ¦ä¼‹åŠæ€¥æ‰±æ±²ç´šçµ¦äº˜å…¢çŸœè‚¯ä¼ä¼å…¶å†€å—œå™¨åœ»åŸºåŸ¼å¤”å¥‡å¦“å¯„å²å´å·±å¹¾å¿ŒæŠ€æ——æ—£"],
    ["d1a1", "æœæœŸææ£‹æ£„æ©Ÿæ¬ºæ°£æ±½æ²‚æ·‡ç˜ç¦çªç’‚ç’£ç•¸ç•¿ç¢ç£¯ç¥ç¥‡ç¥ˆç¥ºç®•ç´€ç¶ºç¾ˆè€†è€­è‚Œè¨˜è­è±ˆèµ·éŒ¡éŒ¤é£¢é¥‘é¨é¨é©¥éº’ç·Šä½¶å‰æ‹®æ¡”é‡‘å–«å„ºï¤‹ï¤Œå¨œæ‡¦ï¤æ‹æ‹¿ï¤", 5, "é‚£ï¤”", 4, "è«¾ï¤™ï¤šï¤›ï¤œæš–ï¤ç…–ï¤ï¤Ÿé›£ï¤ ææºå—ï¤¡ææ¥ æ¹³ï¤¢ç”·ï¤£ï¤¤ï¤¥"],
    ["d2a1", "ç´ï¤¦ï¤§è¡²å›Šå¨˜ï¤¨", 4, "ä¹ƒï¤­å…§å¥ˆæŸ°è€ï¤®å¥³å¹´æ’šç§Šå¿µæ¬æ‹ˆæ»å¯§å¯—åŠªï¤¯å¥´å¼©æ€’ï¤°ï¤±ï¤²ç‘™ï¤³", 5, "é§‘ï¤¹", 10, "æ¿ƒï¥„ï¥…è†¿è¾²æƒ±ï¥†ï¥‡è…¦ï¥ˆï¥‰å°¿ï¥Š", 7, "å«©è¨¥æ»ç´ï¥’", 5, "èƒ½ï¥˜ï¥™å°¼æ³¥åŒ¿æººå¤šèŒ¶"],
    ["d3a1", "ä¸¹äº¶ä½†å–®åœ˜å£‡å½–æ–·æ—¦æª€æ®µæ¹çŸ­ç«¯ç°ç·è›‹è¢’é„²é›æ’»æ¾¾çºç–¸é”å•–åæ†ºæ“”æ›‡æ·¡æ¹›æ½­æ¾¹ç—°èƒè†½è•è¦ƒè«‡è­šéŒŸæ²“ç•“ç­”è¸éå”å ‚å¡˜å¹¢æˆ‡æ’æ£ ç•¶ç³–è³é»¨ä»£åˆå®å¤§å°å²±å¸¶å¾…æˆ´æ“¡ç³è‡ºè¢‹è²¸éšŠé»›å®…å¾·æ‚³å€’åˆ€åˆ°åœ–å µå¡—å°å± å³¶å¶‹åº¦å¾’æ‚¼æŒ‘æ‰æ—æ¡ƒ"],
    ["d4a1", "æ£¹æ«‚æ·˜æ¸¡æ»”æ¿¤ç‡¾ç›œç¹ç¦±ç¨»è„è¦©è³­è·³è¹ˆé€ƒé€”é“éƒ½éé™¶éŸœæ¯’ç€†ç‰˜çŠ¢ç¨ç£ç¦¿ç¯¤çº›è®€å¢©æƒ‡æ•¦æ—½æš¾æ²Œç„ç‡‰è±šé “ä¹­çªä»å†¬å‡å‹•åŒæ†§æ±æ¡æ£Ÿæ´æ½¼ç–¼ç³ç«¥èƒ´è‘£éŠ…å…œæ–—æœæ“ç—˜ç«‡è³ï¥šè±†é€—é ­å±¯è‡€èŠšéé¯éˆå¾—å¶æ©™ç‡ˆç™»ç­‰è—¤è¬„é„§é¨°å–‡æ‡¶ï¥›ç™©ç¾…"],
    ["d5a1", "è˜¿èºè£¸é‚ï¥œæ´›çƒ™ççµ¡è½ï¥é…ªé§±ï¥äº‚åµæ¬„æ¬’ç€¾çˆ›è˜­é¸å‰Œè¾£åµæ“¥æ”¬æ¬–æ¿«ç±ƒçºœè—è¥¤è¦½æ‹‰è‡˜è Ÿå»Šæœ—æµªç‹¼ç…ç‘¯è‚éƒä¾†å´å¾ èŠå†·æ ç•¥äº®å€†å…©å‡‰æ¢æ¨‘ç²®ç²±ç³§è‰¯è«’è¼›é‡ä¾¶å„·å‹µå‘‚å»¬æ…®æˆ¾æ—…æ«šæ¿¾ç¤ªè—œè £é–­é©¢é©ªéº—é»åŠ›æ›†æ­·ç€ç¤«è½¢é‚æ†æˆ€æ”£æ¼£"],
    ["d6a1", "ç…‰ç’‰ç·´è¯è“®è¼¦é€£éŠå†½åˆ—åŠ£æ´Œçƒˆè£‚å»‰æ–‚æ®®æ¿‚ç°¾çµä»¤ä¼¶å›¹ï¥Ÿå²ºå¶ºæ€œç²ç¬­ç¾šç¿è†é€éˆ´é›¶éˆé ˜é½¡ä¾‹æ¾§ç¦®é†´éš·å‹ï¥ æ’ˆæ“„æ«“æ½ç€˜çˆç›§è€è˜†è™œè·¯è¼…éœ²é­¯é·ºé¹µç¢Œç¥¿ç¶ è‰éŒ„é¹¿éº“è«–å£Ÿå¼„æœ§ç€§ç“ç± è¾å„¡ç€¨ç‰¢ç£Šè³‚è³šè³´é›·äº†åƒšå¯®å»–æ–™ç‡ç™‚ç­èŠè“¼"],
    ["d7a1", "é¼é¬§é¾å£˜å©å±¢æ¨“æ·šæ¼ç˜»ç´¯ç¸·è”è¤¸é¤é™‹åŠ‰æ—’æŸ³æ¦´æµæºœç€ç‰ç‘ ç•™ç˜¤ç¡«è¬¬é¡å…­æˆ®é™¸ä¾–å€«å´™æ·ªç¶¸è¼ªå¾‹æ…„æ —ï¥¡éš†å‹’è‚‹å‡œå‡Œæ¥ç¨œç¶¾è±é™µä¿šåˆ©å˜åå”å±¥æ‚§ææ¢¨æµ¬çŠç‹¸ç†ç’ƒï¥¢ç—¢ç±¬ç½¹ç¾¸è‰è£è£¡é‡Œé‡é›¢é¯‰åæ½¾ç‡ç’˜è—ºèºªéš£é±—éºŸæ—æ·‹ç³è‡¨éœ–ç ¬"],
    ["d8a1", "ç«‹ç¬ ç²’æ‘©ç‘ªç—²ç¢¼ç£¨é¦¬é­”éº»å¯å¹•æ¼ è†œè«é‚ˆä¸‡åå¨©å·’å½æ…¢æŒ½æ™©æ›¼æ»¿æ¼«ç£çè¬è”“è »è¼“é¥…é°»å”œæŠ¹æœ«æ²«èŒ‰è¥ªéºäº¡å¦„å¿˜å¿™æœ›ç¶²ç½”èŠ’èŒ«è½è¼é‚™åŸ‹å¦¹åª’å¯æ˜§æšæ¢…æ¯ç…¤ç½µè²·è³£é‚é­…è„ˆè²Šé™Œé©€éº¥å­Ÿæ°“çŒ›ç›²ç›ŸèŒå†ªè¦“å…å†•å‹‰æ£‰æ²”çœ„çœ ç¶¿ç·¬é¢éºµæ»…"],
    ["d9a1", "è”‘å†¥åå‘½æ˜æšæ¤§æºŸçš¿ç‘èŒ—è“‚èŸé…©éŠ˜é³´è¢‚ä¾®å†’å‹Ÿå§†å¸½æ…•æ‘¸æ‘¹æš®æŸæ¨¡æ¯æ¯›ç‰Ÿç‰¡ç‘çœ¸çŸ›è€—èŠ¼èŒ…è¬€è¬¨è²Œæœ¨æ²ç‰§ç›®ç¦ç©†é¶©æ­¿æ²’å¤¢æœ¦è’™å¯å¢“å¦™å»Ÿææ˜´æ³æ¸ºçŒ«ç«—è‹—éŒ¨å‹™å·«æ†®æ‡‹æˆŠæ‹‡æ’«æ— æ¥™æ­¦æ¯‹ç„¡ç·ç•ç¹†èˆèŒ‚è•ªèª£è²¿éœ§éµ¡å¢¨é»˜å€‘åˆå»å•æ–‡"],
    ["daa1", "æ±¶ç´Šç´‹èèšŠé–€é›¯å‹¿æ²•ç‰©å‘³åªšå°¾åµ‹å½Œå¾®æœªæ¢¶æ¥£æ¸¼æ¹„çœ‰ç±³ç¾è–‡è¬è¿·é¡é»´å²·æ‚¶æ„æ†«æ•æ—»æ—¼æ°‘æ³¯çŸç‰ç·¡é–”å¯†èœœè¬å‰åšæ‹ææ’²æœ´æ¨¸æ³Šç€ç’ç®”ç²•ç¸›è†Šèˆ¶è–„è¿«é›¹é§ä¼´åŠåå›æ‹Œæ¬æ”€æ–‘æ§ƒæ³®æ½˜ç­ç•”ç˜¢ç›¤ç›¼ç£ç£»ç¤¬çµ†èˆ¬èŸ è¿”é ’é£¯å‹ƒæ‹”æ’¥æ¸¤æ½‘"],
    ["dba1", "ç™¼è·‹é†±é‰¢é«®é­ƒå€£å‚åŠå¦¨å°¨å¹‡å½·æˆ¿æ”¾æ–¹æ—æ˜‰æ‹æ¦œæ»‚ç£…ç´¡è‚ªè†€èˆ«èŠ³è’¡èšŒè¨ªè¬—é‚¦é˜²é¾å€ä¿³ï¥£åŸ¹å¾˜æ‹œæ’æ¯æ¹ƒç„™ç›ƒèƒŒèƒšè£´è£µè¤™è³ è¼©é…é™ªä¼¯ä½°å¸›æŸæ ¢ç™½ç™¾é­„å¹¡æ¨Šç…©ç‡”ç•ªï¥¤ç¹è•ƒè—©é£œä¼ç­ç½°é–¥å‡¡å¸†æ¢µæ°¾æ±æ³›çŠ¯ç¯„èŒƒæ³•çºåƒ»åŠˆå£æ“˜æª—ç’§ç™–"],
    ["dca1", "ç¢§è˜—é—¢éœ¹ï¥¥åå¼è®Šè¾¨è¾¯é‚Šåˆ¥ç¥é±‰é¼ˆä¸™å€‚å…µå±›å¹·æ˜æ˜ºæŸ„æ£…ç‚³ç”ç—…ç§‰ç«è¼§é¤ é¨ˆä¿å ¡å ±å¯¶æ™®æ­¥æ´‘æ¹ºæ½½ç¤ç”«è©è£œè¤“è­œè¼”ä¼åƒ•åŒåœå®“å¾©æœç¦è…¹èŒ¯è””è¤‡è¦†è¼¹è¼»é¦¥é°’æœ¬ä¹¶ä¿¸å¥‰å°å³¯å³°æ§æ£’çƒ½ç†¢ç«ç¸«è“¬èœ‚é€¢é‹’é³³ä¸ä»˜ä¿¯å‚…å‰–å‰¯å¦å’åŸ å¤«å©¦"],
    ["dda1", "å­šå­µå¯Œåºœï¥¦æ‰¶æ•·æ–§æµ®æº¥çˆ¶ç¬¦ç°¿ç¼¶è…è…‘è†šè‰€èŠ™è©è¨ƒè² è³¦è³»èµ´è¶ºéƒ¨é‡œé˜œé™„é§™é³§åŒ—åˆ†å©å™´å¢³å¥”å¥®å¿¿æ†¤æ‰®æ˜æ±¾ç„šç›†ç²‰ç³ç´›èŠ¬è³é›°ï¥§ä½›å¼—å½¿æ‹‚å´©æœ‹æ£šç¡¼ç¹ƒéµ¬ä¸•å‚™åŒ•åŒªå‘å¦ƒå©¢åº‡æ‚²æ†Šæ‰‰æ‰¹æ–æ‡æ¦§æ¯”æ¯–æ¯—æ¯˜æ²¸ï¥¨çµç—ºç ’ç¢‘ç§•ç§˜ç²ƒç·‹ç¿¡è‚¥"],
    ["dea1", "è„¾è‡‚è²èœšè£¨èª¹è­¬è²»é„™éé£›é¼»åš¬å¬ªå½¬æ–Œæª³æ®¯æµœæ¿±ç€•ç‰ç­è²§è³“é »æ†‘æ°·è˜é¨ä¹äº‹äº›ä»•ä¼ºä¼¼ä½¿ä¿Ÿåƒ¿å²å¸å”†å—£å››å£«å¥¢å¨‘å¯«å¯ºå°„å·³å¸«å¾™æ€æ¨æ–œæ–¯æŸ¶æŸ»æ¢­æ­»æ²™æ³—æ¸£ç€‰ç…ç ‚ç¤¾ç¥€ç¥ ç§ç¯©ç´—çµ²è‚†èˆèè“‘è›‡è£Ÿè©è©è¬è³œèµ¦è¾­é‚ªé£¼é§Ÿéºå‰Šï¥©æœ”ï¥ª"],
    ["dfa1", "å‚˜åˆªå±±æ•£æ±•çŠç”£ç–ç®—è’œé…¸éœ°ä¹·æ’’æ®ºç…è–©ä¸‰ï¥«æ‰æ£®æ¸—èŠŸè”˜è¡«æ·æ¾éˆ’é¢¯ä¸Šå‚·åƒå„Ÿå•†å–ªå˜—å­€å°™å³ å¸¸åºŠåº å»‚æƒ³æ¡‘æ©¡æ¹˜çˆ½ç‰€ç‹€ç›¸ç¥¥ç®±ç¿”è£³è§´è©³è±¡è³éœœå¡ç’½è³½å—‡ï¥¬ç©¡ç´¢è‰²ç‰²ç”Ÿç”¥ï¥­ç¬™å¢…å£»å¶¼åºåº¶å¾æ•æŠ’æ¿æ•æš‘æ›™æ›¸æ –æ£²çŠ€ç‘ç­®çµ®ç·–ç½²"],
    ["e0a1", "èƒ¥èˆ’è–¯è¥¿èª“é€é‹¤é»é¼ å¤•å¥­å¸­æƒœæ˜”æ™³ææ±æ·…æ½ŸçŸ³ç¢©è“†é‡‹éŒ«ä»™åƒŠå…ˆå–„å¬‹å®£æ‰‡æ•¾æ—‹æ¸²ç…½çç‘„ç’‡ç’¿ç™¬ç¦ªç·šç¹•ç¾¨è…ºè†³èˆ¹è˜šèŸ¬è©µè·£é¸éŠ‘é¥é¥é®®å¨å±‘æ¥”æ³„æ´©æ¸«èˆŒè–›è¤»è¨­èªªé›ªé½§å‰¡æš¹æ®²çº–èŸ¾è´é–ƒé™æ”æ¶‰ç‡®ï¥®åŸå§“å®¬æ€§æƒºæˆæ˜Ÿæ™ŸçŒ©ç¹ç››çœç­¬"],
    ["e1a1", "è–è²è…¥èª é†’ä¸–å‹¢æ­²æ´—ç¨…ç¬¹ç´°ï¥¯è²°å¬å˜¯å¡‘å®µå°å°‘å·¢æ‰€æƒæ”æ˜­æ¢³æ²¼æ¶ˆæº¯ç€Ÿç‚¤ç‡’ç”¦ç–ç–ç˜™ç¬‘ç¯ ç°«ç´ ç´¹è”¬è•­è˜‡è¨´é€é¡é‚µéŠ·éŸ¶é¨·ä¿—å±¬æŸæ¶‘ç²ŸçºŒè¬–è´–é€Ÿå­«å·½æè“€éœé£¡ç‡å®‹æ‚šæ¾æ·è¨Ÿèª¦é€é Œåˆ·ï¥°ç‘ç¢é–è¡°é‡—ä¿®å—å—½å›šå‚å£½å«‚å®ˆå²«å³€å¸¥æ„"],
    ["e2a1", "æˆæ‰‹æˆæœæ”¶æ•¸æ¨¹æ®Šæ°´æ´™æ¼±ç‡§ç‹©ç¸ç‡ç’²ç˜¦ç¡ç§€ç©—ç«ªç²¹ç¶ç¶¬ç¹¡ç¾è„©èŒ±è’è“šè—ªè¢–èª°è®è¼¸é‚é‚ƒé…¬éŠ–éŠ¹éš‹éš§éš¨é›–éœ€é ˆé¦–é«“é¬šå”å¡¾å¤™å­°å®¿æ·‘æ½šç†Ÿç¡ç’¹è‚…è½å·¡å¾‡å¾ªæ‚æ—¬æ ’æ¥¯æ©“æ®‰æ´µæ·³ç£ç›¾ç¬ç­ç´”è„£èˆœè€è“´è•£è©¢è«„é†‡éŒé †é¦´æˆŒè¡“è¿°é‰¥å´‡å´§"],
    ["e3a1", "åµ©ç‘Ÿè†è¨æ¿•æ‹¾ç¿’è¤¶è¥²ä¸ä¹˜åƒ§å‹å‡æ‰¿æ˜‡ç¹©è …é™ä¾åŒ™å˜¶å§‹åª¤å°¸å±å±å¸‚å¼‘æƒæ–½æ˜¯æ™‚æ¾æŸ´çŒœçŸ¢ç¤ºç¿…è’”è“è¦–è©¦è©©è«¡è±•è±ºåŸ´å¯”å¼æ¯æ‹­æ¤æ®–æ¹œç†„ç¯’è•è­˜è»¾é£Ÿé£¾ä¼¸ä¾ä¿¡å‘»å¨ å®¸æ„¼æ–°æ™¨ç‡¼ç”³ç¥ç´³è…è‡£è˜è–ªè—èœƒè¨Šèº«è¾›ï¥±è¿…å¤±å®¤å¯¦æ‚‰å¯©å°‹å¿ƒæ²"],
    ["e4a1", "ï¥²æ·±ç€‹ç”šèŠ¯è«¶ä»€åï¥³é›™æ°äºä¿„å…’å•å¨¥å³¨æˆ‘ç‰™èŠ½èªè›¾è¡™è¨é˜¿é›…é¤“é´‰éµå Šå²³å¶½å¹„æƒ¡æ„•æ¡æ¨‚æ¸¥é„‚é”é¡é°é½·å®‰å²¸æŒ‰æ™æ¡ˆçœ¼é›éé¡”é®Ÿæ–¡è¬è»‹é–¼å”µå²©å·–åºµæš—ç™Œè´é—‡å£“æŠ¼ç‹é´¨ä»°å¤®æ€æ˜»æ®ƒç§§é´¦å“å“€åŸƒå´–æ„›æ›–æ¶¯ç¢è‰¾éš˜é„å„æ‰¼æ–æ¶²ç¸Šè…‹é¡"],
    ["e5a1", "æ«»ç½Œé¶¯é¸šä¹Ÿå€»å†¶å¤œæƒ¹æ¶æ¤°çˆºè€¶ï¥´é‡å¼±ï¥µï¥¶ç´„è‹¥è‘¯è’»è—¥èºï¥·ä½¯ï¥¸ï¥¹å£¤å­ƒæ™æšæ”˜æ•­æš˜ï¥ºæ¥Šæ¨£æ´‹ç€ç…¬ç—’ç˜ç¦³ç©°ï¥»ç¾Šï¥¼è¥„ï¥½è®“é‡€é™½ï¥¾é¤Šåœ„å¾¡æ–¼æ¼ç˜€ç¦¦èªé¦­é­šé½¬å„„æ†¶æŠ‘æªè‡†åƒå °å½¦ç„‰è¨€è«ºå­¼è˜–ä¿ºå„¼åš´å¥„æ©æ·¹å¶ªæ¥­å††äºˆä½™ï¥¿ï¦€ï¦å¦‚ï¦‚"],
    ["e6a1", "ï¦ƒæ­Ÿæ±ï¦„ç’µç¤–ï¦…èˆ‡è‰…èŒ¹è¼¿è½ï¦†é¤˜ï¦‡ï¦ˆï¦‰äº¦ï¦ŠåŸŸå½¹æ˜“ï¦‹ï¦Œç–«ç¹¹è­¯ï¦é€†é©›åš¥å §å§¸å¨Ÿå®´ï¦å»¶ï¦ï¦ææŒ»ï¦‘æ¤½æ²‡æ²¿æ¶æ¶“æ·µæ¼”ï¦’çƒŸç„¶ç…™ï¦“ç‡ƒç‡•ï¦”ç¡ç¡¯ï¦•ç­µç·£ï¦–ç¸¯ï¦—è¡è»Ÿï¦˜ï¦™ï¦šé‰›ï¦›é³¶ï¦œï¦ï¦æ‚…æ¶…ï¦Ÿç†±ï¦ ï¦¡é–±å­ï¦¢ï¦£ï¦¤æŸ“ï¦¥ç‚ç„°ç°è‰¶è‹’"],
    ["e7a1", "ï¦¦é–»é«¥é¹½æ›„ï¦§ç‡è‘‰ï¦¨ï¦©å¡‹ï¦ªï¦«å¶¸å½±ï¦¬æ˜ æšæ¥¹æ¦®æ°¸æ³³æ¸¶æ½æ¿šç€›ç€¯ç…ç‡Ÿç°ï¦­ç‘›ï¦®ç“”ç›ˆç©çº“ï¦¯ï¦°è‹±è© è¿ï¦±éˆï¦²éœ™ï¦³ï¦´ä¹‚å€ªï¦µåˆˆå¡æ›³æ±­æ¿ŠçŒŠç¿ç©¢èŠ®è—è˜‚ï¦¶è£”è©£è­½è±«ï¦·éŠ³ï¦¸éœ“é äº”ä¼ä¿‰å‚²åˆå¾å³å—šå¡¢å¢ºå¥§å¨›å¯¤æ‚Ÿï¦¹æ‡Šæ•–æ—¿æ™¤æ¢§æ±šæ¾³"],
    ["e8a1", "çƒç†¬ç’ç­½èœˆèª¤é°²é¼‡å±‹æ²ƒç„ç‰éˆºæº«ç‘¥ç˜Ÿç©©ç¸•è˜Šå…€å£…æ“ç“®ç”•ç™°ç¿é‚•é›é¥”æ¸¦ç“¦çª©çªªè‡¥è›™è¸è¨›å©‰å®Œå®›æ¢¡æ¤€æµ£ç©ç“ç¬ç¢—ç·©ç¿«è„˜è…•èè±Œé˜®é ‘æ›°å¾€æ—ºæ‰æ±ªç‹å€­å¨ƒæ­ªçŸ®å¤–åµ¬å·çŒ¥ç•ï¦ºï¦»åƒ¥å‡¹å ¯å¤­å¦–å§šå¯¥ï¦¼ï¦½å¶¢æ‹—æ–æ’“æ“¾ï¦¾æ›œï¦¿æ©ˆï§€ç‡¿ç‘¤ï§"],
    ["e9a1", "çªˆçª¯ç¹‡ç¹è€€è…°ï§‚èŸ¯è¦è¬ é™ï§ƒé‚€é¥’æ…¾æ¬²æµ´ç¸Ÿè¤¥è¾±ä¿‘å‚­å†—å‹‡åŸ‡å¢‰å®¹åº¸æ…‚æ¦•æ¶Œæ¹§æº¶ç†”ç‘¢ç”¨ç”¬è³èŒ¸è“‰è¸Šé”éï§„äºä½‘å¶å„ªåˆå‹å³å®‡å¯“å°¤æ„šæ†‚æ—´ç‰›ç—ç‘€ç›‚ç¥ç¦‘ç¦¹ç´†ç¾½èŠ‹è—•è™è¿‚é‡éƒµé‡ªéš…é›¨é›©å‹–å½§æ—­æ˜±æ ¯ç…œç¨¶éƒé Šäº‘ï§…æ©’æ®æ¾ç†‰è€˜èŠ¸è•“"],
    ["eaa1", "é‹éš•é›²éŸ»è”šé¬±äºç†Šé›„å…ƒåŸå“¡åœ“åœ’å£åª›å«„å¯ƒæ€¨æ„¿æ´æ²…æ´¹æ¹²æºçˆ°çŒ¿ç‘—è‹‘è¢è½…é ï§†é™¢é¡˜é´›æœˆè¶Šé‰ä½å‰åƒå±åœå§”å¨å°‰æ…°æšæ¸­çˆ²ç‘‹ç·¯èƒƒèè‘¦è”¿èŸè¡›è¤˜è¬‚é•éŸ‹é­ä¹³ä¾‘å„’å…ªï§‡å”¯å–©å­ºå®¥å¹¼å¹½åº¾æ‚ æƒŸæ„ˆæ„‰æ„æ”¸æœ‰ï§ˆæŸ”æŸšï§‰æ¥¡æ¥¢æ²¹æ´§ï§Šæ¸¸ï§‹"],
    ["eba1", "æ¿¡çŒ¶çŒ·ï§Œç‘œç”±ï§ç™’ï§ï§ç¶­è‡¾è¸è£•èª˜è«›è«­è¸°è¹‚éŠé€¾éºé…‰é‡‰é®ï§ï§‘å ‰ï§’æ¯“è‚‰è‚²ï§“ï§”å…å¥«å°¹ï§•ï§–æ½¤ç§èƒ¤è´‡ï§—éˆ—é–ï§˜ï§™ï§šï§›è¿æˆç€œçµ¨èï§œå æ©æ…‡æ®·èª¾éŠ€éš±ä¹™åŸæ·«è”­é™°éŸ³é£®æ–æ³£é‚‘å‡æ‡‰è†ºé·¹ä¾å€šå„€å®œæ„æ‡¿æ“¬æ¤…æ¯…ç–‘çŸ£ç¾©è‰¤è–èŸ»è¡£èª¼"],
    ["eca1", "è­°é†«äºŒä»¥ä¼Šï§ï§å¤·å§¨ï§Ÿå·²å¼›å½›æ€¡ï§ ï§¡ï§¢ï§£çˆ¾ç¥ï§¤ç•°ç—ï§¥ç§»ï§¦è€Œè€³è‚„è‹¡è‘ï§§ï§¨è²½è²³é‚‡ï§©ï§ªé£´é¤Œï§«ï§¬ç€·ç›Šç¿Šç¿Œç¿¼è¬šäººä»åˆƒå°ï§­å’½å› å§»å¯…å¼•å¿æ¹®ï§®ï§¯çµªèŒµï§°èš“èªï§±é­é·ï§²ï§³ä¸€ä½šä½¾å£¹æ—¥æº¢é€¸é°é¦¹ä»»å£¬å¦Šå§™æï§´ï§µç¨”ï§¶èè³ƒå…¥å„"],
    ["eda1", "ï§·ï§¸ï§¹ä»å‰©å­•èŠ¿ä»”åˆºå’¨å§‰å§¿å­å­—å­œæ£æ…ˆæ»‹ç‚™ç…®ç†ç“·ç–µç£ç´«è€…è‡ªèŒ¨è”—è—‰è«®è³‡é›Œä½œå‹ºåš¼æ–«æ˜¨ç¼ç‚¸çˆµç¶½èŠé…Œé›€éµ²å­±æ£§æ®˜æ½ºç›å²‘æš«æ½›ç®´ç°ªè ¶é›œä¸ˆä»—åŒ å ´å¢»å£¯å¥¬å°‡å¸³åº„å¼µæŒæš²æ–æ¨Ÿæª£æ¬Œæ¼¿ç‰†ï§ºçç’‹ç« ç²§è…¸è‡Ÿè‡§èŠè‘¬è”£è–”è—è£è´“é†¬é•·"],
    ["eea1", "éšœå†å“‰åœ¨å®°æ‰ææ ½æ¢“æ¸½æ»“ç½ç¸¡è£è²¡è¼‰é½‹é½çˆ­ç®è«éŒšä½‡ä½å„²å’€å§åº•æŠµæµæ¥®æ¨—æ²®æ¸šç‹™çŒªç–½ç®¸ç´µè‹§è¹è‘—è—·è©›è²¯èº‡é€™é‚¸é›é½Ÿå‹£åŠå«¡å¯‚æ‘˜æ•µæ»´ç‹„ï§»çš„ç©ç¬›ç±ç¸¾ç¿Ÿè»è¬«è³Šèµ¤è·¡è¹Ÿè¿ªè¿¹é©é‘ä½ƒä½ºå‚³å…¨å…¸å‰å‰ªå¡¡å¡¼å¥ å°ˆå±•å»›æ‚›æˆ°æ “æ®¿æ°ˆæ¾±"],
    ["efa1", "ç…ç ç”°ç”¸ç•‘ç™²ç­Œç®‹ç®­ç¯†çºè©®è¼¾è½‰éˆ¿éŠ“éŒ¢é«é›»é¡šé¡«é¤åˆ‡æˆªæŠ˜æµ™ç™¤ç«Šç¯€çµ¶å å²¾åº—æ¼¸ç‚¹ç²˜éœ‘é®é»æ¥æ‘ºè¶ä¸äº•äº­åœåµå‘ˆå§ƒå®šå¹€åº­å»·å¾æƒ…æŒºæ”¿æ•´æ—Œæ™¶æ™¸æŸ¾æ¥¨æª‰æ­£æ±€æ·€æ·¨æ¸Ÿæ¹ç€ç‚¡çç½ç”ºç›ç¢‡ç¦ç¨‹ç©½ç²¾ç¶è‰‡è¨‚è«ªè²é„­é…Šé‡˜é‰¦é‹ŒéŒ éœ†é–"],
    ["f0a1", "éœé ‚é¼åˆ¶åŠ‘å•¼å ¤å¸å¼Ÿæ‚Œææ¢¯æ¿Ÿç¥­ç¬¬è‡è–ºè£½è«¸è¹„é†é™¤éš›éœ½é¡Œé½Šä¿å…†å‡‹åŠ©å˜²å¼”å½«æªæ“æ—©æ™æ›ºæ›¹æœæ¢æ£—æ§½æ¼•æ½®ç…§ç‡¥çˆªç’ªçœºç¥–ç¥šç§Ÿç¨ çª•ç²—ç³Ÿçµ„ç¹°è‚‡è—»èš¤è©”èª¿è¶™èºé€ é­é‡£é˜»é›•é³¥æ—ç°‡è¶³éƒå­˜å°Šå’æ‹™çŒå€§å®—å¾æ‚°æ…«æ£•æ·™ç®ç¨®çµ‚ç¶œç¸±è…«"],
    ["f1a1", "è¸ªè¸µé¾é˜ä½åå·¦åº§æŒ«ç½ªä¸»ä½ä¾åšå§èƒ„å‘ªå‘¨å—¾å¥å®™å·å»šæ™æœ±æŸ±æ ªæ³¨æ´²æ¹Šæ¾ç‚·ç ç–‡ç±Œç´‚ç´¬ç¶¢èˆŸè››è¨»èª…èµ°èºŠè¼³é€±é…é…’é‘„é§ç«¹ç²¥ä¿Šå„å‡†åŸˆå¯¯å³»æ™™æ¨½æµšæº–æ¿¬ç„Œç•¯ç«£è ¢é€¡éµé›‹é§¿èŒä¸­ä»²è¡†é‡å½æ«›æ¥«æ±è‘ºå¢æ†æ›¾æ‹¯çƒç”‘ç—‡ç¹’è’¸è­‰è´ˆä¹‹åª"],
    ["f2a1", "å’«åœ°å€å¿—æŒæŒ‡æ‘¯æ”¯æ—¨æ™ºææ³æ­¢æ± æ²šæ¼¬çŸ¥ç ¥ç¥‰ç¥—ç´™è‚¢è„‚è‡³èŠèŠ·èœ˜èªŒï§¼è´„è¶¾é²ç›´ç¨™ç¨·ç¹”è·å”‡å—”å¡µæŒ¯æ¢æ™‰æ™‹æ¡­æ¦›æ®„æ´¥æº±çç‘¨ç’¡ç•›ç–¹ç›¡çœç‹ç§¦ç¸‰ç¸è‡»è”¯è¢—è¨ºè³‘è»«è¾°é€²é­é™£é™³éœ‡ä¾„å±å§ªå«‰å¸™æ¡ç“†ç–¾ç§©çª’è†£è›­è³ªè·Œè¿­æ–Ÿæœ•ï§½åŸ·æ½—ç·è¼¯"],
    ["f3a1", "é¶é›†å¾µæ‡²æ¾„ä¸”ä¾˜å€Ÿå‰å—Ÿåµ¯å·®æ¬¡æ­¤ç£‹ç®šï§¾è¹‰è»Šé®æ‰æ¾ç€çª„éŒ¯é‘¿é½ªæ’°æ¾¯ç‡¦ç’¨ç“šç«„ç°’çº‚ç²²çº˜è®šè´Šé‘½é¤é¥Œåˆ¹å¯Ÿæ“¦æœ­ç´®åƒ­åƒå¡¹æ…˜æ…™æ‡ºæ–¬ç«™è®’è®–å€‰å€¡å‰µå”±å¨¼å» å½°æ„´æ•æ˜Œæ˜¶æš¢æ§æ»„æ¼²çŒ–ç˜¡çª“è„¹è‰™è–è’¼å‚µåŸ°å¯€å¯¨å½©æ¡ç ¦ç¶µèœè”¡é‡‡é‡µå†ŠæŸµç­–"],
    ["f4a1", "è²¬å‡„å¦»æ‚½è™•å€œï§¿å‰”å°ºæ…½æˆšæ‹“æ“²æ–¥æ»Œç˜ è„Šè¹ é™Ÿéš»ä»Ÿåƒå–˜å¤©å·æ“…æ³‰æ·ºç”ç©¿èˆ›è–¦è³¤è¸é·é‡§é—¡é˜¡éŸ†å‡¸å“²å–†å¾¹æ’¤æ¾ˆç¶´è¼Ÿè½éµåƒ‰å°–æ²¾æ·»ç”›ç»ç°½ç±¤è©¹è«‚å å¦¾å¸–æ·ç‰’ç–Šç«è«œè²¼è¼’å»³æ™´æ·¸è½èè«‹é‘é¯–ï¨€å‰ƒæ›¿æ¶•æ»¯ç· è«¦é€®éé«”åˆå‰¿å“¨æ†”æŠ„æ‹›æ¢¢"],
    ["f5a1", "æ¤’æ¥šæ¨µç‚’ç„¦ç¡ç¤ç¤ç§’ç¨è‚–è‰¸è‹•è‰è•‰è²‚è¶…é…¢é†‹é†®ä¿ƒå›‘ç‡­çŸ—èœ€è§¸å¯¸å¿–æ‘é‚¨å¢å¡šå¯µæ‚¤æ†æ‘ ç¸½è°è”¥éŠƒæ’®å‚¬å´”æœ€å¢œæŠ½æ¨æ¤æ¥¸æ¨æ¹«çšºç§‹èŠ»è©è«è¶¨è¿½é„’é…‹é†œéŒéŒ˜éšé››é¨¶é°ä¸‘ç•œç¥ç«ºç­‘ç¯‰ç¸®è“„è¹™è¹´è»¸é€æ˜¥æ¤¿ç‘ƒå‡ºæœ®é»œå……å¿ æ²–èŸ²è¡è¡·æ‚´è†µèƒ"],
    ["f6a1", "è´…å–å¹å˜´å¨¶å°±ç‚Šç¿ èšè„†è‡­è¶£é†‰é©Ÿé·²å´ä»„å æƒ»æ¸¬å±¤ä¾ˆå€¤å—¤å³™å¹Ÿæ¥æ¢”æ²»æ·„ç†¾ç—”ç—´ç™¡ç¨šç©‰ç·‡ç·»ç½®è‡´èš©è¼œé›‰é¦³é½’å‰‡å‹…é£­è¦ªä¸ƒæŸ’æ¼†ä¾µå¯¢æ•æ²ˆæµ¸ç›ç §é‡é¼èŸ„ç§¤ç¨±å¿«ä»–å’¤å”¾å¢®å¦¥æƒ°æ‰“æ‹–æœ¶æ¥•èˆµé™€é¦±é§å€¬å“å•„å¼ï¨æ‰˜ï¨‚æ“¢æ™«æŸæ¿æ¿¯ç¢ç¸è¨—"],
    ["f7a1", "é¸å‘‘å˜†å¦å½ˆæ†šæ­ç˜ç‚­ç¶»èª•å¥ªè„«æ¢çœˆè€½è²ªå¡”æ­æ¦»å®•å¸‘æ¹¯ï¨ƒè•©å…Œå°å¤ªæ€ æ…‹æ®†æ±°æ³°ç¬èƒè‹”è·†é‚°é¢±ï¨„æ“‡æ¾¤æ’‘æ”„å…ååœŸè¨æ…Ÿæ¡¶ï¨…ç—›ç­’çµ±é€šå †æ§Œè…¿è¤ªé€€é ¹å¸å¥—å¦¬æŠ•é€é¬ªæ…ç‰¹é—–å¡å©†å·´æŠŠæ’­æ“ºæ·æ³¢æ´¾çˆ¬ç¶ç ´ç½·èŠ­è·›é —åˆ¤å‚æ¿ç‰ˆç“£è²©è¾¦éˆ‘"],
    ["f8a1", "é˜ªå…«å­æŒä½©å”„æ‚–æ•—æ²›æµ¿ç‰Œç‹½ç¨—è¦‡è²å½­æ¾çƒ¹è†¨æ„ä¾¿åæ‰ç‰‡ç¯‡ç·¨ç¿©éé­é¨™è²¶åªå¹³æ°èè©•å å¬–å¹£å»¢å¼Šæ–ƒè‚ºè”½é–‰é™›ä½ˆåŒ…åŒåŒå’†å“ºåœƒå¸ƒæ€–æŠ›æŠ±æ•ï¨†æ³¡æµ¦ç–±ç ²èƒè„¯è‹è‘¡è’²è¢è¤’é€‹é‹ªé£½é®‘å¹…æš´æ›ç€‘çˆ†ï¨‡ä¿µå‰½å½ªæ…“æ“æ¨™æ¼‚ç“¢ç¥¨è¡¨è±¹é£‡é£„é©ƒ"],
    ["f9a1", "å“ç¨Ÿæ¥“è«·è±Šé¢¨é¦®å½¼æŠ«ç–²çš®è¢«é¿é™‚åŒ¹å¼¼å¿…æ³ŒçŒç•¢ç–‹ç­†è‹¾é¦ä¹é€¼ä¸‹ä½•å¦å¤å»ˆæ˜°æ²³ç‘•è·è¦è³€ééœé°•å£‘å­¸è™è¬”é¶´å¯’æ¨æ‚æ—±æ±—æ¼¢æ¾£ç€šç½•ç¿°é–‘é–’é™éŸ“å‰²è½„å‡½å«å’¸å•£å–Šæª»æ¶µç·˜è‰¦éŠœé™·é¹¹åˆå“ˆç›’è›¤é–¤é—”é™œäº¢ä¼‰å§®å«¦å··æ’æŠ—æ­æ¡æ²†æ¸¯ç¼¸è‚›èˆª"],
    ["faa1", "ï¨ˆï¨‰é …äº¥å•å’³å“å¥šå­©å®³æ‡ˆæ¥·æµ·ç€£èŸ¹è§£è©²è«§é‚‚é§­éª¸åŠ¾æ ¸å€–å¹¸æè‡è¡Œäº«å‘åš®ç¦é„•éŸ¿é¤‰é¥—é¦™å™“å¢Ÿè™›è¨±æ†²æ«¶ç»è»’æ­‡éšªé©—å¥•çˆ€èµ«é©ä¿”å³´å¼¦æ‡¸æ™›æ³«ç‚«ç„ç¹ç¾çœ©ççµƒçµ¢ç¸£èˆ·è¡’ï¨Šè³¢é‰‰é¡¯å­‘ç©´è¡€é å«Œä¿ å”å¤¾å³½æŒ¾æµ¹ç‹¹è„…è„‡è¢é‹é °äº¨å…„åˆ‘å‹"],
    ["fba1", "å½¢æ³‚æ»ç€…çç‚¯ç†’ç©ç‘©èŠè¢è¡¡é€ˆé‚¢é£é¦¨å…®å½—æƒ æ…§æš³è•™è¹Šé†¯é‹ä¹äº’å‘¼å£•å£ºå¥½å²µå¼§æˆ¶æ‰ˆæ˜Šæ™§æ¯«æµ©æ·æ¹–æ»¸æ¾”æ¿ æ¿©çç‹ç¥ç‘šç“ çš“ç¥œç³Šç¸èƒ¡èŠ¦è‘«è’¿è™è™Ÿè´è­·è±ªé¬é €é¡¥æƒ‘æˆ–é…·å©šæ˜æ··æ¸¾ç¿é­‚å¿½æƒšç¬å“„å¼˜æ±æ³“æ´ªçƒ˜ç´…è™¹è¨Œé´»åŒ–å’Œå¬…æ¨ºç«ç•µ"],
    ["fca1", "ç¦ç¦¾èŠ±è¯è©±è­è²¨é´ï¨‹æ“´æ”«ç¢ºç¢»ç©«ä¸¸å–šå¥å®¦å¹»æ‚£æ›æ­¡æ™¥æ¡“æ¸™ç…¥ç’°ç´ˆé‚„é©©é°¥æ´»æ»‘çŒ¾è±é—Šå‡°å¹Œå¾¨ææƒ¶æ„°æ…Œæ™ƒæ™„æ¦¥æ³æ¹Ÿæ»‰æ½¢ç…Œç’œçš‡ç¯ç°§è’è—é‘éšé»ƒåŒ¯å›å»»å¾Šæ¢æ‚”æ‡·æ™¦æœƒæªœæ·®æ¾®ç°çªç¹ªè†¾èŒ´è›”èª¨è³„åŠƒç²å®–æ©«é„å“®åš†å­æ•ˆæ–…æ›‰æ¢Ÿæ¶æ·†"],
    ["fda1", "çˆ»è‚´é…µé©ä¾¯å€™åšåå¼å–‰å—…å¸¿å¾Œæœ½ç…¦çé€…å‹›å‹³å¡¤å£ç„„ç†ç‡»è–°è¨“æšˆè–¨å–§æš„ç…Šè±å‰å–™æ¯å½™å¾½æ®æš‰ç…‡è«±è¼éº¾ä¼‘æºçƒ‹ç•¦è™§æ¤è­é·¸å…‡å‡¶åŒˆæ´¶èƒ¸é»‘æ˜•æ¬£ç‚˜ç—•åƒå±¹ç´‡è¨–æ¬ æ¬½æ­†å¸æ°æ´½ç¿•èˆˆåƒ–å‡å–œå™«å›å§¬å¬‰å¸Œæ†™æ†˜æˆ±æ™æ›¦ç†™ç†¹ç†ºçŠ§ç¦§ç¨€ç¾²è©°"]
  ];
});

// node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\0", 127],
    ["a140", "ã€€ï¼Œã€ã€‚ï¼â€§ï¼›ï¼šï¼Ÿï¼ï¸°â€¦â€¥ï¹ï¹‘ï¹’Â·ï¹”ï¹•ï¹–ï¹—ï½œâ€“ï¸±â€”ï¸³â•´ï¸´ï¹ï¼ˆï¼‰ï¸µï¸¶ï½›ï½ï¸·ï¸¸ã€”ã€•ï¸¹ï¸ºã€ã€‘ï¸»ï¸¼ã€Šã€‹ï¸½ï¸¾ã€ˆã€‰ï¸¿ï¹€ã€Œã€ï¹ï¹‚ã€ã€ï¹ƒï¹„ï¹™ï¹š"],
    ["a1a1", "ï¹›ï¹œï¹ï¹â€˜â€™â€œâ€ã€ã€â€µâ€²ï¼ƒï¼†ï¼Šâ€»Â§ã€ƒâ—‹â—â–³â–²â—â˜†â˜…â—‡â—†â–¡â– â–½â–¼ãŠ£â„…Â¯ï¿£ï¼¿Ëï¹‰ï¹Šï¹ï¹ï¹‹ï¹Œï¹Ÿï¹ ï¹¡ï¼‹ï¼Ã—Ã·Â±âˆšï¼œï¼ï¼â‰¦â‰§â‰ âˆâ‰’â‰¡ï¹¢", 4, "ï½âˆ©âˆªâŠ¥âˆ âˆŸâŠ¿ã’ã‘âˆ«âˆ®âˆµâˆ´â™€â™‚âŠ•âŠ™â†‘â†“â†â†’â†–â†—â†™â†˜âˆ¥âˆ£ï¼"],
    ["a240", "ï¼¼âˆ•ï¹¨ï¼„ï¿¥ã€’ï¿ ï¿¡ï¼…ï¼ â„ƒâ„‰ï¹©ï¹ªï¹«ã•ãœãããã¡ããã„Â°å…™å…›å…å…å…¡å…£å—§ç“©ç³â–", 7, "â–â–â–â–Œâ–‹â–Šâ–‰â”¼â”´â”¬â”¤â”œâ–”â”€â”‚â–•â”Œâ”â””â”˜â•­"],
    ["a2a1", "â•®â•°â•¯â•â•â•ªâ•¡â—¢â—£â—¥â—¤â•±â•²â•³ï¼", 9, "â… ", 9, "ã€¡", 8, "åå„å…ï¼¡", 25, "ï½", 21],
    ["a340", "ï½—ï½˜ï½™ï½šÎ‘", 16, "Î£", 6, "Î±", 16, "Ïƒ", 6, "ã„…", 10],
    ["a3a1", "ã„", 25, "Ë™Ë‰ËŠË‡Ë‹"],
    ["a3e1", "â‚¬"],
    ["a440", "ä¸€ä¹™ä¸ä¸ƒä¹ƒä¹äº†äºŒäººå„¿å…¥å…«å‡ åˆ€åˆåŠ›åŒ•ååœåˆä¸‰ä¸‹ä¸ˆä¸Šä¸«ä¸¸å‡¡ä¹…ä¹ˆä¹Ÿä¹äºäº¡å…€åˆƒå‹ºåƒå‰å£åœŸå£«å¤•å¤§å¥³å­å­‘å­“å¯¸å°å°¢å°¸å±±å·å·¥å·±å·²å·³å·¾å¹²å»¾å¼‹å¼“æ‰"],
    ["a4a1", "ä¸‘ä¸ä¸ä¸­ä¸°ä¸¹ä¹‹å°¹äºˆäº‘äº•äº’äº”äº¢ä»ä»€ä»ƒä»†ä»‡ä»ä»Šä»‹ä»„å…ƒå…å…§å…­å…®å…¬å†—å‡¶åˆ†åˆ‡åˆˆå‹»å‹¾å‹¿åŒ–åŒ¹åˆå‡å…åå„å‹åŠåå£¬å¤©å¤«å¤ªå¤­å­”å°‘å°¤å°ºå±¯å·´å¹»å»¿å¼”å¼•å¿ƒæˆˆæˆ¶æ‰‹æ‰æ”¯æ–‡æ–—æ–¤æ–¹æ—¥æ›°æœˆæœ¨æ¬ æ­¢æ­¹æ¯‹æ¯”æ¯›æ°æ°´ç«çˆªçˆ¶çˆ»ç‰‡ç‰™ç‰›çŠ¬ç‹ä¸™"],
    ["a540", "ä¸–ä¸•ä¸”ä¸˜ä¸»ä¹ä¹ä¹ä»¥ä»˜ä»”ä»•ä»–ä»—ä»£ä»¤ä»™ä»å……å…„å†‰å†Šå†¬å‡¹å‡ºå‡¸åˆŠåŠ åŠŸåŒ…åŒ†åŒ—åŒä»ŸåŠå‰å¡å å¯å®å»å¯å¤å³å¬å®å©å¨å¼å¸åµå«å¦åªå²å±å°å¥å­å»å››å›šå¤–"],
    ["a5a1", "å¤®å¤±å¥´å¥¶å­•å®ƒå°¼å·¨å·§å·¦å¸‚å¸ƒå¹³å¹¼å¼å¼˜å¼—å¿…æˆŠæ‰“æ‰”æ‰’æ‰‘æ–¥æ—¦æœ®æœ¬æœªæœ«æœ­æ­£æ¯æ°‘æ°æ°¸æ±æ±€æ°¾çŠ¯ç„ç‰ç“œç“¦ç”˜ç”Ÿç”¨ç”©ç”°ç”±ç”²ç”³ç–‹ç™½çš®çš¿ç›®çŸ›çŸ¢çŸ³ç¤ºç¦¾ç©´ç«‹ä¸ä¸Ÿä¹’ä¹“ä¹©äº™äº¤äº¦äº¥ä»¿ä¼‰ä¼™ä¼Šä¼•ä¼ä¼ä¼‘ä¼ä»²ä»¶ä»»ä»°ä»³ä»½ä¼ä¼‹å…‰å…‡å…†å…ˆå…¨"],
    ["a640", "å…±å†å†°åˆ—åˆ‘åˆ’åˆåˆ–åŠ£åŒˆåŒ¡åŒ å°å±å‰ååŒåŠååå‹å„å‘ååˆåƒåå†å’å› å›å›åœ³åœ°åœ¨åœ­åœ¬åœ¯åœ©å¤™å¤šå¤·å¤¸å¦„å¥¸å¦ƒå¥½å¥¹å¦‚å¦å­—å­˜å®‡å®ˆå®…å®‰å¯ºå°–å±¹å·å¸†å¹¶å¹´"],
    ["a6a1", "å¼å¼›å¿™å¿–æˆæˆŒæˆæˆæ‰£æ‰›æ‰˜æ”¶æ—©æ—¨æ—¬æ—­æ›²æ›³æœ‰æœ½æœ´æœ±æœµæ¬¡æ­¤æ­»æ°–æ±æ±—æ±™æ±Ÿæ± æ±æ±•æ±¡æ±›æ±æ±ç°ç‰Ÿç‰ç™¾ç«¹ç±³ç³¸ç¼¶ç¾Šç¾½è€è€ƒè€Œè€’è€³è¿è‚‰è‚‹è‚Œè‡£è‡ªè‡³è‡¼èˆŒèˆ›èˆŸè‰®è‰²è‰¾è™«è¡€è¡Œè¡£è¥¿é˜¡ä¸²äº¨ä½ä½ä½‡ä½—ä½ä¼´ä½›ä½•ä¼°ä½ä½‘ä¼½ä¼ºä¼¸ä½ƒä½”ä¼¼ä½†ä½£"],
    ["a740", "ä½œä½ ä¼¯ä½ä¼¶ä½™ä½ä½ˆä½šå…Œå…‹å…å…µå†¶å†·åˆ¥åˆ¤åˆ©åˆªåˆ¨åŠ«åŠ©åŠªåŠ¬åŒ£å³åµåå­åå¾å¦å‘å§å‘†å‘ƒå³å‘ˆå‘‚å›å©å‘Šå¹å»å¸å®åµå¶å å¼å‘€å±å«åŸå¬å›ªå›°å›¤å›«åŠå‘å€å"],
    ["a7a1", "å‡ååœ¾åååœ»å£¯å¤¾å¦å¦’å¦¨å¦å¦£å¦™å¦–å¦å¦¤å¦“å¦Šå¦¥å­å­œå­šå­›å®Œå®‹å®å°¬å±€å±å°¿å°¾å²å²‘å²”å²Œå·«å¸Œåºåº‡åºŠå»·å¼„å¼Ÿå½¤å½¢å½·å½¹å¿˜å¿Œå¿—å¿å¿±å¿«å¿¸å¿ªæˆ’æˆ‘æŠ„æŠ—æŠ–æŠ€æ‰¶æŠ‰æ‰­æŠŠæ‰¼æ‰¾æ‰¹æ‰³æŠ’æ‰¯æŠ˜æ‰®æŠ•æŠ“æŠ‘æŠ†æ”¹æ”»æ”¸æ—±æ›´æŸææææ‘æœæ–ææ‰æ†æ "],
    ["a840", "æ“æ—æ­¥æ¯æ±‚æ±æ²™æ²æ²ˆæ²‰æ²…æ²›æ±ªæ±ºæ²æ±°æ²Œæ±¨æ²–æ²’æ±½æ²ƒæ±²æ±¾æ±´æ²†æ±¶æ²æ²”æ²˜æ²‚ç¶ç¼ç½ç¸ç‰¢ç‰¡ç‰ ç‹„ç‹‚ç–ç”¬ç”«ç”·ç”¸çš‚ç›¯çŸ£ç§ç§€ç¦¿ç©¶ç³»ç½•è‚–è‚“è‚è‚˜è‚›è‚šè‚²è‰¯èŠ’"],
    ["a8a1", "èŠ‹èŠè¦‹è§’è¨€è°·è±†è±•è²èµ¤èµ°è¶³èº«è»Šè¾›è¾°è¿‚è¿†è¿…è¿„å·¡é‚‘é‚¢é‚ªé‚¦é‚£é…‰é‡†é‡Œé˜²é˜®é˜±é˜ªé˜¬ä¸¦ä¹–ä¹³äº‹äº›äºäº«äº¬ä½¯ä¾ä¾ä½³ä½¿ä½¬ä¾›ä¾‹ä¾†ä¾ƒä½°ä½µä¾ˆä½©ä½»ä¾–ä½¾ä¾ä¾‘ä½ºå…”å…’å…•å…©å…·å…¶å…¸å†½å‡½åˆ»åˆ¸åˆ·åˆºåˆ°åˆ®åˆ¶å‰åŠ¾åŠ»å’å”å“å‘å¦å·å¸å¹å–å”å—å‘³å‘µ"],
    ["a940", "å’–å‘¸å’•å’€å‘»å‘·å’„å’’å’†å‘¼å’å‘±å‘¶å’Œå’šå‘¢å‘¨å’‹å‘½å’å›ºåƒå·åªå©å¡å¦å¤å¼å¤œå¥‰å¥‡å¥ˆå¥„å¥”å¦¾å¦»å§”å¦¹å¦®å§‘å§†å§å§å§‹å§“å§Šå¦¯å¦³å§’å§…å­Ÿå­¤å­£å®—å®šå®˜å®œå®™å®›å°šå±ˆå±…"],
    ["a9a1", "å±†å²·å²¡å²¸å²©å²«å²±å²³å¸˜å¸šå¸–å¸•å¸›å¸‘å¹¸åºšåº—åºœåº•åº–å»¶å¼¦å¼§å¼©å¾€å¾å½¿å½¼å¿å¿ å¿½å¿µå¿¿æ€æ€”æ€¯æ€µæ€–æ€ªæ€•æ€¡æ€§æ€©æ€«æ€›æˆ–æˆ•æˆ¿æˆ¾æ‰€æ‰¿æ‹‰æ‹Œæ‹„æŠ¿æ‹‚æŠ¹æ‹’æ‹›æŠ«æ‹“æ‹”æ‹‹æ‹ˆæŠ¨æŠ½æŠ¼æ‹æ‹™æ‹‡æ‹æŠµæ‹šæŠ±æ‹˜æ‹–æ‹—æ‹†æŠ¬æ‹æ”¾æ–§æ–¼æ—ºæ˜”æ˜“æ˜Œæ˜†æ˜‚æ˜æ˜€æ˜æ˜•æ˜Š"],
    ["aa40", "æ˜‡æœæœ‹æ­æ‹æ•æ±æœæ³æ·æ‡ææ—æ¯æ°æ¿æ‰æ¾ææµæšæ“æ¼æªæ²æ¬£æ­¦æ­§æ­¿æ°“æ°›æ³£æ³¨æ³³æ²±æ³Œæ³¥æ²³æ²½æ²¾æ²¼æ³¢æ²«æ³•æ³“æ²¸æ³„æ²¹æ³æ²®æ³—æ³…æ³±æ²¿æ²»æ³¡æ³›æ³Šæ²¬æ³¯æ³œæ³–æ³ "],
    ["aaa1", "ç‚•ç‚ç‚’ç‚Šç‚™çˆ¬çˆ­çˆ¸ç‰ˆç‰§ç‰©ç‹€ç‹ç‹™ç‹—ç‹ç©ç¨çŸç«ç¥ç”½ç–ç–™ç–šçš„ç›‚ç›²ç›´çŸ¥çŸ½ç¤¾ç¥€ç¥ç§‰ç§ˆç©ºç©¹ç«ºç³¾ç½”ç¾Œç¾‹è€…è‚ºè‚¥è‚¢è‚±è‚¡è‚«è‚©è‚´è‚ªè‚¯è‡¥è‡¾èˆèŠ³èŠèŠ™èŠ­èŠ½èŠŸèŠ¹èŠ±èŠ¬èŠ¥èŠ¯èŠ¸èŠ£èŠ°èŠ¾èŠ·è™è™±åˆè¡¨è»‹è¿è¿”è¿‘é‚µé‚¸é‚±é‚¶é‡‡é‡‘é•·é–€é˜œé™€é˜¿é˜»é™„"],
    ["ab40", "é™‚éš¹é›¨é’éäºŸäº­äº®ä¿¡ä¾µä¾¯ä¾¿ä¿ ä¿‘ä¿ä¿ä¿ƒä¾¶ä¿˜ä¿Ÿä¿Šä¿—ä¾®ä¿ä¿„ä¿‚ä¿šä¿ä¿ä¾·å…—å†’å†‘å† å‰å‰ƒå‰Šå‰å‰Œå‰‹å‰‡å‹‡å‹‰å‹ƒå‹åŒå—å»åšå›å’¬å“€å’¨å“å“‰å’¸å’¦å’³å“‡å“‚å’½å’ªå“"],
    ["aba1", "å“„å“ˆå’¯å’«å’±å’»å’©å’§å’¿å›¿å‚å‹å å£å¢åŸå®å“å¥•å¥‘å¥å¥å¥å§œå§˜å§¿å§£å§¨å¨ƒå§¥å§ªå§šå§¦å¨å§»å­©å®£å®¦å®¤å®¢å®¥å°å±å±å±å±‹å³™å³’å··å¸å¸¥å¸Ÿå¹½åº åº¦å»ºå¼ˆå¼­å½¥å¾ˆå¾…å¾Šå¾‹å¾‡å¾Œå¾‰æ€’æ€æ€ æ€¥æ€æ€¨ææ°æ¨æ¢æ†æƒæ¬æ«æªæ¤æ‰æ‹œæŒ–æŒ‰æ‹¼æ‹­æŒæ‹®æ‹½æŒ‡æ‹±æ‹·"],
    ["ac40", "æ‹¯æ‹¬æ‹¾æ‹´æŒ‘æŒ‚æ”¿æ•…æ–«æ–½æ—¢æ˜¥æ˜­æ˜ æ˜§æ˜¯æ˜Ÿæ˜¨æ˜±æ˜¤æ›·æŸ¿æŸ“æŸ±æŸ”æŸæŸ¬æ¶æ¯æŸµæŸ©æŸ¯æŸ„æŸ‘æ´æŸšæŸ¥æ¸æŸæŸæŸ³æ°æŸ™æŸ¢æŸæŸ’æ­ªæ®ƒæ®†æ®µæ¯’æ¯—æ°Ÿæ³‰æ´‹æ´²æ´ªæµæ´¥æ´Œæ´±æ´æ´—"],
    ["aca1", "æ´»æ´½æ´¾æ´¶æ´›æ³µæ´¹æ´§æ´¸æ´©æ´®æ´µæ´æ´«ç‚«ç‚ºç‚³ç‚¬ç‚¯ç‚­ç‚¸ç‚®ç‚¤çˆ°ç‰²ç‰¯ç‰´ç‹©ç‹ ç‹¡ç·çŠç»ç²çç€ç³ç”šç”­ç•ç•Œç•ç•‹ç–«ç–¤ç–¥ç–¢ç–£ç™¸çš†çš‡çšˆç›ˆç›†ç›ƒç›…çœç›¹ç›¸çœ‰çœ‹ç›¾ç›¼çœ‡çŸœç ‚ç ”ç Œç ç¥†ç¥‰ç¥ˆç¥‡ç¦¹ç¦ºç§‘ç§’ç§‹ç©¿çªç«¿ç«½ç±½ç´‚ç´…ç´€ç´‰ç´‡ç´„ç´†ç¼¸ç¾ç¾¿è€„"],
    ["ad40", "è€è€è€‘è€¶èƒ–èƒ¥èƒšèƒƒèƒ„èƒŒèƒ¡èƒ›èƒèƒèƒ¤èƒè‡´èˆ¢è‹§èŒƒèŒ…è‹£è‹›è‹¦èŒ„è‹¥èŒ‚èŒ‰è‹’è‹—è‹±èŒè‹œè‹”è‹‘è‹è‹“è‹Ÿè‹¯èŒ†è™è™¹è™»è™ºè¡è¡«è¦è§”è¨ˆè¨‚è¨ƒè²è² èµ´èµ³è¶´è»è»Œè¿°è¿¦è¿¢è¿ªè¿¥"],
    ["ada1", "è¿­è¿«è¿¤è¿¨éƒŠéƒéƒéƒƒé…‹é…Šé‡é–‚é™é™‹é™Œé™é¢é©éŸ‹éŸ­éŸ³é é¢¨é£›é£Ÿé¦–é¦™ä¹˜äº³å€Œå€å€£ä¿¯å€¦å€¥ä¿¸å€©å€–å€†å€¼å€Ÿå€šå€’å€‘ä¿ºå€€å€”å€¨ä¿±å€¡å€‹å€™å€˜ä¿³ä¿®å€­å€ªä¿¾å€«å€‰å…¼å†¤å†¥å†¢å‡å‡Œå‡†å‡‹å‰–å‰œå‰”å‰›å‰åŒªå¿åŸååŸå“¨å”å”å”·å“¼å“¥å“²å”†å“ºå””å“©å“­å“¡å”‰å“®å“ª"],
    ["ae40", "å“¦å”§å”‡å“½å”åœƒåœ„åŸ‚åŸ”åŸ‹åŸƒå ‰å¤å¥—å¥˜å¥šå¨‘å¨˜å¨œå¨Ÿå¨›å¨“å§¬å¨ å¨£å¨©å¨¥å¨Œå¨‰å­«å±˜å®°å®³å®¶å®´å®®å®µå®¹å®¸å°„å±‘å±•å±å³­å³½å³»å³ªå³¨å³°å³¶å´å³´å·®å¸­å¸«åº«åº­åº§å¼±å¾’å¾‘å¾æ™"],
    ["aea1", "æ£æ¥ææ•æ­æ©æ¯æ‚„æ‚Ÿæ‚šæ‚æ‚”æ‚Œæ‚…æ‚–æ‰‡æ‹³æŒˆæ‹¿ææŒ¾æŒ¯æ•æ‚æ†ææ‰æŒºææŒ½æŒªæŒ«æŒ¨ææŒæ•ˆæ•‰æ–™æ—æ—…æ™‚æ™‰æ™æ™ƒæ™’æ™Œæ™…æ™æ›¸æœ”æœ•æœ—æ ¡æ ¸æ¡ˆæ¡†æ¡“æ ¹æ¡‚æ¡”æ ©æ¢³æ —æ¡Œæ¡‘æ ½æŸ´æ¡æ¡€æ ¼æ¡ƒæ ªæ¡…æ “æ ˜æ¡æ®Šæ®‰æ®·æ°£æ°§æ°¨æ°¦æ°¤æ³°æµªæ¶•æ¶ˆæ¶‡æµ¦æµ¸æµ·æµ™æ¶“"],
    ["af40", "æµ¬æ¶‰æµ®æµšæµ´æµ©æ¶Œæ¶Šæµ¹æ¶…æµ¥æ¶”çƒŠçƒ˜çƒ¤çƒ™çƒˆçƒçˆ¹ç‰¹ç‹¼ç‹¹ç‹½ç‹¸ç‹·ç†ç­ç‰ç®ç çªçç•”ç•ç•œç•šç•™ç–¾ç—…ç—‡ç–²ç–³ç–½ç–¼ç–¹ç—‚ç–¸çš‹çš°ç›Šç›ç›çœ©çœŸçœ çœ¨çŸ©ç °ç §ç ¸ç ç ´ç ·"],
    ["afa1", "ç ¥ç ­ç  ç Ÿç ²ç¥•ç¥ç¥ ç¥Ÿç¥–ç¥ç¥ç¥—ç¥šç§¤ç§£ç§§ç§Ÿç§¦ç§©ç§˜çª„çªˆç«™ç¬†ç¬‘ç²‰ç´¡ç´—ç´‹ç´Šç´ ç´¢ç´”ç´ç´•ç´šç´œç´ç´™ç´›ç¼ºç½Ÿç¾”ç¿…ç¿è€†è€˜è€•è€™è€—è€½è€¿èƒ±è„‚èƒ°è„…èƒ­èƒ´è„†èƒ¸èƒ³è„ˆèƒ½è„Šèƒ¼èƒ¯è‡­è‡¬èˆ€èˆèˆªèˆ«èˆ¨èˆ¬èŠ»èŒ«è’è”èŠèŒ¸èè‰èŒµèŒ´èèŒ²èŒ¹èŒ¶èŒ—è€èŒ±èŒ¨èƒ"],
    ["b040", "è™”èšŠèšªèš“èš¤èš©èšŒèš£èšœè¡°è¡·è¢è¢‚è¡½è¡¹è¨˜è¨è¨è¨Œè¨•è¨Šè¨—è¨“è¨–è¨è¨‘è±ˆè±ºè±¹è²¡è²¢èµ·èº¬è»’è»”è»è¾±é€é€†è¿·é€€è¿ºè¿´é€ƒè¿½é€…è¿¸é‚•éƒ¡éƒéƒ¢é…’é…é…Œé‡˜é‡é‡—é‡œé‡™é–ƒé™¢é™£é™¡"],
    ["b0a1", "é™›é™é™¤é™˜é™éš»é£¢é¦¬éª¨é«˜é¬¥é¬²é¬¼ä¹¾åºå½åœå‡åƒåŒåšå‰å¥å¶åå•åµå´å·åå€å¯å­å…œå†•å‡°å‰ªå‰¯å‹’å‹™å‹˜å‹•åŒåŒåŒ™åŒ¿å€åŒ¾åƒæ›¼å•†å•ªå•¦å•„å•å•¡å•ƒå•Šå”±å•–å•å••å”¯å•¤å”¸å”®å•œå”¬å•£å”³å•å•—åœˆåœ‹åœ‰åŸŸå …å Šå †åŸ åŸ¤åŸºå ‚å µåŸ·åŸ¹å¤ å¥¢å¨¶å©å©‰å©¦å©ªå©€"],
    ["b140", "å¨¼å©¢å©šå©†å©Šå­°å¯‡å¯…å¯„å¯‚å®¿å¯†å°‰å°ˆå°‡å± å±œå±å´‡å´†å´å´›å´–å´¢å´‘å´©å´”å´™å´¤å´§å´—å·¢å¸¸å¸¶å¸³å¸·åº·åº¸åº¶åºµåº¾å¼µå¼·å½—å½¬å½©å½«å¾—å¾™å¾å¾˜å¾¡å¾ å¾œæ¿æ‚£æ‚‰æ‚ æ‚¨æƒ‹æ‚´æƒ¦æ‚½"],
    ["b1a1", "æƒ…æ‚»æ‚µæƒœæ‚¼æƒ˜æƒ•æƒ†æƒŸæ‚¸æƒšæƒ‡æˆšæˆ›æ‰ˆæ æ§æ²æ–æ¢æ¥æ·æ§æ˜æªæ±æ©æ‰æƒæ›æ«æ¨æ„æˆæ™æ¡æ¬æ’ææ€æ»æ©æ¨æºæ•æ•–æ•‘æ•™æ•—å•Ÿæ•æ•˜æ••æ•”æ–œæ–›æ–¬æ—æ—‹æ—Œæ—æ™æ™šæ™¤æ™¨æ™¦æ™æ›¹å‹—æœ›æ¢æ¢¯æ¢¢æ¢“æ¢µæ¡¿æ¡¶æ¢±æ¢§æ¢—æ¢°æ¢ƒæ£„æ¢­æ¢†æ¢…æ¢”æ¢æ¢¨æ¢Ÿæ¢¡æ¢‚æ¬²æ®º"],
    ["b240", "æ¯«æ¯¬æ°«æ¶æ¶¼æ·³æ·™æ¶²æ·¡æ·Œæ·¤æ·»æ·ºæ¸…æ·‡æ·‹æ¶¯æ·‘æ¶®æ·æ·¹æ¶¸æ··æ·µæ·…æ·’æ¸šæ¶µæ·šæ·«æ·˜æ·ªæ·±æ·®æ·¨æ·†æ·„æ¶ªæ·¬æ¶¿æ·¦çƒ¹ç„‰ç„Šçƒ½çƒ¯çˆ½ç‰½çŠçŒœçŒ›çŒ–çŒ“çŒ™ç‡ç…çŠçƒç†ç¾çç“ ç“¶"],
    ["b2a1", "ç“·ç”œç”¢ç•¥ç•¦ç•¢ç•°ç–ç—”ç—•ç–µç—Šç—çšç›”ç›’ç››çœ·çœ¾çœ¼çœ¶çœ¸çœºç¡«ç¡ƒç¡ç¥¥ç¥¨ç¥­ç§»çª’çª•ç¬ ç¬¨ç¬›ç¬¬ç¬¦ç¬™ç¬ç¬®ç²’ç²—ç²•çµ†çµƒçµ±ç´®ç´¹ç´¼çµ€ç´°ç´³çµ„ç´¯çµ‚ç´²ç´±ç¼½ç¾ç¾šç¿Œç¿ç¿’è€œèŠè†è„¯è„–è„£è„«è„©è„°è„¤èˆ‚èˆµèˆ·èˆ¶èˆ¹èèè˜è¸è¢è–è½è«è’èŠè“è‰è è·è»è¼"],
    ["b340", "è†è§è™•å½ªè›‡è›€èš¶è›„èšµè›†è›‹èš±èš¯è›‰è¡“è¢è¢ˆè¢«è¢’è¢–è¢è¢‹è¦“è¦è¨ªè¨è¨£è¨¥è¨±è¨­è¨Ÿè¨›è¨¢è±‰è±šè²©è²¬è²«è²¨è²ªè²§èµ§èµ¦è¶¾è¶ºè»›è»Ÿé€™é€é€šé€—é€£é€Ÿé€é€é€•é€é€ é€é€¢é€–é€›é€”"],
    ["b3a1", "éƒ¨éƒ­éƒ½é…—é‡é‡µé‡¦é‡£é‡§é‡­é‡©é–‰é™ªé™µé™³é™¸é™°é™´é™¶é™·é™¬é›€é›ªé›©ç« ç«Ÿé ‚é ƒé­šé³¥é¹µé¹¿éº¥éº»å‚¢å‚å‚…å‚™å‚‘å‚€å‚–å‚˜å‚šæœ€å‡±å‰²å‰´å‰µå‰©å‹å‹å‹›åšå¥å•»å–€å–§å•¼å–Šå–å–˜å–‚å–œå–ªå–”å–‡å–‹å–ƒå–³å–®å–Ÿå”¾å–²å–šå–»å–¬å–±å•¾å–‰å–«å–™åœå ¯å ªå ´å ¤å °å ±å ¡å å  å£¹å£ºå¥ "],
    ["b440", "å©·åªšå©¿åª’åª›åª§å­³å­±å¯’å¯Œå¯“å¯å°Šå°‹å°±åµŒåµå´´åµ‡å·½å¹…å¸½å¹€å¹ƒå¹¾å»Šå»å»‚å»„å¼¼å½­å¾©å¾ªå¾¨æƒ‘æƒ¡æ‚²æ‚¶æƒ æ„œæ„£æƒºæ„•æƒ°æƒ»æƒ´æ…¨æƒ±æ„æƒ¶æ„‰æ„€æ„’æˆŸæ‰‰æ£æŒææ€æ©æ‰æ†æ"],
    ["b4a1", "æ’æ£ææ¡æ–æ­æ®æ¶æ´æªæ›æ‘’æšæ¹æ•æ•¦æ•¢æ•£æ–‘æ–æ–¯æ™®æ™°æ™´æ™¶æ™¯æš‘æ™ºæ™¾æ™·æ›¾æ›¿æœŸæœæ£ºæ£•æ£ æ£˜æ£—æ¤…æ£Ÿæ£µæ£®æ£§æ£¹æ£’æ£²æ££æ£‹æ£æ¤æ¤’æ¤æ£‰æ£šæ¥®æ£»æ¬¾æ¬ºæ¬½æ®˜æ®–æ®¼æ¯¯æ°®æ°¯æ°¬æ¸¯æ¸¸æ¹”æ¸¡æ¸²æ¹§æ¹Šæ¸ æ¸¥æ¸£æ¸›æ¹›æ¹˜æ¸¤æ¹–æ¹®æ¸­æ¸¦æ¹¯æ¸´æ¹æ¸ºæ¸¬æ¹ƒæ¸æ¸¾æ»‹"],
    ["b540", "æº‰æ¸™æ¹æ¹£æ¹„æ¹²æ¹©æ¹Ÿç„™ç„šç„¦ç„°ç„¡ç„¶ç…®ç„œç‰ŒçŠ„çŠ€çŒ¶çŒ¥çŒ´çŒ©çºçªç³ç¢ç¥çµç¶ç´ç¯ç›ç¦ç¨ç”¥ç”¦ç•«ç•ªç—¢ç—›ç—£ç—™ç—˜ç—ç— ç™»ç™¼çš–çš“çš´ç›œççŸ­ç¡ç¡¬ç¡¯ç¨ç¨ˆç¨‹ç¨…ç¨€çª˜"],
    ["b5a1", "çª—çª–ç«¥ç«£ç­‰ç­–ç­†ç­ç­’ç­”ç­ç­‹ç­ç­‘ç²Ÿç²¥çµçµçµ¨çµ•ç´«çµ®çµ²çµ¡çµ¦çµ¢çµ°çµ³å–„ç¿”ç¿•è€‹è’è‚…è…•è…”è…‹è…‘è…è„¹è…†è„¾è…Œè…“è…´èˆ’èˆœè©èƒè¸èè è…è‹èè¯è±è´è‘—èŠè°èŒèŒè½è²èŠè¸èè„èœè‡è”èŸè™›è›Ÿè›™è›­è›”è››è›¤è›è›è¡—è£è£‚è¢±è¦ƒè¦–è¨»è© è©•è©è¨¼è©"],
    ["b640", "è©”è©›è©è©†è¨´è¨ºè¨¶è©–è±¡è²‚è²¯è²¼è²³è²½è³è²»è³€è²´è²·è²¶è²¿è²¸è¶Šè¶…è¶è·è·è·‹è·šè·‘è·Œè·›è·†è»»è»¸è»¼è¾œé€®é€µé€±é€¸é€²é€¶é„‚éƒµé„‰éƒ¾é…£é…¥é‡éˆ”éˆ•éˆ£éˆ‰éˆéˆéˆéˆ‡éˆ‘é–”é–é–‹é–‘"],
    ["b6a1", "é–“é–’é–éšŠéšéš‹é™½éš…éš†éšé™²éš„é›é›…é›„é›†é›‡é›¯é›²éŸŒé …é †é ˆé£§é£ªé£¯é£©é£²é£­é¦®é¦­é»ƒé»é»‘äº‚å‚­å‚µå‚²å‚³åƒ…å‚¾å‚¬å‚·å‚»å‚¯åƒ‡å‰¿å‰·å‰½å‹Ÿå‹¦å‹¤å‹¢å‹£åŒ¯å—Ÿå—¨å—“å—¦å—å—œå—‡å—‘å—£å—¤å—¯å—šå—¡å—…å—†å—¥å—‰åœ’åœ“å¡å¡‘å¡˜å¡—å¡šå¡”å¡«å¡Œå¡­å¡Šå¡¢å¡’å¡‹å¥§å«å«‰å«Œåª¾åª½åª¼"],
    ["b740", "åª³å«‚åª²åµ©åµ¯å¹Œå¹¹å»‰å»ˆå¼’å½™å¾¬å¾®æ„šæ„æ…ˆæ„Ÿæƒ³æ„›æƒ¹æ„æ„ˆæ…æ…Œæ…„æ…æ„¾æ„´æ„§æ„æ„†æ„·æˆ¡æˆ¢æ“æ¾ææªæ­æ½æ¬ææœæ”ææ¶æ–æ—æ†æ•¬æ–Ÿæ–°æš—æš‰æš‡æšˆæš–æš„æš˜æšæœƒæ¦”æ¥­"],
    ["b7a1", "æ¥šæ¥·æ¥ æ¥”æ¥µæ¤°æ¦‚æ¥Šæ¥¨æ¥«æ¥æ¥“æ¥¹æ¦†æ¥æ¥£æ¥›æ­‡æ­²æ¯€æ®¿æ¯“æ¯½æº¢æº¯æ»“æº¶æ»‚æºæºæ»‡æ»…æº¥æº˜æº¼æººæº«æ»‘æº–æºœæ»„æ»”æºªæº§æº´ç…ç…™ç…©ç…¤ç…‰ç…§ç…œç…¬ç…¦ç…Œç…¥ç…ç…†ç…¨ç…–çˆºç‰’çŒ·ç…çŒ¿çŒ¾ç‘¯ç‘šç‘•ç‘Ÿç‘ç‘ç¿ç‘™ç‘›ç‘œç•¶ç•¸ç˜€ç—°ç˜ç—²ç—±ç—ºç—¿ç—´ç—³ç›ç›Ÿç›ç«ç¦çç£"],
    ["b840", "ç¹çªç¬çœç¥ç¨ç¢çŸ®ç¢ç¢°ç¢—ç¢˜ç¢Œç¢‰ç¡¼ç¢‘ç¢“ç¡¿ç¥ºç¥¿ç¦è¬ç¦½ç¨œç¨šç¨ ç¨”ç¨Ÿç¨çªŸçª ç­·ç¯€ç­ ç­®ç­§ç²±ç²³ç²µç¶“çµ¹ç¶‘ç¶ç¶çµ›ç½®ç½©ç½ªç½²ç¾©ç¾¨ç¾¤è–è˜è‚†è‚„è…±è…°è…¸è…¥è…®è…³è…«"],
    ["b8a1", "è…¹è…ºè…¦èˆ…è‰‡è’‚è‘·è½è±è‘µè‘¦è‘«è‘‰è‘¬è‘›è¼èµè‘¡è‘£è‘©è‘­è‘†è™è™œè™Ÿè›¹èœ“èœˆèœ‡èœ€è›¾è›»èœ‚èœƒèœ†èœŠè¡™è£Ÿè£”è£™è£œè£˜è£è£¡è£Šè£•è£’è¦œè§£è©«è©²è©³è©¦è©©è©°èª‡è©¼è©£èª è©±èª…è©­è©¢è©®è©¬è©¹è©»è¨¾è©¨è±¢è²Šè²‰è³Šè³‡è³ˆè³„è²²è³ƒè³‚è³…è·¡è·Ÿè·¨è·¯è·³è·ºè·ªè·¤è·¦èº²è¼ƒè¼‰è»¾è¼Š"],
    ["b940", "è¾Ÿè¾²é‹éŠé“é‚é”é€¼é•éé‡éééé‘é€¾éé„’é„—é…¬é…ªé…©é‡‰éˆ·é‰—éˆ¸éˆ½é‰€éˆ¾é‰›é‰‹é‰¤é‰‘éˆ´é‰‰é‰é‰…éˆ¹éˆ¿é‰šé–˜éš˜éš”éš•é›é›‹é›‰é›Šé›·é›»é›¹é›¶é–é´é¶é é ‘é “é Šé ’é Œé£¼é£´"],
    ["b9a1", "é£½é£¾é¦³é¦±é¦´é«¡é³©éº‚é¼é¼“é¼ åƒ§åƒ®åƒ¥åƒ–åƒ­åƒšåƒ•åƒåƒ‘åƒ±åƒåƒ©å…¢å‡³åŠƒåŠ‚åŒ±å­å—¾å˜€å˜›å˜—å—½å˜”å˜†å˜‰å˜å˜å—·å˜–å˜Ÿå˜ˆå˜å—¶åœ˜åœ–å¡µå¡¾å¢ƒå¢“å¢Šå¡¹å¢…å¡½å£½å¤¥å¤¢å¤¤å¥ªå¥©å«¡å«¦å«©å«—å«–å«˜å«£å­µå¯å¯§å¯¡å¯¥å¯¦å¯¨å¯¢å¯¤å¯Ÿå°å±¢å¶„å¶‡å¹›å¹£å¹•å¹—å¹”å»“å»–å¼Šå½†å½°å¾¹æ…‡"],
    ["ba40", "æ„¿æ…‹æ…·æ…¢æ…£æ…Ÿæ…šæ…˜æ…µæˆªæ’‡æ‘˜æ‘”æ’¤æ‘¸æ‘Ÿæ‘ºæ‘‘æ‘§æ´æ‘­æ‘»æ•²æ–¡æ——æ—–æš¢æš¨æšæ¦œæ¦¨æ¦•æ§æ¦®æ§“æ§‹æ¦›æ¦·æ¦»æ¦«æ¦´æ§æ§æ¦­æ§Œæ¦¦æ§ƒæ¦£æ­‰æ­Œæ°³æ¼³æ¼”æ»¾æ¼“æ»´æ¼©æ¼¾æ¼ æ¼¬æ¼æ¼‚æ¼¢"],
    ["baa1", "æ»¿æ»¯æ¼†æ¼±æ¼¸æ¼²æ¼£æ¼•æ¼«æ¼¯æ¾ˆæ¼ªæ»¬æ¼æ»²æ»Œæ»·ç†”ç†™ç…½ç†Šç†„ç†’çˆ¾çŠ’çŠ–ç„çç‘¤ç‘£ç‘ªç‘°ç‘­ç”„ç–‘ç˜§ç˜ç˜‹ç˜‰ç˜“ç›¡ç›£ç„ç½ç¿ç¡ç£ç¢Ÿç¢§ç¢³ç¢©ç¢£ç¦ç¦ç¦ç¨®ç¨±çªªçª©ç«­ç«¯ç®¡ç®•ç®‹ç­µç®—ç®ç®”ç®ç®¸ç®‡ç®„ç²¹ç²½ç²¾ç¶»ç¶°ç¶œç¶½ç¶¾ç¶ ç·Šç¶´ç¶²ç¶±ç¶ºç¶¢ç¶¿ç¶µç¶¸ç¶­ç·’ç·‡ç¶¬"],
    ["bb40", "ç½°ç¿ ç¿¡ç¿Ÿèèšè‚‡è…è†€è†è†ˆè†Šè…¿è†‚è‡§è‡ºèˆ‡èˆ”èˆè‰‹è“‰è’¿è“†è“„è’™è’è’²è’œè“‹è’¸è“€è““è’è’¼è“‘è“Šèœ¿èœœèœ»èœ¢èœ¥èœ´èœ˜è•èœ·èœ©è£³è¤‚è£´è£¹è£¸è£½è£¨è¤šè£¯èª¦èªŒèªèª£èªèª¡èª“èª¤"],
    ["bba1", "èªªèª¥èª¨èª˜èª‘èªšèª§è±ªè²è²Œè³“è³‘è³’èµ«è¶™è¶•è·¼è¼”è¼’è¼•è¼“è¾£é é˜éœé£é™éé¢éé›é„™é„˜é„é…µé…¸é…·é…´é‰¸éŠ€éŠ…éŠ˜éŠ–é‰»éŠ“éŠœéŠ¨é‰¼éŠ‘é–¡é–¨é–©é–£é–¥é–¤éš™éšœéš›é›Œé›’éœ€é¼é…éŸ¶é —é ˜é¢¯é¢±é¤ƒé¤…é¤Œé¤‰é§éª¯éª°é«¦é­é­‚é³´é³¶é³³éº¼é¼»é½Šå„„å„€åƒ»åƒµåƒ¹å„‚å„ˆå„‰å„…å‡œ"],
    ["bc40", "åŠ‡åŠˆåŠ‰åŠåŠŠå‹°å²å˜®å˜»å˜¹å˜²å˜¿å˜´å˜©å™“å™å™—å™´å˜¶å˜¯å˜°å¢€å¢Ÿå¢å¢³å¢œå¢®å¢©å¢¦å¥­å¬‰å«»å¬‹å«µå¬Œå¬ˆå¯®å¯¬å¯©å¯«å±¤å±¥å¶å¶”å¹¢å¹Ÿå¹¡å»¢å»šå»Ÿå»å»£å» å½ˆå½±å¾·å¾µæ…¶æ…§æ…®æ…æ…•æ†‚"],
    ["bca1", "æ…¼æ…°æ…«æ…¾æ†§æ†æ†«æ†æ†¬æ†šæ†¤æ†”æ†®æˆ®æ‘©æ‘¯æ‘¹æ’æ’²æ’ˆæ’æ’°æ’¥æ’“æ’•æ’©æ’’æ’®æ’­æ’«æ’šæ’¬æ’™æ’¢æ’³æ•µæ•·æ•¸æš®æš«æš´æš±æ¨£æ¨Ÿæ§¨æ¨æ¨æ¨™æ§½æ¨¡æ¨“æ¨Šæ§³æ¨‚æ¨…æ§­æ¨‘æ­æ­æ®¤æ¯…æ¯†æ¼¿æ½¼æ¾„æ½‘æ½¦æ½”æ¾†æ½­æ½›æ½¸æ½®æ¾æ½ºæ½°æ½¤æ¾—æ½˜æ»•æ½¯æ½ æ½Ÿç†Ÿç†¬ç†±ç†¨ç‰–çŠ›çç—ç‘©ç’‹ç’ƒ"],
    ["bd40", "ç‘¾ç’€ç•¿ç˜ ç˜©ç˜Ÿç˜¤ç˜¦ç˜¡ç˜¢çššçšºç›¤çç‡çŒç‘ç‹ç£‹ç£…ç¢ºç£Šç¢¾ç£•ç¢¼ç£ç¨¿ç¨¼ç©€ç¨½ç¨·ç¨»çª¯çª®ç®­ç®±ç¯„ç®´ç¯†ç¯‡ç¯ç® ç¯Œç³Šç· ç·´ç·¯ç·»ç·˜ç·¬ç·ç·¨ç·£ç·šç·ç·©ç¶ç·™ç·²ç·¹ç½µç½·ç¾¯"],
    ["bda1", "ç¿©è€¦è†›è†œè†è† è†šè†˜è”—è”½è”šè“®è”¬è”­è”“è”‘è”£è”¡è””è“¬è”¥è“¿è”†è‚è´è¶è è¦è¸è¨è™è—èŒè“è¡›è¡è¤è¤‡è¤’è¤“è¤•è¤Šèª¼è«’è«‡è«„èª•è«‹è«¸èª²è«‰è«‚èª¿èª°è«–è«èª¶èª¹è«›è±Œè±è±¬è³ è³è³¦è³¤è³¬è³­è³¢è³£è³œè³ªè³¡èµ­è¶Ÿè¶£è¸«è¸è¸è¸¢è¸è¸©è¸Ÿè¸¡è¸èººè¼è¼›è¼Ÿè¼©è¼¦è¼ªè¼œè¼"],
    ["be40", "è¼¥é©é®é¨é­é·é„°é„­é„§é„±é†‡é†‰é†‹é†ƒé‹…éŠ»éŠ·é‹ªéŠ¬é‹¤é‹éŠ³éŠ¼é‹’é‹‡é‹°éŠ²é–­é–±éœ„éœ†éœ‡éœ‰é éé‹éé ¡é «é œé¢³é¤Šé¤“é¤’é¤˜é§é§é§Ÿé§›é§‘é§•é§’é§™éª·é«®é«¯é¬§é­…é­„é­·é­¯é´†é´‰"],
    ["bea1", "é´ƒéº©éº¾é»å¢¨é½’å„’å„˜å„”å„å„•å†€å†ªå‡åŠ‘åŠ“å‹³å™™å™«å™¹å™©å™¤å™¸å™ªå™¨å™¥å™±å™¯å™¬å™¢å™¶å£å¢¾å£‡å£…å¥®å¬å¬´å­¸å¯°å°å½Šæ†²æ†‘æ†©æ†Šæ‡æ†¶æ†¾æ‡Šæ‡ˆæˆ°æ“…æ“æ“‹æ’»æ’¼æ“šæ“„æ“‡æ“‚æ“æ’¿æ“’æ“”æ’¾æ•´æ›†æ›‰æš¹æ›„æ›‡æš¸æ¨½æ¨¸æ¨ºæ©™æ©«æ©˜æ¨¹æ©„æ©¢æ©¡æ©‹æ©‡æ¨µæ©Ÿæ©ˆæ­™æ­·æ°…æ¿‚æ¾±æ¾¡"],
    ["bf40", "æ¿ƒæ¾¤æ¿æ¾§æ¾³æ¿€æ¾¹æ¾¶æ¾¦æ¾ æ¾´ç†¾ç‡‰ç‡ç‡’ç‡ˆç‡•ç†¹ç‡ç‡™ç‡œç‡ƒç‡„ç¨ç’œç’£ç’˜ç’Ÿç’ç“¢ç”Œç”ç˜´ç˜¸ç˜ºç›§ç›¥ç ççŸç¥ç£¨ç£šç£¬ç£§ç¦¦ç©ç©ç©†ç©Œç©‹çªºç¯™ç°‘ç¯‰ç¯¤ç¯›ç¯¡ç¯©ç¯¦ç³•ç³–ç¸Š"],
    ["bfa1", "ç¸‘ç¸ˆç¸›ç¸£ç¸ç¸ç¸‰ç¸ç½¹ç¾²ç¿°ç¿±ç¿®è€¨è†³è†©è†¨è‡»èˆˆè‰˜è‰™è•Šè•™è•ˆè•¨è•©è•ƒè•‰è•­è•ªè•èƒèŸèè¢èè¡¡è¤ªè¤²è¤¥è¤«è¤¡è¦ªè¦¦è«¦è«ºè««è«±è¬€è«œè«§è«®è«¾è¬è¬‚è«·è«­è«³è«¶è«¼è±«è±­è²“è³´è¹„è¸±è¸´è¹‚è¸¹è¸µè¼»è¼¯è¼¸è¼³è¾¨è¾¦éµé´é¸é²é¼éºé„´é†’éŒ éŒ¶é‹¸éŒ³éŒ¯éŒ¢é‹¼éŒ«éŒ„éŒš"],
    ["c040", "éŒéŒ¦éŒ¡éŒ•éŒ®éŒ™é–»éš§éš¨éšªé›•éœéœ‘éœ–éœéœ“éœé›éœé¦é˜é °é ¸é »é ·é ­é ¹é ¤é¤é¤¨é¤é¤›é¤¡é¤šé§­é§¢é§±éª¸éª¼é«»é«­é¬¨é®‘é´•é´£é´¦é´¨é´’é´›é»˜é»”é¾é¾œå„ªå„Ÿå„¡å„²å‹µåšåš€åšåš…åš‡"],
    ["c0a1", "åšå£•å£“å£‘å£å¬°å¬ªå¬¤å­ºå°·å±¨å¶¼å¶ºå¶½å¶¸å¹«å½Œå¾½æ‡‰æ‡‚æ‡‡æ‡¦æ‡‹æˆ²æˆ´æ“æ“Šæ“˜æ“ æ“°æ“¦æ“¬æ“±æ“¢æ“­æ–‚æ–ƒæ›™æ›–æª€æª”æª„æª¢æªœæ«›æª£æ©¾æª—æªæª æ­œæ®®æ¯šæ°ˆæ¿˜æ¿±æ¿Ÿæ¿ æ¿›æ¿¤æ¿«æ¿¯æ¾€æ¿¬æ¿¡æ¿©æ¿•æ¿®æ¿°ç‡§ç‡Ÿç‡®ç‡¦ç‡¥ç‡­ç‡¬ç‡´ç‡ çˆµç‰†ç°ç²ç’©ç’°ç’¦ç’¨ç™†ç™‚ç™Œç›ªç³çªç°ç¬"],
    ["c140", "ç§ç­çŸ¯ç£·ç£ºç£´ç£¯ç¤ç¦§ç¦ªç©—çª¿ç°‡ç°ç¯¾ç¯·ç°Œç¯ ç³ ç³œç³ç³¢ç³Ÿç³™ç³ç¸®ç¸¾ç¹†ç¸·ç¸²ç¹ƒç¸«ç¸½ç¸±ç¹…ç¹ç¸´ç¸¹ç¹ˆç¸µç¸¿ç¸¯ç½„ç¿³ç¿¼è±è²è°è¯è³è‡†è‡ƒè†ºè‡‚è‡€è†¿è†½è‡‰è†¾è‡¨èˆ‰è‰±è–ª"],
    ["c1a1", "è–„è•¾è–œè–‘è–”è–¯è–›è–‡è–¨è–Šè™§èŸ€èŸ‘è³èŸ’èŸ†è«è»èºèŸˆèŸ‹è¤»è¤¶è¥„è¤¸è¤½è¦¬è¬è¬—è¬™è¬›è¬Šè¬ è¬è¬„è¬è±è°¿è±³è³ºè³½è³¼è³¸è³»è¶¨è¹‰è¹‹è¹ˆè¹Šè½„è¼¾è½‚è½…è¼¿é¿é½é‚„é‚é‚‚é‚€é„¹é†£é†é†œéé‚éŒ¨éµéŠé¥é‹éŒ˜é¾é¬é›é°éšé”é—Šé—‹é—Œé—ˆé—†éš±éš¸é›–éœœéœé éŸ“é¡†é¢¶é¤µé¨"],
    ["c240", "é§¿é®®é®«é®ªé®­é´»é´¿éº‹é»é»é»œé»é»›é¼¾é½‹å¢åš•åš®å£™å£˜å¬¸å½æ‡£æˆ³æ“´æ“²æ“¾æ”†æ“ºæ“»æ“·æ–·æ›œæœ¦æª³æª¬æ«ƒæª»æª¸æ«‚æª®æª¯æ­Ÿæ­¸æ®¯ç€‰ç€‹æ¿¾ç€†æ¿ºç€‘ç€ç‡»ç‡¼ç‡¾ç‡¸ç·çµç’§ç’¿ç”•ç™–ç™˜"],
    ["c2a1", "ç™’ç½ç¿ç»ç¼ç¤ç¦®ç©¡ç©¢ç© ç«„ç«…ç°«ç°§ç°ªç°ç°£ç°¡ç³§ç¹”ç¹•ç¹ç¹šç¹¡ç¹’ç¹™ç½ˆç¿¹ç¿»è·è¶è‡è‡èˆŠè—è–©è—è—è—‰è–°è–ºè–¹è–¦èŸ¯èŸ¬èŸ²èŸ è¦†è¦²è§´è¬¨è¬¹è¬¬è¬«è±è´…è¹™è¹£è¹¦è¹¤è¹Ÿè¹•è»€è½‰è½é‚‡é‚ƒé‚ˆé†«é†¬é‡é”éŠé–é¢é³é®é¬é°é˜éšé—é—”é—–é—é—•é›¢é›œé›™é››é›éœ¤é£é¦"],
    ["c340", "é­éŸ¹é¡é¡é¡Œé¡é¡“é¢ºé¤¾é¤¿é¤½é¤®é¦¥é¨é«é¬ƒé¬†é­é­é­é¯Šé¯‰é¯½é¯ˆé¯€éµ‘éµéµ é» é¼•é¼¬å„³åš¥å£å£Ÿå£¢å¯µé¾å»¬æ‡²æ‡·æ‡¶æ‡µæ”€æ”æ› æ›æ«¥æ«æ«šæ«“ç€›ç€Ÿç€¨ç€šç€ç€•ç€˜çˆ†çˆç‰˜çŠ¢ç¸"],
    ["c3a1", "çºç’½ç“Šç“£ç–‡ç–†ç™Ÿç™¡çŸ‡ç¤™ç¦±ç©«ç©©ç°¾ç°¿ç°¸ç°½ç°·ç±€ç¹«ç¹­ç¹¹ç¹©ç¹ªç¾…ç¹³ç¾¶ç¾¹ç¾¸è‡˜è—©è—è—ªè—•è—¤è—¥è—·èŸ»è …è èŸ¹èŸ¾è¥ è¥Ÿè¥–è¥è­è­œè­˜è­‰è­šè­è­è­†è­™è´ˆè´Šè¹¼è¹²èº‡è¹¶è¹¬è¹ºè¹´è½”è½è¾­é‚Šé‚‹é†±é†®é¡é‘éŸéƒéˆéœéé–é¢éé˜é¤é—é¨é—œéš´é›£éœªéœ§é¡éŸœéŸ»é¡"],
    ["c440", "é¡˜é¡›é¢¼é¥…é¥‰é¨–é¨™é¬é¯¨é¯§é¯–é¯›é¶‰éµ¡éµ²éµªéµ¬éº’éº—éº“éº´å‹¸åš¨åš·åš¶åš´åš¼å£¤å­€å­ƒå­½å¯¶å·‰æ‡¸æ‡ºæ”˜æ””æ”™æ›¦æœ§æ«¬ç€¾ç€°ç€²çˆç»ç“ç™¢ç™¥ç¤¦ç¤ªç¤¬ç¤«ç«‡ç«¶ç±Œç±ƒç±ç³¯ç³°è¾®ç¹½ç¹¼"],
    ["c4a1", "çº‚ç½Œè€€è‡šè‰¦è—»è—¹è˜‘è—ºè˜†è˜‹è˜‡è˜Šè ”è •è¥¤è¦ºè§¸è­°è­¬è­¦è­¯è­Ÿè­«è´è´èº‰èºèº…èº‚é†´é‡‹é˜éƒé½é—¡éœ°é£„é¥’é¥‘é¦¨é¨«é¨°é¨·é¨µé°“é°é¹¹éºµé»¨é¼¯é½Ÿé½£é½¡å„·å„¸å›å›€å›‚å¤”å±¬å·æ‡¼æ‡¾æ”æ”œæ–•æ›©æ«»æ¬„æ«ºæ®²çŒçˆ›çŠ§ç“–ç“”ç™©çŸ“ç±çºçºŒç¾¼è˜—è˜­è˜šè £è ¢è ¡è Ÿè¥ªè¥¬è¦½è­´"],
    ["c540", "è­·è­½è´“èºŠèºèº‹è½Ÿè¾¯é†ºé®é³éµéºé¸é²é«é—¢éœ¸éœ¹éœ²éŸ¿é¡§é¡¥é¥—é©…é©ƒé©€é¨¾é«é­”é­‘é°­é°¥é¶¯é¶´é·‚é¶¸éºé»¯é¼™é½œé½¦é½§å„¼å„»å›ˆå›Šå›‰å­¿å·”å·’å½æ‡¿æ”¤æ¬Šæ­¡ç‘ç˜ç€ç“¤ç–Šç™®ç™¬"],
    ["c5a1", "ç¦³ç± ç±Ÿè¾è½è‡Ÿè¥²è¥¯è§¼è®€è´–è´—èº‘èº“è½¡é…ˆé‘„é‘‘é‘’éœ½éœ¾éŸƒéŸé¡«é¥•é©•é©é«’é¬šé±‰é°±é°¾é°»é·“é·—é¼´é½¬é½ªé¾”å›Œå·–æˆ€æ”£æ”«æ”ªæ›¬æ¬ç“šç«Šç±¤ç±£ç±¥çº“çº–çº”è‡¢è˜¸è˜¿è ±è®Šé‚é‚é‘£é‘ é‘¤é¨é¡¯é¥œé©šé©›é©—é«“é«”é«‘é±”é±—é±–é·¥éºŸé»´å›‘å£©æ”¬çç™±ç™²çŸ—ç½ç¾ˆè ¶è ¹è¡¢è®“è®’"],
    ["c640", "è®–è‰·è´›é‡€é‘ªé‚éˆé„éŸ†é¡°é©Ÿé¬¢é­˜é±Ÿé·¹é·ºé¹¼é¹½é¼‡é½·é½²å»³æ¬–ç£ç±¬ç±®è »è§€èº¡é‡é‘²é‘°é¡±é¥é«–é¬£é»Œç¤çŸšè®šé‘·éŸ‰é©¢é©¥çºœè®œèºªé‡…é‘½é‘¾é‘¼é±·é±¸é»·è±”é‘¿é¸šçˆ¨é©ªé¬±é¸›é¸ç±²"],
    ["c940", "ä¹‚ä¹œå‡µåŒšå‚ä¸‡ä¸Œä¹‡äºå›—ï¨Œå±®å½³ä¸å†‡ä¸ä¸®äº“ä»‚ä»‰ä»ˆå†˜å‹¼å¬å¹åœ å¤ƒå¤¬å°å·¿æ—¡æ®³æ¯Œæ°”çˆ¿ä¸±ä¸¼ä»¨ä»œä»©ä»¡ä»ä»šåˆŒåŒœåŒåœ¢åœ£å¤—å¤¯å®å®„å°’å°»å±´å±³å¸„åº€åº‚å¿‰æˆ‰æ‰æ°•"],
    ["c9a1", "æ°¶æ±ƒæ°¿æ°»çŠ®çŠ°çŠç¦¸è‚Šé˜ä¼ä¼˜ä¼¬ä»µä¼”ä»±ä¼€ä»·ä¼ˆä¼ä¼‚ä¼…ä¼¢ä¼“ä¼„ä»´ä¼’å†±åˆ“åˆ‰åˆåŠ¦åŒ¢åŒŸååŠå‡å›¡å›Ÿåœ®åœªåœ´å¤¼å¦€å¥¼å¦…å¥»å¥¾å¥·å¥¿å­–å°•å°¥å±¼å±ºå±»å±¾å·Ÿå¹µåº„å¼‚å¼šå½´å¿•å¿”å¿æ‰œæ‰æ‰¤æ‰¡æ‰¦æ‰¢æ‰™æ‰ æ‰šæ‰¥æ—¯æ—®æœ¾æœ¹æœ¸æœ»æœºæœ¿æœ¼æœ³æ°˜æ±†æ±’æ±œæ±æ±Šæ±”æ±‹"],
    ["ca40", "æ±Œç±ç‰çŠ´çŠµçç”ªç™¿ç©µç½‘è‰¸è‰¼èŠ€è‰½è‰¿è™è¥¾é‚™é‚—é‚˜é‚›é‚”é˜¢é˜¤é˜ é˜£ä½–ä¼»ä½¢ä½‰ä½“ä½¤ä¼¾ä½§ä½’ä½Ÿä½ä½˜ä¼­ä¼³ä¼¿ä½¡å†å†¹åˆœåˆåˆ¡åŠ­åŠ®åŒ‰å£å²ååå°å·åªå‘”å‘…å™åœå¥å˜"],
    ["caa1", "å½å‘å‘å¨å¤å‘‡å›®å›§å›¥åå…åŒå‰å‹å’å¤†å¥€å¦¦å¦˜å¦ å¦—å¦å¦¢å¦å¦å¦§å¦¡å®å®’å°¨å°ªå²å²å²ˆå²‹å²‰å²’å²Šå²†å²“å²•å· å¸Šå¸åº‹åº‰åºŒåºˆåºå¼…å¼å½¸å½¶å¿’å¿‘å¿å¿­å¿¨å¿®å¿³å¿¡å¿¤å¿£å¿ºå¿¯å¿·å¿»æ€€å¿´æˆºæŠƒæŠŒæŠæŠæŠ”æŠ‡æ‰±æ‰»æ‰ºæ‰°æŠæŠˆæ‰·æ‰½æ‰²æ‰´æ”·æ—°æ—´æ—³æ—²æ—µæ…æ‡"],
    ["cb40", "æ™æ•æŒæˆæææšæ‹æ¯æ°™æ°šæ±¸æ±§æ±«æ²„æ²‹æ²æ±±æ±¯æ±©æ²šæ±­æ²‡æ²•æ²œæ±¦æ±³æ±¥æ±»æ²ç´çºç‰£çŠ¿çŠ½ç‹ƒç‹†ç‹çŠºç‹…ç•ç—ç“ç”ç’ç”ºç”¹ç–”ç–•çšç¤½è€´è‚•è‚™è‚è‚’è‚œèŠèŠèŠ…èŠèŠ‘èŠ“"],
    ["cba1", "èŠŠèŠƒèŠ„è±¸è¿‰è¾¿é‚Ÿé‚¡é‚¥é‚é‚§é‚ é˜°é˜¨é˜¯é˜­ä¸³ä¾˜ä½¼ä¾…ä½½ä¾€ä¾‡ä½¶ä½´ä¾‰ä¾„ä½·ä½Œä¾—ä½ªä¾šä½¹ä¾ä½¸ä¾ä¾œä¾”ä¾ä¾’ä¾‚ä¾•ä½«ä½®å†å†¼å†¾åˆµåˆ²åˆ³å‰†åˆ±åŠ¼åŒŠåŒ‹åŒ¼å’å”å’‡å‘¿å’å’‘å’‚å’ˆå‘«å‘ºå‘¾å‘¥å‘¬å‘´å‘¦å’å‘¯å‘¡å‘ å’˜å‘£å‘§å‘¤å›·å›¹å¯å²å­å«å±å°å¶å€åµå»å³å´å¢"],
    ["cc40", "å¨å½å¤Œå¥…å¦µå¦ºå§å§å¦²å§Œå§å¦¶å¦¼å§ƒå§–å¦±å¦½å§€å§ˆå¦´å§‡å­¢å­¥å®“å®•å±„å±‡å²®å²¤å² å²µå²¯å²¨å²¬å²Ÿå²£å²­å²¢å²ªå²§å²å²¥å²¶å²°å²¦å¸—å¸”å¸™å¼¨å¼¢å¼£å¼¤å½”å¾‚å½¾å½½å¿å¿¥æ€­æ€¦æ€™æ€²æ€‹"],
    ["cca1", "æ€´æ€Šæ€—æ€³æ€šæ€æ€¬æ€¢æ€æ€æ€®æ€“æ€‘æ€Œæ€‰æ€œæˆ”æˆ½æŠ­æŠ´æ‹‘æŠ¾æŠªæŠ¶æ‹ŠæŠ®æŠ³æŠ¯æŠ»æŠ©æŠ°æŠ¸æ”½æ–¨æ–»æ˜‰æ—¼æ˜„æ˜’æ˜ˆæ—»æ˜ƒæ˜‹æ˜æ˜…æ—½æ˜‘æ˜æ›¶æœŠæ…æ¬ææ’æ¶æ»æ˜æ†æ„æ´ææŒæºæŸæ‘æ™æƒæ½ææ¸æ¹æ”æ¬¥æ®€æ­¾æ¯æ°æ²“æ³¬æ³«æ³®æ³™æ²¶æ³”æ²­æ³§æ²·æ³æ³‚æ²ºæ³ƒæ³†æ³­æ³²"],
    ["cd40", "æ³’æ³æ²´æ²Šæ²æ²€æ³æ³€æ´°æ³æ³‡æ²°æ³¹æ³æ³©æ³‘ç‚”ç‚˜ç‚…ç‚“ç‚†ç‚„ç‚‘ç‚–ç‚‚ç‚šç‚ƒç‰ªç‹–ç‹‹ç‹˜ç‹‰ç‹œç‹’ç‹”ç‹šç‹Œç‹‘ç¤ç¡ç­ç¦ç¢ç ç¬çç“ç“¨ç”¿ç•€ç”¾ç–Œç–˜çš¯ç›³ç›±ç›°ç›µçŸ¸çŸ¼çŸ¹çŸ»çŸº"],
    ["cda1", "çŸ·ç¥‚ç¤¿ç§…ç©¸ç©»ç«»ç±µç³½è€µè‚è‚®è‚£è‚¸è‚µè‚­èˆ èŠ è‹€èŠ«èŠšèŠ˜èŠ›èŠµèŠ§èŠ®èŠ¼èŠèŠºèŠ´èŠ¨èŠ¡èŠ©è‹‚èŠ¤è‹ƒèŠ¶èŠ¢è™°è™¯è™­è™®è±–è¿’è¿‹è¿“è¿è¿–è¿•è¿—é‚²é‚´é‚¯é‚³é‚°é˜¹é˜½é˜¼é˜ºé™ƒä¿ä¿…ä¿“ä¾²ä¿‰ä¿‹ä¿ä¿”ä¿œä¿™ä¾»ä¾³ä¿›ä¿‡ä¿–ä¾ºä¿€ä¾¹ä¿¬å‰„å‰‰å‹€å‹‚åŒ½å¼å—å–å™å˜å’ºå’¡å’­å’¥å“"],
    ["ce40", "å“ƒèŒå’·å’®å“–å’¶å“…å“†å’ å‘°å’¼å’¢å’¾å‘²å“å’°åµååŸå¤åŒå—åå›å”å˜åå™å¥åšå•å£´å¤å¥“å§¡å§å§®å¨€å§±å§å§ºå§½å§¼å§¶å§¤å§²å§·å§›å§©å§³å§µå§ å§¾å§´å§­å®¨å±Œå³å³˜å³Œå³—å³‹å³›"],
    ["cea1", "å³å³šå³‰å³‡å³Šå³–å³“å³”å³å³ˆå³†å³å³Ÿå³¸å·¹å¸¡å¸¢å¸£å¸ å¸¤åº°åº¤åº¢åº›åº£åº¥å¼‡å¼®å½–å¾†æ€·æ€¹æ”æ²ææ…æ“æ‡æ‰æ›æŒæ€æ‚æŸæ€¤æ„æ˜æ¦æ®æ‰‚æ‰ƒæ‹æŒæŒ‹æ‹µæŒæŒƒæ‹«æ‹¹æŒæŒŒæ‹¸æ‹¶æŒ€æŒ“æŒ”æ‹ºæŒ•æ‹»æ‹°æ•æ•ƒæ–ªæ–¿æ˜¶æ˜¡æ˜²æ˜µæ˜œæ˜¦æ˜¢æ˜³æ˜«æ˜ºæ˜æ˜´æ˜¹æ˜®æœæœæŸæŸ²æŸˆæº"],
    ["cf40", "æŸœæ»æŸ¸æŸ˜æŸ€æ·æŸ…æŸ«æŸ¤æŸŸæµæŸæ³æŸ·æŸ¶æŸ®æŸ£æŸ‚æ¹æŸæŸ§æŸ°æ²æŸ¼æŸ†æŸ­æŸŒæ®æŸ¦æŸ›æŸºæŸ‰æŸŠæŸƒæŸªæŸ‹æ¬¨æ®‚æ®„æ®¶æ¯–æ¯˜æ¯ æ° æ°¡æ´¨æ´´æ´­æ´Ÿæ´¼æ´¿æ´’æ´Šæ³šæ´³æ´„æ´™æ´ºæ´šæ´‘æ´€æ´æµ‚"],
    ["cfa1", "æ´æ´˜æ´·æ´ƒæ´æµ€æ´‡æ´ æ´¬æ´ˆæ´¢æ´‰æ´ç‚·ç‚Ÿç‚¾ç‚±ç‚°ç‚¡ç‚´ç‚µç‚©ç‰ç‰‰ç‰Šç‰¬ç‰°ç‰³ç‰®ç‹Šç‹¤ç‹¨ç‹«ç‹Ÿç‹ªç‹¦ç‹£ç…çŒç‚çˆç…ç¹ç¶çµç´ç«ç¿ç‡ç¾çƒç†ç¸ç‹ç“¬ç“®ç”®ç•‡ç•ˆç–§ç–ªç™¹ç›„çœˆçœƒçœ„çœ…çœŠç›·ç›»ç›ºçŸ§çŸ¨ç †ç ‘ç ’ç …ç ç ç ç ‰ç ƒç “ç¥Šç¥Œç¥‹ç¥…ç¥„ç§•ç§ç§ç§–ç§çª€"],
    ["d040", "ç©¾ç«‘ç¬€ç¬ç±ºç±¸ç±¹ç±¿ç²€ç²ç´ƒç´ˆç´ç½˜ç¾‘ç¾ç¾¾è€‡è€è€è€”è€·èƒ˜èƒ‡èƒ èƒ‘èƒˆèƒ‚èƒèƒ…èƒ£èƒ™èƒœèƒŠèƒ•èƒ‰èƒèƒ—èƒ¦èƒè‡¿èˆ¡èŠ”è‹™è‹¾è‹¹èŒ‡è‹¨èŒ€è‹•èŒºè‹«è‹–è‹´è‹¬è‹¡è‹²è‹µèŒŒè‹»è‹¶è‹°è‹ª"],
    ["d0a1", "è‹¤è‹ è‹ºè‹³è‹­è™·è™´è™¼è™³è¡è¡è¡§è¡ªè¡©è§“è¨„è¨‡èµ²è¿£è¿¡è¿®è¿ éƒ±é‚½é‚¿éƒ•éƒ…é‚¾éƒ‡éƒ‹éƒˆé‡”é‡“é™”é™é™‘é™“é™Šé™å€å€…å€‡å€“å€¢å€°å€›ä¿µä¿´å€³å€·å€¬ä¿¶ä¿·å€—å€œå€ å€§å€µå€¯å€±å€å…šå†”å†“å‡Šå‡„å‡…å‡ˆå‡å‰¡å‰šå‰’å‰å‰Ÿå‰•å‰¢å‹åŒåå”¦å“¢å”—å”’å“§å“³å“¤å”šå“¿å”„å”ˆå“«å”‘å”…å“±"],
    ["d140", "å”Šå“»å“·å“¸å“ å”å”ƒå”‹åœåœ‚åŸŒå ²åŸ•åŸ’åºåŸ†å½å¼å¸å¶å¿åŸ‡åŸå¹åŸå¤å¥Šå¨™å¨–å¨­å¨®å¨•å¨å¨—å¨Šå¨å¨³å­¬å®§å®­å®¬å°ƒå±–å±”å³¬å³¿å³®å³±å³·å´€å³¹å¸©å¸¨åº¨åº®åºªåº¬å¼³å¼°å½§ææšæ§"],
    ["d1a1", "ææ‚¢æ‚ˆæ‚€æ‚’æ‚æ‚æ‚ƒæ‚•æ‚›æ‚—æ‚‡æ‚œæ‚æˆ™æ‰†æ‹²æŒæ–æŒ¬æ„æ…æŒ¶æƒæ¤æŒ¹æ‹æŠæŒ¼æŒ©ææŒ´æ˜æ”æ™æŒ­æ‡æŒ³æšæ‘æŒ¸æ—æ€æˆæ•Šæ•†æ—†æ—ƒæ—„æ—‚æ™Šæ™Ÿæ™‡æ™‘æœ’æœ“æ Ÿæ šæ¡‰æ ²æ ³æ »æ¡‹æ¡æ –æ ±æ œæ µæ «æ ­æ ¯æ¡æ¡„æ ´æ æ ’æ ”æ ¦æ ¨æ ®æ¡æ ºæ ¥æ  æ¬¬æ¬¯æ¬­æ¬±æ¬´æ­­è‚‚æ®ˆæ¯¦æ¯¤"],
    ["d240", "æ¯¨æ¯£æ¯¢æ¯§æ°¥æµºæµ£æµ¤æµ¶æ´æµ¡æ¶’æµ˜æµ¢æµ­æµ¯æ¶‘æ¶æ·¯æµ¿æ¶†æµæµ§æµ æ¶—æµ°æµ¼æµŸæ¶‚æ¶˜æ´¯æµ¨æ¶‹æµ¾æ¶€æ¶„æ´–æ¶ƒæµ»æµ½æµµæ¶çƒœçƒ“çƒ‘çƒçƒ‹ç¼¹çƒ¢çƒ—çƒ’çƒçƒ çƒ”çƒçƒ…çƒ†çƒ‡çƒšçƒçƒ¡ç‰‚ç‰¸"],
    ["d2a1", "ç‰·ç‰¶çŒ€ç‹ºç‹´ç‹¾ç‹¶ç‹³ç‹»çŒç“ç™ç¥ç–ç¼ç§ç£ç©çœç’ç›ç”ççšç—ç˜ç¨ç“ç“Ÿç“´ç“µç”¡ç•›ç•Ÿç–°ç—ç–»ç—„ç—€ç–¿ç–¶ç–ºçšŠç›‰çœçœ›çœçœ“çœ’çœ£çœ‘çœ•çœ™çœšçœ¢çœ§ç £ç ¬ç ¢ç µç ¯ç ¨ç ®ç «ç ¡ç ©ç ³ç ªç ±ç¥”ç¥›ç¥ç¥œç¥“ç¥’ç¥‘ç§«ç§¬ç§ ç§®ç§­ç§ªç§œç§ç§çª†çª‰çª…çª‹çªŒçªŠçª‡ç«˜ç¬"],
    ["d340", "ç¬„ç¬“ç¬…ç¬ç¬ˆç¬Šç¬ç¬‰ç¬’ç²„ç²‘ç²Šç²Œç²ˆç²ç²…ç´ç´ç´‘ç´ç´˜ç´–ç´“ç´Ÿç´’ç´ç´Œç½œç½¡ç½ç½ ç½ç½›ç¾–ç¾’ç¿ƒç¿‚ç¿€è€–è€¾è€¹èƒºèƒ²èƒ¹èƒµè„èƒ»è„€èˆèˆ¯èˆ¥èŒ³èŒ­è„èŒ™è‘èŒ¥è–èŒ¿èèŒ¦èŒœèŒ¢"],
    ["d3a1", "è‚èèŒ›èŒªèŒˆèŒ¼èèŒ–èŒ¤èŒ èŒ·èŒ¯èŒ©è‡è…èŒè“èŒèŒ¬è‹èŒ§èˆè™“è™’èš¢èš¨èš–èšèš‘èšèš‡èš—èš†èš‹èššèš…èš¥èš™èš¡èš§èš•èš˜èšèšèšèš”è¡ƒè¡„è¡­è¡µè¡¶è¡²è¢€è¡±è¡¿è¡¯è¢ƒè¡¾è¡´è¡¼è¨’è±‡è±—è±»è²¤è²£èµ¶èµ¸è¶µè¶·è¶¶è»‘è»“è¿¾è¿µé€‚è¿¿è¿»é€„è¿¼è¿¶éƒ–éƒ éƒ™éƒšéƒ£éƒŸéƒ¥éƒ˜éƒ›éƒ—éƒœéƒ¤é…"],
    ["d440", "é…é…é‡•é‡¢é‡šé™œé™Ÿéš¼é££é«Ÿé¬¯ä¹¿å°åªå¡åå å“å‹åå²åˆååå›åŠå¢å€•å…åŸå©å«å£å¤å†å€å®å³å—å‘å‡å‰«å‰­å‰¬å‰®å‹–å‹“åŒ­åœå•µå•¶å”¼å•å•å”´å”ªå•‘å•¢å”¶å”µå”°å•’å•…"],
    ["d4a1", "å”Œå”²å•¥å•å”¹å•ˆå”­å”»å•€å•‹åœŠåœ‡åŸ»å ”åŸ¢åŸ¶åŸœåŸ´å €åŸ­åŸ½å ˆåŸ¸å ‹åŸ³åŸå ‡åŸ®åŸ£åŸ²åŸ¥åŸ¬åŸ¡å åŸ¼å åŸ§å å ŒåŸ±åŸ©åŸ°å å „å¥œå© å©˜å©•å©§å©å¨¸å¨µå©­å©å©Ÿå©¥å©¬å©“å©¤å©—å©ƒå©å©’å©„å©›å©ˆåªå¨¾å©å¨¹å©Œå©°å©©å©‡å©‘å©–å©‚å©œå­²å­®å¯å¯€å±™å´å´‹å´å´šå´ å´Œå´¨å´å´¦å´¥å´"],
    ["d540", "å´°å´’å´£å´Ÿå´®å¸¾å¸´åº±åº´åº¹åº²åº³å¼¶å¼¸å¾›å¾–å¾Ÿæ‚Šæ‚æ‚†æ‚¾æ‚°æ‚ºæƒ“æƒ”æƒæƒ¤æƒ™æƒæƒˆæ‚±æƒ›æ‚·æƒŠæ‚¿æƒƒæƒæƒ€æŒ²æ¥æŠæ‚æ½æ½ææ­ææ—æ«ææ¯æ‡ææ®æ¯æµæœæ­æ®æ¼æ¤æŒ»æŸ"],
    ["d5a1", "æ¸æ…ææ‘ææ°æ•“æ—æ™¥æ™¡æ™›æ™™æ™œæ™¢æœ˜æ¡¹æ¢‡æ¢æ¢œæ¡­æ¡®æ¢®æ¢«æ¥–æ¡¯æ¢£æ¢¬æ¢©æ¡µæ¡´æ¢²æ¢æ¡·æ¢’æ¡¼æ¡«æ¡²æ¢ªæ¢€æ¡±æ¡¾æ¢›æ¢–æ¢‹æ¢ æ¢‰æ¢¤æ¡¸æ¡»æ¢‘æ¢Œæ¢Šæ¡½æ¬¶æ¬³æ¬·æ¬¸æ®‘æ®æ®æ®æ®Œæ°ªæ·€æ¶«æ¶´æ¶³æ¹´æ¶¬æ·©æ·¢æ¶·æ·¶æ·”æ¸€æ·ˆæ· æ·Ÿæ·–æ¶¾æ·¥æ·œæ·æ·›æ·´æ·Šæ¶½æ·­æ·°æ¶ºæ·•æ·‚æ·æ·‰"],
    ["d640", "æ·æ·²æ·“æ·½æ·—æ·æ·£æ¶»çƒºç„çƒ·ç„—çƒ´ç„Œçƒ°ç„„çƒ³ç„çƒ¼çƒ¿ç„†ç„“ç„€çƒ¸çƒ¶ç„‹ç„‚ç„ç‰¾ç‰»ç‰¼ç‰¿çŒçŒ—çŒ‡çŒ‘çŒ˜çŒŠçŒˆç‹¿çŒçŒçˆç¶ç¸çµç„çç½ç‡ç€çºç¼ç¿çŒç‹ç´çˆç•¤ç•£ç—ç—’ç—"],
    ["d6a1", "ç—‹ç—Œç—‘ç—çšçš‰ç›“çœ¹çœ¯çœ­çœ±çœ²çœ´çœ³çœ½çœ¥çœ»çœµç¡ˆç¡’ç¡‰ç¡ç¡Šç¡Œç ¦ç¡…ç¡ç¥¤ç¥§ç¥©ç¥ªç¥£ç¥«ç¥¡ç¦»ç§ºç§¸ç§¶ç§·çªçª”çªç¬µç­‡ç¬´ç¬¥ç¬°ç¬¢ç¬¤ç¬³ç¬˜ç¬ªç¬ç¬±ç¬«ç¬­ç¬¯ç¬²ç¬¸ç¬šç¬£ç²”ç²˜ç²–ç²£ç´µç´½ç´¸ç´¶ç´ºçµ…ç´¬ç´©çµçµ‡ç´¾ç´¿çµŠç´»ç´¨ç½£ç¾•ç¾œç¾ç¾›ç¿Šç¿‹ç¿ç¿ç¿‘ç¿‡ç¿ç¿‰è€Ÿ"],
    ["d740", "è€è€›è‡èƒèˆè„˜è„¥è„™è„›è„­è„Ÿè„¬è„è„¡è„•è„§è„è„¢èˆ‘èˆ¸èˆ³èˆºèˆ´èˆ²è‰´èè£è¨èèºè³è¤è´èèè•è™èµè”è©è½èƒèŒèè›èªè‹è¾è¥è¯èˆè—è°è¿è¦è‡è®è¶èšè™™è™–èš¿èš·"],
    ["d7a1", "è›‚è›è›…èšºèš°è›ˆèš¹èš³èš¸è›Œèš´èš»èš¼è›ƒèš½èš¾è¡’è¢‰è¢•è¢¨è¢¢è¢ªè¢šè¢‘è¢¡è¢Ÿè¢˜è¢§è¢™è¢›è¢—è¢¤è¢¬è¢Œè¢“è¢è¦‚è§–è§™è§•è¨°è¨§è¨¬è¨è°¹è°»è±œè±è±½è²¥èµ½èµ»èµ¹è¶¼è·‚è¶¹è¶¿è·è»˜è»è»è»œè»—è» è»¡é€¤é€‹é€‘é€œé€Œé€¡éƒ¯éƒªéƒ°éƒ´éƒ²éƒ³éƒ”éƒ«éƒ¬éƒ©é…–é…˜é…šé…“é…•é‡¬é‡´é‡±é‡³é‡¸é‡¤é‡¹é‡ª"],
    ["d840", "é‡«é‡·é‡¨é‡®é•ºé–†é–ˆé™¼é™­é™«é™±é™¯éš¿éªé „é£¥é¦—å‚›å‚•å‚”å‚å‚‹å‚£å‚ƒå‚Œå‚å‚å¨å‚œå‚’å‚‚å‚‡å…Ÿå‡”åŒ’åŒ‘å¤å§å–‘å–¨å–¥å–­å•·å™…å–¢å–“å–ˆå–å–µå–å–£å–’å–¤å•½å–Œå–¦å•¿å–•å–¡å–åœŒå ©å ·"],
    ["d8a1", "å ™å å §å £å ¨åŸµå¡ˆå ¥å œå ›å ³å ¿å ¶å ®å ¹å ¸å ­å ¬å »å¥¡åª¯åª”åªŸå©ºåª¢åªå©¸åª¦å©¼åª¥åª¬åª•åª®å¨·åª„åªŠåª—åªƒåª‹åª©å©»å©½åªŒåªœåªåª“åªå¯ªå¯å¯‹å¯”å¯‘å¯Šå¯å°Œå°°å´·åµƒåµ«åµåµ‹å´¿å´µåµ‘åµåµ•å´³å´ºåµ’å´½å´±åµ™åµ‚å´¹åµ‰å´¸å´¼å´²å´¶åµ€åµ…å¹„å¹å½˜å¾¦å¾¥å¾«æƒ‰æ‚¹æƒŒæƒ¢æƒæƒ„æ„”"],
    ["d940", "æƒ²æ„Šæ„–æ„…æƒµæ„“æƒ¸æƒ¼æƒ¾æƒæ„ƒæ„˜æ„æ„æƒ¿æ„„æ„‹æ‰Šæ”æ±æ°ææ¥æ¨æ¯æƒæ’æ³æŠæ æ¶æ•æ²æµæ‘¡æŸæ¾ææœæ„æ˜æ“æ‚æ‡æŒæ‹æˆæ°æ—æ™æ”²æ•§æ•ªæ•¤æ•œæ•¨æ•¥æ–Œæ–æ–æ–®æ—æ—’"],
    ["d9a1", "æ™¼æ™¬æ™»æš€æ™±æ™¹æ™ªæ™²æœæ¤Œæ£“æ¤„æ£œæ¤ªæ£¬æ£ªæ£±æ¤æ£–æ£·æ£«æ£¤æ£¶æ¤“æ¤æ£³æ£¡æ¤‡æ£Œæ¤ˆæ¥°æ¢´æ¤‘æ£¯æ£†æ¤”æ£¸æ£æ£½æ£¼æ£¨æ¤‹æ¤Šæ¤—æ£æ£ˆæ£æ£æ£¦æ£´æ£‘æ¤†æ£”æ£©æ¤•æ¤¥æ£‡æ¬¹æ¬»æ¬¿æ¬¼æ®”æ®—æ®™æ®•æ®½æ¯°æ¯²æ¯³æ°°æ·¼æ¹†æ¹‡æ¸Ÿæ¹‰æºˆæ¸¼æ¸½æ¹…æ¹¢æ¸«æ¸¿æ¹æ¹æ¹³æ¸œæ¸³æ¹‹æ¹€æ¹‘æ¸»æ¸ƒæ¸®æ¹"],
    ["da40", "æ¹¨æ¹œæ¹¡æ¸±æ¸¨æ¹ æ¹±æ¹«æ¸¹æ¸¢æ¸°æ¹“æ¹¥æ¸§æ¹¸æ¹¤æ¹·æ¹•æ¹¹æ¹’æ¹¦æ¸µæ¸¶æ¹šç„ ç„ç„¯çƒ»ç„®ç„±ç„£ç„¥ç„¢ç„²ç„Ÿç„¨ç„ºç„›ç‰‹ç‰šçŠˆçŠ‰çŠ†çŠ…çŠ‹çŒ’çŒ‹çŒ°çŒ¢çŒ±çŒ³çŒ§çŒ²çŒ­çŒ¦çŒ£çŒµçŒŒç®ç¬ç°ç«ç–"],
    ["daa1", "çšç¡ç­ç±ç¤ç£çç©ç ç²ç“»ç”¯ç•¯ç•¬ç—§ç—šç—¡ç—¦ç—ç—Ÿç—¤ç——çš•çš’ç›šç†ç‡ç„çç…çŠçç‹çŒçŸçŸ¬ç¡ ç¡¤ç¡¥ç¡œç¡­ç¡±ç¡ªç¡®ç¡°ç¡©ç¡¨ç¡ç¡¢ç¥´ç¥³ç¥²ç¥°ç¨‚ç¨Šç¨ƒç¨Œç¨„çª™ç«¦ç«¤ç­Šç¬»ç­„ç­ˆç­Œç­ç­€ç­˜ç­…ç²¢ç²ç²¨ç²¡çµ˜çµ¯çµ£çµ“çµ–çµ§çµªçµçµ­çµœçµ«çµ’çµ”çµ©çµ‘çµŸçµç¼¾ç¼¿ç½¥"],
    ["db40", "ç½¦ç¾¢ç¾ ç¾¡ç¿—è‘èèèƒ¾èƒ”è…ƒè…Šè…’è…è…‡è„½è…è„ºè‡¦è‡®è‡·è‡¸è‡¹èˆ„èˆ¼èˆ½èˆ¿è‰µèŒ»èè¹è£è€è¨è’è§è¤è¼è¶èè†èˆè«è£è¿èèè¥è˜è¿è¡è‹èè–èµè‰è‰èèè‘è†è‚è³"],
    ["dba1", "è•èºè‡è‘èªè“èƒè¬è®è„è»è—è¢è›è›è¾è›˜è›¢è›¦è›“è›£è›šè›ªè›è›«è›œè›¬è›©è›—è›¨è›‘è¡ˆè¡–è¡•è¢ºè£—è¢¹è¢¸è£€è¢¾è¢¶è¢¼è¢·è¢½è¢²è¤è£‰è¦•è¦˜è¦—è§è§šè§›è©è©è¨¹è©™è©€è©—è©˜è©„è©…è©’è©ˆè©‘è©Šè©Œè©è±Ÿè²è²€è²ºè²¾è²°è²¹è²µè¶„è¶€è¶‰è·˜è·“è·è·‡è·–è·œè·è·•è·™è·ˆè·—è·…è»¯è»·è»º"],
    ["dc40", "è»¹è»¦è»®è»¥è»µè»§è»¨è»¶è»«è»±è»¬è»´è»©é€­é€´é€¯é„†é„¬é„„éƒ¿éƒ¼é„ˆéƒ¹éƒ»é„é„€é„‡é„…é„ƒé…¡é…¤é…Ÿé…¢é… éˆéˆŠéˆ¥éˆƒéˆšéˆ¦éˆéˆŒéˆ€éˆ’é‡¿é‡½éˆ†éˆ„éˆ§éˆ‚éˆœéˆ¤éˆ™éˆ—éˆ…éˆ–é•»é–é–Œé–éš‡é™¾éšˆ"],
    ["dca1", "éš‰éšƒéš€é›‚é›ˆé›ƒé›±é›°é¬é°é®é ‡é¢©é£«é³¦é»¹äºƒäº„äº¶å‚½å‚¿åƒ†å‚®åƒ„åƒŠå‚´åƒˆåƒ‚å‚°åƒå‚ºå‚±åƒ‹åƒ‰å‚¶å‚¸å‡—å‰ºå‰¸å‰»å‰¼å—ƒå—›å—Œå—å—‹å—Šå—å—€å—”å—„å—©å–¿å—’å–å—å—•å—¢å—–å—ˆå—²å—å—™å—‚åœ”å¡“å¡¨å¡¤å¡å¡å¡‰å¡¯å¡•å¡å¡å¡™å¡¥å¡›å ½å¡£å¡±å£¼å«‡å«„å«‹åªºåª¸åª±åªµåª°åª¿å«ˆåª»å«†"],
    ["dd40", "åª·å«€å«Šåª´åª¶å«åª¹åªå¯–å¯˜å¯™å°Ÿå°³åµ±åµ£åµŠåµ¥åµ²åµ¬åµåµ¨åµ§åµ¢å·°å¹å¹å¹Šå¹å¹‹å»…å»Œå»†å»‹å»‡å½€å¾¯å¾­æƒ·æ…‰æ…Šæ„«æ……æ„¶æ„²æ„®æ…†æ„¯æ…æ„©æ…€æˆ é…¨æˆ£æˆ¥æˆ¤æ…æ±æ«ææ’æ‰æ æ¤"],
    ["dda1", "æ³æ‘ƒæŸæ•æ˜æ¹æ·æ¢æ£æŒæ¦æ°æ¨æ‘æµæ¯æŠæšæ‘€æ¥æ§æ‹æ§æ›æ®æ¡ææ•¯æ–’æ—“æš†æšŒæš•æšæš‹æšŠæš™æš”æ™¸æœ æ¥¦æ¥Ÿæ¤¸æ¥æ¥¢æ¥±æ¤¿æ¥…æ¥ªæ¤¹æ¥‚æ¥—æ¥™æ¥ºæ¥ˆæ¥‰æ¤µæ¥¬æ¤³æ¤½æ¥¥æ£°æ¥¸æ¤´æ¥©æ¥€æ¥¯æ¥„æ¥¶æ¥˜æ¥æ¥´æ¥Œæ¤»æ¥‹æ¤·æ¥œæ¥æ¥‘æ¤²æ¥’æ¤¯æ¥»æ¤¼æ­†æ­…æ­ƒæ­‚æ­ˆæ­æ®›ï¨æ¯»æ¯¼"],
    ["de40", "æ¯¹æ¯·æ¯¸æº›æ»–æ»ˆæºæ»€æºŸæº“æº”æº æº±æº¹æ»†æ»’æº½æ»æºæ»‰æº·æº°æ»æº¦æ»æº²æº¾æ»ƒæ»œæ»˜æº™æº’æºæºæº¤æº¡æº¿æº³æ»æ»Šæº—æº®æº£ç…‡ç…”ç…’ç…£ç… ç…ç…ç…¢ç…²ç…¸ç…ªç…¡ç…‚ç…˜ç…ƒç…‹ç…°ç…Ÿç…ç…“"],
    ["dea1", "ç…„ç…ç…šç‰çŠçŠŒçŠ‘çŠçŠçŒ¼ç‚çŒ»çŒºç€çŠç‰ç‘„ç‘Šç‘‹ç‘’ç‘‘ç‘—ç‘€ç‘ç‘ç‘ç‘‚ç‘†ç‘ç‘”ç“¡ç“¿ç“¾ç“½ç”ç•¹ç•·æ¦ƒç—¯ç˜ç˜ƒç—·ç—¾ç—¼ç—¹ç—¸ç˜ç—»ç—¶ç—­ç—µç—½çš™çšµç›ç•çŸç ç’ç–çšç©ç§ç”ç™ç­çŸ ç¢‡ç¢šç¢”ç¢ç¢„ç¢•ç¢…ç¢†ç¢¡ç¢ƒç¡¹ç¢™ç¢€ç¢–ç¡»ç¥¼ç¦‚ç¥½ç¥¹ç¨‘ç¨˜ç¨™ç¨’ç¨—ç¨•ç¨¢ç¨“"],
    ["df40", "ç¨›ç¨çª£çª¢çªç««ç­¦ç­¤ç­­ç­´ç­©ç­²ç­¥ç­³ç­±ç­°ç­¡ç­¸ç­¶ç­£ç²²ç²´ç²¯ç¶ˆç¶†ç¶€ç¶çµ¿ç¶…çµºç¶çµ»ç¶ƒçµ¼ç¶Œç¶”ç¶„çµ½ç¶’ç½­ç½«ç½§ç½¨ç½¬ç¾¦ç¾¥ç¾§ç¿›ç¿œè€¡è…¤è… è…·è…œè…©è…›è…¢è…²æœ¡è…è…¶è…§è…¯"],
    ["dfa1", "è…„è…¡èˆè‰‰è‰„è‰€è‰‚è‰…è“±è¿è‘–è‘¶è‘¹è’è’è‘¥è‘‘è‘€è’†è‘§è°è‘è‘½è‘šè‘™è‘´è‘³è‘è”‡è‘è·èºè´è‘ºè‘ƒè‘¸è²è‘…è©è™è‘‹è¯è‘‚è­è‘Ÿè‘°è¹è‘è‘Œè‘’è‘¯è“…è’è»è‘‡è¶è³è‘¨è‘¾è‘„è«è‘ è‘”è‘®è‘èœ‹èœ„è›·èœŒè›ºè›–è›µèè›¸èœèœ‰èœè›¶èœèœ…è£–è£‹è£è£è£è£›è£šè£Œè£è¦…è¦›è§Ÿè§¥è§¤"],
    ["e040", "è§¡è§ è§¢è§œè§¦è©¶èª†è©¿è©¡è¨¿è©·èª‚èª„è©µèªƒèªè©´è©ºè°¼è±‹è±Šè±¥è±¤è±¦è²†è²„è²…è³Œèµ¨èµ©è¶‘è¶Œè¶è¶è¶è¶“è¶”è¶è¶’è·°è· è·¬è·±è·®è·è·©è·£è·¢è·§è·²è·«è·´è¼†è»¿è¼è¼€è¼…è¼‡è¼ˆè¼‚è¼‹é’é€¿"],
    ["e0a1", "é„é‰é€½é„é„é„é„‘é„–é„”é„‹é„é…®é…¯é‰ˆé‰’éˆ°éˆºé‰¦éˆ³é‰¥é‰éŠƒéˆ®é‰Šé‰†é‰­é‰¬é‰é‰ é‰§é‰¯éˆ¶é‰¡é‰°éˆ±é‰”é‰£é‰é‰²é‰é‰“é‰Œé‰–éˆ²é–Ÿé–œé–é–›éš’éš“éš‘éš—é›é›ºé›½é›¸é›µé³é·é¸é²é é é é¢¬é£¶é£¹é¦¯é¦²é¦°é¦µéª­éª«é­›é³ªé³­é³§éº€é»½åƒ¦åƒ”åƒ—åƒ¨åƒ³åƒ›åƒªåƒåƒ¤åƒ“åƒ¬åƒ°åƒ¯åƒ£åƒ "],
    ["e140", "å‡˜åŠ€åŠå‹©å‹«åŒ°å¬å˜§å˜•å˜Œå˜’å—¼å˜å˜œå˜å˜“å˜‚å—ºå˜å˜„å—¿å—¹å¢‰å¡¼å¢å¢˜å¢†å¢å¡¿å¡´å¢‹å¡ºå¢‡å¢‘å¢å¡¶å¢‚å¢ˆå¡»å¢”å¢å£¾å¥«å«œå«®å«¥å«•å«ªå«šå«­å««å«³å«¢å« å«›å«¬å«å«å«™å«¨å«Ÿå­·å¯ "],
    ["e1a1", "å¯£å±£å¶‚å¶€åµ½å¶†åµºå¶åµ·å¶Šå¶‰å¶ˆåµ¾åµ¼å¶åµ¹åµ¿å¹˜å¹™å¹“å»˜å»‘å»—å»å»œå»•å»™å»’å»”å½„å½ƒå½¯å¾¶æ„¬æ„¨æ…æ…æ…±æ…³æ…’æ…“æ…²æ…¬æ†€æ…´æ…”æ…ºæ…›æ…¥æ„»æ…ªæ…¡æ…–æˆ©æˆ§æˆ«æ«æ‘æ‘›æ‘æ‘´æ‘¶æ‘²æ‘³æ‘½æ‘µæ‘¦æ’¦æ‘æ’‚æ‘æ‘œæ‘‹æ‘“æ‘ æ‘æ‘¿æ¿æ‘¬æ‘«æ‘™æ‘¥æ‘·æ•³æ– æš¡æš æšŸæœ…æœ„æœ¢æ¦±æ¦¶æ§‰"],
    ["e240", "æ¦ æ§æ¦–æ¦°æ¦¬æ¦¼æ¦‘æ¦™æ¦æ¦§æ¦æ¦©æ¦¾æ¦¯æ¦¿æ§„æ¦½æ¦¤æ§”æ¦¹æ§Šæ¦šæ§æ¦³æ¦“æ¦ªæ¦¡æ¦æ§™æ¦—æ¦æ§‚æ¦µæ¦¥æ§†æ­Šæ­æ­‹æ®æ®Ÿæ® æ¯ƒæ¯„æ¯¾æ»æ»µæ»±æ¼ƒæ¼¥æ»¸æ¼·æ»»æ¼®æ¼‰æ½æ¼™æ¼šæ¼§æ¼˜æ¼»æ¼’æ»­æ¼Š"],
    ["e2a1", "æ¼¶æ½³æ»¹æ»®æ¼­æ½€æ¼°æ¼¼æ¼µæ»«æ¼‡æ¼æ½ƒæ¼…æ»½æ»¶æ¼¹æ¼œæ»¼æ¼ºæ¼Ÿæ¼æ¼æ¼ˆæ¼¡ç†‡ç†ç†‰ç†€ç†…ç†‚ç†ç…»ç††ç†ç†—ç‰„ç‰“çŠ—çŠ•çŠ“çƒçç‘çŒç‘¢ç‘³ç‘±ç‘µç‘²ç‘§ç‘®ç”€ç”‚ç”ƒç•½ç–ç˜–ç˜ˆç˜Œç˜•ç˜‘ç˜Šç˜”çš¸çç¼ç…ç‚ç®ç€ç¯ç¾çƒç¢²ç¢ªç¢´ç¢­ç¢¨ç¡¾ç¢«ç¢ç¢¥ç¢ ç¢¬ç¢¢ç¢¤ç¦˜ç¦Šç¦‹ç¦–ç¦•ç¦”ç¦“"],
    ["e340", "ç¦—ç¦ˆç¦’ç¦ç¨«ç©Šç¨°ç¨¯ç¨¨ç¨¦çª¨çª«çª¬ç«®ç®ˆç®œç®Šç®‘ç®ç®–ç®ç®Œç®›ç®ç®…ç®˜åŠ„ç®™ç®¤ç®‚ç²»ç²¿ç²¼ç²ºç¶§ç¶·ç·‚ç¶£ç¶ªç·ç·€ç·…ç¶ç·ç·„ç·†ç·‹ç·Œç¶¯ç¶¹ç¶–ç¶¼ç¶Ÿç¶¦ç¶®ç¶©ç¶¡ç·‰ç½³ç¿¢ç¿£ç¿¥ç¿"],
    ["e3a1", "è€¤èèœè†‰è††è†ƒè†‡è†è†Œè†‹èˆ•è’—è’¤è’¡è’Ÿè’ºè“è“‚è’¬è’®è’«è’¹è’´è“è“è’ªè’šè’±è“è’è’§è’»è’¢è’”è“‡è“Œè’›è’©è’¯è’¨è“–è’˜è’¶è“è’ è“—è“”è“’è“›è’°è’‘è™¡èœ³èœ£èœ¨è«è€èœ®èœèœ¡èœ™èœ›èƒèœ¬èèœ¾è†èœ èœ²èœªèœ­èœ¼èœ’èœºèœ±èœµè‚èœ¦èœ§èœ¸èœ¤èœšèœ°èœ‘è£·è£§è£±è£²è£ºè£¾è£®è£¼è£¶è£»"],
    ["e440", "è£°è£¬è£«è¦è¦¡è¦Ÿè¦è§©è§«è§¨èª«èª™èª‹èª’èªèª–è°½è±¨è±©è³•è³è³—è¶–è¸‰è¸‚è·¿è¸è·½è¸Šè¸ƒè¸‡è¸†è¸…è·¾è¸€è¸„è¼è¼‘è¼è¼é„£é„œé„ é„¢é„Ÿé„é„šé„¤é„¡é„›é…ºé…²é…¹é…³éŠ¥éŠ¤é‰¶éŠ›é‰ºéŠ éŠ”éŠªéŠ"],
    ["e4a1", "éŠ¦éŠšéŠ«é‰¹éŠ—é‰¿éŠ£é‹®éŠéŠ‚éŠ•éŠ¢é‰½éŠˆéŠ¡éŠŠéŠ†éŠŒéŠ™éŠ§é‰¾éŠ‡éŠ©éŠéŠ‹éˆ­éšéš¡é›¿é˜é½éºé¾éƒé€é‚é»é„éé¿éŸéŸé –é¢­é¢®é¤‚é¤€é¤‡é¦é¦œé§ƒé¦¹é¦»é¦ºé§‚é¦½é§‡éª±é«£é«§é¬¾é¬¿é­ é­¡é­Ÿé³±é³²é³µéº§åƒ¿å„ƒå„°åƒ¸å„†å„‡åƒ¶åƒ¾å„‹å„Œåƒ½å„ŠåŠ‹åŠŒå‹±å‹¯å™ˆå™‚å™Œå˜µå™å™Šå™‰å™†å™˜"],
    ["e540", "å™šå™€å˜³å˜½å˜¬å˜¾å˜¸å˜ªå˜ºåœšå¢«å¢å¢±å¢ å¢£å¢¯å¢¬å¢¥å¢¡å£¿å«¿å«´å«½å«·å«¶å¬ƒå«¸å¬‚å«¹å¬å¬‡å¬…å¬å±§å¶™å¶—å¶Ÿå¶’å¶¢å¶“å¶•å¶ å¶œå¶¡å¶šå¶å¹©å¹å¹ å¹œç·³å»›å»å»¡å½‰å¾²æ†‹æ†ƒæ…¹æ†±æ†°æ†¢æ†‰"],
    ["e5a1", "æ†›æ†“æ†¯æ†­æ†Ÿæ†’æ†ªæ†¡æ†æ…¦æ†³æˆ­æ‘®æ‘°æ’–æ’ æ’…æ’—æ’œæ’æ’‹æ’Šæ’Œæ’£æ’Ÿæ‘¨æ’±æ’˜æ•¶æ•ºæ•¹æ•»æ–²æ–³æšµæš°æš©æš²æš·æšªæš¯æ¨€æ¨†æ¨—æ§¥æ§¸æ¨•æ§±æ§¤æ¨ æ§¿æ§¬æ§¢æ¨›æ¨æ§¾æ¨§æ§²æ§®æ¨”æ§·æ§§æ©€æ¨ˆæ§¦æ§»æ¨æ§¼æ§«æ¨‰æ¨„æ¨˜æ¨¥æ¨æ§¶æ¨¦æ¨‡æ§´æ¨–æ­‘æ®¥æ®£æ®¢æ®¦æ°æ°€æ¯¿æ°‚æ½æ¼¦æ½¾æ¾‡æ¿†æ¾’"],
    ["e640", "æ¾æ¾‰æ¾Œæ½¢æ½æ¾…æ½šæ¾–æ½¶æ½¬æ¾‚æ½•æ½²æ½’æ½æ½—æ¾”æ¾“æ½æ¼€æ½¡æ½«æ½½æ½§æ¾æ½“æ¾‹æ½©æ½¿æ¾•æ½£æ½·æ½ªæ½»ç†²ç†¯ç†›ç†°ç† ç†šç†©ç†µç†ç†¥ç†ç†¤ç†¡ç†ªç†œç†§ç†³çŠ˜çŠšç˜ç’ççŸç çç›ç¡çšç™"],
    ["e6a1", "ç¢ç’‡ç’‰ç’Šç’†ç’ç‘½ç’…ç’ˆç‘¼ç‘¹ç”ˆç”‡ç•¾ç˜¥ç˜ç˜™ç˜ç˜œç˜£ç˜šç˜¨ç˜›çšœçšçšçš›ççç‰çˆç£ç¢»ç£ç£Œç£‘ç£ç£”ç£ˆç£ƒç£„ç£‰ç¦šç¦¡ç¦ ç¦œç¦¢ç¦›æ­¶ç¨¹çª²çª´çª³ç®·ç¯‹ç®¾ç®¬ç¯ç®¯ç®¹ç¯Šç®µç³…ç³ˆç³Œç³‹ç··ç·›ç·ªç·§ç·—ç·¡ç¸ƒç·ºç·¦ç·¶ç·±ç·°ç·®ç·Ÿç½¶ç¾¬ç¾°ç¾­ç¿­ç¿«ç¿ªç¿¬ç¿¦ç¿¨è¤è§è†£è†Ÿ"],
    ["e740", "è†è†•è†¢è†™è†—èˆ–è‰è‰“è‰’è‰è‰è‰‘è”¤è”»è”è”€è”©è”è”‰è”è”Ÿè”Šè”§è”œè“»è”«è“ºè”ˆè”Œè“´è”ªè“²è”•è“·è“«è“³è“¼è”’è“ªè“©è”–è“¾è”¨è”è”®è”‚è“½è”è“¶è”±è”¦è“§è“¨è“°è“¯è“¹è”˜è” è”°è”‹è”™è”¯è™¢"],
    ["e7a1", "è–è£è¤è·èŸ¡è³è˜è”è›è’è¡èšè‘èè­èªèèèŸèè¯è¬èºè®èœè¥èè»èµè¢è§è©è¡šè¤…è¤Œè¤”è¤‹è¤—è¤˜è¤™è¤†è¤–è¤‘è¤è¤‰è¦¢è¦¤è¦£è§­è§°è§¬è«è«†èª¸è«“è«‘è«”è«•èª»è«—èª¾è«€è«…è«˜è«ƒèªºèª½è«™è°¾è±è²è³¥è³Ÿè³™è³¨è³šè³è³§è¶ è¶œè¶¡è¶›è¸ è¸£è¸¥è¸¤è¸®è¸•è¸›è¸–è¸‘è¸™è¸¦è¸§"],
    ["e840", "è¸”è¸’è¸˜è¸“è¸œè¸—è¸šè¼¬è¼¤è¼˜è¼šè¼ è¼£è¼–è¼—é³é°é¯é§é«é„¯é„«é„©é„ªé„²é„¦é„®é†…é††é†Šé†é†‚é†„é†€é‹é‹ƒé‹„é‹€é‹™éŠ¶é‹é‹±é‹Ÿé‹˜é‹©é‹—é‹é‹Œé‹¯é‹‚é‹¨é‹Šé‹ˆé‹é‹¦é‹é‹•é‹‰é‹ é‹é‹§é‹‘é‹“"],
    ["e8a1", "éŠµé‹¡é‹†éŠ´é•¼é–¬é–«é–®é–°éš¤éš¢é›“éœ…éœˆéœ‚éšéŠééˆéŸéŸé é é ¦é ©é ¨é  é ›é §é¢²é¤ˆé£ºé¤‘é¤”é¤–é¤—é¤•é§œé§é§é§“é§”é§é§‰é§–é§˜é§‹é§—é§Œéª³é«¬é««é«³é«²é«±é­†é­ƒé­§é­´é­±é­¦é­¶é­µé­°é­¨é­¤é­¬é³¼é³ºé³½é³¿é³·é´‡é´€é³¹é³»é´ˆé´…é´„éºƒé»“é¼é¼å„œå„“å„—å„šå„‘å‡åŒ´å¡å™°å™ å™®"],
    ["e940", "å™³å™¦å™£å™­å™²å™å™·åœœåœ›å£ˆå¢½å£‰å¢¿å¢ºå£‚å¢¼å£†å¬—å¬™å¬›å¬¡å¬”å¬“å¬å¬–å¬¨å¬šå¬ å¬å¯¯å¶¬å¶±å¶©å¶§å¶µå¶°å¶®å¶ªå¶¨å¶²å¶­å¶¯å¶´å¹§å¹¨å¹¦å¹¯å»©å»§å»¦å»¨å»¥å½‹å¾¼æ†æ†¨æ†–æ‡…æ†´æ‡†æ‡æ‡Œæ†º"],
    ["e9a1", "æ†¿æ†¸æ†Œæ“—æ“–æ“æ“æ“‰æ’½æ’‰æ“ƒæ“›æ“³æ“™æ”³æ•¿æ•¼æ–¢æ›ˆæš¾æ›€æ›Šæ›‹æ›æš½æš»æšºæ›Œæœ£æ¨´æ©¦æ©‰æ©§æ¨²æ©¨æ¨¾æ©æ©­æ©¶æ©›æ©‘æ¨¨æ©šæ¨»æ¨¿æ©æ©ªæ©¤æ©æ©æ©”æ©¯æ©©æ© æ¨¼æ©æ©–æ©•æ©æ©æ©†æ­•æ­”æ­–æ®§æ®ªæ®«æ¯ˆæ¯‡æ°„æ°ƒæ°†æ¾­æ¿‹æ¾£æ¿‡æ¾¼æ¿æ¿ˆæ½æ¿„æ¾½æ¾æ¿Šæ¾¨ç€„æ¾¥æ¾®æ¾ºæ¾¬æ¾ªæ¿æ¾¿æ¾¸"],
    ["ea40", "æ¾¢æ¿‰æ¾«æ¿æ¾¯æ¾²æ¾°ç‡…ç‡‚ç†¿ç†¸ç‡–ç‡€ç‡ç‡‹ç‡”ç‡Šç‡‡ç‡ç†½ç‡˜ç†¼ç‡†ç‡šç‡›çŠçŠç©ç¦ç§ç¬ç¥ç«çªç‘¿ç’šç’ ç’”ç’’ç’•ç’¡ç”‹ç–€ç˜¯ç˜­ç˜±ç˜½ç˜³ç˜¼ç˜µç˜²ç˜°çš»ç›¦çšçç¡çœç›ç¢ç£ç•ç™"],
    ["eaa1", "ç—ç£ç£©ç£¥ç£ªç£ç££ç£›ç£¡ç£¢ç£­ç£Ÿç£ ç¦¤ç©„ç©ˆç©‡çª¶çª¸çªµçª±çª·ç¯ç¯£ç¯§ç¯ç¯•ç¯¥ç¯šç¯¨ç¯¹ç¯”ç¯ªç¯¢ç¯œç¯«ç¯˜ç¯Ÿç³’ç³”ç³—ç³ç³‘ç¸’ç¸¡ç¸—ç¸Œç¸Ÿç¸ ç¸“ç¸ç¸œç¸•ç¸šç¸¢ç¸‹ç¸ç¸–ç¸ç¸”ç¸¥ç¸¤ç½ƒç½»ç½¼ç½ºç¾±ç¿¯è€ªè€©è¬è†±è†¦è†®è†¹è†µè†«è†°è†¬è†´è†²è†·è†§è‡²è‰•è‰–è‰—è•–è•…è•«è•è•“è•¡è•˜"],
    ["eb40", "è•€è•†è•¤è•è•¢è•„è•‘è•‡è•£è”¾è•›è•±è•è•®è•µè••è•§è• è–Œè•¦è•è•”è•¥è•¬è™£è™¥è™¤è›èè—è“è’èˆèè–è˜è¹è‡è£è…èè‘èè„è”èœèšè‰è¤è¤¦è¤°è¤­è¤®è¤§è¤±è¤¢è¤©è¤£è¤¯è¤¬è¤Ÿè§±è« "],
    ["eba1", "è«¢è«²è«´è«µè«è¬”è«¤è«Ÿè«°è«ˆè«è«¡è«¨è«¿è«¯è«»è²‘è²’è²è³µè³®è³±è³°è³³èµ¬èµ®è¶¥è¶§è¸³è¸¾è¸¸è¹€è¹…è¸¶è¸¼è¸½è¹è¸°è¸¿èº½è¼¶è¼®è¼µè¼²è¼¹è¼·è¼´é¶é¹é»é‚†éƒºé„³é„µé„¶é†“é†é†‘é†é†éŒ§éŒéŒˆéŒŸéŒ†éŒéºéŒ¸éŒ¼éŒ›éŒ£éŒ’éŒé†éŒ­éŒéŒé‹‹éŒé‹ºéŒ¥éŒ“é‹¹é‹·éŒ´éŒ‚éŒ¤é‹¿éŒ©éŒ¹éŒµéŒªéŒ”éŒŒ"],
    ["ec40", "éŒ‹é‹¾éŒ‰éŒ€é‹»éŒ–é–¼é—é–¾é–¹é–ºé–¶é–¿é–µé–½éš©é›”éœ‹éœ’éœé™é—é”éŸ°éŸ¸é µé ¯é ²é¤¤é¤Ÿé¤§é¤©é¦é§®é§¬é§¥é§¤é§°é§£é§ªé§©é§§éª¹éª¿éª´éª»é«¶é«ºé«¹é«·é¬³é®€é®…é®‡é­¼é­¾é­»é®‚é®“é®’é®é­ºé®•"],
    ["eca1", "é­½é®ˆé´¥é´—é´ é´é´”é´©é´é´˜é´¢é´é´™é´Ÿéºˆéº†éº‡éº®éº­é»•é»–é»ºé¼’é¼½å„¦å„¥å„¢å„¤å„ å„©å‹´åš“åšŒåšåš†åš„åšƒå™¾åš‚å™¿åšå£–å£”å£å£’å¬­å¬¥å¬²å¬£å¬¬å¬§å¬¦å¬¯å¬®å­»å¯±å¯²å¶·å¹¬å¹ªå¾¾å¾»æ‡ƒæ†µæ†¼æ‡§æ‡ æ‡¥æ‡¤æ‡¨æ‡æ“¯æ“©æ“£æ“«æ“¤æ“¨æ–æ–€æ–¶æ—šæ›’æªæª–æªæª¥æª‰æªŸæª›æª¡æªæª‡æª“æª"],
    ["ed40", "æª•æªƒæª¨æª¤æª‘æ©¿æª¦æªšæª…æªŒæª’æ­›æ®­æ°‰æ¿Œæ¾©æ¿´æ¿”æ¿£æ¿œæ¿­æ¿§æ¿¦æ¿æ¿²æ¿æ¿¢æ¿¨ç‡¡ç‡±ç‡¨ç‡²ç‡¤ç‡°ç‡¢ç³ç®ç¯ç’—ç’²ç’«ç’ç’ªç’­ç’±ç’¥ç’¯ç”ç”‘ç”’ç”ç–„ç™ƒç™ˆç™‰ç™‡çš¤ç›©çµç«ç²ç·ç¶"],
    ["eda1", "ç´ç±ç¨çŸ°ç£³ç£½ç¤‚ç£»ç£¼ç£²ç¤…ç£¹ç£¾ç¤„ç¦«ç¦¨ç©œç©›ç©–ç©˜ç©”ç©šçª¾ç«€ç«ç°…ç°ç¯²ç°€ç¯¿ç¯»ç°ç¯´ç°‹ç¯³ç°‚ç°‰ç°ƒç°ç¯¸ç¯½ç°†ç¯°ç¯±ç°ç°Šç³¨ç¸­ç¸¼ç¹‚ç¸³é¡ˆç¸¸ç¸ªç¹‰ç¹€ç¹‡ç¸©ç¹Œç¸°ç¸»ç¸¶ç¹„ç¸ºç½…ç½¿ç½¾ç½½ç¿´ç¿²è€¬è†»è‡„è‡Œè‡Šè‡…è‡‡è†¼è‡©è‰›è‰šè‰œè–ƒè–€è–è–§è–•è– è–‹è–£è•»è–¤è–šè–"],
    ["ee40", "è•·è•¼è–‰è–¡è•ºè•¸è•—è–è––è–†è–è–™è–è–è–¢è–‚è–ˆè–…è•¹è•¶è–˜è–è–Ÿè™¨è¾èªè­èŸ…è°è¬è¹èµè¼è®èŸ‰èŸƒèŸ‚èŸŒè·è¯èŸ„èŸŠè´è¶è¿è¸è½èŸè²è¤µè¤³è¤¼è¤¾è¥è¥’è¤·è¥‚è¦­è¦¯è¦®è§²è§³è¬"],
    ["eea1", "è¬˜è¬–è¬‘è¬…è¬‹è¬¢è¬è¬’è¬•è¬‡è¬è¬ˆè¬†è¬œè¬“è¬šè±è±°è±²è±±è±¯è²•è²”è³¹èµ¯è¹è¹è¹“è¹è¹Œè¹‡è½ƒè½€é‚…é¾é„¸é†šé†¢é†›é†™é†Ÿé†¡é†é† é¡éƒé¯é¤é–é‡é¼é˜éœé¶é‰éé‘é é­ééŒéªé¹é—é•é’éé±é·é»é¡éé£é§é€éé™é—‡é—€é—‰é—ƒé—…é–·éš®éš°éš¬éœ éœŸéœ˜éœéœ™éšé¡éœ"],
    ["ef40", "éééŸ•éŸ”éŸ±é¡é¡„é¡Šé¡‰é¡…é¡ƒé¤¥é¤«é¤¬é¤ªé¤³é¤²é¤¯é¤­é¤±é¤°é¦˜é¦£é¦¡é¨‚é§ºé§´é§·é§¹é§¸é§¶é§»é§½é§¾é§¼é¨ƒéª¾é«¾é«½é¬é«¼é­ˆé®šé®¨é®é®›é®¦é®¡é®¥é®¤é®†é®¢é® é®¯é´³éµéµ§é´¶é´®é´¯é´±é´¸é´°"],
    ["efa1", "éµ…éµ‚éµƒé´¾é´·éµ€é´½ç¿µé´­éºŠéº‰éºéº°é»ˆé»šé»»é»¿é¼¤é¼£é¼¢é½”é¾ å„±å„­å„®åš˜åšœåš—åššåšåš™å¥°å¬¼å±©å±ªå·€å¹­å¹®æ‡˜æ‡Ÿæ‡­æ‡®æ‡±æ‡ªæ‡°æ‡«æ‡–æ‡©æ“¿æ”„æ“½æ“¸æ”æ”ƒæ“¼æ–”æ—›æ›šæ››æ›˜æ«…æª¹æª½æ«¡æ«†æªºæª¶æª·æ«‡æª´æª­æ­æ¯‰æ°‹ç€‡ç€Œç€ç€ç€…ç€”ç€æ¿¿ç€€æ¿»ç€¦æ¿¼æ¿·ç€Šçˆç‡¿ç‡¹çˆƒç‡½ç¶"],
    ["f040", "ç’¸ç“€ç’µç“ç’¾ç’¶ç’»ç“‚ç””ç”“ç™œç™¤ç™™ç™ç™“ç™—ç™šçš¦çš½ç›¬çŸ‚çºç£¿ç¤Œç¤“ç¤”ç¤‰ç¤ç¤’ç¤‘ç¦­ç¦¬ç©Ÿç°œç°©ç°™ç° ç°Ÿç°­ç°ç°¦ç°¨ç°¢ç°¥ç°°ç¹œç¹ç¹–ç¹£ç¹˜ç¹¢ç¹Ÿç¹‘ç¹ ç¹—ç¹“ç¾µç¾³ç¿·ç¿¸èµè‡‘è‡’"],
    ["f0a1", "è‡è‰Ÿè‰è–´è—†è—€è—ƒè—‚è–³è–µè–½è—‡è—„è–¿è—‹è—è—ˆè—…è–±è–¶è—’è˜¤è–¸è–·è–¾è™©èŸ§èŸ¦èŸ¢èŸ›èŸ«èŸªèŸ¥èŸŸèŸ³èŸ¤èŸ”èŸœèŸ“èŸ­èŸ˜èŸ£è¤èŸ—èŸ™è èŸ´èŸ¨èŸè¥“è¥‹è¥è¥Œè¥†è¥è¥‘è¥‰è¬ªè¬§è¬£è¬³è¬°è¬µè­‡è¬¯è¬¼è¬¾è¬±è¬¥è¬·è¬¦è¬¶è¬®è¬¤è¬»è¬½è¬ºè±‚è±µè²™è²˜è²—è³¾è´„è´‚è´€è¹œè¹¢è¹ è¹—è¹–è¹è¹¥è¹§"],
    ["f140", "è¹›è¹šè¹¡è¹è¹©è¹”è½†è½‡è½ˆè½‹é„¨é„ºé„»é„¾é†¨é†¥é†§é†¯é†ªéµéŒé’é·é›éé‰é§ééªéé¦é•éˆé™éŸéé±é‘é²é¤é¨é´é£é¥é—’é—“é—‘éš³é›—é›šå·‚é›Ÿé›˜é›éœ£éœ¢éœ¥é¬é®é¨é«é¤éª"],
    ["f1a1", "é¢é¥éŸ—éŸ™éŸ–éŸ˜éŸºé¡é¡‘é¡’é¢¸é¥é¤¼é¤ºé¨é¨‹é¨‰é¨é¨„é¨‘é¨Šé¨…é¨‡é¨†é«€é«œé¬ˆé¬„é¬…é¬©é¬µé­Šé­Œé­‹é¯‡é¯†é¯ƒé®¿é¯é®µé®¸é¯“é®¶é¯„é®¹é®½éµœéµ“éµéµŠéµ›éµ‹éµ™éµ–éµŒéµ—éµ’éµ”éµŸéµ˜éµšéºéºŒé»Ÿé¼é¼€é¼–é¼¥é¼«é¼ªé¼©é¼¨é½Œé½•å„´å„µåŠ–å‹·å´åš«åš­åš¦åš§åšªåš¬å£šå£å£›å¤’å¬½å¬¾å¬¿å·ƒå¹°"],
    ["f240", "å¾¿æ‡»æ”‡æ”æ”æ”‰æ”Œæ”æ–„æ—æ—æ›æ«§æ« æ«Œæ«‘æ«™æ«‹æ«Ÿæ«œæ«æ««æ«æ«æ«æ­ æ®°æ°Œç€™ç€§ç€ ç€–ç€«ç€¡ç€¢ç€£ç€©ç€—ç€¤ç€œç€ªçˆŒçˆŠçˆ‡çˆ‚çˆ…çŠ¥çŠ¦çŠ¤çŠ£çŠ¡ç“‹ç“…ç’·ç“ƒç”–ç™ çŸ‰çŸŠçŸ„çŸ±ç¤ç¤›"],
    ["f2a1", "ç¤¡ç¤œç¤—ç¤ç¦°ç©§ç©¨ç°³ç°¼ç°¹ç°¬ç°»ç³¬ç³ªç¹¶ç¹µç¹¸ç¹°ç¹·ç¹¯ç¹ºç¹²ç¹´ç¹¨ç½‹ç½Šç¾ƒç¾†ç¾·ç¿½ç¿¾è¸è‡—è‡•è‰¤è‰¡è‰£è—«è—±è—­è—™è—¡è—¨è—šè——è—¬è—²è—¸è—˜è—Ÿè—£è—œè—‘è—°è—¦è—¯è—è—¢è €èŸºè ƒèŸ¶èŸ·è ‰è Œè ‹è †èŸ¼è ˆèŸ¿è Šè ‚è¥¢è¥šè¥›è¥—è¥¡è¥œè¥˜è¥è¥™è¦ˆè¦·è¦¶è§¶è­è­ˆè­Šè­€è­“è­–è­”è­‹è­•"],
    ["f340", "è­‘è­‚è­’è­—è±ƒè±·è±¶è²šè´†è´‡è´‰è¶¬è¶ªè¶­è¶«è¹­è¹¸è¹³è¹ªè¹¯è¹»è»‚è½’è½‘è½è½è½“è¾´é…€é„¿é†°é†­éé‡éé‚éšéé¹é¬éŒé™é©é¦éŠé”é®é£é•é„éé€é’é§é•½é—šé—›é›¡éœ©éœ«éœ¬éœ¨éœ¦"],
    ["f3a1", "é³é·é¶éŸéŸéŸŸé¡œé¡™é¡é¡—é¢¿é¢½é¢»é¢¾é¥ˆé¥‡é¥ƒé¦¦é¦§é¨šé¨•é¨¥é¨é¨¤é¨›é¨¢é¨ é¨§é¨£é¨é¨œé¨”é«‚é¬‹é¬Šé¬é¬Œé¬·é¯ªé¯«é¯ é¯é¯¤é¯¦é¯¢é¯°é¯”é¯—é¯¬é¯œé¯™é¯¥é¯•é¯¡é¯šéµ·é¶é¶Šé¶„é¶ˆéµ±é¶€éµ¸é¶†é¶‹é¶Œéµ½éµ«éµ´éµµéµ°éµ©é¶…éµ³éµ»é¶‚éµ¯éµ¹éµ¿é¶‡éµ¨éº”éº‘é»€é»¼é¼­é½€é½é½é½–é½—é½˜åŒ·åš²"],
    ["f440", "åšµåš³å££å­…å·†å·‡å»®å»¯å¿€å¿æ‡¹æ”—æ”–æ”•æ”“æ—Ÿæ›¨æ›£æ›¤æ«³æ«°æ«ªæ«¨æ«¹æ«±æ«®æ«¯ç€¼ç€µç€¯ç€·ç€´ç€±ç‚ç€¸ç€¿ç€ºç€¹ç€ç€»ç€³ççˆ“çˆ”çŠ¨ç½ç¼ç’ºçš«çšªçš¾ç›­çŸŒçŸçŸçŸçŸ²ç¤¥ç¤£ç¤§ç¤¨ç¤¤ç¤©"],
    ["f4a1", "ç¦²ç©®ç©¬ç©­ç«·ç±‰ç±ˆç±Šç±‡ç±…ç³®ç¹»ç¹¾çºçº€ç¾ºç¿¿è¹è‡›è‡™èˆ‹è‰¨è‰©è˜¢è—¿è˜è—¾è˜›è˜€è—¶è˜„è˜‰è˜…è˜Œè—½è ™è è ‘è —è “è –è¥£è¥¦è¦¹è§·è­ è­ªè­è­¨è­£è­¥è­§è­­è¶®èº†èºˆèº„è½™è½–è½—è½•è½˜è½šé‚é…ƒé…é†·é†µé†²é†³é‹é“é»é éé”é¾é•éé¨é™ééµé€é·é‡éé–é’éºé‰é¸éŠé¿"],
    ["f540", "é¼éŒé¶é‘é†é—é— é—Ÿéœ®éœ¯é¹é»éŸ½éŸ¾é¡ é¡¢é¡£é¡Ÿé£é£‚é¥é¥é¥™é¥Œé¥‹é¥“é¨²é¨´é¨±é¨¬é¨ªé¨¶é¨©é¨®é¨¸é¨­é«‡é«Šé«†é¬é¬’é¬‘é°‹é°ˆé¯·é°…é°’é¯¸é±€é°‡é°é°†é°—é°”é°‰é¶Ÿé¶™é¶¤é¶é¶’é¶˜é¶é¶›"],
    ["f5a1", "é¶ é¶”é¶œé¶ªé¶—é¶¡é¶šé¶¢é¶¨é¶é¶£é¶¿é¶©é¶–é¶¦é¶§éº™éº›éºšé»¥é»¤é»§é»¦é¼°é¼®é½›é½ é½é½é½™é¾‘å„ºå„¹åŠ˜åŠ—å›ƒåš½åš¾å­ˆå­‡å·‹å·å»±æ‡½æ”›æ¬‚æ«¼æ¬ƒæ«¸æ¬€çƒç„çŠçˆç‰ç…ç†çˆçˆšçˆ™ç¾ç”—ç™ªçŸç¤­ç¤±ç¤¯ç±”ç±“ç³²çºŠçº‡çºˆçº‹çº†çºç½ç¾»è€°è‡è˜˜è˜ªè˜¦è˜Ÿè˜£è˜œè˜™è˜§è˜®è˜¡è˜ è˜©è˜è˜¥"],
    ["f640", "è ©è è ›è  è ¤è œè «è¡Šè¥­è¥©è¥®è¥«è§ºè­¹è­¸è­…è­ºè­»è´è´”è¶¯èºèºŒè½è½›è½é…†é…„é……é†¹é¿é»é¶é©é½é¼é°é¹éªé·é¬é‘€é±é—¥é—¤é—£éœµéœºé¿éŸ¡é¡¤é£‰é£†é£€é¥˜é¥–é¨¹é¨½é©†é©„é©‚é©é¨º"],
    ["f6a1", "é¨¿é«é¬•é¬—é¬˜é¬–é¬ºé­’é°«é°é°œé°¬é°£é°¨é°©é°¤é°¡é¶·é¶¶é¶¼é·é·‡é·Šé·é¶¾é·…é·ƒé¶»é¶µé·é¶¹é¶ºé¶¬é·ˆé¶±é¶­é·Œé¶³é·é¶²é¹ºéºœé»«é»®é»­é¼›é¼˜é¼šé¼±é½é½¥é½¤é¾’äº¹å›†å›…å›‹å¥±å­‹å­Œå·•å·‘å»²æ”¡æ” æ”¦æ”¢æ¬‹æ¬ˆæ¬‰æ°ç•ç–ç—ç’çˆçˆŸçŠ©ç¿ç“˜ç“•ç“™ç“—ç™­çš­ç¤µç¦´ç©°ç©±ç±—ç±œç±™ç±›ç±š"],
    ["f740", "ç³´ç³±çº‘ç½ç¾‡è‡è‰«è˜´è˜µè˜³è˜¬è˜²è˜¶è ¬è ¨è ¦è ªè ¥è¥±è¦¿è¦¾è§»è­¾è®„è®‚è®†è®…è­¿è´•èº•èº”èºšèº’èºèº–èº—è½ è½¢é…‡é‘Œé‘é‘Šé‘‹é‘é‘‡é‘…é‘ˆé‘‰é‘†éœ¿éŸ£é¡ªé¡©é£‹é¥”é¥›é©é©“é©”é©Œé©é©ˆé©Š"],
    ["f7a1", "é©‰é©’é©é«é¬™é¬«é¬»é­–é­•é±†é±ˆé°¿é±„é°¹é°³é±é°¼é°·é°´é°²é°½é°¶é·›é·’é·é·šé·‹é·é·œé·‘é·Ÿé·©é·™é·˜é·–é·µé·•é·éº¶é»°é¼µé¼³é¼²é½‚é½«é¾•é¾¢å„½åŠ™å£¨å£§å¥²å­å·˜è ¯å½æˆæˆƒæˆ„æ”©æ”¥æ––æ›«æ¬‘æ¬’æ¬æ¯Šç›çšçˆ¢ç‚ççƒç™°çŸ”ç±§ç±¦çº•è‰¬è˜ºè™€è˜¹è˜¼è˜±è˜»è˜¾è °è ²è ®è ³è¥¶è¥´è¥³è§¾"],
    ["f840", "è®Œè®è®‹è®ˆè±…è´™èº˜è½¤è½£é†¼é‘¢é‘•é‘é‘—é‘éŸ„éŸ…é €é©–é©™é¬é¬Ÿé¬ é±’é±˜é±é±Šé±é±‹é±•é±™é±Œé±é·»é··é·¯é·£é·«é·¸é·¤é·¶é·¡é·®é·¦é·²é·°é·¢é·¬é·´é·³é·¨é·­é»‚é»é»²é»³é¼†é¼œé¼¸é¼·é¼¶é½ƒé½"],
    ["f8a1", "é½±é½°é½®é½¯å›“å›å­å±­æ”­æ›­æ›®æ¬“çŸç¡çç çˆ£ç“›ç“¥çŸ•ç¤¸ç¦·ç¦¶ç±ªçº—ç¾‰è‰­è™ƒè ¸è ·è µè¡‹è®”è®•èºèºŸèº èºé†¾é†½é‡‚é‘«é‘¨é‘©é›¥é†éƒé‡éŸ‡éŸ¥é©é«•é­™é±£é±§é±¦é±¢é±é± é¸‚é·¾é¸‡é¸ƒé¸†é¸…é¸€é¸é¸‰é·¿é·½é¸„éº é¼é½†é½´é½µé½¶å›”æ”®æ–¸æ¬˜æ¬™æ¬—æ¬šç¢çˆ¦çŠªçŸ˜çŸ™ç¤¹ç±©ç±«ç³¶çºš"],
    ["f940", "çº˜çº›çº™è‡ è‡¡è™†è™‡è™ˆè¥¹è¥ºè¥¼è¥»è§¿è®˜è®™èº¥èº¤èº£é‘®é‘­é‘¯é‘±é‘³é‰é¡²é¥Ÿé±¨é±®é±­é¸‹é¸é¸é¸é¸’é¸‘éº¡é»µé¼‰é½‡é½¸é½»é½ºé½¹åœç¦ç±¯è ¼è¶²èº¦é‡ƒé‘´é‘¸é‘¶é‘µé© é±´é±³é±±é±µé¸”é¸“é»¶é¼Š"],
    ["f9a1", "é¾¤ç¨ç¥ç³·è™ªè ¾è ½è ¿è®è²œèº©è»‰é‹é¡³é¡´é£Œé¥¡é¦«é©¤é©¦é©§é¬¤é¸•é¸—é½ˆæˆ‡æ¬çˆ§è™Œèº¨é’‚é’€é’é©©é©¨é¬®é¸™çˆ©è™‹è®Ÿé’ƒé±¹éº·ç™µé©«é±ºé¸ç©çªéº¤é½¾é½‰é¾˜ç¢éŠ¹è£å¢»æ’ç²§å«ºâ•”â•¦â•—â• â•¬â•£â•šâ•©â•â•’â•¤â••â•â•ªâ•¡â•˜â•§â•›â•“â•¥â•–â•Ÿâ•«â•¢â•™â•¨â•œâ•‘â•â•­â•®â•°â•¯â–“"]
  ];
});

// node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = __commonJS((exports, module) => {
  module.exports = [
    ["8740", "ä°ä°²ä˜ƒä–¦ä•¸ğ§‰§äµ·ä–³ğ§²±ä³¢ğ§³…ã®•äœ¶ä„ä±‡ä±€ğ¤Š¿ğ£˜—ğ§’ğ¦º‹ğ§ƒ’ä±—ğª‘ää—šä²…ğ§±¬ä´‡äª¤äš¡ğ¦¬£çˆ¥ğ¥©”ğ¡©£ğ£¸†ğ£½¡æ™å›»"],
    ["8767", "ç¶•å¤ğ¨®¹ã·´éœ´ğ§¯¯å¯›ğ¡µåª¤ã˜¥ğ©º°å«‘å®·å³¼æ®è–“ğ©¥…ç‘¡ç’ã¡µğ¡µ“ğ£šğ¦€¡ã»¬"],
    ["87a1", "ğ¥£ã«µç«¼é¾—ğ¤…¡ğ¨¤ğ£‡ªğ ªŠğ£‰äŒŠè’„é¾–é¯ä¤°è˜“å¢–éŠéˆ˜ç§ç¨²æ™ æ¨©è¢ç‘Œç¯…æ‚ç¨¬å‰é†ã“¦ç„ğ¥¶¹ç“†é¿‡å³ä¤¯å‘Œä„±ğ£šå ˜ç©²ğ§­¥è®äš®ğ¦ºˆä†ğ¥¶™ç®®ğ¢’¼é¿ˆğ¢“ğ¢“‰ğ¢“Œé¿‰è”„ğ£–»ä‚´é¿Šä“¡ğª·¿æ‹ç®é¿‹"],
    ["8840", "ã‡€", 4, "ğ „Œã‡…ğ ƒ‘ğ ƒã‡†ã‡‡ğ ƒ‹ğ¡¿¨ã‡ˆğ ƒŠã‡‰ã‡Šã‡‹ã‡Œğ „ã‡ã‡Ä€ÃÇÃ€Ä’Ã‰ÄšÃˆÅŒÃ“Ç‘Ã’à¿¿ÃŠÌ„áº¾à¿¿ÃŠÌŒá»€ÃŠÄÃ¡ÇÃ É‘Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜Çš"],
    ["88a1", "ÇœÃ¼à¿¿ÃªÌ„áº¿à¿¿ÃªÌŒá»ÃªÉ¡âšâ›"],
    ["8940", "ğª©ğ¡……"],
    ["8943", "æ”Š"],
    ["8946", "ä¸½æ»éµé‡Ÿ"],
    ["894c", "ğ§œµæ’‘ä¼šä¼¨ä¾¨å…–å…´å†œå‡¤åŠ¡åŠ¨åŒ»åå‘å˜å›¢å£°å¤„å¤‡å¤²å¤´å­¦å®å®Ÿå²šåº†æ€»æ–‰æŸ¾æ „æ¡¥æµç‚¼ç”µçº¤çº¬çººç»‡ç»ç»Ÿç¼†ç¼·è‰ºè‹è¯è§†è®¾è¯¢è½¦è½§è½®"],
    ["89a1", "ç‘ç³¼ç·æ¥†ç«‰åˆ§"],
    ["89ab", "é†Œç¢¸é…è‚¼"],
    ["89b0", "è´‹èƒ¶ğ §§"],
    ["89b5", "è‚Ÿé»‡ä³é·‰é¸Œä°¾ğ©·¶ğ§€é¸Šğª„³ã—"],
    ["89c1", "æºšèˆ¾ç”™"],
    ["89c5", "ä¤‘é©¬éªé¾™ç¦‡ğ¨‘¬ğ¡·Šğ —ğ¢«¦ä¸¤äºäº€äº‡äº¿ä»«ä¼·ã‘Œä¾½ã¹ˆå€ƒå‚ˆã‘½ã’“ã’¥å††å¤…å‡›å‡¼åˆ…äº‰å‰¹åŠåŒ§ã—‡å©ã•‘å°ã•“å‚å£ã•­ã•²ãšå’“å’£å’´å’¹å“å“¯å”˜å”£å”¨ã–˜å”¿ã–¥ã–¿å——ã—…"],
    ["8a40", "ğ§¶„å”¥"],
    ["8a43", "ğ ±‚ğ ´•ğ¥„«å–ğ¢³†ã§¬ğ è¹†ğ¤¶¸ğ©“¥ä“ğ¨‚¾çºğ¢°¸ã¨´äŸ•ğ¨…ğ¦§²ğ¤·ªæ“ğ µ¼ğ ¾´ğ ³•ğ¡ƒ´æ’è¹¾ğ º–ğ °‹ğ ½¤ğ¢²©ğ¨‰–ğ¤““"],
    ["8a64", "ğ µ†ğ©©ğ¨ƒ©äŸ´ğ¤º§ğ¢³‚éª²ã©§ğ©—´ã¿­ã”†ğ¥‹‡ğ©Ÿ”ğ§£ˆğ¢µ„éµ®é •"],
    ["8a76", "ä™ğ¦‚¥æ’´å“£ğ¢µŒğ¢¯Šğ¡·ã§»ğ¡¯"],
    ["8aa1", "ğ¦›šğ¦œ–ğ§¦ æ“ªğ¥’ğ ±ƒè¹¨ğ¢†¡ğ¨­Œğ œ±"],
    ["8aac", "ä ‹ğ †©ã¿ºå¡³ğ¢¶"],
    ["8ab2", "ğ¤—ˆğ “¼ğ¦‚—ğ ½Œğ ¶–å•¹ä‚»äº"],
    ["8abb", "äª´ğ¢©¦ğ¡‚è†ªé£µğ ¶œæ¹ã§¾ğ¢µè·€åš¡æ‘¼ã¹ƒ"],
    ["8ac9", "ğª˜ğ ¸‰ğ¢«ğ¢³‰"],
    ["8ace", "ğ¡ƒˆğ£§‚ã¦’ã¨†ğ¨Š›ã•¸ğ¥¹‰ğ¢ƒ‡å™’ğ ¼±ğ¢²²ğ©œ ã’¼æ°½ğ¤¸»"],
    ["8adf", "ğ§•´ğ¢º‹ğ¢ˆˆğª™›ğ¨³ğ ¹ºğ °´ğ¦ œç¾“ğ¡ƒğ¢ ƒğ¢¤¹ã—»ğ¥‡£ğ ºŒğ ¾ğ ºªã¾“ğ ¼°ğ µ‡ğ¡…ğ ¹Œ"],
    ["8af6", "ğ º«ğ ®©ğ µˆğ¡ƒ€ğ¡„½ã¿¹ğ¢š–æ²ğ ¾­"],
    ["8b40", "ğ£´ğ§˜¹ğ¢¯ğ µ¾ğ µ¿ğ¢±‘ğ¢±•ã¨˜ğ º˜ğ¡ƒ‡ğ ¼®ğª˜²ğ¦­ğ¨³’ğ¨¶™ğ¨³Šé–ªå“Œè‹„å–¹"],
    ["8b55", "ğ©»ƒé°¦éª¶ğ§ğ¢·®ç…€è…­èƒ¬å°œğ¦•²è„´ã—åŸğ¨‚½é†¶ğ »ºğ ¸ğ ¹·ğ »»ã—ğ¤·«ã˜‰ğ ³–åš¯ğ¢µğ¡ƒ‰ğ ¸ğ ¹¸ğ¡¸ğ¡…ˆğ¨ˆ‡ğ¡‘•ğ ¹¹ğ¤¹ğ¢¶¤å©”ğ¡€ğ¡€ğ¡ƒµğ¡ƒ¶åœğ ¸‘"],
    ["8ba1", "ğ§š”ğ¨‹ğ ¾µğ ¹»ğ¥…¾ãœƒğ ¾¶ğ¡†€ğ¥‹˜ğªŠ½ğ¤§šğ¡ ºğ¤…·ğ¨‰¼å¢™å‰¨ã˜šğ¥œ½ç®²å­¨ä €ä¬¬é¼§ä§§é°Ÿé®ğ¥­´ğ£„½å—»ã—²åš‰ä¸¨å¤‚ğ¡¯ğ¯¡¸é‘ğ ‚†ä¹›äº»ã”¾å°£å½‘å¿„ã£ºæ‰Œæ”µæ­ºæ°µæ°ºç¬çˆ«ä¸¬çŠ­ğ¤£©ç½’ç¤»ç³¹ç½“ğ¦‰ªã“"],
    ["8bde", "ğ¦‹è€‚è‚€ğ¦˜’ğ¦¥‘åè¡¤è§ğ§¢²è® è´é’…é•¸é•¿é—¨ğ¨¸éŸ¦é¡µé£é£é¥£ğ© é±¼é¸Ÿé»„æ­¯ï¤‡ä¸·ğ ‚‡é˜æˆ·é’¢"],
    ["8c40", "å€»æ·¾ğ©±³é¾¦ã·‰è¢ğ¤…ç·å³µä¬ ğ¥‡ã•™ğ¥´°æ„¢ğ¨¨²è¾§é‡¶ç†‘æœ™çºğ£Šğª„‡ã²‹ğ¡¦€ä¬ç£¤ç‚å†®ğ¨œä€‰æ©£ğªŠºäˆ£è˜ğ ©¯ç¨ªğ©¥‡ğ¨«ªé•çåŒ¤ğ¢¾é´ç›™ğ¨§£é¾§çŸäº£ä¿°å‚¼ä¸¯ä¼—é¾¨å´ç¶‹å¢’å£ğ¡¶¶åº’åº™å¿‚ğ¢œ’æ–‹"],
    ["8ca1", "ğ£¹æ¤™æ©ƒğ£±£æ³¿"],
    ["8ca7", "çˆ€ğ¤”…çŒã»›ğ¤¨“å¬•ç’¹è®ƒğ¥²¤ğ¥š•çª“ç¯¬ç³ƒç¹¬è‹¸è–—é¾©è¢é¾ªèº¹é¾«è¿è•Ÿé§ éˆ¡é¾¬ğ¨¶¹ğ¡¿ä±äŠ¢å¨š"],
    ["8cc9", "é¡¨æ«ä‰¶åœ½"],
    ["8cce", "è—–ğ¤¥»èŠ¿ğ§„ä²ğ¦µ´åµ»ğ¦¬•ğ¦¾¾é¾­é¾®å®–é¾¯æ›§ç¹›æ¹—ç§Šã¶ˆä“ƒğ£‰–ğ¢–äšä”¶"],
    ["8ce6", "å³•ğ£¬šè«¹å±¸ã´’ğ£•‘åµ¸é¾²ç…—ä•˜ğ¤ƒ¬ğ¡¸£ä±·ã¥¸ã‘Šğ †¤ğ¦±è«Œä¾´ğ ˆ¹å¦¿è…¬é¡–ğ©£ºå¼»"],
    ["8d40", "ğ ®Ÿ"],
    ["8d42", "ğ¢‡ğ¨¥­ä„‚äš»ğ©¹ã¼‡é¾³ğª†µäƒ¸ãŸ–ä›·ğ¦±†ä…¼ğ¨š²ğ§¿ä•­ã£”ğ¥’šä•¡ä”›ä¶‰ä±»äµ¶ä—ªã¿ˆğ¤¬ã™¡ä“ä’½ä‡­å´¾åµˆåµ–ã·¼ã å¶¤å¶¹ã  ã ¸å¹‚åº½å¼¥å¾ƒã¤ˆã¤”ã¤¿ã¥æƒ—æ„½å³¥ã¦‰æ†·æ†¹æ‡ã¦¸æˆ¬æŠæ‹¥æŒ˜ã§¸åš±"],
    ["8da1", "ã¨ƒæ¢æ»æ‡æ‘šã©‹æ“€å´•å˜¡é¾Ÿãª—æ–†ãª½æ—¿æ™“ã«²æš’ã¬¢æœ–ã­‚æ¤æ €ã­˜æ¡Šæ¢„ã­²ã­±ã­»æ¤‰æ¥ƒç‰œæ¥¤æ¦Ÿæ¦…ã®¼æ§–ã¯æ©¥æ©´æ©±æª‚ã¯¬æª™ã¯²æª«æªµæ«”æ«¶æ®æ¯æ¯ªæ±µæ²ªã³‹æ´‚æ´†æ´¦æ¶ã³¯æ¶¤æ¶±æ¸•æ¸˜æ¸©æº†ğ¨§€æº»æ»¢æ»šé½¿æ»¨æ»©æ¼¤æ¼´ãµ†ğ£½æ¾æ¾¾ãµªãµµç†·å²™ã¶Šç€¬ã¶‘çç”ç¯ç¿ç‚‰ğ Œ¥äã—±ğ »˜"],
    ["8e40", "ğ£»—å¾ğ¦»“ç„¾ğ¥Ÿ ã™æ¦¢ğ¨¯©å­´ç©‰ğ¥£¡ğ©“™ç©¥ç©½ğ¥¦¬çª»çª°ç«‚ç«ƒç‡‘ğ¦’ä‡Šç«šç«ç«ªä‡¯å’²ğ¥°ç¬‹ç­•ç¬©ğ¥Œğ¥³¾ç®¢ç­¯èœğ¥®´ğ¦±¿ç¯è¡ç®’ç®¸ğ¥´ ã¶­ğ¥±¥è’’ç¯ºç°†ç°µğ¥³ç±„ç²ƒğ¤¢‚ç²¦æ™½ğ¤•¸ç³‰ç³‡ç³¦ç±´ç³³ç³µç³"],
    ["8ea1", "ç¹§ä”ğ¦¹„çµğ¦»–ç’ç¶‰ç¶«ç„µç¶³ç·’ğ¤—ğ¦€©ç·¤ã´“ç·µğ¡Ÿ¹ç·¥ğ¨­ç¸ğ¦„¡ğ¦…šç¹®çº’äŒ«é‘¬ç¸§ç½€ç½ç½‡ç¤¶ğ¦‹é§¡ç¾—ğ¦‘ç¾£ğ¡™¡ğ ¨ä•œğ£¦ä”ƒğ¨Œºç¿ºğ¦’‰è€…è€ˆè€è€¨è€¯ğª‚‡ğ¦³ƒè€»è€¼è¡ğ¢œ”ä¦‰ğ¦˜¦ğ£·£ğ¦›¨æœ¥è‚§ğ¨©ˆè„‡è„šå¢°ğ¢›¶æ±¿ğ¦’˜ğ¤¾¸æ“§ğ¡’Šèˆ˜ğ¡¡æ©“ğ¤©¥ğ¤ª•ä‘ºèˆ©ğ ¬ğ¦©’ğ£µ¾ä¿¹ğ¡“½è“¢è¢ğ¦¬Šğ¤¦§ğ£”°ğ¡³ğ£·¸èŠªæ¤›ğ¯¦”ä‡›"],
    ["8f40", "è•‹è‹èŒšğ ¸–ğ¡´ã›ğ£…½ğ£•šè‰»è‹¢èŒ˜ğ£º‹ğ¦¶£ğ¦¬…ğ¦®—ğ£—ã¶¿èŒå—¬è…ä”‹ğ¦¶¥è¬èè“ã‘¾ğ¦»”æ©—è•šã’–ğ¦¹‚ğ¢»¯è‘˜ğ¥¯¤è‘±ã·“ä“¤æª§è‘Šğ£²µç¥˜è’¨ğ¦®–ğ¦¹·ğ¦¹ƒè“èè‘ä’ è’“è“¤ğ¥²‘ä‰€ğ¥³€ä•ƒè”´å«²ğ¦º™ä”§è•³ä”–æ¿è˜–"],
    ["8fa1", "ğ¨˜¥ğ¨˜»è—ğ§‚ˆè˜‚ğ¡–‚ğ§ƒğ¯¦²ä•ªè˜¨ã™ˆğ¡¢¢å·ğ§šè™¾è±ğªƒ¸èŸ®ğ¢°§è±èŸšè å™¡è™¬æ¡–ä˜è¡…è¡†ğ§— ğ£¶¹ğ§—¤è¡è¢œä™›è¢´è¢µæè£…ç·ğ§œè¦‡è¦Šè¦¦è¦©è¦§è¦¼ğ¨¨¥è§§ğ§¤¤ğ§ª½èªœç“é‡¾èªğ§©™ç«©ğ§¬ºğ£¾äœ“ğ§¬¸ç…¼è¬Œè¬Ÿğ¥°ğ¥•¥è¬¿è­Œè­èª©ğ¤©ºè®è®›èª¯ğ¡›Ÿä˜•è¡è²›ğ§µ”ğ§¶ğ¯§”ãœ¥ğ§µ“è³–ğ§¶˜ğ§¶½è´’è´ƒğ¡¤è³›çœè´‘ğ¤³‰ã»èµ·"],
    ["9040", "è¶©ğ¨€‚ğ¡€”ğ¤¦Šã­¼ğ¨†¼ğ§„Œç«§èº­èº¶è»ƒé‹”è¼™è¼­ğ¨¥ğ¨’è¾¥éŒƒğªŠŸğ ©è¾³ä¤ªğ¨§ğ¨”½ğ£¶»å»¸ğ£‰¢è¿¹ğª€”ğ¨š¼ğ¨”ğ¢Œ¥ã¦€ğ¦»—é€·ğ¨”¼ğ§ª¾é¡ğ¨•¬ğ¨˜‹é‚¨ğ¨œ“éƒ„ğ¨›¦é‚®éƒ½é…§ã«°é†©é‡„ç²¬ğ¨¤³ğ¡º‰éˆæ²Ÿé‰é‰¢ğ¥–¹éŠ¹ğ¨«†ğ£²›ğ¨¬Œğ¥—›"],
    ["90a1", "ğ ´±éŒ¬é«ğ¨«¡ğ¨¯«ç‚å«ƒğ¨«¢ğ¨«¥ä¥¥é‰„ğ¨¯¬ğ¨°¹ğ¨¯¿é³é‘›èº¼é–…é–¦é¦é– æ¿¶äŠ¹ğ¢™ºğ¨›˜ğ¡‰¼ğ£¸®ä§Ÿæ°œé™»éš–ä…¬éš£ğ¦»•æ‡šéš¶ç£µğ¨« éš½åŒä¦¡ğ¦²¸ğ ‰´ğ¦ğ©‚¯ğ©ƒ¥ğ¤«‘ğ¡¤•ğ£ŒŠéœ±è™‚éœ¶ä¨ä”½ä–…ğ¤«©çµå­éœ›éœğ©‡•é—å­Šğ©‡«éŸé¥åƒğ£‚·ğ£‚¼é‰éŸé±é¾éŸ€éŸ’éŸ ğ¥‘¬éŸ®çœğ©³éŸ¿éŸµğ©ğ§¥ºä«‘é ´é ³é¡‹é¡¦ã¬ğ§…µãµ‘ğ ˜°ğ¤…œ"],
    ["9140", "ğ¥œ†é£Šé¢·é£ˆé£‡ä«¿ğ¦´§ğ¡›“å–°é£¡é£¦é£¬é¸é¤¹ğ¤¨©ä­²ğ©¡—ğ©¤…é§µé¨Œé¨»é¨é©˜ğ¥œ¥ã›„ğ©‚±ğ©¯•é« é«¢ğ©¬…é«´ä°é¬”é¬­ğ¨˜€å€´é¬´ğ¦¦¨ã£ƒğ£½é­é­€ğ©´¾å©…ğ¡¡£é®ğ¤‰‹é°‚é¯¿é°Œğ©¹¨é·”ğ©¾·ğª†’ğª†«ğªƒ¡ğª„£ğª‡Ÿéµ¾é¶ƒğª„´é¸æ¢ˆ"],
    ["91a1", "é·„ğ¢…›ğª†“ğªˆ ğ¡¤»ğªˆ³é´¹ğª‚¹ğªŠ´éºéº•éºéº¢ä´´éºªéº¯ğ¤¤é»ã­ ã§¥ã´ä¼²ã¾ğ¨°«é¼‚é¼ˆä®–é¤ğ¦¶¢é¼—é¼–é¼¹åšŸåšŠé½…é¦¸ğ©‚‹éŸ²è‘¿é½¢é½©ç«œé¾çˆ–ä®¾ğ¤¥µğ¤¦»ç…·ğ¤§¸ğ¤ˆğ¤©‘çğ¨¯šğ¡£ºç¦Ÿğ¨¥¾ğ¨¸¶é©é³ğ¨©„é‹¬éé‹ğ¨¥¬ğ¤’¹çˆ—ã»«ç²ç©ƒçƒğ¤‘³ğ¤¸ç…¾ğ¡Ÿ¯ç‚£ğ¡¢¾ğ£–™ã»‡ğ¡¢…ğ¥¯ğ¡Ÿ¸ãœ¢ğ¡›»ğ¡ ¹ã›¡ğ¡´ğ¡£‘ğ¥½‹ãœ£ğ¡›€å›ğ¤¨¥ğ¡¾ğ¡Š¨"],
    ["9240", "ğ¡†ğ¡’¶è”ƒğ£š¦è”ƒè‘•ğ¤¦”ğ§…¥ğ£¸±ğ¥•œğ£»»ğ§’ä“´ğ£›®ğ©¦ğ¦¼¦æŸ¹ãœ³ã°•ã·§å¡¬ğ¡¤¢æ ä—ğ£œ¿ğ¤ƒ¡ğ¤‚‹ğ¤„ğ¦°¡å“‹åšğ¦š±åš’ğ ¿Ÿğ ®¨ğ ¸é†ğ¨¬“éœä»¸å„«ã ™ğ¤¶äº¼ğ ‘¥ğ ¿ä½‹ä¾Šğ¥™‘å©¨ğ †«ğ ‹ã¦™ğ ŒŠğ ”ãµä¼©ğ ‹€ğ¨º³ğ ‰µè«šğ ˆŒäº˜"],
    ["92a1", "åƒå„ä¾¢ä¼ƒğ¤¨ğ£ºŠä½‚å€®å¬å‚ä¿Œä¿¥å˜åƒ¼å…™å…›å…å…æ¹¶ğ£–•ğ£¸¹ğ£º¿æµ²ğ¡¢„ğ£º‰å†¨å‡ƒğ — ä“ğ ’£ğ ’’ğ ’‘èµºğ¨ªœğ œå‰™åŠ¤ğ ¡³å‹¡é®ä™ºç†Œğ¤Œğ ° ğ¤¦¬ğ¡ƒ¤æ§‘ğ ¸ç‘¹ã»ç’™ç”ç‘–ç˜ä®ğ¤ª¼ğ¤‚åã–„çˆğ¤ƒ‰å–´ğ …å“ğ ¯†åœé‰é›´é¦åŸåå¿ã˜¾å£‹åª™ğ¨©†ğ¡›ºğ¡¯ğ¡œå¨¬å¦¸éŠå©¾å«å¨’ğ¥¥†ğ¡§³ğ¡¡¡ğ¤Š•ã›µæ´…ç‘ƒå¨¡ğ¥ºƒ"],
    ["9340", "åªğ¨¯—ğ “é ç’Œğ¡Œƒç„…ä¥²éˆğ¨§»é½ã å°å²å¹å¹ˆğ¡¦–ğ¡¥¼ğ£«®å»å­ğ¡¤ƒğ¡¤„ãœğ¡¢ ã›ğ¡›¾ã›“è„ªğ¨©‡ğ¡¶ºğ£‘²ğ¨¦¨å¼Œå¼ğ¡¤§ğ¡«å©«ğ¡œ»å­„è˜”ğ§—½è¡ æ¾ğ¢¡ ğ¢˜«å¿›ãº¸ğ¢–¯ğ¢–¾ğ©‚ˆğ¦½³æ‡€ğ €¾ğ †ğ¢˜›æ†™æ†˜æµğ¢²›ğ¢´‡ğ¤›”ğ©…"],
    ["93a1", "æ‘±ğ¤™¥ğ¢­ªã¨©ğ¢¬¢ğ£‘ğ©£ªğ¢¹¸æŒ·ğª‘›æ’¶æŒ±æ‘ğ¤§£ğ¢µ§æŠ¤ğ¢²¡æ»æ•«æ¥²ã¯´ğ£‚ğ£Š­ğ¤¦‰ğ£Š«å”ğ£‹ ğ¡£™ğ©¿æ›ğ£Š‰ğ£†³ã« ä†ğ¥–„ğ¨¬¢ğ¥–ğ¡›¼ğ¥•›ğ¥¥ç£®ğ£„ƒğ¡ ªğ£ˆ´ã‘¤ğ£ˆğ£†‚ğ¤‹‰æšğ¦´¤æ™«ä®“æ˜°ğ§¡°ğ¡·«æ™£ğ£‹’ğ£‹¡æ˜ğ¥¡²ã£‘ğ£ ºğ£¼ã®™ğ£¢ğ£¾ç“ã®–æğ¤˜ªæ¢¶æ ã¯„æª¾ã¡£ğ£Ÿ•ğ¤’‡æ¨³æ©’æ«‰æ¬…ğ¡¤’æ”‘æ¢˜æ©Œã¯—æ©ºæ­—ğ£¿€ğ£²šé é‹²ğ¨¯ªğ¨«‹"],
    ["9440", "éŠ‰ğ¨€ğ¨§œé‘§æ¶¥æ¼‹ğ¤§¬æµ§ğ£½¿ã¶æ¸„ğ¤€¼å¨½æ¸Šå¡‡æ´¤ç¡‚ç„»ğ¤Œšğ¤‰¶çƒ±ç‰çŠ‡çŠ”ğ¤ğ¤œ¥å…¹ğ¤ª¤ğ —«ç‘ºğ£»¸ğ£™Ÿğ¤©Šğ¤¤—ğ¥¿¡ã¼†ãº±ğ¤«Ÿğ¨°£ğ£¼µæ‚§ã»³ç“Œç¼é‡ç·ä’Ÿğ¦·ªä•‘ç–ƒã½£ğ¤³™ğ¤´†ã½˜ç••ç™³ğª—†ã¬™ç‘¨ğ¨«Œğ¤¦«ğ¤¦ã«»"],
    ["94a1", "ã·ğ¤©ã»¿ğ¤§…ğ¤£³é‡ºåœ²é‚ğ¨«£ğ¡¡¤åƒŸğ¥ˆ¡ğ¥‡§ç¸ğ£ˆ²çœçœç»ğ¤š—ğ£ã©ğ¤£°ç¸ç’›ãº¿ğ¤ªºğ¤«‡äƒˆğ¤ª–ğ¦†®éŒ‡ğ¥–ç ç¢ç¢ˆç£’çç¥™ğ§ğ¥›£ä„ç¦›è’–ç¦¥æ¨­ğ£»ºç¨ºç§´ä…®ğ¡›¦ä„²éˆµç§±ğ µŒğ¤¦Œğ Š™ğ£¶ºğ¡®ã–—å•«ã•°ãšªğ ‡”ğ °ç«¢å©™ğ¢›µğ¥ª¯ğ¥ªœå¨ğ ‰›ç£°å¨ªğ¥¯†ç«¾ä‡¹ç±ç±­äˆ‘ğ¥®³ğ¥º¼ğ¥º¦ç³ğ¤§¹ğ¡°ç²ç±¼ç²®æª²ç·œç¸‡ç·“ç½ğ¦‰¡"],
    ["9540", "ğ¦…œğ§­ˆç¶—ğ¥º‚ä‰ªğ¦­µğ ¤–æŸ–ğ ğ£—åŸ„ğ¦’ğ¦¸ğ¤¥¢ç¿ç¬§ğ  ¬ğ¥«©ğ¥µƒç¬Œğ¥¸é§¦è™…é©£æ¨œğ£¿ã§¢ğ¤§·ğ¦–­é¨Ÿğ¦– è’€ğ§„§ğ¦³‘ä“ªè„·ä‚èƒ†è„‰è…‚ğ¦´é£ƒğ¦©‚è‰¢è‰¥ğ¦©‘è‘“ğ¦¶§è˜ğ§ˆ›åª†ä…¿ğ¡¡€å¬«ğ¡¢¡å«¤ğ¡£˜èš ğ¯¦¼ğ£¶è ­ğ§¢å¨‚"],
    ["95a1", "è¡®ä½…è¢‡è¢¿è£¦è¥¥è¥ğ¥šƒè¥”ğ§…ğ§„ğ¨¯µğ¨¯™ğ¨®œğ¨§¹ãº­è’£ä›µä›ãŸ²è¨½è¨œğ©‘ˆå½éˆ«ğ¤Š„æ—”ç„©çƒ„ğ¡¡…éµ­è²Ÿè³©ğ§·œå¦šçŸƒå§°ä®ã›”è¸ªèº§ğ¤°‰è¼°è½Šä‹´æ±˜æ¾»ğ¢Œ¡ä¢›æ½¹æº‹ğ¡Ÿšé¯©ãšµğ¤¤¯é‚»é‚—å•±ä¤†é†»é„ğ¨©‹ä¢ğ¨«¼é§ğ¨°ğ¨°»è“¥è¨«é–™é–§é–—é––ğ¨´´ç‘…ã»‚ğ¤£¿ğ¤©‚ğ¤ªã»§ğ£ˆ¥éšğ¨»§ğ¨¹¦ğ¨¹¥ã»Œğ¤§­ğ¤©¸ğ£¿®ç’ç‘«ã»¼éğ©‚°"],
    ["9640", "æ¡‡ä¨ğ©‚“ğ¥ŸŸéé¨ğ¨¦‰ğ¨°¦ğ¨¬¯ğ¦¾éŠºå¬‘è­©ä¤¼ç¹ğ¤ˆ›é›é±é¤¸ğ ¼¦å·ğ¨¯…ğ¤ª²é Ÿğ©“šé‹¶ğ©——é‡¥ä“€ğ¨­ğ¤©§ğ¨­¤é£œğ¨©…ã¼€éˆªä¤¥è”é¤»é¥ğ§¬†ã·½é¦›ä­¯é¦ªé©œğ¨­¥ğ¥£ˆæªé¨¡å«¾é¨¯ğ©£±ä®ğ©¥ˆé¦¼ä®½ä®—é½å¡²ğ¡Œ‚å ¢ğ¤¦¸"],
    ["96a1", "ğ¡“¨ç¡„ğ¢œŸğ£¶¸æ£…ãµ½é‘˜ã¤§æ…ğ¢ğ¢¥«æ„‡é±é±“é±»é°µé°é­¿é¯ğ©¸­é®Ÿğª‡µğªƒ¾é´¡ä²®ğ¤„„é¸˜ä²°é´Œğª†´ğªƒ­ğªƒ³ğ©¤¯é¶¥è’½ğ¦¸’ğ¦¿Ÿğ¦®‚è—¼ä”³ğ¦¶¤ğ¦º„ğ¦·°è è—®ğ¦¸€ğ£Ÿ—ğ¦¤ç§¢ğ£–œğ£™€ä¤­ğ¤§ãµ¢é›éŠ¾éˆğ Š¿ç¢¹é‰·é‘ä¿¤ã‘€é¤ğ¥•ç ½ç¡”ç¢¶ç¡‹ğ¡—ğ£‡‰ğ¤¥ãššä½²æ¿šæ¿™ç€ç€å”ğ¤†µå»å£³åŠé´–åŸ—ç„´ã’¯ğ¤†¬ç‡«ğ¦±€ğ¤¾—å¬¨ğ¡µğ¨©‰"],
    ["9740", "æ„Œå«å¨‹äŠ¼ğ¤’ˆãœ¬ä­»ğ¨§¼é»é¸ğ¡£–ğ ¼è‘²ğ¦³€ğ¡“ğ¤‹ºğ¢°¦ğ¤å¦”ğ£¶·ğ¦ç¶¨ğ¦…›ğ¦‚¤ğ¤¦¹ğ¤¦‹ğ¨§ºé‹¥ç¢ã»©ç’´ğ¨­£ğ¡¢Ÿã»¡ğ¤ª³æ«˜ç³ç»ã»–ğ¤¨¾ğ¤ª”ğ¡Ÿ™ğ¤©¦ğ §ğ¡¤ğ¤§¥ç‘ˆğ¤¤–ç‚¥ğ¤¥¶éŠ„ç¦éŸğ “¾éŒ±ğ¨«ğ¨¨–é†ğ¨¯§ğ¥—•ä¤µğ¨ª‚ç…«"],
    ["97a1", "ğ¤¥ƒğ ³¿åš¤ğ ˜šğ ¯«ğ ²¸å”‚ç§„ğ¡Ÿºç·¾ğ¡›‚ğ¤©ğ¡¡’ä”®éãœŠğ¨«€ğ¤¦­å¦°ğ¡¢¿ğ¡¢ƒğ§’„åª¡ã›¢ğ£µ›ãš°é‰Ÿå©¹ğ¨ªğ¡¡¢é´ã³ğ ª´äª–ã¦Šåƒ´ãµ©ãµŒğ¡œç…µä‹»ğ¨ˆ˜æ¸ğ©ƒ¤ä“«æµ—ğ§¹ç§æ²¯ã³–ğ£¿­ğ£¸­æ¸‚æ¼Œãµ¯ğ µç•‘ãš¼ã“ˆäš€ã»šä¡±å§„é‰®ä¤¾è½ğ¨°œğ¦¯€å ’åŸˆã›–ğ¡‘’çƒ¾ğ¤¢ğ¤©±ğ¢¿£ğ¡Š°ğ¢½æ¢¹æ¥§ğ¡˜ğ£“¥ğ§¯´ğ£›Ÿğ¨ªƒğ£Ÿ–ğ£ºğ¤²Ÿæ¨šğ£š­ğ¦²·è¾ä“Ÿä“"],
    ["9840", "ğ¦´¦ğ¦µ‘ğ¦²‚ğ¦¿æ¼—ğ§„‰èŒ½ğ¡œºè­ğ¦²€ğ§“ğ¡Ÿ›å¦‰åª‚ğ¡³å©¡å©±ğ¡¤…ğ¤‡¼ãœ­å§¯ğ¡œ¼ã›‡ç†éæššğ¤Š¥å©®å¨«ğ¤Š“æ¨«ğ£»¹ğ§œ¶ğ¤‘›ğ¤‹Šç„ğ¤‰™ğ¨§¡ä¾°ğ¦´¨å³‚ğ¤“ğ§¹ğ¤½æ¨Œğ¤‰–ğ¡Œ„ç‚¦ç„³ğ¤©ã¶¥æ³Ÿğ¯ ¥ğ¤©ç¹¥å§«å´¯ã·³å½œğ¤©ğ¡ŸŸç¶¤è¦"],
    ["98a1", "å’…ğ£«ºğ£Œ€ğ ˆ”å¾ğ £•ğ ˜™ã¿¥ğ¡¾ğªŠ¶ç€ƒğ©…›åµ°çç³“ğ¨©™ğ© ä¿ˆç¿§ç‹çŒğ§«´çŒ¸çŒ¹ğ¥›¶ççˆãº©ğ§¬˜é¬ç‡µğ¤£²ç¡è‡¶ã»ŠçœŒã»‘æ²¢å›½ç™ççŸã»¢ã»°ã»´ã»ºç““ã¼ã½“ç•‚ç•­ç•²ç–ã½¼ç—ˆç—œã¿€ç™ã¿—ç™´ã¿œç™ºğ¤½œç†ˆå˜£è¦€å¡©ä€çƒä€¹æ¡ä…ã—›ç˜äªä¯å±ç¾çŸ‹å£²ç ˜ç‚¹ç œä‚¨ç ¹ç¡‡ç¡‘ç¡¦è‘ˆğ¥”µç¤³æ ƒç¤²ä„ƒ"],
    ["9940", "ä„‰ç¦‘ç¦™è¾»ç¨†è¾¼ä…§çª‘ä†²çª¼è‰¹ä‡„ç«ç«›ä‡ä¸¡ç­¢ç­¬ç­»ç°’ç°›ä‰ ä‰ºç±»ç²œäŠŒç²¸äŠ”ç³­è¾“çƒ€ğ ³ç·ç·”ç·ç·½ç¾®ç¾´çŠŸä—è€ è€¥ç¬¹è€®è€±è”ã·Œå´ç‚ è‚·èƒ©ä­è„ŒçŒªè„è„’ç• è„”äã¬¹è…–è…™è…š"],
    ["99a1", "ä“å ºè…¼è†„ä¥è†“ä­è†¥åŸ¯è‡è‡¤è‰”ä’èŠ¦è‰¶è‹Šè‹˜è‹¿ä’°è—é™©æ¦Šè…çƒµè‘¤æƒ£è’ˆä”„è’¾è“¡è“¸è”è”¸è•’ä”»è•¯è•°è— ä•·è™²èš’èš²è›¯é™…è‹ä˜†ä˜—è¢®è£¿è¤¤è¥‡è¦‘ğ§¥§è¨©è¨¸èª”èª´è±‘è³”è³²è´œä˜å¡Ÿè·ƒäŸ­ä»®è¸ºå—˜å”è¹±å—µèº°ä ·è»è»¢è»¤è»­è»²è¾·è¿è¿Šè¿Œé€³é§„ä¢­é£ éˆ“ä¤éˆ¨é‰˜é‰«éŠ±éŠ®éŠ¿"],
    ["9a40", "é‹£é‹«é‹³é‹´é‹½éƒé„é­ä¥…ä¥‘éº¿é—åŒéé­é¾ä¥ªé‘”é‘¹é”­é–¢ä¦§é—´é˜³ä§¥æ ä¨¤é€ä¨µé²éŸ‚å™”ä«¤æƒ¨é¢¹ä¬™é£±å¡„é¤é¤™å†´é¤œé¤·é¥‚é¥é¥¢ä­°é§…ä®é¨¼é¬çªƒé­©é®é¯é¯±é¯´ä±­é° ã¯ğ¡¯‚éµ‰é°º"],
    ["9aa1", "é»¾å™é¶“é¶½é·€é·¼é“¶è¾¶é¹»éº¬éº±éº½é»†é“œé»¢é»±é»¸ç«ˆé½„ğ ‚”ğ Š·ğ  æ¤šé“ƒå¦¬ğ “—å¡€é“ã¹ğ —•ğ ˜•ğ ™¶ğ¡šºå—ç…³ğ «‚ğ «ğ ®¿å‘ªğ¯ »ğ ¯‹å’ğ ¯»ğ °»ğ ±“ğ ±¥ğ ±¼æƒ§ğ ²å™ºğ ²µğ ³ğ ³­ğ µ¯ğ ¶²ğ ·ˆæ¥•é°¯è¥ğ ¸„ğ ¸ğ »—ğ ¾ğ ¼­ğ ¹³å° ğ ¾¼å¸‹ğ¡œğ¡ğ¡¶æœğ¡»ğ¡‚ˆğ¡‚–ã™‡ğ¡‚¿ğ¡ƒ“ğ¡„¯ğ¡„»å¤è’­ğ¡‹£ğ¡µğ¡Œ¶è®ğ¡•·ğ¡˜™ğ¡Ÿƒğ¡Ÿ‡ä¹¸ç‚»ğ¡ ­ğ¡¥ª"],
    ["9b40", "ğ¡¨­ğ¡©…ğ¡°ªğ¡±°ğ¡²¬ğ¡»ˆæ‹ƒğ¡»•ğ¡¼•ç†˜æ¡•ğ¢…æ§©ã›ˆğ¢‰¼ğ¢—ğ¢ºğ¢œªğ¢¡±ğ¢¥è‹½ğ¢¥§ğ¢¦“ğ¢«•è¦¥ğ¢«¨è¾ ğ¢¬é¸ğ¢¬¿é¡‡éª½ğ¢±Œ"],
    ["9b62", "ğ¢²ˆğ¢²·ğ¥¯¨ğ¢´ˆğ¢´’ğ¢¶·ğ¢¶•ğ¢¹‚ğ¢½´ğ¢¿Œğ£€³ğ£¦ğ£ŒŸğ£å¾±æ™ˆæš¿ğ§©¹ğ£•§ğ£—³çˆğ¤¦ºçŸ—ğ£˜šğ£œ–çº‡ğ †å¢µæœ"],
    ["9ba1", "æ¤˜ğ£ª§ğ§™—ğ¥¿¢ğ£¸‘ğ£º¹ğ§—¾ğ¢‚šä£äª¸ğ¤„™ğ¨ªšğ¤‹®ğ¤Œğ¤€»ğ¤Œ´ğ¤–ğ¤©…ğ —Šå‡’ğ ˜‘å¦Ÿğ¡º¨ã®¾ğ£³¿ğ¤„ğ¤“–åˆğ¤™´ã¦›ğ¤œ¯ğ¨—¨ğ©§‰ã¢ğ¢‡ƒè­ğ¨­é§–ğ¤ ’ğ¤£»ğ¤¨•çˆ‰ğ¤«€ğ ±¸å¥¥ğ¤º¥ğ¤¾†ğ ¹è»šğ¥€¬åŠåœ¿ç…±ğ¥Š™ğ¥™ğ£½Šğ¤ª§å–¼ğ¥‘†ğ¥‘®ğ¦­’é‡”ã‘³ğ¥”¿ğ§˜²ğ¥•äœ˜ğ¥•¢ğ¥•¦ğ¥Ÿ‡ğ¤¤¿ğ¥¡å¦ã“»ğ£Œæƒğ¥¤ƒä¼ğ¨¥ˆğ¥ª®ğ¥®‰ğ¥°†ğ¡¶å¡ç…‘æ¾¶ğ¦„‚ğ§°’é–ğ¦†²ğ¤¾šè­¢ğ¦‚ğ¦‘Š"],
    ["9c40", "åµ›ğ¦¯·è¼¶ğ¦’„ğ¡¤œè«ªğ¤§¶ğ¦’ˆğ£¿¯ğ¦”’ä¯€ğ¦–¿ğ¦šµğ¢œ›é‘¥ğ¥Ÿ¡æ†•å¨§ğ¯£ä¾»åš¹ğ¤”¡ğ¦›¼ä¹ªğ¤¤´é™–æ¶ğ¦²½ã˜˜è¥·ğ¦™ğ¦¡®ğ¦‘ğ¦¡ç‡Ÿğ¦£‡ç­‚ğ©ƒ€ğ ¨‘ğ¦¤¦é„„ğ¦¤¹ç©…é·°ğ¦§ºé¨¦ğ¦¨­ã™Ÿğ¦‘©ğ €¡ç¦ƒğ¦¨´ğ¦­›å´¬ğ£”™èğ¦®ä›ğ¦²¤ç”»è¡¥ğ¦¶®å¢¶"],
    ["9ca1", "ãœœğ¢–ğ§‹ğ§‡ã±”ğ§Š€ğ§Š…éŠğ¢…ºğ§Š‹éŒ°ğ§‹¦ğ¤§æ°¹é’Ÿğ§‘ğ »¸è §è£µğ¢¤¦ğ¨‘³ğ¡±æº¸ğ¤¨ªğ¡  ã¦¤ãš¹å°ç§£ä”¿æš¶ğ©²­ğ©¢¤è¥ƒğ§ŸŒğ§¡˜å›–äƒŸğ¡˜Šã¦¡ğ£œ¯ğ¨ƒ¨ğ¡…ç†­è¦ğ§§ğ©†¨å©§ä²·ğ§‚¯ğ¨¦«ğ§§½ğ§¨Šğ§¬‹ğ§µ¦ğ¤…ºç­ƒç¥¾ğ¨€‰æ¾µğª‹Ÿæ¨ƒğ¨Œ˜å¢ğ¦¸‡é¿æ ¶éğ¨…¯ğ¨€£ğ¦¦µğ¡­ğ£ˆ¯ğ¨ˆå¶…ğ¨°°ğ¨‚ƒåœ•é £ğ¨¥‰å¶«ğ¤¦ˆæ–¾æ§•å’ğ¤ª¥ğ£¾ã°‘æœ¶ğ¨‚ğ¨ƒ´ğ¨„®ğ¡¾¡ğ¨…"],
    ["9d40", "ğ¨†‰ğ¨†¯ğ¨ˆšğ¨Œ†ğ¨Œ¯ğ¨Šã—Šğ¨‘¨ğ¨šªä£ºæ¦ğ¨¥–ç ˆé‰•ğ¨¦¸ä²ğ¨§§äŸğ¨§¨ğ¨­†ğ¨¯”å§¸ğ¨°‰è¼‹ğ¨¿…ğ©ƒ¬ç­‘ğ©„ğ©„¼ã··ğ©…ğ¤«Šè¿çŠåš‹ğ©“§ğ©—©ğ©–°ğ©–¸ğ©œ²ğ©£‘ğ©¥‰ğ©¥ªğ©§ƒğ©¨¨ğ©¬ğ©µšğ©¶›çºŸğ©»¸ğ©¼£ä²¤é•‡ğªŠ“ç†¢ğª‹¿ä¶‘é€’ğª—‹ä¶œğ ²œè¾¾å—"],
    ["9da1", "è¾ºğ¢’°è¾¹ğ¤ª“ä”‰ç¹¿æ½–æª±ä»ªã“¤ğ¨¬¬ğ§¢ãœºèº€ğ¡Ÿµğ¨€¤ğ¨­¬ğ¨®™ğ§¨¾ğ¦š¯ã·«ğ§™•ğ£²·ğ¥˜µğ¥¥–äºšğ¥ºğ¦‰˜åš¿ğ ¹­è¸å­­ğ£ºˆğ¤²ææ‹ğ¡Ÿ¶ğ¡¡»æ”°å˜­ğ¥±Šåšğ¥Œ‘ã·†ğ©¶˜ä±½å˜¢å˜ç½‰ğ¥»˜å¥µğ£µ€è°ä¸œğ ¿ªğ µ‰ğ£šºè„—éµè´˜ç˜»é±…ç™ç¹é…å²è…ˆè‹·å˜¥è„²è˜è‚½å—ªç¥¢å™ƒå–ğ ºã—å˜…å—±æ›±ğ¨‹¢ã˜­ç”´å—°å–ºå’—å•²ğ ±ğ ²–å»ğ¥…ˆğ ¹¶ğ¢±¢"],
    ["9e40", "ğ º¢éº«çµšå—ğ¡µæŠé­å’”è³ç‡¶é…¶æ¼æ¹æ¾å•©ğ¢­ƒé±²ğ¢º³å†šã“Ÿğ ¶§å†§å‘å”å”“ç™¦è¸­ğ¦¢Šç–±è‚¶è „è†è£‡è†¶èœğ¡ƒä“¬çŒ„ğ¤œ†å®èŒ‹ğ¦¢“å™»ğ¢›´ğ§´¯ğ¤†£ğ§µ³ğ¦»ğ§Š¶é…°ğ¡‡™éˆˆğ£³¼ğªš©ğ º¬ğ »¹ç‰¦ğ¡²¢äğ¤¿‚ğ§¿¹ğ ¿«äƒº"],
    ["9ea1", "é±æ”Ÿğ¢¶ ä£³ğ¤Ÿ ğ©µ¼ğ ¿¬ğ ¸Šæ¢ğ§–£ğ ¿­"],
    ["9ead", "ğ¦ˆğ¡†‡ç†£çºéµä¸šä¸„ã•·å¬æ²²å§ãš¬ã§œå½ãš¥ğ¤˜˜å¢šğ¤­®èˆ­å‘‹åªğ¥ª•ğ ¥¹"],
    ["9ec5", "ã©’ğ¢‘¥ç´ğ©º¬ä´‰é¯­ğ£³¾ğ©¼°ä±›ğ¤¾©ğ©–ğ©¿è‘œğ£¶¶ğ§Š²ğ¦³ğ£œ æŒ®ç´¥ğ£»·ğ£¸¬ã¨ªé€ˆå‹Œã¹´ã™ºä—©ğ ’ç™€å«°ğ º¶ç¡ºğ§¼®å¢§ä‚¿å™¼é®‹åµ´ç™”ğª´éº…ä³¡ç—¹ãŸ»æ„™ğ£ƒšğ¤²"],
    ["9ef5", "å™ğ¡Š©å§ğ¤¥£ğ©¸†åˆ´ğ§‚®ã–­æ±Šéµ¼"],
    ["9f40", "ç±–é¬¹åŸğ¡¬å±“æ““ğ©“ğ¦Œµğ§…¤èš­ğ ´¨ğ¦´¢ğ¤«¢ğ µ±"],
    ["9f4f", "å‡¾ğ¡¼å¶éœƒğ¡·‘éºéŒç¬Ÿé¬‚å³‘ç®£æ‰¨æŒµé«¿ç¯é¬ªç±¾é¬®ç±‚ç²†é°•ç¯¼é¬‰é¼—é°›ğ¤¤¾é½šå•³å¯ƒä¿½éº˜ä¿²å‰ ã¸†å‹‘å§å–å¦·å¸’éŸˆé¶«è½œå‘©é´é¥€éºåŒ¬æ„°"],
    ["9fa1", "æ¤¬åšé°Šé´‚ä°»é™æ¦€å‚¦ç•†ğ¡­é§šå‰³"],
    ["9fae", "é…™éšé…œ"],
    ["9fb2", "é…‘ğ¨º—æ¿ğ¦´£æ«Šå˜‘é†ç•ºæŠ…ğ ¼çç±°ğ¥°¡ğ£³½"],
    ["9fc1", "ğ¤¤™ç›–é®ä¸ªğ ³”è¾è¡‚"],
    ["9fc9", "å±Šæ§€åƒ­åºåˆŸå·µä»æ°±ğ ‡²ä¼¹å’œå“šåŠšè¶‚ã—¾å¼Œã—³"],
    ["9fdb", "æ­’é…¼é¾¥é®—é ®é¢´éªºéº¨éº„ç…ºç¬”"],
    ["9fe7", "æ¯ºè ˜ç½¸"],
    ["9feb", "å˜ ğª™Šè¹·é½“"],
    ["9ff0", "è·”è¹é¸œè¸æŠ‚ğ¨½è¸¨è¹µç«“ğ¤©·ç¨¾ç£˜æ³ªè©§ç˜‡"],
    ["a040", "ğ¨©šé¼¦æ³èŸ–ç—ƒğªŠ²ç¡“ğ¯¡€è´Œç‹¢ç±è¬­çŒ‚ç“±è³«ğ¤ª»è˜¯å¾ºè¢ ä’·"],
    ["a055", "ğ¡ »ğ¦¸…"],
    ["a058", "è©¾ğ¢”›"],
    ["a05b", "æƒ½ç™§é«—éµ„é®é®èŸµ"],
    ["a063", "è è³·çŒ¬éœ¡é®°ã—–çŠ²ä°‡ç±‘é¥Šğ¦…™æ…™ä°„éº–æ…½"],
    ["a073", "åŸæ…¯æŠ¦æˆ¹æ‹ã©œæ‡¢åªğ£µæ¤æ ‚ã—’"],
    ["a0a1", "åµ—ğ¨¯‚è¿šğ¨¸¹"],
    ["a0a6", "åƒ™ğ¡µ†ç¤†åŒ²é˜¸ğ ¼»ä¥"],
    ["a0ae", "çŸ¾"],
    ["a0b0", "ç³‚ğ¥¼šç³šç¨­è¦è£çµç”…ç“²è¦”èˆšæœŒè¢ğ§’†è›ç“°è„ƒçœ¤è¦‰ğ¦ŸŒç•“ğ¦»‘è©èŸè‡ˆèŒè©‰è²­è­ƒçœ«ç“¸è“šã˜µæ¦²è¶¦"],
    ["a0d4", "è¦©ç‘¨æ¶¹èŸğ¤€‘ç“§ã·›ç…¶æ‚¤æ†œã³‘ç…¢æ·"],
    ["a0e2", "ç½±ğ¨¬­ç‰æƒ©ä­¾åˆ ã°˜ğ£³‡ğ¥»—ğ§™–ğ¥”±ğ¡¥„ğ¡‹¾ğ©¤ƒğ¦·œğ§‚­å³ğ¦†­ğ¨¨ğ£™·ğ ƒ®ğ¦¡†ğ¤¼ä•¢å¬Ÿğ¦Œé½éº¦ğ¦‰«"],
    ["a3c0", "â€", 31, "â¡"],
    ["c6a1", "â‘ ", 9, "â‘´", 9, "â…°", 9, "ä¸¶ä¸¿äº…äº å†‚å†–å†«å‹¹åŒ¸å©å¶å¤Šå®€å·›â¼³å¹¿å»´å½å½¡æ”´æ— ç–’ç™¶è¾µéš¶Â¨Ë†ãƒ½ãƒ¾ã‚ã‚ã€ƒä»ã€…ã€†ã€‡ãƒ¼ï¼»ï¼½âœ½ã", 23],
    ["c740", "ã™", 58, "ã‚¡ã‚¢ã‚£ã‚¤"],
    ["c7a1", "ã‚¥", 81, "Ğ", 5, "ĞĞ–", 4],
    ["c840", "Ğ›", 26, "Ñ‘Ğ¶", 25, "â‡§â†¸â†¹ã‡ğ ƒŒä¹šğ ‚Šåˆ‚ä’‘"],
    ["c8a1", "é¾°å†ˆé¾±ğ§˜‡"],
    ["c8cd", "ï¿¢ï¿¤ï¼‡ï¼‚ãˆ±â„–â„¡ã‚›ã‚œâº€âº„âº†âº‡âºˆâºŠâºŒâºâº•âºœâºâº¥âº§âºªâº¬âº®âº¶âº¼âº¾â»†â»Šâ»Œâ»â»â»–â»—â»â»£"],
    ["c8f5", "ÊƒÉÉ›É”ÉµÅ“Ã¸Å‹ÊŠÉª"],
    ["f9fe", "ï¿­"],
    ["fa40", "ğ •‡é‹›ğ —Ÿğ£¿…è•ŒäŠµç¯å†µã™‰ğ¤¥‚ğ¨§¤é„ğ¡§›è‹®ğ£³ˆç ¼æ„æ‹Ÿğ¤¤³ğ¨¦ªğ Š ğ¦®³ğ¡Œ…ä¾«ğ¢“­å€ˆğ¦´©ğ§ª„ğ£˜€ğ¤ª±ğ¢”“å€©ğ ¾å¾¤ğ €ğ ‡æ»›ğ Ÿå½å„ã‘ºå„é¡¬ãƒè–ğ¤¦¤ğ ’‡å… ğ£´å…ªğ ¯¿ğ¢ƒ¼ğ ‹¥ğ¢”°ğ –ğ£ˆ³ğ¡¦ƒå®‚è½ğ –³ğ£²™å†²å†¸"],
    ["faa1", "é´´å‡‰å‡å‡‘ã³œå‡“ğ¤ª¦å†³å‡¢å‚å‡­èæ¤¾ğ£œ­å½»åˆ‹åˆ¦åˆ¼åŠµå‰—åŠ”åŠ¹å‹…ç°•è•‚å‹ è˜ğ¦¬“åŒ…ğ¨«å•‰æ»™ğ£¾€ğ ¥”ğ£¿¬åŒ³å„ğ ¯¢æ³‹ğ¡œ¦æ ›ç•æŠãºªã£Œğ¡›¨ç‡ä’¢å­å´ğ¨š«å¾å¿ğ¡––ğ¡˜“çŸ¦å“ğ¨ª›å å«å®ç§ğ¥²ã½™çœåå…æ±‰ä¹‰åŸ¾å™ãª«ğ ®å ğ£¿«ğ¢¶£å¶ğ ±·å“ç¹å”«æ™—æµ›å‘­ğ¦­“ğ µ´å•å’å’¤ä¦ğ¡œğ »ã¶´ğ µ"],
    ["fb40", "ğ¨¦¼ğ¢š˜å•‡ä³­å¯ç—å–†å–©å˜…ğ¡£—ğ¤€ºä•’ğ¤µæš³ğ¡‚´å˜·æ›ğ£ŠŠæš¤æš­å™å™ç£±å›±é‡å¾åœ€å›¯å›­ğ¨­¦ã˜£ğ¡‰å†ğ¤†¥æ±®ç‚‹å‚ãš±ğ¦±¾åŸ¦ğ¡–å ƒğ¡‘”ğ¤£å ¦ğ¤¯µå¡œå¢ªã•¡å£ å£œğ¡ˆ¼å£»å¯¿åƒğª…ğ¤‰¸é“ã–¡å¤Ÿæ¢¦ã›ƒæ¹™"],
    ["fba1", "ğ¡˜¾å¨¤å•“ğ¡š’è”…å§‰ğ µğ¦²ğ¦´ªğ¡Ÿœå§™ğ¡Ÿ»ğ¡²ğ¦¶¦æµ±ğ¡ ¨ğ¡›•å§¹ğ¦¹…åª«å©£ã›¦ğ¤¦©å©·ãœˆåª–ç‘¥å«“ğ¦¾¡ğ¢•”ã¶…ğ¡¤‘ãœ²ğ¡š¸åºƒå‹å­¶æ–ˆå­¼ğ§¨ä€„ä¡ğ ˆ„å¯•æ… ğ¡¨´ğ¥§Œğ –¥å¯³å®ä´å°…ğ¡­„å°“çå°”ğ¡²¥ğ¦¬¨å±‰ä£å²…å³©å³¯å¶‹ğ¡·¹ğ¡¸·å´å´˜åµ†ğ¡º¤å²ºå·—è‹¼ã ­ğ¤¤ğ¢‰ğ¢…³èŠ‡ã ¶ã¯‚å¸®æªŠå¹µå¹ºğ¤’¼ğ ³“å¦äº·å»å¨ğ¡±å¸‰å»´ğ¨’‚"],
    ["fc40", "å»¹å»»ã¢ å»¼æ ¾é›å¼ğ ‡ğ¯¢”ã«ä¢®ğ¡Œºå¼ºğ¦¢ˆğ¢å½˜ğ¢‘±å½£é½ğ¦¹®å½²é€ğ¨¨¶å¾§å¶¶ãµŸğ¥‰ğ¡½ªğ§ƒ¸ğ¢™¨é‡–ğ Šğ¨¨©æ€±æš…ğ¡¡·ã¥£ã·‡ã˜¹åğ¢´ç¥±ã¹€æ‚æ‚¤æ‚³ğ¤¦‚ğ¤¦ğ§©“ç’¤åƒ¡åª æ…¤è¤æ…‚ğ¯¢¦ğ¦»’æ†å‡´ğ ™–æ†‡å®ªğ£¾·"],
    ["fca1", "ğ¢¡Ÿæ‡“ğ¨®ğ©¥æ‡ã¤²ğ¢¦€ğ¢£æ€£æ…œæ”æ‹ğ „˜æ‹…ğ¡°æ‹•ğ¢¸æ¬ğ¤§Ÿã¨—æ¸æ¸ğ¡ğ¡Ÿ¼æ’æ¾Šğ¢¸¶é ”ğ¤‚Œğ¥œæ“¡æ“¥é‘»ã©¦æºã©—æ•æ¼–ğ¤¨¨ğ¤¨£æ–…æ•­æ•Ÿğ£¾æ–µğ¤¥€ä¬·æ—‘äƒ˜ğ¡ ©æ— æ—£å¿Ÿğ£€æ˜˜ğ£‡·ğ£‡¸æ™„ğ£†¤ğ£†¥æ™‹ğ ¹µæ™§ğ¥‡¦æ™³æ™´ğ¡¸½ğ£ˆ±ğ¨—´ğ£‡ˆğ¥Œ“çŸ…ğ¢£·é¦¤æœ‚ğ¤œğ¤¨¡ã¬«æ§ºğ£Ÿ‚ææ§æ¢ğ¤‡ğ©ƒ­æŸ—ä“©æ ¢æ¹éˆ¼æ ğ£¦ğ¦¶ æ¡"],
    ["fd40", "ğ£‘¯æ§¡æ¨‹ğ¨«Ÿæ¥³æ£ƒğ£—æ¤æ¤€ã´²ã¨ğ£˜¼ã®€æ¬æ¥¡ğ¨©Šä‹¼æ¤¶æ¦˜ã®¡ğ ‰è£å‚æ§¹ğ£™™ğ¢„ªæ©…ğ£œƒæªã¯³æ±æ«ˆğ©†œã°æ¬ğ ¤£æƒæ¬µæ­´ğ¢Ÿæºµğ£«›ğ µğ¡¥˜ã€å¡ğ£­šæ¯¡ğ£»¼æ¯œæ°·ğ¢’‹ğ¤£±ğ¦­‘æ±šèˆ¦æ±¹ğ£¶¼ä“…ğ£¶½ğ¤†¤ğ¤¤Œğ¤¤€"],
    ["fda1", "ğ£³‰ã›¥ã³«ğ ´²é®ƒğ£‡¹ğ¢’‘ç¾æ ·ğ¦´¥ğ¦¶¡ğ¦·«æ¶–æµœæ¹¼æ¼„ğ¤¥¿ğ¤‚…ğ¦¹²è”³ğ¦½´å‡‡æ²œæ¸è®ğ¨¬¡æ¸¯ğ£¸¯ç‘“ğ£¾‚ç§Œæ¹åª‘ğ£‹æ¿¸ãœæ¾ğ£¸°æ»ºğ¡’—ğ¤€½ä••é°æ½„æ½œãµæ½´ğ©…°ã´»æ¾Ÿğ¤…„æ¿“ğ¤‚‘ğ¤…•ğ¤€¹ğ£¿°ğ£¾´ğ¤„¿å‡Ÿğ¤…–ğ¤…—ğ¤…€ğ¦‡ç‹ç¾ç‚§ç‚çƒŒçƒ•çƒ–çƒŸä„„ã·¨ç†´ç†–ğ¤‰·ç„«ç……åªˆç…Šç…®å²œğ¤¥ç…é¢ğ¤‹ç„¬ğ¤‘šğ¤¨§ğ¤¨¢ç†ºğ¨¯¨ç‚½çˆ"],
    ["fe40", "é‘‚çˆ•å¤‘é‘ƒçˆ¤éğ¥˜…çˆ®ç‰€ğ¤¥´æ¢½ç‰•ç‰—ã¹•ğ£„æ æ¼½çŠ‚çŒªçŒ«ğ¤ £ğ¨ «ä£­ğ¨ „çŒ¨çŒ®ççªğ °ºğ¦¨®ç‰ç‘‰ğ¤‡¢ğ¡›§ğ¤¨¤æ˜£ã›…ğ¤¦·ğ¤¦ğ¤§»ç·ç•æ¤ƒğ¤¨¦ç¹ğ —ƒã»—ç‘œğ¢¢­ç‘ ğ¨º²ç‘‡ç¤ç‘¶è¹ç‘¬ãœ°ç‘´é±æ¨¬ç’‚ä¥“ğ¤ªŒ"],
    ["fea1", "ğ¤…Ÿğ¤©¹ğ¨®å­†ğ¨°ƒğ¡¢ç“ˆğ¡¦ˆç”ç“©ç”ğ¨»™ğ¡©‹å¯—ğ¨º¬é…ç•ç•Šç•§ç•®ğ¤¾‚ã¼„ğ¤´“ç–ç‘ç–ç–´ç˜‚ç˜¬ç™‘ç™ç™¯ç™¶ğ¦µçšè‡¯ãŸ¸ğ¦¤‘ğ¦¤çš¡çš¥çš·ç›Œğ¦¾Ÿè‘¢ğ¥‚ğ¥…½ğ¡¸œçœçœ¦ç€æ’¯ğ¥ˆ ç˜ğ£Š¬ç¯ğ¨¥¤ğ¨¥¨ğ¡›çŸ´ç ‰ğ¡¶ğ¤¨’æ£Šç¢¯ç£‡ç£“éš¥ç¤®ğ¥— ç£—ç¤´ç¢±ğ§˜Œè¾¸è¢„ğ¨¬«ğ¦‚ƒğ¢˜œç¦†è¤€æ¤‚ç¦€ğ¥¡—ç¦ğ§¬¹ç¤¼ç¦©æ¸ªğ§„¦ãº¨ç§†ğ©„ç§”"]
  ];
});

// node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = __commonJS((exports, module) => {
  "use strict";
  module.exports = {
    shiftjis: {
      type: "_dbcs",
      table: function() {
        return require_shiftjis();
      },
      encodeAdd: {"Â¥": 92, "â€¾": 126},
      encodeSkipVals: [{from: 60736, to: 63808}]
    },
    csshiftjis: "shiftjis",
    mskanji: "shiftjis",
    sjis: "shiftjis",
    windows31j: "shiftjis",
    ms31j: "shiftjis",
    xsjis: "shiftjis",
    windows932: "shiftjis",
    ms932: "shiftjis",
    "932": "shiftjis",
    cp932: "shiftjis",
    eucjp: {
      type: "_dbcs",
      table: function() {
        return require_eucjp();
      },
      encodeAdd: {"Â¥": 92, "â€¾": 126}
    },
    gb2312: "cp936",
    gb231280: "cp936",
    gb23121980: "cp936",
    csgb2312: "cp936",
    csiso58gb231280: "cp936",
    euccn: "cp936",
    windows936: "cp936",
    ms936: "cp936",
    "936": "cp936",
    cp936: {
      type: "_dbcs",
      table: function() {
        return require_cp936();
      }
    },
    gbk: {
      type: "_dbcs",
      table: function() {
        return require_cp936().concat(require_gbk_added());
      }
    },
    xgbk: "gbk",
    isoir58: "gbk",
    gb18030: {
      type: "_dbcs",
      table: function() {
        return require_cp936().concat(require_gbk_added());
      },
      gb18030: function() {
        return require_gb18030_ranges();
      },
      encodeSkipVals: [128],
      encodeAdd: {"â‚¬": 41699}
    },
    chinese: "gb18030",
    windows949: "cp949",
    ms949: "cp949",
    "949": "cp949",
    cp949: {
      type: "_dbcs",
      table: function() {
        return require_cp949();
      }
    },
    cseuckr: "cp949",
    csksc56011987: "cp949",
    euckr: "cp949",
    isoir149: "cp949",
    korean: "cp949",
    ksc56011987: "cp949",
    ksc56011989: "cp949",
    ksc5601: "cp949",
    windows950: "cp950",
    ms950: "cp950",
    "950": "cp950",
    cp950: {
      type: "_dbcs",
      table: function() {
        return require_cp950();
      }
    },
    big5: "big5hkscs",
    big5hkscs: {
      type: "_dbcs",
      table: function() {
        return require_cp950().concat(require_big5_added());
      },
      encodeSkipVals: [41676]
    },
    cnbig5: "big5hkscs",
    csbig5: "big5hkscs",
    xxbig5: "big5hkscs"
  };
});

// node_modules/iconv-lite/encodings/index.js
var require_encodings = __commonJS((exports, module) => {
  "use strict";
  var modules = [
    require_internal(),
    require_utf32(),
    require_utf16(),
    require_utf7(),
    require_sbcs_codec(),
    require_sbcs_data(),
    require_sbcs_data_generated(),
    require_dbcs_codec(),
    require_dbcs_data()
  ];
  for (var i2 = 0; i2 < modules.length; i2++) {
    var module = modules[i2];
    for (var enc in module)
      if (Object.prototype.hasOwnProperty.call(module, enc))
        exports[enc] = module[enc];
  }
});

// node_modules/iconv-lite/lib/streams.js
var require_streams = __commonJS((exports, module) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  module.exports = function(stream_module) {
    var Transform = stream_module.Transform;
    function IconvLiteEncoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.decodeStrings = false;
      Transform.call(this, options);
    }
    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
      constructor: {value: IconvLiteEncoderStream}
    });
    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
      if (typeof chunk != "string")
        return done(new Error("Iconv encoding stream needs strings as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length)
          this.push(res);
        done();
      } catch (e2) {
        done(e2);
      }
    };
    IconvLiteEncoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length)
          this.push(res);
        done();
      } catch (e2) {
        done(e2);
      }
    };
    IconvLiteEncoderStream.prototype.collect = function(cb) {
      var chunks = [];
      this.on("error", cb);
      this.on("data", function(chunk) {
        chunks.push(chunk);
      });
      this.on("end", function() {
        cb(null, Buffer2.concat(chunks));
      });
      return this;
    };
    function IconvLiteDecoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.encoding = this.encoding = "utf8";
      Transform.call(this, options);
    }
    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
      constructor: {value: IconvLiteDecoderStream}
    });
    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
      if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array))
        return done(new Error("Iconv decoding stream needs buffers as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length)
          this.push(res, this.encoding);
        done();
      } catch (e2) {
        done(e2);
      }
    };
    IconvLiteDecoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length)
          this.push(res, this.encoding);
        done();
      } catch (e2) {
        done(e2);
      }
    };
    IconvLiteDecoderStream.prototype.collect = function(cb) {
      var res = "";
      this.on("error", cb);
      this.on("data", function(chunk) {
        res += chunk;
      });
      this.on("end", function() {
        cb(null, res);
      });
      return this;
    };
    return {
      IconvLiteEncoderStream,
      IconvLiteDecoderStream
    };
  };
});

// node_modules/iconv-lite/lib/index.js
var require_lib = __commonJS((exports, module) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  var bomHandling = require_bom_handling();
  var iconv = module.exports;
  iconv.encodings = null;
  iconv.defaultCharUnicode = "ï¿½";
  iconv.defaultCharSingleByte = "?";
  iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || "");
    var encoder = iconv.getEncoder(encoding, options);
    var res = encoder.write(str);
    var trail = encoder.end();
    return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
  };
  iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === "string") {
      if (!iconv.skipDecodeWarning) {
        console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
        iconv.skipDecodeWarning = true;
      }
      buf = Buffer2.from("" + (buf || ""), "binary");
    }
    var decoder = iconv.getDecoder(encoding, options);
    var res = decoder.write(buf);
    var trail = decoder.end();
    return trail ? res + trail : res;
  };
  iconv.encodingExists = function encodingExists(enc) {
    try {
      iconv.getCodec(enc);
      return true;
    } catch (e2) {
      return false;
    }
  };
  iconv.toEncoding = iconv.encode;
  iconv.fromEncoding = iconv.decode;
  iconv._codecDataCache = {};
  iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
      iconv.encodings = require_encodings();
    var enc = iconv._canonicalizeEncoding(encoding);
    var codecOptions = {};
    while (true) {
      var codec = iconv._codecDataCache[enc];
      if (codec)
        return codec;
      var codecDef = iconv.encodings[enc];
      switch (typeof codecDef) {
        case "string":
          enc = codecDef;
          break;
        case "object":
          for (var key in codecDef)
            codecOptions[key] = codecDef[key];
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          enc = codecDef.type;
          break;
        case "function":
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          codec = new codecDef(codecOptions, iconv);
          iconv._codecDataCache[codecOptions.encodingName] = codec;
          return codec;
        default:
          throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
      }
    }
  };
  iconv._canonicalizeEncoding = function(encoding) {
    return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
  };
  iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
    if (codec.bomAware && options && options.addBOM)
      encoder = new bomHandling.PrependBOM(encoder, options);
    return encoder;
  };
  iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
    if (codec.bomAware && !(options && options.stripBOM === false))
      decoder = new bomHandling.StripBOM(decoder, options);
    return decoder;
  };
  iconv.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
    if (iconv.supportsStreams)
      return;
    var streams = require_streams()(stream_module2);
    iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
    iconv.encodeStream = function encodeStream(encoding, options) {
      return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    };
    iconv.decodeStream = function decodeStream(encoding, options) {
      return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    };
    iconv.supportsStreams = true;
  };
  var stream_module;
  try {
    stream_module = require("stream");
  } catch (e2) {
  }
  if (stream_module && stream_module.Transform) {
    iconv.enableStreamingAPI(stream_module);
  } else {
    iconv.encodeStream = iconv.decodeStream = function() {
      throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
    };
  }
  if (false) {
    console.error("iconv-lite warning: js files use non-utf8 encoding. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.");
  }
});

// node_modules/encoding/lib/encoding.js
var require_encoding = __commonJS((exports, module) => {
  "use strict";
  var iconvLite = require_lib();
  module.exports.convert = convert;
  function convert(str, to2, from) {
    from = checkEncoding(from || "UTF-8");
    to2 = checkEncoding(to2 || "UTF-8");
    str = str || "";
    var result;
    if (from !== "UTF-8" && typeof str === "string") {
      str = Buffer.from(str, "binary");
    }
    if (from === to2) {
      if (typeof str === "string") {
        result = Buffer.from(str);
      } else {
        result = str;
      }
    } else {
      try {
        result = convertIconvLite(str, to2, from);
      } catch (E2) {
        console.error(E2);
        result = str;
      }
    }
    if (typeof result === "string") {
      result = Buffer.from(result, "utf-8");
    }
    return result;
  }
  function convertIconvLite(str, to2, from) {
    if (to2 === "UTF-8") {
      return iconvLite.decode(str, from);
    } else if (from === "UTF-8") {
      return iconvLite.encode(str, to2);
    } else {
      return iconvLite.encode(iconvLite.decode(str, from), to2);
    }
  }
  function checkEncoding(name) {
    return (name || "").toString().trim().replace(/^latin[\-_]?(\d+)$/i, "ISO-8859-$1").replace(/^win(?:dows)?[\-_]?(\d+)$/i, "WINDOWS-$1").replace(/^utf[\-_]?(\d+)$/i, "UTF-$1").replace(/^ks_c_5601\-1987$/i, "CP949").replace(/^us[\-_]?ascii$/i, "ASCII").toUpperCase();
  }
});

// node_modules/node-fetch/lib/index.es.js
var require_index_es = __commonJS((exports) => {
  __export(exports, {
    FetchError: () => FetchError,
    Headers: () => Headers,
    Request: () => Request,
    Response: () => Response,
    default: () => index_es_default
  });
  const BUFFER = Symbol("buffer");
  const TYPE = Symbol("type");
  class Blob2 {
    constructor() {
      this[TYPE] = "";
      const blobParts = arguments[0];
      const options = arguments[1];
      const buffers = [];
      if (blobParts) {
        const a2 = blobParts;
        const length = Number(a2.length);
        for (let i2 = 0; i2 < length; i2++) {
          const element = a2[i2];
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob2) {
            buffer = element[BUFFER];
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          buffers.push(buffer);
        }
      }
      this[BUFFER] = Buffer.concat(buffers);
      let type = options && options.type !== void 0 && String(options.type).toLowerCase();
      if (type && !/[^\u0020-\u007E]/.test(type)) {
        this[TYPE] = type;
      }
    }
    get size() {
      return this[BUFFER].length;
    }
    get type() {
      return this[TYPE];
    }
    slice() {
      const size = this.size;
      const start = arguments[0];
      const end = arguments[1];
      let relativeStart, relativeEnd;
      if (start === void 0) {
        relativeStart = 0;
      } else if (start < 0) {
        relativeStart = Math.max(size + start, 0);
      } else {
        relativeStart = Math.min(start, size);
      }
      if (end === void 0) {
        relativeEnd = size;
      } else if (end < 0) {
        relativeEnd = Math.max(size + end, 0);
      } else {
        relativeEnd = Math.min(end, size);
      }
      const span = Math.max(relativeEnd - relativeStart, 0);
      const buffer = this[BUFFER];
      const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
      const blob = new Blob2([], {type: arguments[2]});
      blob[BUFFER] = slicedBuffer;
      return blob;
    }
  }
  Object.defineProperties(Blob2.prototype, {
    size: {enumerable: true},
    type: {enumerable: true},
    slice: {enumerable: true}
  });
  Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
    value: "Blob",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function FetchError(message, type, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type;
    if (systemError) {
      this.code = this.errno = systemError.code;
    }
    Error.captureStackTrace(this, this.constructor);
  }
  FetchError.prototype = Object.create(Error.prototype);
  FetchError.prototype.constructor = FetchError;
  FetchError.prototype.name = "FetchError";
  const Stream = require("stream");
  var _require = require("stream");
  const PassThrough = _require.PassThrough;
  let convert;
  try {
    convert = require_encoding().convert;
  } catch (e2) {
  }
  const INTERNALS = Symbol("Body internals");
  function Body(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === void 0 ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
    if (body == null) {
      body = null;
    } else if (typeof body === "string") {
    } else if (isURLSearchParams(body)) {
    } else if (body instanceof Blob2) {
    } else if (Buffer.isBuffer(body)) {
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    } else if (body instanceof Stream) {
    } else {
      body = String(body);
    }
    this[INTERNALS] = {
      body,
      disturbed: false,
      error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof Stream) {
      body.on("error", function(err) {
        _this[INTERNALS].error = new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
      });
    }
  }
  Body.prototype = {
    get body() {
      return this[INTERNALS].body;
    },
    get bodyUsed() {
      return this[INTERNALS].disturbed;
    },
    arrayBuffer() {
      return consumeBody.call(this).then(function(buf) {
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      });
    },
    blob() {
      let ct2 = this.headers && this.headers.get("content-type") || "";
      return consumeBody.call(this).then(function(buf) {
        return Object.assign(new Blob2([], {
          type: ct2.toLowerCase()
        }), {
          [BUFFER]: buf
        });
      });
    },
    json() {
      var _this2 = this;
      return consumeBody.call(this).then(function(buffer) {
        try {
          return JSON.parse(buffer.toString());
        } catch (err) {
          return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
        }
      });
    },
    text() {
      return consumeBody.call(this).then(function(buffer) {
        return buffer.toString();
      });
    },
    buffer() {
      return consumeBody.call(this);
    },
    textConverted() {
      var _this3 = this;
      return consumeBody.call(this).then(function(buffer) {
        return convertBody(buffer, _this3.headers);
      });
    }
  };
  Object.defineProperties(Body.prototype, {
    body: {enumerable: true},
    bodyUsed: {enumerable: true},
    arrayBuffer: {enumerable: true},
    blob: {enumerable: true},
    json: {enumerable: true},
    text: {enumerable: true}
  });
  Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)) {
      if (!(name in proto)) {
        const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
        Object.defineProperty(proto, name, desc);
      }
    }
  };
  function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
      return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
      return Body.Promise.reject(this[INTERNALS].error);
    }
    if (this.body === null) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    if (typeof this.body === "string") {
      return Body.Promise.resolve(Buffer.from(this.body));
    }
    if (this.body instanceof Blob2) {
      return Body.Promise.resolve(this.body[BUFFER]);
    }
    if (Buffer.isBuffer(this.body)) {
      return Body.Promise.resolve(this.body);
    }
    if (Object.prototype.toString.call(this.body) === "[object ArrayBuffer]") {
      return Body.Promise.resolve(Buffer.from(this.body));
    }
    if (!(this.body instanceof Stream)) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve, reject) {
      let resTimeout;
      if (_this4.timeout) {
        resTimeout = setTimeout(function() {
          abort = true;
          reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
        }, _this4.timeout);
      }
      _this4.body.on("error", function(err) {
        reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
      });
      _this4.body.on("data", function(chunk) {
        if (abort || chunk === null) {
          return;
        }
        if (_this4.size && accumBytes + chunk.length > _this4.size) {
          abort = true;
          reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
          return;
        }
        accumBytes += chunk.length;
        accum.push(chunk);
      });
      _this4.body.on("end", function() {
        if (abort) {
          return;
        }
        clearTimeout(resTimeout);
        try {
          resolve(Buffer.concat(accum));
        } catch (err) {
          reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
        }
      });
    });
  }
  function convertBody(buffer, headers) {
    if (typeof convert !== "function") {
      throw new Error("The package `encoding` must be installed to use the textConverted() function");
    }
    const ct2 = headers.get("content-type");
    let charset = "utf-8";
    let res, str;
    if (ct2) {
      res = /charset=([^;]*)/i.exec(ct2);
    }
    str = buffer.slice(0, 1024).toString();
    if (!res && str) {
      res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    if (!res && str) {
      res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
      if (res) {
        res = /charset=(.*)/i.exec(res.pop());
      }
    }
    if (!res && str) {
      res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    if (res) {
      charset = res.pop();
      if (charset === "gb2312" || charset === "gbk") {
        charset = "gb18030";
      }
    }
    return convert(buffer, "UTF-8", charset).toString();
  }
  function isURLSearchParams(obj) {
    if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
      return false;
    }
    return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
  }
  function clone(instance) {
    let p1, p2;
    let body = instance.body;
    if (instance.bodyUsed) {
      throw new Error("cannot clone body after it is used");
    }
    if (body instanceof Stream && typeof body.getBoundary !== "function") {
      p1 = new PassThrough();
      p2 = new PassThrough();
      body.pipe(p1);
      body.pipe(p2);
      instance[INTERNALS].body = p1;
      body = p2;
    }
    return body;
  }
  function extractContentType(instance) {
    const body = instance.body;
    if (body === null) {
      return null;
    } else if (typeof body === "string") {
      return "text/plain;charset=UTF-8";
    } else if (isURLSearchParams(body)) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (body instanceof Blob2) {
      return body.type || null;
    } else if (Buffer.isBuffer(body)) {
      return null;
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      return null;
    } else if (typeof body.getBoundary === "function") {
      return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else {
      return null;
    }
  }
  function getTotalBytes(instance) {
    const body = instance.body;
    if (body === null) {
      return 0;
    } else if (typeof body === "string") {
      return Buffer.byteLength(body);
    } else if (isURLSearchParams(body)) {
      return Buffer.byteLength(String(body));
    } else if (body instanceof Blob2) {
      return body.size;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      return body.byteLength;
    } else if (body && typeof body.getLengthSync === "function") {
      if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
        return body.getLengthSync();
      }
      return null;
    } else {
      return null;
    }
  }
  function writeToStream(dest, instance) {
    const body = instance.body;
    if (body === null) {
      dest.end();
    } else if (typeof body === "string") {
      dest.write(body);
      dest.end();
    } else if (isURLSearchParams(body)) {
      dest.write(Buffer.from(String(body)));
      dest.end();
    } else if (body instanceof Blob2) {
      dest.write(body[BUFFER]);
      dest.end();
    } else if (Buffer.isBuffer(body)) {
      dest.write(body);
      dest.end();
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      dest.write(Buffer.from(body));
      dest.end();
    } else {
      body.pipe(dest);
    }
  }
  Body.Promise = global.Promise;
  const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
  const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  function validateName(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name)) {
      throw new TypeError(`${name} is not a legal HTTP header name`);
    }
  }
  function validateValue(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
      throw new TypeError(`${value} is not a legal HTTP header value`);
    }
  }
  function find(map, name) {
    name = name.toLowerCase();
    for (const key in map) {
      if (key.toLowerCase() === name) {
        return key;
      }
    }
    return void 0;
  }
  const MAP = Symbol("map");
  class Headers {
    constructor() {
      let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      this[MAP] = Object.create(null);
      if (init instanceof Headers) {
        const rawHeaders = init.raw();
        const headerNames = Object.keys(rawHeaders);
        for (const headerName of headerNames) {
          for (const value of rawHeaders[headerName]) {
            this.append(headerName, value);
          }
        }
        return;
      }
      if (init == null) {
      } else if (typeof init === "object") {
        const method = init[Symbol.iterator];
        if (method != null) {
          if (typeof method !== "function") {
            throw new TypeError("Header pairs must be iterable");
          }
          const pairs = [];
          for (const pair of init) {
            if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
              throw new TypeError("Each header pair must be iterable");
            }
            pairs.push(Array.from(pair));
          }
          for (const pair of pairs) {
            if (pair.length !== 2) {
              throw new TypeError("Each header pair must be a name/value tuple");
            }
            this.append(pair[0], pair[1]);
          }
        } else {
          for (const key of Object.keys(init)) {
            const value = init[key];
            this.append(key, value);
          }
        }
      } else {
        throw new TypeError("Provided initializer must be an object");
      }
    }
    get(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key === void 0) {
        return null;
      }
      return this[MAP][key].join(", ");
    }
    forEach(callback) {
      let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
      let pairs = getHeaders(this);
      let i2 = 0;
      while (i2 < pairs.length) {
        var _pairs$i = pairs[i2];
        const name = _pairs$i[0], value = _pairs$i[1];
        callback.call(thisArg, value, name, this);
        pairs = getHeaders(this);
        i2++;
      }
    }
    set(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      this[MAP][key !== void 0 ? key : name] = [value];
    }
    append(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      if (key !== void 0) {
        this[MAP][key].push(value);
      } else {
        this[MAP][name] = [value];
      }
    }
    has(name) {
      name = `${name}`;
      validateName(name);
      return find(this[MAP], name) !== void 0;
    }
    delete(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key !== void 0) {
        delete this[MAP][key];
      }
    }
    raw() {
      return this[MAP];
    }
    keys() {
      return createHeadersIterator(this, "key");
    }
    values() {
      return createHeadersIterator(this, "value");
    }
    [Symbol.iterator]() {
      return createHeadersIterator(this, "key+value");
    }
  }
  Headers.prototype.entries = Headers.prototype[Symbol.iterator];
  Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
    value: "Headers",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Headers.prototype, {
    get: {enumerable: true},
    forEach: {enumerable: true},
    set: {enumerable: true},
    append: {enumerable: true},
    has: {enumerable: true},
    delete: {enumerable: true},
    keys: {enumerable: true},
    values: {enumerable: true},
    entries: {enumerable: true}
  });
  function getHeaders(headers) {
    let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
    const keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind === "key" ? function(k2) {
      return k2.toLowerCase();
    } : kind === "value" ? function(k2) {
      return headers[MAP][k2].join(", ");
    } : function(k2) {
      return [k2.toLowerCase(), headers[MAP][k2].join(", ")];
    });
  }
  const INTERNAL = Symbol("internal");
  function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
      target,
      kind,
      index: 0
    };
    return iterator;
  }
  const HeadersIteratorPrototype = Object.setPrototypeOf({
    next() {
      if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
        throw new TypeError("Value of `this` is not a HeadersIterator");
      }
      var _INTERNAL = this[INTERNAL];
      const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
      const values = getHeaders(target, kind);
      const len = values.length;
      if (index >= len) {
        return {
          value: void 0,
          done: true
        };
      }
      this[INTERNAL].index = index + 1;
      return {
        value: values[index],
        done: false
      };
    }
  }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
  Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: "HeadersIterator",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function exportNodeCompatibleHeaders(headers) {
    const obj = Object.assign({__proto__: null}, headers[MAP]);
    const hostHeaderKey = find(headers[MAP], "Host");
    if (hostHeaderKey !== void 0) {
      obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
  }
  function createHeadersLenient(obj) {
    const headers = new Headers();
    for (const name of Object.keys(obj)) {
      if (invalidTokenRegex.test(name)) {
        continue;
      }
      if (Array.isArray(obj[name])) {
        for (const val of obj[name]) {
          if (invalidHeaderCharRegex.test(val)) {
            continue;
          }
          if (headers[MAP][name] === void 0) {
            headers[MAP][name] = [val];
          } else {
            headers[MAP][name].push(val);
          }
        }
      } else if (!invalidHeaderCharRegex.test(obj[name])) {
        headers[MAP][name] = [obj[name]];
      }
    }
    return headers;
  }
  var _require$1 = require("http");
  const STATUS_CODES = _require$1.STATUS_CODES;
  const INTERNALS$1 = Symbol("Response internals");
  class Response {
    constructor() {
      let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      Body.call(this, body, opts);
      const status = opts.status || 200;
      this[INTERNALS$1] = {
        url: opts.url,
        status,
        statusText: opts.statusText || STATUS_CODES[status],
        headers: new Headers(opts.headers)
      };
    }
    get url() {
      return this[INTERNALS$1].url;
    }
    get status() {
      return this[INTERNALS$1].status;
    }
    get ok() {
      return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get statusText() {
      return this[INTERNALS$1].statusText;
    }
    get headers() {
      return this[INTERNALS$1].headers;
    }
    clone() {
      return new Response(clone(this), {
        url: this.url,
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        ok: this.ok
      });
    }
  }
  Body.mixIn(Response.prototype);
  Object.defineProperties(Response.prototype, {
    url: {enumerable: true},
    status: {enumerable: true},
    ok: {enumerable: true},
    statusText: {enumerable: true},
    headers: {enumerable: true},
    clone: {enumerable: true}
  });
  Object.defineProperty(Response.prototype, Symbol.toStringTag, {
    value: "Response",
    writable: false,
    enumerable: false,
    configurable: true
  });
  var _require$2 = require("url");
  const format_url = _require$2.format;
  const parse_url = _require$2.parse;
  const INTERNALS$2 = Symbol("Request internals");
  function isRequest(input) {
    return typeof input === "object" && typeof input[INTERNALS$2] === "object";
  }
  class Request {
    constructor(input) {
      let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let parsedURL;
      if (!isRequest(input)) {
        if (input && input.href) {
          parsedURL = parse_url(input.href);
        } else {
          parsedURL = parse_url(`${input}`);
        }
        input = {};
      } else {
        parsedURL = parse_url(input.url);
      }
      let method = init.method || input.method || "GET";
      method = method.toUpperCase();
      if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body");
      }
      let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
      Body.call(this, inputBody, {
        timeout: init.timeout || input.timeout || 0,
        size: init.size || input.size || 0
      });
      const headers = new Headers(init.headers || input.headers || {});
      if (init.body != null) {
        const contentType = extractContentType(this);
        if (contentType !== null && !headers.has("Content-Type")) {
          headers.append("Content-Type", contentType);
        }
      }
      this[INTERNALS$2] = {
        method,
        redirect: init.redirect || input.redirect || "follow",
        headers,
        parsedURL
      };
      this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
      this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
      this.counter = init.counter || input.counter || 0;
      this.agent = init.agent || input.agent;
    }
    get method() {
      return this[INTERNALS$2].method;
    }
    get url() {
      return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
      return this[INTERNALS$2].headers;
    }
    get redirect() {
      return this[INTERNALS$2].redirect;
    }
    clone() {
      return new Request(this);
    }
  }
  Body.mixIn(Request.prototype);
  Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: "Request",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Request.prototype, {
    method: {enumerable: true},
    url: {enumerable: true},
    headers: {enumerable: true},
    redirect: {enumerable: true},
    clone: {enumerable: true}
  });
  function getNodeRequestOptions(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers(request[INTERNALS$2].headers);
    if (!headers.has("Accept")) {
      headers.set("Accept", "*/*");
    }
    if (!parsedURL.protocol || !parsedURL.hostname) {
      throw new TypeError("Only absolute URLs are supported");
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
      throw new TypeError("Only HTTP(S) protocols are supported");
    }
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
      contentLengthValue = "0";
    }
    if (request.body != null) {
      const totalBytes = getTotalBytes(request);
      if (typeof totalBytes === "number") {
        contentLengthValue = String(totalBytes);
      }
    }
    if (contentLengthValue) {
      headers.set("Content-Length", contentLengthValue);
    }
    if (!headers.has("User-Agent")) {
      headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
    }
    if (request.compress) {
      headers.set("Accept-Encoding", "gzip,deflate");
    }
    if (!headers.has("Connection") && !request.agent) {
      headers.set("Connection", "close");
    }
    return Object.assign({}, parsedURL, {
      method: request.method,
      headers: exportNodeCompatibleHeaders(headers),
      agent: request.agent
    });
  }
  const http = require("http");
  const https = require("https");
  var _require$3 = require("stream");
  const PassThrough$1 = _require$3.PassThrough;
  var _require2 = require("url");
  const resolve_url = _require2.resolve;
  const zlib = require("zlib");
  function fetch2(url, opts) {
    if (!fetch2.Promise) {
      throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
    }
    Body.Promise = fetch2.Promise;
    return new fetch2.Promise(function(resolve, reject) {
      const request = new Request(url, opts);
      const options = getNodeRequestOptions(request);
      const send = (options.protocol === "https:" ? https : http).request;
      const req = send(options);
      let reqTimeout;
      function finalize() {
        req.abort();
        clearTimeout(reqTimeout);
      }
      if (request.timeout) {
        req.once("socket", function(socket) {
          reqTimeout = setTimeout(function() {
            reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
            finalize();
          }, request.timeout);
        });
      }
      req.on("error", function(err) {
        reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
        finalize();
      });
      req.on("response", function(res) {
        clearTimeout(reqTimeout);
        const headers = createHeadersLenient(res.headers);
        if (fetch2.isRedirect(res.statusCode)) {
          const location = headers.get("Location");
          const locationURL = location === null ? null : resolve_url(request.url, location);
          switch (request.redirect) {
            case "error":
              reject(new FetchError(`redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              if (locationURL !== null) {
                headers.set("Location", locationURL);
              }
              break;
            case "follow":
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOpts = {
                headers: new Headers(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: request.body
              };
              if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                requestOpts.method = "GET";
                requestOpts.body = void 0;
                requestOpts.headers.delete("content-length");
              }
              resolve(fetch2(new Request(locationURL, requestOpts)));
              finalize();
              return;
          }
        }
        let body = res.pipe(new PassThrough$1());
        const response_options = {
          url: request.url,
          status: res.statusCode,
          statusText: res.statusMessage,
          headers,
          size: request.size,
          timeout: request.timeout
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
          resolve(new Response(body, response_options));
          return;
        }
        const zlibOptions = {
          flush: zlib.Z_SYNC_FLUSH,
          finishFlush: zlib.Z_SYNC_FLUSH
        };
        if (codings == "gzip" || codings == "x-gzip") {
          body = body.pipe(zlib.createGunzip(zlibOptions));
          resolve(new Response(body, response_options));
          return;
        }
        if (codings == "deflate" || codings == "x-deflate") {
          const raw = res.pipe(new PassThrough$1());
          raw.once("data", function(chunk) {
            if ((chunk[0] & 15) === 8) {
              body = body.pipe(zlib.createInflate());
            } else {
              body = body.pipe(zlib.createInflateRaw());
            }
            resolve(new Response(body, response_options));
          });
          return;
        }
        resolve(new Response(body, response_options));
      });
      writeToStream(req, request);
    });
  }
  fetch2.isRedirect = function(code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
  };
  fetch2.default = fetch2;
  fetch2.Promise = global.Promise;
  const index_es_default = fetch2;
});

// node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js
const tf_core_esm_exports = {};
__export(tf_core_esm_exports, {
  AdadeltaOptimizer: () => Kf,
  AdagradOptimizer: () => jf,
  AdamOptimizer: () => Xf,
  AdamaxOptimizer: () => $f,
  DataStorage: () => so,
  ENV: () => i,
  Environment: () => o,
  KernelBackend: () => co,
  MomentumOptimizer: () => Qf,
  Optimizer: () => qf,
  RMSPropOptimizer: () => Jf,
  Rank: () => vt,
  Reduction: () => Xl,
  SGDOptimizer: () => Yf,
  Tensor: () => dt,
  TensorBuffer: () => lt,
  Variable: () => bt,
  abs: () => Vu,
  acos: () => zu,
  acosh: () => Gu,
  add: () => Vs,
  addN: () => zs,
  addStrict: () => Gs,
  all: () => ul,
  any: () => sl,
  argMax: () => cl,
  argMin: () => ll,
  asin: () => Hu,
  asinh: () => qu,
  atan: () => Ku,
  atan2: () => Hs,
  atanh: () => ju,
  avgPool: () => Qc,
  avgPool3d: () => tl,
  backend: () => on,
  backend_util: () => To,
  basicLSTMCell: () => Sl,
  batchNorm: () => Ns,
  batchNorm2d: () => Fs,
  batchNorm3d: () => Os,
  batchNorm4d: () => _s,
  batchNormalization: () => Ts,
  batchNormalization2d: () => Ss,
  batchNormalization3d: () => As,
  batchNormalization4d: () => Ds,
  batchToSpaceND: () => cr,
  booleanMaskAsync: () => Ic,
  browser: () => Ff,
  buffer: () => ur,
  cast: () => lr,
  ceil: () => Xu,
  clipByValue: () => $u,
  clone: () => hr,
  complex: () => En,
  concat: () => Gn,
  concat1d: () => Hn,
  concat2d: () => qn,
  concat3d: () => Kn,
  concat4d: () => jn,
  conv1d: () => Dc,
  conv2d: () => Tc,
  conv2dTranspose: () => Lc,
  conv3d: () => Nc,
  conv3dTranspose: () => Wc,
  cos: () => Yu,
  cosh: () => Qu,
  cumsum: () => fr,
  customGrad: () => oo,
  deprecationWarn: () => ze,
  depthToSpace: () => pr,
  depthwiseConv2d: () => _c,
  diag: () => Ul,
  disableDeprecationWarnings: () => Ve,
  dispose: () => Xe,
  disposeVariables: () => Ge,
  div: () => qs,
  divNoNan: () => Ks,
  divStrict: () => js,
  dot: () => Vc,
  dropout: () => Vl,
  elu: () => yl,
  enableDebugMode: () => Ue,
  enableProdMode: () => We,
  engine: () => He,
  env: () => a,
  equal: () => cc,
  equalStrict: () => lc,
  erf: () => Ju,
  exp: () => Zu,
  expandDims: () => dr,
  expm1: () => ts,
  eye: () => vr,
  fft: () => Ol,
  fill: () => Ln,
  findBackend: () => en,
  findBackendFactory: () => nn,
  floor: () => es,
  floorDiv: () => Xs,
  frame: () => ql,
  fused: () => Rh,
  gather: () => Ec,
  gatherND: () => Wl,
  getBackend: () => Ze,
  getKernel: () => s,
  getKernelsForBackend: () => c,
  grad: () => Zr,
  grads: () => to,
  greater: () => hc,
  greaterEqual: () => fc,
  greaterEqualStrict: () => pc,
  greaterStrict: () => dc,
  hammingWindow: () => Hl,
  hannWindow: () => Gl,
  ifft: () => _l,
  imag: () => In,
  image: () => mh,
  inTopKAsync: () => $l,
  io: () => Af,
  irfft: () => Bl,
  isFinite: () => ps,
  isInf: () => fs,
  isNaN: () => hs,
  keep: () => $e,
  leakyRelu: () => xl,
  less: () => vc,
  lessEqual: () => mc,
  lessEqualStrict: () => gc,
  lessStrict: () => yc,
  linalg: () => ch,
  linspace: () => Wn,
  localResponseNormalization: () => Il,
  log: () => ns,
  log1p: () => rs,
  logSigmoid: () => os,
  logSoftmax: () => uo,
  logSumExp: () => hl,
  logicalAnd: () => Ms,
  logicalNot: () => Bs,
  logicalOr: () => Ps,
  logicalXor: () => Ls,
  losses: () => ah,
  matMul: () => Uc,
  math: () => Tf,
  max: () => fl,
  maxPool: () => Yc,
  maxPool3d: () => Zc,
  maximum: () => $s,
  maximumStrict: () => Ys,
  mean: () => pl,
  memory: () => qe,
  min: () => dl,
  minimum: () => Qs,
  minimumStrict: () => Js,
  mod: () => Zs,
  modStrict: () => tc,
  moments: () => vl,
  movingAverage: () => Dl,
  mul: () => ec,
  mulStrict: () => nc,
  multiRNNCell: () => Al,
  multinomial: () => mr,
  neg: () => as,
  nextFrame: () => np,
  norm: () => kl,
  notEqual: () => xc,
  notEqualStrict: () => bc,
  oneHot: () => gr,
  ones: () => Bn,
  onesLike: () => Vn,
  op: () => Cn,
  outerProduct: () => zc,
  pad: () => yr,
  pad1d: () => xr,
  pad2d: () => br,
  pad3d: () => wr,
  pad4d: () => Cr,
  pool: () => Jc,
  pow: () => rc,
  powStrict: () => oc,
  prelu: () => bl,
  print: () => sr,
  prod: () => gl,
  profile: () => Ke,
  rand: () => Er,
  randomGamma: () => Ir,
  randomNormal: () => Rr,
  randomUniform: () => kr,
  range: () => Un,
  ready: () => Je,
  real: () => Rn,
  reciprocal: () => is,
  registerBackend: () => rn,
  registerKernel: () => l,
  relu: () => wl,
  relu6: () => Cl,
  removeBackend: () => tn,
  reshape: () => Sr,
  reverse: () => Gc,
  reverse1d: () => Hc,
  reverse2d: () => qc,
  reverse3d: () => Kc,
  reverse4d: () => jc,
  rfft: () => Ml,
  round: () => us,
  rsqrt: () => ss,
  scalar: () => An,
  scatterND: () => Fl,
  selu: () => El,
  separableConv2d: () => Pc,
  serialization: () => Bf,
  setBackend: () => Qe,
  setPlatform: () => an,
  setdiff1dAsync: () => _r,
  sigmoid: () => cs,
  sign: () => ls,
  signal: () => jl,
  sin: () => ds,
  sinh: () => vs,
  slice: () => el,
  slice1d: () => nl,
  slice2d: () => rl,
  slice3d: () => ol,
  slice4d: () => al,
  slice_util: () => Jr,
  softmax: () => io,
  softplus: () => ms,
  spaceToBatchND: () => Ar,
  sparseToDense: () => Ll,
  spectral: () => Pl,
  split: () => Xn,
  sqrt: () => gs,
  square: () => Uu,
  squaredDifference: () => ac,
  squaredDifferenceStrict: () => ic,
  squeeze: () => Dr,
  stack: () => Tr,
  step: () => ys,
  stft: () => Kl,
  stridedSlice: () => Tl,
  sub: () => uc,
  subStrict: () => sc,
  sum: () => ml,
  tan: () => xs,
  tanh: () => bs,
  tensor: () => kn,
  tensor1d: () => Dn,
  tensor2d: () => Tn,
  tensor3d: () => Nn,
  tensor4d: () => Fn,
  tensor5d: () => On,
  tensor6d: () => _n,
  tensor_util: () => At,
  test_util: () => zf,
  tidy: () => je,
  tile: () => Nr,
  time: () => Ye,
  topk: () => Nl,
  train: () => tp,
  transpose: () => Rl,
  truncatedNormal: () => Fr,
  unregisterKernel: () => h,
  unsortedSegmentSum: () => Rc,
  unstack: () => Or,
  util: () => tt,
  valueAndGrad: () => eo,
  valueAndGrads: () => no,
  variable: () => Mn,
  variableGrads: () => ro,
  version_core: () => Gf,
  webgl: () => Hf,
  where: () => Ws,
  whereAsync: () => Us,
  zeros: () => Pn,
  zerosLike: () => zn
});
var t = function(e2, n2) {
  return (t = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(t2, e3) {
    t2.__proto__ = e3;
  } || function(t2, e3) {
    for (var n3 in e3)
      e3.hasOwnProperty(n3) && (t2[n3] = e3[n3]);
  })(e2, n2);
};
function e(e2, n2) {
  function r2() {
    this.constructor = e2;
  }
  t(e2, n2), e2.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
}
function n(t2, e2, n2, r2) {
  return new (n2 || (n2 = Promise))(function(o2, a2) {
    function i2(t3) {
      try {
        s2(r2.next(t3));
      } catch (t4) {
        a2(t4);
      }
    }
    function u2(t3) {
      try {
        s2(r2.throw(t3));
      } catch (t4) {
        a2(t4);
      }
    }
    function s2(t3) {
      t3.done ? o2(t3.value) : new n2(function(e3) {
        e3(t3.value);
      }).then(i2, u2);
    }
    s2((r2 = r2.apply(t2, e2 || [])).next());
  });
}
function r(t2, e2) {
  var n2, r2, o2, a2, i2 = {label: 0, sent: function() {
    if (1 & o2[0])
      throw o2[1];
    return o2[1];
  }, trys: [], ops: []};
  return a2 = {next: u2(0), throw: u2(1), return: u2(2)}, "function" == typeof Symbol && (a2[Symbol.iterator] = function() {
    return this;
  }), a2;
  function u2(a3) {
    return function(u3) {
      return function(a4) {
        if (n2)
          throw new TypeError("Generator is already executing.");
        for (; i2; )
          try {
            if (n2 = 1, r2 && (o2 = 2 & a4[0] ? r2.return : a4[0] ? r2.throw || ((o2 = r2.return) && o2.call(r2), 0) : r2.next) && !(o2 = o2.call(r2, a4[1])).done)
              return o2;
            switch (r2 = 0, o2 && (a4 = [2 & a4[0], o2.value]), a4[0]) {
              case 0:
              case 1:
                o2 = a4;
                break;
              case 4:
                return i2.label++, {value: a4[1], done: false};
              case 5:
                i2.label++, r2 = a4[1], a4 = [0];
                continue;
              case 7:
                a4 = i2.ops.pop(), i2.trys.pop();
                continue;
              default:
                if (!(o2 = (o2 = i2.trys).length > 0 && o2[o2.length - 1]) && (6 === a4[0] || 2 === a4[0])) {
                  i2 = 0;
                  continue;
                }
                if (3 === a4[0] && (!o2 || a4[1] > o2[0] && a4[1] < o2[3])) {
                  i2.label = a4[1];
                  break;
                }
                if (6 === a4[0] && i2.label < o2[1]) {
                  i2.label = o2[1], o2 = a4;
                  break;
                }
                if (o2 && i2.label < o2[2]) {
                  i2.label = o2[2], i2.ops.push(a4);
                  break;
                }
                o2[2] && i2.ops.pop(), i2.trys.pop();
                continue;
            }
            a4 = e2.call(t2, i2);
          } catch (t3) {
            a4 = [6, t3], r2 = 0;
          } finally {
            n2 = o2 = 0;
          }
        if (5 & a4[0])
          throw a4[1];
        return {value: a4[0] ? a4[1] : void 0, done: true};
      }([a3, u3]);
    };
  }
}
var o = function() {
  function t2(t3) {
    this.global = t3, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.populateURLFlags();
  }
  return t2.prototype.setPlatform = function(t3, e2) {
    null != this.platform && console.warn("Platform " + this.platformName + " has already been set. Overwriting the platform with " + e2 + "."), this.platformName = t3, this.platform = e2;
  }, t2.prototype.registerFlag = function(t3, e2, n2) {
    if (this.flagRegistry[t3] = {evaluationFn: e2, setHook: n2}, null != this.urlFlags[t3]) {
      var r2 = this.urlFlags[t3];
      console.warn("Setting feature override from URL " + t3 + ": " + r2 + "."), this.set(t3, r2);
    }
  }, t2.prototype.get = function(t3) {
    return t3 in this.flags ? this.flags[t3] : (this.flags[t3] = this.evaluateFlag(t3), this.flags[t3]);
  }, t2.prototype.getNumber = function(t3) {
    return this.get(t3);
  }, t2.prototype.getBool = function(t3) {
    return this.get(t3);
  }, t2.prototype.getFlags = function() {
    return this.flags;
  }, Object.defineProperty(t2.prototype, "features", {get: function() {
    return this.flags;
  }, enumerable: true, configurable: true}), t2.prototype.set = function(t3, e2) {
    if (null == this.flagRegistry[t3])
      throw new Error("Cannot set flag " + t3 + " as it has not been registered.");
    this.flags[t3] = e2, null != this.flagRegistry[t3].setHook && this.flagRegistry[t3].setHook(e2);
  }, t2.prototype.evaluateFlag = function(t3) {
    if (null == this.flagRegistry[t3])
      throw new Error("Cannot evaluate flag '" + t3 + "': no evaluation function found.");
    return this.flagRegistry[t3].evaluationFn();
  }, t2.prototype.setFlags = function(t3) {
    this.flags = Object.assign({}, t3);
  }, t2.prototype.reset = function() {
    this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
  }, t2.prototype.populateURLFlags = function() {
    var t3 = this;
    if (void 0 !== this.global && void 0 !== this.global.location && void 0 !== this.global.location.search) {
      var e2, n2, r2 = (e2 = this.global.location.search, n2 = {}, e2.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function(t4) {
        for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
          e3[r3 - 1] = arguments[r3];
        return function(t5, e4, n3) {
          t5[decodeURIComponent(e4)] = decodeURIComponent(n3 || "");
        }(n2, e3[0], e3[1]), e3.join("=");
      }), n2);
      if ("tfjsflags" in r2)
        r2.tfjsflags.split(",").forEach(function(e3) {
          var n3 = e3.split(":"), r3 = n3[0], o2 = n3[1];
          t3.urlFlags[r3] = function(t4, e4) {
            if ("true" === (e4 = e4.toLowerCase()) || "false" === e4)
              return "true" === e4;
            if ("" + +e4 === e4)
              return +e4;
            throw new Error("Could not parse value flag value " + e4 + " for flag " + t4 + ".");
          }(r3, o2);
        });
    }
  }, t2;
}();
function a() {
  return i;
}
var i = null;
var u = new Map();
function s(t2, e2) {
  var n2 = f(t2, e2);
  return u.get(n2);
}
function c(t2) {
  for (var e2 = u.entries(), n2 = []; ; ) {
    var r2 = e2.next(), o2 = r2.done, a2 = r2.value;
    if (o2)
      break;
    var i2 = a2[0], s2 = a2[1];
    i2.split("_")[0] === t2 && n2.push(s2);
  }
  return n2;
}
function l(t2) {
  var e2 = t2.kernelName, n2 = t2.backendName, r2 = f(e2, n2);
  if (u.has(r2))
    throw new Error("The kernel '" + e2 + "' for backend '" + n2 + "' is already registered");
  u.set(r2, t2);
}
function h(t2, e2) {
  var n2 = f(t2, e2);
  if (!u.has(n2))
    throw new Error("The kernel '" + t2 + "' for backend '" + e2 + "' is not registered");
  u.delete(n2);
}
function f(t2, e2) {
  return e2 + "_" + t2;
}
function p(t2) {
  for (var e2 = t2.length, n2 = 0, r2 = 0; e2 > 0; )
    r2 = Math.random() * e2 | 0, n2 = t2[--e2], t2[e2] = t2[r2], t2[r2] = n2;
}
function d(t2, e2, n2) {
  return Math.max(t2, Math.min(e2, n2));
}
function v(t2) {
  return t2 % 2 == 0 ? t2 : t2 + 1;
}
function m(t2) {
  for (var e2 = 0, n2 = 0; n2 < t2.length; n2++)
    e2 += t2[n2];
  return e2;
}
function g(t2, e2) {
  if (!t2)
    throw new Error("string" == typeof e2 ? e2 : e2());
}
function y(t2, e2, n2) {
  void 0 === n2 && (n2 = ""), g(C(t2, e2), function() {
    return n2 + " Shapes " + t2 + " and " + e2 + " must match";
  });
}
function x(t2) {
  g(null != t2, function() {
    return "The input to the tensor constructor must be a non-null value.";
  });
}
function b(t2, e2, n2) {
  if (void 0 === e2 && (e2 = []), void 0 === n2 && (n2 = false), null == e2 && (e2 = []), Array.isArray(t2) || B(t2) && !n2)
    for (var r2 = 0; r2 < t2.length; ++r2)
      b(t2[r2], e2, n2);
  else
    e2.push(t2);
  return e2;
}
function w(t2) {
  if (0 === t2.length)
    return 1;
  for (var e2 = t2[0], n2 = 1; n2 < t2.length; n2++)
    e2 *= t2[n2];
  return e2;
}
function C(t2, e2) {
  if (t2 === e2)
    return true;
  if (null == t2 || null == e2)
    return false;
  if (t2.length !== e2.length)
    return false;
  for (var n2 = 0; n2 < t2.length; n2++)
    if (t2[n2] !== e2[n2])
      return false;
  return true;
}
function E(t2) {
  return t2 % 1 == 0;
}
function R(t2) {
  if (null != Math.tanh)
    return Math.tanh(t2);
  if (t2 === 1 / 0)
    return 1;
  if (t2 === -1 / 0)
    return -1;
  var e2 = Math.exp(2 * t2);
  return (e2 - 1) / (e2 + 1);
}
function I(t2) {
  var e2 = Math.ceil(Math.sqrt(t2));
  return [e2, Math.ceil(t2 / e2)];
}
function k(t2, e2) {
  return e2 <= t2.length ? t2 : t2 + " ".repeat(e2 - t2.length);
}
function S(t2, e2, n2) {
  return void 0 === e2 && (e2 = function(t3) {
    return 0;
  }), new Promise(function(r2, o2) {
    var a2 = 0, i2 = function() {
      if (t2())
        r2();
      else {
        var u2 = e2(++a2);
        null != n2 && a2 >= n2 ? o2() : setTimeout(i2, u2);
      }
    };
    i2();
  });
}
function A(t2, e2) {
  for (var n2 = 1, r2 = -1, o2 = 0; o2 < t2.length; ++o2)
    if (t2[o2] >= 0)
      n2 *= t2[o2];
    else if (-1 === t2[o2]) {
      if (-1 !== r2)
        throw Error("Shapes can only have 1 implicit size. Found -1 at dim " + r2 + " and dim " + o2);
      r2 = o2;
    } else if (t2[o2] < 0)
      throw Error("Shapes can not be < 0. Found " + t2[o2] + " at dim " + o2);
  if (-1 === r2) {
    if (e2 > 0 && e2 !== n2)
      throw Error("Size(" + e2 + ") must match the product of shape " + t2);
    return t2;
  }
  if (0 === n2)
    throw Error("Cannot infer the missing size in [" + t2 + "] when there are 0 elements");
  if (e2 % n2 != 0)
    throw Error("The implicit shape can't be a fractional number. Got " + e2 + " / " + n2);
  var a2 = t2.slice();
  return a2[r2] = e2 / n2, a2;
}
function D(t2, e2) {
  var n2 = e2.length;
  return g((t2 = null == t2 ? e2.map(function(t3, e3) {
    return e3;
  }) : [].concat(t2)).every(function(t3) {
    return t3 >= -n2 && t3 < n2;
  }), function() {
    return "All values in axis param must be in range [-" + n2 + ", " + n2 + ") but got axis " + t2;
  }), g(t2.every(function(t3) {
    return E(t3);
  }), function() {
    return "All values in axis param must be integers but got axis " + t2;
  }), t2.map(function(t3) {
    return t3 < 0 ? n2 + t3 : t3;
  });
}
function T(t2, e2) {
  for (var n2 = [], r2 = [], o2 = null != e2 && Array.isArray(e2) && 0 === e2.length, a2 = null == e2 || o2 ? null : D(e2, t2).sort(), i2 = 0, u2 = 0; u2 < t2.length; ++u2) {
    if (null != a2) {
      if (a2[i2] === u2 && 1 !== t2[u2])
        throw new Error("Can't squeeze axis " + u2 + " since its dim '" + t2[u2] + "' is not 1");
      (null == a2[i2] || a2[i2] > u2) && 1 === t2[u2] && (n2.push(t2[u2]), r2.push(u2)), a2[i2] <= u2 && i2++;
    }
    1 !== t2[u2] && (n2.push(t2[u2]), r2.push(u2));
  }
  return {newShape: n2, keptDims: r2};
}
function N(t2, e2) {
  var n2 = null;
  if (null == t2 || "float32" === t2)
    n2 = new Float32Array(e2);
  else if ("int32" === t2)
    n2 = new Int32Array(e2);
  else {
    if ("bool" !== t2)
      throw new Error("Unknown data type " + t2);
    n2 = new Uint8Array(e2);
  }
  return n2;
}
function F(t2, e2) {
  var n2 = null;
  if (null == t2 || "float32" === t2)
    n2 = new Float32Array(e2);
  else if ("int32" === t2)
    n2 = new Int32Array(e2);
  else if ("bool" === t2)
    n2 = new Uint8Array(e2);
  else {
    if ("string" !== t2)
      throw new Error("Unknown data type " + t2);
    n2 = new Array(e2);
  }
  return n2;
}
function O(t2, e2) {
  for (var n2 = 0; n2 < t2.length; n2++) {
    var r2 = t2[n2];
    if (isNaN(r2) || !isFinite(r2))
      throw Error("A tensor of type " + e2 + " being uploaded contains " + r2 + ".");
  }
}
function _(t2) {
  return "bool" === t2 || "complex64" === t2 || "float32" === t2 || "int32" === t2 || "string" === t2;
}
function M(t2, e2) {
  return "complex64" !== e2 && (("float32" !== e2 || "complex64" === t2) && (("int32" !== e2 || "float32" === t2 || "complex64" === t2) && ("bool" !== e2 || "bool" !== t2)));
}
function B(t2) {
  return t2 instanceof Float32Array || t2 instanceof Int32Array || t2 instanceof Uint8Array;
}
function P(t2) {
  if ("float32" === t2 || "int32" === t2)
    return 4;
  if ("complex64" === t2)
    return 8;
  if ("bool" === t2)
    return 1;
  throw new Error("Unknown dtype " + t2);
}
function L(t2) {
  if (null == t2)
    return 0;
  var e2 = 0;
  return t2.forEach(function(t3) {
    return e2 += t3.length;
  }), e2;
}
function W(t2) {
  return "string" == typeof t2 || t2 instanceof String;
}
function U(t2) {
  return "boolean" == typeof t2;
}
function V(t2) {
  return "number" == typeof t2;
}
function z(t2) {
  return Array.isArray(t2) ? z(t2[0]) : t2 instanceof Float32Array ? "float32" : t2 instanceof Int32Array || t2 instanceof Uint8Array ? "int32" : V(t2) ? "float32" : W(t2) ? "string" : U(t2) ? "bool" : "float32";
}
function G(t2) {
  return !!(t2 && t2.constructor && t2.call && t2.apply);
}
function H(t2, e2) {
  for (var n2 = e2; n2 < t2; ++n2)
    if (t2 % n2 == 0)
      return n2;
  return t2;
}
function q(t2) {
  var e2 = t2.length;
  if (e2 < 2)
    return [];
  var n2 = new Array(e2 - 1);
  n2[e2 - 2] = t2[e2 - 1];
  for (var r2 = e2 - 3; r2 >= 0; --r2)
    n2[r2] = n2[r2 + 1] * t2[r2 + 1];
  return n2;
}
function K(t2, e2, n2) {
  if ("string" === e2)
    throw new Error("Cannot convert a string[] to a TypedArray");
  if (Array.isArray(t2) && (t2 = b(t2)), n2 && O(t2, e2), function(t3, e3) {
    return t3 instanceof Float32Array && "float32" === e3 || t3 instanceof Int32Array && "int32" === e3 || t3 instanceof Uint8Array && "bool" === e3;
  }(t2, e2))
    return t2;
  if (null == e2 || "float32" === e2 || "complex64" === e2)
    return new Float32Array(t2);
  if ("int32" === e2)
    return new Int32Array(t2);
  if ("bool" === e2) {
    for (var r2 = new Uint8Array(t2.length), o2 = 0; o2 < r2.length; ++o2)
      0 !== Math.round(t2[o2]) && (r2[o2] = 1);
    return r2;
  }
  throw new Error("Unknown data type " + e2);
}
function j(t2, e2) {
  if (0 === t2.length)
    return e2[0];
  var n2 = t2.reduce(function(t3, e3) {
    return t3 * e3;
  });
  if (0 === n2)
    return [];
  if (n2 !== e2.length)
    throw new Error("[" + t2 + "] does not match the input size.");
  return function t3(e3, n3, r2) {
    var o2 = new Array();
    if (1 === n3.length)
      for (var a2 = n3[0], i2 = 0; i2 < a2; i2++)
        o2[i2] = r2[e3 + i2];
    else {
      a2 = n3[0];
      var u2 = n3.slice(1), s2 = u2.reduce(function(t4, e4) {
        return t4 * e4;
      });
      for (i2 = 0; i2 < a2; i2++)
        o2[i2] = t3(e3 + i2 * s2, u2, r2);
    }
    return o2;
  }(0, t2, e2);
}
function X(t2, e2) {
  for (var n2 = $(t2, e2), r2 = 0; r2 < n2.length; r2++)
    n2[r2] = 1;
  return n2;
}
function $(t2, e2) {
  if (null == e2 || "float32" === e2 || "complex64" === e2)
    return new Float32Array(t2);
  if ("int32" === e2)
    return new Int32Array(t2);
  if ("bool" === e2)
    return new Uint8Array(t2);
  throw new Error("Unknown data type " + e2);
}
function Y() {
  return a().platform.now();
}
function Q(t2) {
  t2.forEach(function(e2) {
    g(Number.isInteger(e2) && e2 >= 0, function() {
      return "Tensor must have a shape comprised of positive integers but got shape [" + t2 + "].";
    });
  });
}
function J(t2, e2) {
  return void 0 === e2 && (e2 = "utf-8"), e2 = e2 || "utf-8", a().platform.encode(t2, e2);
}
function Z(t2, e2) {
  return void 0 === e2 && (e2 = "utf-8"), e2 = e2 || "utf-8", a().platform.decode(t2, e2);
}
var tt = Object.freeze({shuffle: p, clamp: d, nearestLargerEven: v, sum: m, randUniform: function(t2, e2) {
  var n2 = Math.random();
  return e2 * n2 + (1 - n2) * t2;
}, distSquared: function(t2, e2) {
  for (var n2 = 0, r2 = 0; r2 < t2.length; r2++) {
    var o2 = Number(t2[r2]) - Number(e2[r2]);
    n2 += o2 * o2;
  }
  return n2;
}, assert: g, assertShapesMatch: y, assertNonNull: x, flatten: b, sizeFromShape: w, isScalarShape: function(t2) {
  return 0 === t2.length;
}, arraysEqual: C, isInt: E, tanh: R, sizeToSquarishShape: I, createShuffledIndices: function(t2) {
  for (var e2 = new Uint32Array(t2), n2 = 0; n2 < t2; ++n2)
    e2[n2] = n2;
  return p(e2), e2;
}, rightPad: k, repeatedTry: S, inferFromImplicitShape: A, parseAxisParam: D, squeezeShape: T, getTypedArrayFromDType: N, getArrayFromDType: F, checkConversionForErrors: O, isValidDtype: _, hasEncodingLoss: M, isTypedArray: B, bytesPerElement: P, bytesFromStringArray: L, isString: W, isBoolean: U, isNumber: V, inferDtype: z, isFunction: G, nearestDivisor: H, computeStrides: q, toTypedArray: K, toNestedArray: j, makeOnesTypedArray: X, makeZerosTypedArray: $, now: Y, assertNonNegativeIntegerDimensions: Q, fetch: function(t2, e2) {
  return a().platform.fetch(t2, e2);
}, encodeString: J, decodeString: Z});
var et = function() {
  function t2(t3, e2) {
    this.backendTimer = t3, this.logger = e2, null == e2 && (this.logger = new nt());
  }
  return t2.prototype.profileKernel = function(t3, e2, n2) {
    var r2, o2 = this, a2 = this.backendTimer.time(function() {
      r2 = n2();
    });
    return r2.forEach(function(n3) {
      n3.data().then(function(r3) {
        !function(t4, e3, n4) {
          if ("float32" !== e3)
            return false;
          for (var r4 = 0; r4 < t4.length; r4++) {
            var o3 = t4[r4];
            if (isNaN(o3) || !isFinite(o3))
              return console.warn("Found " + o3 + " in the result of '" + n4 + "'"), true;
          }
        }(r3, n3.dtype, t3), a2.then(function(a3) {
          var i2 = "";
          null != a3.getExtraProfileInfo && (i2 = a3.getExtraProfileInfo()), o2.logger.logKernelProfile(t3, n3, r3, a3.kernelMs, e2, i2);
        });
      });
    }), r2;
  }, t2;
}();
var nt = function() {
  function t2() {
  }
  return t2.prototype.logKernelProfile = function(t3, e2, n2, r2, o2, a2) {
    var i2 = k(r2 + "ms", 9), u2 = k(t3, 25), s2 = e2.rank, c2 = e2.size, l2 = k(e2.shape.toString(), 14), h2 = "";
    for (var f2 in o2) {
      var p2 = o2[f2].shape, d2 = p2.length;
      h2 += f2 + ": " + d2 + "D " + (d2 > 0 ? p2 : "") + " ";
    }
    console.log("%c" + u2 + "	%c" + i2 + "	%c" + s2 + "D " + l2 + "	%c" + c2 + "	%c" + h2 + "	%c" + a2, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
  }, t2;
}();
var rt = 20;
var ot = 3;
var at = 7;
function it(t2, e2, n2, r2) {
  var o2 = q(e2), a2 = function(t3, e3, n3, r3) {
    var o3 = w(e3), a3 = r3[r3.length - 1], i3 = new Array(a3).fill(0), u3 = e3.length, s3 = "complex64" === n3 ? ct(t3) : t3;
    if (u3 > 1)
      for (var c2 = 0; c2 < o3 / a3; c2++)
        for (var l2 = c2 * a3, h2 = 0; h2 < a3; h2++)
          i3[h2] = Math.max(i3[h2], ut(s3[l2 + h2], 0, n3).length);
    return i3;
  }(t2, e2, n2, o2), i2 = e2.length, u2 = function t3(e3, n3, r3, o3, a3, i3) {
    void 0 === i3 && (i3 = true);
    var u3 = "complex64" === r3 ? 2 : 1;
    var s3 = n3[0];
    var c2 = n3.length;
    if (0 === c2) {
      if ("complex64" === r3) {
        var l2 = ct(e3);
        return [ut(l2[0], 0, r3)];
      }
      return "bool" === r3 ? [st(e3[0])] : [e3[0].toString()];
    }
    if (1 === c2) {
      if (s3 > rt) {
        var h2 = ot * u3, f2 = Array.from(e3.slice(0, h2)), p2 = Array.from(e3.slice((s3 - ot) * u3, s3 * u3));
        return "complex64" === r3 && (f2 = ct(f2), p2 = ct(p2)), ["[" + f2.map(function(t4, e4) {
          return ut(t4, a3[e4], r3);
        }).join(", ") + ", ..., " + p2.map(function(t4, e4) {
          return ut(t4, a3[s3 - ot + e4], r3);
        }).join(", ") + "]"];
      }
      var d2 = "complex64" === r3 ? ct(e3) : Array.from(e3);
      return ["[" + d2.map(function(t4, e4) {
        return ut(t4, a3[e4], r3);
      }).join(", ") + "]"];
    }
    var v2 = n3.slice(1);
    var m2 = o3.slice(1);
    var g2 = o3[0] * u3;
    var y2 = [];
    if (s3 > rt) {
      for (var x2 = 0; x2 < ot; x2++) {
        var b2 = x2 * g2, w2 = b2 + g2;
        y2.push.apply(y2, t3(e3.slice(b2, w2), v2, r3, m2, a3, false));
      }
      y2.push("...");
      for (var x2 = s3 - ot; x2 < s3; x2++) {
        var b2 = x2 * g2, w2 = b2 + g2;
        y2.push.apply(y2, t3(e3.slice(b2, w2), v2, r3, m2, a3, x2 === s3 - 1));
      }
    } else
      for (var x2 = 0; x2 < s3; x2++) {
        var b2 = x2 * g2, w2 = b2 + g2;
        y2.push.apply(y2, t3(e3.slice(b2, w2), v2, r3, m2, a3, x2 === s3 - 1));
      }
    var C2 = 2 === c2 ? "," : "";
    y2[0] = "[" + y2[0] + C2;
    for (var x2 = 1; x2 < y2.length - 1; x2++)
      y2[x2] = " " + y2[x2] + C2;
    var E2 = ",\n";
    for (var x2 = 2; x2 < c2; x2++)
      E2 += "\n";
    y2[y2.length - 1] = " " + y2[y2.length - 1] + "]" + (i3 ? "" : E2);
    return y2;
  }(t2, e2, n2, o2, a2), s2 = ["Tensor"];
  return r2 && (s2.push("  dtype: " + n2), s2.push("  rank: " + i2), s2.push("  shape: [" + e2 + "]"), s2.push("  values:")), s2.push(u2.map(function(t3) {
    return "    " + t3;
  }).join("\n")), s2.join("\n");
}
function ut(t2, e2, n2) {
  return k(Array.isArray(t2) ? parseFloat(t2[0].toFixed(at)) + " + " + parseFloat(t2[1].toFixed(at)) + "j" : W(t2) ? "'" + t2 + "'" : "bool" === n2 ? st(t2) : parseFloat(t2.toFixed(at)).toString(), e2);
}
function st(t2) {
  return 0 === t2 ? "false" : "true";
}
function ct(t2) {
  for (var e2 = [], n2 = 0; n2 < t2.length; n2 += 2)
    e2.push([t2[n2], t2[n2 + 1]]);
  return e2;
}
var lt = function() {
  function t2(t3, e2, n2) {
    var r2 = this;
    if (this.dtype = e2, this.shape = t3.slice(), this.size = w(t3), null != n2) {
      var o2 = n2.length;
      g(o2 === this.size, function() {
        return "Length of values '" + o2 + "' does not match the size inferred by the shape '" + r2.size + "'.";
      });
    }
    if ("complex64" === e2)
      throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
    this.values = n2 || F(e2, this.size), this.strides = q(t3);
  }
  return t2.prototype.set = function(t3) {
    for (var e2 = this, n2 = [], r2 = 1; r2 < arguments.length; r2++)
      n2[r2 - 1] = arguments[r2];
    0 === n2.length && (n2 = [0]), g(n2.length === this.rank, function() {
      return "The number of provided coordinates (" + n2.length + ") must match the rank (" + e2.rank + ")";
    });
    var o2 = this.locToIndex(n2);
    this.values[o2] = t3;
  }, t2.prototype.get = function() {
    for (var t3 = [], e2 = 0; e2 < arguments.length; e2++)
      t3[e2] = arguments[e2];
    0 === t3.length && (t3 = [0]);
    for (var n2 = 0, r2 = 0, o2 = t3; r2 < o2.length; r2++) {
      var a2 = o2[r2];
      if (a2 < 0 || a2 >= this.shape[n2]) {
        var i2 = "Requested out of range element at " + t3 + ".   Buffer shape=" + this.shape;
        throw new Error(i2);
      }
      n2++;
    }
    for (var u2 = t3[t3.length - 1], s2 = 0; s2 < t3.length - 1; ++s2)
      u2 += this.strides[s2] * t3[s2];
    return this.values[u2];
  }, t2.prototype.locToIndex = function(t3) {
    if (0 === this.rank)
      return 0;
    if (1 === this.rank)
      return t3[0];
    for (var e2 = t3[t3.length - 1], n2 = 0; n2 < t3.length - 1; ++n2)
      e2 += this.strides[n2] * t3[n2];
    return e2;
  }, t2.prototype.indexToLoc = function(t3) {
    if (0 === this.rank)
      return [];
    if (1 === this.rank)
      return [t3];
    for (var e2 = new Array(this.shape.length), n2 = 0; n2 < e2.length - 1; ++n2)
      e2[n2] = Math.floor(t3 / this.strides[n2]), t3 -= e2[n2] * this.strides[n2];
    return e2[e2.length - 1] = t3, e2;
  }, Object.defineProperty(t2.prototype, "rank", {get: function() {
    return this.shape.length;
  }, enumerable: true, configurable: true}), t2.prototype.toTensor = function() {
    return ht().makeTensor(this.values, this.shape, this.dtype);
  }, t2;
}();
var ht = null;
var ft = null;
var pt = null;
var dt = function() {
  function t2(t3, e2, n2, r2) {
    this.kept = false, this.isDisposedInternal = false, this.shape = t3.slice(), this.dtype = e2 || "float32", this.size = w(t3), this.strides = q(t3), this.dataId = n2, this.id = r2, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
  }
  return t2.prototype.flatten = function() {
    return this.throwIfDisposed(), this.as1D();
  }, t2.prototype.asScalar = function() {
    return this.throwIfDisposed(), g(1 === this.size, function() {
      return "The array must have only 1 element.";
    }), this.reshape([]);
  }, t2.prototype.as1D = function() {
    return this.throwIfDisposed(), this.reshape([this.size]);
  }, t2.prototype.as2D = function(t3, e2) {
    return this.throwIfDisposed(), this.reshape([t3, e2]);
  }, t2.prototype.as3D = function(t3, e2, n2) {
    return this.throwIfDisposed(), this.reshape([t3, e2, n2]);
  }, t2.prototype.as4D = function(t3, e2, n2, r2) {
    return this.throwIfDisposed(), this.reshape([t3, e2, n2, r2]);
  }, t2.prototype.as5D = function(t3, e2, n2, r2, o2) {
    return this.throwIfDisposed(), this.reshape([t3, e2, n2, r2, o2]);
  }, t2.prototype.asType = function(t3) {
    return this.throwIfDisposed(), ft.cast(this, t3);
  }, Object.defineProperty(t2.prototype, "rank", {get: function() {
    return this.shape.length;
  }, enumerable: true, configurable: true}), t2.prototype.buffer = function() {
    return n(this, void 0, void 0, function() {
      var t3;
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return [4, this.data()];
          case 1:
            return t3 = e2.sent(), [2, ft.buffer(this.shape, this.dtype, t3)];
        }
      });
    });
  }, t2.prototype.bufferSync = function() {
    return ft.buffer(this.shape, this.dtype, this.dataSync());
  }, t2.prototype.array = function() {
    return n(this, void 0, void 0, function() {
      var t3;
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return [4, this.data()];
          case 1:
            return t3 = e2.sent(), [2, j(this.shape, t3)];
        }
      });
    });
  }, t2.prototype.arraySync = function() {
    return j(this.shape, this.dataSync());
  }, t2.prototype.data = function() {
    return n(this, void 0, void 0, function() {
      var t3, e2;
      return r(this, function(n2) {
        switch (n2.label) {
          case 0:
            return this.throwIfDisposed(), t3 = ht().read(this.dataId), "string" !== this.dtype ? [3, 2] : [4, t3];
          case 1:
            e2 = n2.sent();
            try {
              return [2, e2.map(function(t4) {
                return Z(t4);
              })];
            } catch (t4) {
              throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
            }
            n2.label = 2;
          case 2:
            return [2, t3];
        }
      });
    });
  }, t2.prototype.dataSync = function() {
    this.throwIfDisposed();
    var t3 = ht().readSync(this.dataId);
    if ("string" === this.dtype)
      try {
        return t3.map(function(t4) {
          return Z(t4);
        });
      } catch (t4) {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
    return t3;
  }, t2.prototype.bytes = function() {
    return n(this, void 0, void 0, function() {
      var t3;
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return this.throwIfDisposed(), [4, ht().read(this.dataId)];
          case 1:
            return t3 = e2.sent(), "string" === this.dtype ? [2, t3] : [2, new Uint8Array(t3.buffer)];
        }
      });
    });
  }, t2.prototype.dispose = function() {
    this.isDisposed || (ht().disposeTensor(this), this.isDisposedInternal = true);
  }, Object.defineProperty(t2.prototype, "isDisposed", {get: function() {
    return this.isDisposedInternal;
  }, enumerable: true, configurable: true}), t2.prototype.throwIfDisposed = function() {
    if (this.isDisposed)
      throw new Error("Tensor is disposed.");
  }, t2.prototype.toFloat = function() {
    return this.asType("float32");
  }, t2.prototype.toInt = function() {
    return this.asType("int32");
  }, t2.prototype.toBool = function() {
    return this.asType("bool");
  }, t2.prototype.print = function(t3) {
    return void 0 === t3 && (t3 = false), ft.print(this, t3);
  }, t2.prototype.reshape = function(t3) {
    return this.throwIfDisposed(), ft.reshape(this, t3);
  }, t2.prototype.reshapeAs = function(t3) {
    return this.throwIfDisposed(), this.reshape(t3.shape);
  }, t2.prototype.expandDims = function(t3) {
    return void 0 === t3 && (t3 = 0), ft.expandDims(this, t3);
  }, t2.prototype.cumsum = function(t3, e2, n2) {
    return void 0 === t3 && (t3 = 0), void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = false), ft.cumsum(this, t3, e2, n2);
  }, t2.prototype.squeeze = function(t3) {
    return this.throwIfDisposed(), ft.squeeze(this, t3);
  }, t2.prototype.clone = function() {
    return this.throwIfDisposed(), ft.clone(this);
  }, t2.prototype.oneHot = function(t3, e2, n2) {
    return this.throwIfDisposed(), ft.oneHot(this, t3, e2, n2);
  }, t2.prototype.toString = function(t3) {
    return void 0 === t3 && (t3 = false), it(this.dataSync(), this.shape, this.dtype, t3);
  }, t2.prototype.tile = function(t3) {
    return this.throwIfDisposed(), ft.tile(this, t3);
  }, t2.prototype.gather = function(t3, e2) {
    return void 0 === e2 && (e2 = 0), this.throwIfDisposed(), ft.gather(this, t3, e2);
  }, t2.prototype.matMul = function(t3, e2, n2) {
    return void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = false), this.throwIfDisposed(), ft.matMul(this, t3, e2, n2);
  }, t2.prototype.dot = function(t3) {
    return this.throwIfDisposed(), ft.dot(this, t3);
  }, t2.prototype.norm = function(t3, e2, n2) {
    return void 0 === t3 && (t3 = "euclidean"), void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false), this.throwIfDisposed(), ft.norm(this, t3, e2, n2);
  }, t2.prototype.slice = function(t3, e2) {
    return this.throwIfDisposed(), ft.slice(this, t3, e2);
  }, t2.prototype.reverse = function(t3) {
    return this.throwIfDisposed(), ft.reverse(this, t3);
  }, t2.prototype.concat = function(e2, n2) {
    return void 0 === n2 && (n2 = 0), this.throwIfDisposed(), e2 instanceof t2 && (e2 = [e2]), ft.concat([this].concat(e2), n2);
  }, t2.prototype.split = function(t3, e2) {
    return void 0 === e2 && (e2 = 0), this.throwIfDisposed(), ft.split(this, t3, e2);
  }, t2.prototype.stack = function(t3, e2) {
    return void 0 === e2 && (e2 = 0), ft.stack([this, t3], e2);
  }, t2.prototype.unstack = function(t3) {
    return void 0 === t3 && (t3 = 0), ft.unstack(this, t3);
  }, t2.prototype.pad = function(t3, e2) {
    return void 0 === e2 && (e2 = 0), ft.pad(this, t3, e2);
  }, t2.prototype.batchNormalization = function(t3, e2, n2, r2, o2) {
    return void 0 === n2 && (n2 = 1e-3), pt("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"), this.batchNorm(t3, e2, o2, r2, n2);
  }, t2.prototype.batchNorm = function(t3, e2, n2, r2, o2) {
    return void 0 === o2 && (o2 = 1e-3), this.throwIfDisposed(), ft.batchNorm(this, t3, e2, n2, r2, o2);
  }, t2.prototype.all = function(t3, e2) {
    return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.all(this, t3, e2);
  }, t2.prototype.any = function(t3, e2) {
    return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.any(this, t3, e2);
  }, t2.prototype.logSumExp = function(t3, e2) {
    return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.logSumExp(this, t3, e2);
  }, t2.prototype.sum = function(t3, e2) {
    return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.sum(this, t3, e2);
  }, t2.prototype.prod = function(t3, e2) {
    return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.prod(this, t3, e2);
  }, t2.prototype.mean = function(t3, e2) {
    return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.mean(this, t3, e2);
  }, t2.prototype.min = function(t3, e2) {
    return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.min(this, t3, e2);
  }, t2.prototype.max = function(t3, e2) {
    return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.max(this, t3, e2);
  }, t2.prototype.argMin = function(t3) {
    return void 0 === t3 && (t3 = null), this.throwIfDisposed(), ft.argMin(this, t3);
  }, t2.prototype.argMax = function(t3) {
    return void 0 === t3 && (t3 = null), this.throwIfDisposed(), ft.argMax(this, t3);
  }, t2.prototype.cast = function(t3) {
    return this.throwIfDisposed(), ft.cast(this, t3);
  }, t2.prototype.add = function(t3) {
    return this.throwIfDisposed(), ft.add(this, t3);
  }, t2.prototype.addStrict = function(t3) {
    return this.throwIfDisposed(), ft.addStrict(this, t3);
  }, t2.prototype.atan2 = function(t3) {
    return this.throwIfDisposed(), ft.atan2(this, t3);
  }, t2.prototype.sub = function(t3) {
    return this.throwIfDisposed(), ft.sub(this, t3);
  }, t2.prototype.subStrict = function(t3) {
    return this.throwIfDisposed(), ft.subStrict(this, t3);
  }, t2.prototype.pow = function(t3) {
    return this.throwIfDisposed(), ft.pow(this, t3);
  }, t2.prototype.powStrict = function(t3) {
    return this.throwIfDisposed(), ft.powStrict(this, t3);
  }, t2.prototype.mul = function(t3) {
    return this.throwIfDisposed(), ft.mul(this, t3);
  }, t2.prototype.mulStrict = function(t3) {
    return this.throwIfDisposed(), ft.mulStrict(this, t3);
  }, t2.prototype.div = function(t3) {
    return this.throwIfDisposed(), ft.div(this, t3);
  }, t2.prototype.divNoNan = function(t3) {
    return this.throwIfDisposed(), ft.divNoNan(this, t3);
  }, t2.prototype.floorDiv = function(t3) {
    return this.throwIfDisposed(), ft.floorDiv(this, t3);
  }, t2.prototype.divStrict = function(t3) {
    return this.throwIfDisposed(), ft.divStrict(this, t3);
  }, t2.prototype.minimum = function(t3) {
    return this.throwIfDisposed(), ft.minimum(this, t3);
  }, t2.prototype.minimumStrict = function(t3) {
    return this.throwIfDisposed(), ft.minimumStrict(this, t3);
  }, t2.prototype.maximum = function(t3) {
    return this.throwIfDisposed(), ft.maximum(this, t3);
  }, t2.prototype.maximumStrict = function(t3) {
    return this.throwIfDisposed(), ft.maximumStrict(this, t3);
  }, t2.prototype.mod = function(t3) {
    return this.throwIfDisposed(), ft.mod(this, t3);
  }, t2.prototype.modStrict = function(t3) {
    return this.throwIfDisposed(), ft.modStrict(this, t3);
  }, t2.prototype.squaredDifference = function(t3) {
    return this.throwIfDisposed(), ft.squaredDifference(this, t3);
  }, t2.prototype.squaredDifferenceStrict = function(t3) {
    return this.throwIfDisposed(), ft.squaredDifferenceStrict(this, t3);
  }, t2.prototype.transpose = function(t3) {
    return this.throwIfDisposed(), ft.transpose(this, t3);
  }, t2.prototype.notEqual = function(t3) {
    return this.throwIfDisposed(), ft.notEqual(this, t3);
  }, t2.prototype.notEqualStrict = function(t3) {
    return this.throwIfDisposed(), ft.notEqualStrict(this, t3);
  }, t2.prototype.less = function(t3) {
    return this.throwIfDisposed(), ft.less(this, t3);
  }, t2.prototype.lessStrict = function(t3) {
    return this.throwIfDisposed(), ft.lessStrict(this, t3);
  }, t2.prototype.equal = function(t3) {
    return this.throwIfDisposed(), ft.equal(this, t3);
  }, t2.prototype.equalStrict = function(t3) {
    return this.throwIfDisposed(), ft.equalStrict(this, t3);
  }, t2.prototype.lessEqual = function(t3) {
    return this.throwIfDisposed(), ft.lessEqual(this, t3);
  }, t2.prototype.lessEqualStrict = function(t3) {
    return this.throwIfDisposed(), ft.lessEqualStrict(this, t3);
  }, t2.prototype.greater = function(t3) {
    return this.throwIfDisposed(), ft.greater(this, t3);
  }, t2.prototype.greaterStrict = function(t3) {
    return this.throwIfDisposed(), ft.greaterStrict(this, t3);
  }, t2.prototype.greaterEqual = function(t3) {
    return this.throwIfDisposed(), ft.greaterEqual(this, t3);
  }, t2.prototype.greaterEqualStrict = function(t3) {
    return this.throwIfDisposed(), ft.greaterEqualStrict(this, t3);
  }, t2.prototype.logicalAnd = function(t3) {
    return this.throwIfDisposed(), ft.logicalAnd(this, t3);
  }, t2.prototype.logicalOr = function(t3) {
    return this.throwIfDisposed(), ft.logicalOr(this, t3);
  }, t2.prototype.logicalNot = function() {
    return this.throwIfDisposed(), ft.logicalNot(this);
  }, t2.prototype.logicalXor = function(t3) {
    return this.throwIfDisposed(), ft.logicalXor(this, t3);
  }, t2.prototype.where = function(t3, e2) {
    return this.throwIfDisposed(), ft.where(t3, this, e2);
  }, t2.prototype.neg = function() {
    return this.throwIfDisposed(), ft.neg(this);
  }, t2.prototype.ceil = function() {
    return this.throwIfDisposed(), ft.ceil(this);
  }, t2.prototype.floor = function() {
    return this.throwIfDisposed(), ft.floor(this);
  }, t2.prototype.sign = function() {
    return this.throwIfDisposed(), ft.sign(this);
  }, t2.prototype.isNaN = function() {
    return this.throwIfDisposed(), ft.isNaN(this);
  }, t2.prototype.isInf = function() {
    return this.throwIfDisposed(), ft.isInf(this);
  }, t2.prototype.isFinite = function() {
    return this.throwIfDisposed(), ft.isFinite(this);
  }, t2.prototype.exp = function() {
    return this.throwIfDisposed(), ft.exp(this);
  }, t2.prototype.expm1 = function() {
    return this.throwIfDisposed(), ft.expm1(this);
  }, t2.prototype.log = function() {
    return this.throwIfDisposed(), ft.log(this);
  }, t2.prototype.log1p = function() {
    return this.throwIfDisposed(), ft.log1p(this);
  }, t2.prototype.sqrt = function() {
    return this.throwIfDisposed(), ft.sqrt(this);
  }, t2.prototype.rsqrt = function() {
    return this.throwIfDisposed(), ft.rsqrt(this);
  }, t2.prototype.square = function() {
    return this.throwIfDisposed(), ft.square(this);
  }, t2.prototype.reciprocal = function() {
    return this.throwIfDisposed(), ft.reciprocal(this);
  }, t2.prototype.abs = function() {
    return this.throwIfDisposed(), ft.abs(this);
  }, t2.prototype.clipByValue = function(t3, e2) {
    return this.throwIfDisposed(), ft.clipByValue(this, t3, e2);
  }, t2.prototype.relu = function() {
    return this.throwIfDisposed(), ft.relu(this);
  }, t2.prototype.relu6 = function() {
    return this.throwIfDisposed(), ft.relu6(this);
  }, t2.prototype.elu = function() {
    return this.throwIfDisposed(), ft.elu(this);
  }, t2.prototype.selu = function() {
    return this.throwIfDisposed(), ft.selu(this);
  }, t2.prototype.leakyRelu = function(t3) {
    return void 0 === t3 && (t3 = 0.2), this.throwIfDisposed(), ft.leakyRelu(this, t3);
  }, t2.prototype.prelu = function(t3) {
    return this.throwIfDisposed(), ft.prelu(this, t3);
  }, t2.prototype.sigmoid = function() {
    return this.throwIfDisposed(), ft.sigmoid(this);
  }, t2.prototype.logSigmoid = function() {
    return this.throwIfDisposed(), ft.logSigmoid(this);
  }, t2.prototype.softplus = function() {
    return this.throwIfDisposed(), ft.softplus(this);
  }, t2.prototype.zerosLike = function() {
    return this.throwIfDisposed(), ft.zerosLike(this);
  }, t2.prototype.onesLike = function() {
    return this.throwIfDisposed(), ft.onesLike(this);
  }, t2.prototype.sin = function() {
    return this.throwIfDisposed(), ft.sin(this);
  }, t2.prototype.cos = function() {
    return this.throwIfDisposed(), ft.cos(this);
  }, t2.prototype.tan = function() {
    return this.throwIfDisposed(), ft.tan(this);
  }, t2.prototype.asin = function() {
    return this.throwIfDisposed(), ft.asin(this);
  }, t2.prototype.acos = function() {
    return this.throwIfDisposed(), ft.acos(this);
  }, t2.prototype.atan = function() {
    return this.throwIfDisposed(), ft.atan(this);
  }, t2.prototype.sinh = function() {
    return this.throwIfDisposed(), ft.sinh(this);
  }, t2.prototype.cosh = function() {
    return this.throwIfDisposed(), ft.cosh(this);
  }, t2.prototype.tanh = function() {
    return this.throwIfDisposed(), ft.tanh(this);
  }, t2.prototype.asinh = function() {
    return this.throwIfDisposed(), ft.asinh(this);
  }, t2.prototype.acosh = function() {
    return this.throwIfDisposed(), ft.acosh(this);
  }, t2.prototype.atanh = function() {
    return this.throwIfDisposed(), ft.atanh(this);
  }, t2.prototype.erf = function() {
    return this.throwIfDisposed(), ft.erf(this);
  }, t2.prototype.round = function() {
    return this.throwIfDisposed(), ft.round(this);
  }, t2.prototype.step = function(t3) {
    return void 0 === t3 && (t3 = 0), this.throwIfDisposed(), ft.step(this, t3);
  }, t2.prototype.softmax = function(t3) {
    return void 0 === t3 && (t3 = -1), this.throwIfDisposed(), ft.softmax(this, t3);
  }, t2.prototype.logSoftmax = function(t3) {
    return void 0 === t3 && (t3 = -1), this.throwIfDisposed(), ft.logSoftmax(this, t3);
  }, t2.prototype.resizeBilinear = function(t3, e2) {
    return void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.image.resizeBilinear(this, t3, e2);
  }, t2.prototype.resizeNearestNeighbor = function(t3, e2) {
    return void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.image.resizeNearestNeighbor(this, t3, e2);
  }, t2.prototype.conv1d = function(t3, e2, n2, r2, o2, a2) {
    return void 0 === r2 && (r2 = "NWC"), void 0 === o2 && (o2 = 1), this.throwIfDisposed(), ft.conv1d(this, t3, e2, n2, r2, o2, a2);
  }, t2.prototype.conv2d = function(t3, e2, n2, r2, o2, a2) {
    return void 0 === r2 && (r2 = "NHWC"), void 0 === o2 && (o2 = [1, 1]), this.throwIfDisposed(), ft.conv2d(this, t3, e2, n2, r2, o2, a2);
  }, t2.prototype.conv2dTranspose = function(t3, e2, n2, r2, o2) {
    return this.throwIfDisposed(), ft.conv2dTranspose(this, t3, e2, n2, r2, o2);
  }, t2.prototype.depthwiseConv2D = function(t3, e2, n2, r2, o2, a2) {
    return void 0 === r2 && (r2 = "NHWC"), void 0 === o2 && (o2 = [1, 1]), this.throwIfDisposed(), ft.depthwiseConv2d(this, t3, e2, n2, r2, o2, a2);
  }, t2.prototype.separableConv2d = function(t3, e2, n2, r2, o2, a2) {
    return void 0 === o2 && (o2 = [1, 1]), void 0 === a2 && (a2 = "NHWC"), this.throwIfDisposed(), ft.separableConv2d(this, t3, e2, n2, r2, o2, a2);
  }, t2.prototype.avgPool = function(t3, e2, n2, r2) {
    return this.throwIfDisposed(), ft.avgPool(this, t3, e2, n2, r2);
  }, t2.prototype.maxPool = function(t3, e2, n2, r2) {
    return this.throwIfDisposed(), ft.maxPool(this, t3, e2, n2, r2);
  }, t2.prototype.localResponseNormalization = function(t3, e2, n2, r2) {
    return void 0 === t3 && (t3 = 5), void 0 === e2 && (e2 = 1), void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = 0.5), ft.localResponseNormalization(this, t3, e2, n2, r2);
  }, t2.prototype.pool = function(t3, e2, n2, r2, o2) {
    return this.throwIfDisposed(), ft.pool(this, t3, e2, n2, r2, o2);
  }, t2.prototype.variable = function(t3, e2, n2) {
    return void 0 === t3 && (t3 = true), this.throwIfDisposed(), ht().makeVariable(this, t3, e2, n2);
  }, t2.prototype.unsortedSegmentSum = function(t3, e2) {
    return this.throwIfDisposed(), ft.unsortedSegmentSum(this, t3, e2);
  }, t2.prototype.batchToSpaceND = function(t3, e2) {
    return this.throwIfDisposed(), ft.batchToSpaceND(this, t3, e2);
  }, t2.prototype.spaceToBatchND = function(t3, e2) {
    return this.throwIfDisposed(), ft.spaceToBatchND(this, t3, e2);
  }, t2.prototype.topk = function(t3, e2) {
    return void 0 === t3 && (t3 = 1), void 0 === e2 && (e2 = true), this.throwIfDisposed(), ft.topk(this, t3, e2);
  }, t2.prototype.stridedSlice = function(t3, e2, n2, r2, o2, a2, i2, u2) {
    return void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = 0), void 0 === a2 && (a2 = 0), void 0 === i2 && (i2 = 0), void 0 === u2 && (u2 = 0), this.throwIfDisposed(), ft.stridedSlice(this, t3, e2, n2, r2, o2, a2, i2, u2);
  }, t2.prototype.depthToSpace = function(t3, e2) {
    return this.throwIfDisposed(), ft.depthToSpace(this, t3, e2);
  }, t2.prototype.fft = function() {
    return this.throwIfDisposed(), ft.spectral.fft(this);
  }, t2.prototype.ifft = function() {
    return this.throwIfDisposed(), ft.spectral.ifft(this);
  }, t2.prototype.rfft = function() {
    return this.throwIfDisposed(), ft.spectral.rfft(this);
  }, t2.prototype.irfft = function() {
    return this.throwIfDisposed(), ft.spectral.irfft(this);
  }, t2;
}();
Object.defineProperty(dt, Symbol.hasInstance, {value: function(t2) {
  return !!t2 && null != t2.dataId && null != t2.shape && null != t2.dtype;
}});
var vt;
var mt;
var gt;
var yt;
var xt;
var bt = function(t2) {
  function n2(e2, n3, r2, o2) {
    var a2 = t2.call(this, e2.shape, e2.dtype, e2.dataId, o2) || this;
    return a2.trainable = n3, a2.name = r2, a2;
  }
  return e(n2, t2), n2.prototype.assign = function(t3) {
    if (t3.dtype !== this.dtype)
      throw new Error("dtype of the new value (" + t3.dtype + ") and previous value (" + this.dtype + ") must match");
    if (!C(t3.shape, this.shape))
      throw new Error("shape of the new value (" + t3.shape + ") and previous value (" + this.shape + ") must match");
    ht().disposeTensor(this), this.dataId = t3.dataId, ht().incRef(this, null);
  }, n2.prototype.dispose = function() {
    ht().disposeVariable(this), this.isDisposedInternal = true;
  }, n2;
}(dt);
Object.defineProperty(bt, Symbol.hasInstance, {value: function(t2) {
  return t2 instanceof dt && null != t2.assign && t2.assign instanceof Function;
}}), function(t2) {
  t2.R0 = "R0", t2.R1 = "R1", t2.R2 = "R2", t2.R3 = "R3", t2.R4 = "R4", t2.R5 = "R5", t2.R6 = "R6";
}(vt || (vt = {})), function(t2) {
  t2.float32 = "float32", t2.int32 = "int32", t2.bool = "int32", t2.complex64 = "complex64";
}(mt || (mt = {})), function(t2) {
  t2.float32 = "float32", t2.int32 = "int32", t2.bool = "bool", t2.complex64 = "complex64";
}(gt || (gt = {})), function(t2) {
  t2.float32 = "float32", t2.int32 = "float32", t2.bool = "float32", t2.complex64 = "complex64";
}(yt || (yt = {})), function(t2) {
  t2.float32 = "complex64", t2.int32 = "complex64", t2.bool = "complex64", t2.complex64 = "complex64";
}(xt || (xt = {}));
var wt = {float32: yt, int32: mt, bool: gt, complex64: xt};
function Ct(t2, e2) {
  if ("string" === t2 || "string" === e2) {
    if ("string" === t2 && "string" === e2)
      return "string";
    throw new Error("Can not upcast " + t2 + " with " + e2);
  }
  return wt[t2][e2];
}
function Et(t2) {
  return Ct(t2, "int32");
}
function Rt(t2, e2) {
  if (t2.dtype === e2.dtype)
    return [t2, e2];
  var n2 = Ct(t2.dtype, e2.dtype);
  return [t2.cast(n2), e2.cast(n2)];
}
function It(t2, e2) {
  g(t2.dtype === e2.dtype, function() {
    return "The dtypes of the first(" + t2.dtype + ") and second(" + e2.dtype + ") input must match";
  });
}
function kt(t2) {
  var e2 = [];
  return function t3(e3, n2, r2) {
    if (null == e3)
      return;
    if (e3 instanceof dt)
      return void n2.push(e3);
    if (o2 = e3, !Array.isArray(o2) && "object" != typeof o2)
      return;
    var o2;
    var a2 = e3;
    for (var i2 in a2) {
      var u2 = a2[i2];
      r2.has(u2) || (r2.add(u2), t3(u2, n2, r2));
    }
  }(t2, e2, new Set()), e2;
}
var St;
var At = Object.freeze({makeTypesMatch: Rt, assertTypesMatch: It, isTensorInList: function(t2, e2) {
  for (var n2 = 0; n2 < e2.length; n2++)
    if (e2[n2].id === t2.id)
      return true;
  return false;
}, getTensorsInContainer: kt});
var Dt = function() {
  function t2() {
    this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap(), this.profiling = false, this.activeProfile = {newBytes: 0, newTensors: 0, peakBytes: 0, kernels: [], result: null};
  }
  return t2.prototype.dispose = function() {
    for (var t3 in this.registeredVariables)
      this.registeredVariables[t3].dispose();
  }, t2;
}();
var Tt = function() {
  function t2(t3) {
    this.ENV = t3, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new Dt();
  }
  return t2.prototype.ready = function() {
    return n(this, void 0, void 0, function() {
      var t3, e2, n2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (null != this.pendingBackendInit)
              return [2, this.pendingBackendInit.then(function() {
              })];
            if (null != this.backendInstance)
              return [2];
            t3 = this.getSortedBackends(), e2 = 0, r2.label = 1;
          case 1:
            return e2 < t3.length ? (n2 = t3[e2], [4, this.initializeBackend(n2).success]) : [3, 5];
          case 2:
            return r2.sent() ? [4, this.setBackend(n2)] : [3, 4];
          case 3:
            return r2.sent(), [2];
          case 4:
            return e2++, [3, 1];
          case 5:
            throw new Error("Could not initialize any backends, all backend initializations failed.");
        }
      });
    });
  }, Object.defineProperty(t2.prototype, "backend", {get: function() {
    if (null != this.pendingBackendInit)
      throw new Error("Backend '" + this.backendName + "' has not yet been initialized. Make sure to await tf.ready() before calling other methods");
    if (null == this.backendInstance) {
      var t3 = this.initializeBackendsAndReturnBest(), e2 = t3.name;
      if (t3.asyncInit)
        throw new Error("The highest priority backend '" + e2 + "' has not yet been initialized. Make sure to await tf.ready() before calling other methods");
      this.setBackend(e2);
    }
    return this.backendInstance;
  }, enumerable: true, configurable: true}), t2.prototype.backendNames = function() {
    return Object.keys(this.registryFactory);
  }, t2.prototype.findBackend = function(t3) {
    if (!(t3 in this.registry)) {
      if (!(t3 in this.registryFactory))
        return null;
      if (this.initializeBackend(t3).asyncInit)
        return null;
    }
    return this.registry[t3];
  }, t2.prototype.findBackendFactory = function(t3) {
    return t3 in this.registryFactory ? this.registryFactory[t3].factory : null;
  }, t2.prototype.registerBackend = function(t3, e2, n2) {
    return void 0 === n2 && (n2 = 1), t3 in this.registryFactory ? (console.warn(t3 + " backend was already registered. Reusing existing backend factory."), false) : (this.registryFactory[t3] = {factory: e2, priority: n2}, true);
  }, t2.prototype.setBackend = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2, o2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (null == this.registryFactory[t3])
              throw new Error("Backend name '" + t3 + "' not found in registry");
            return this.backendName = t3, null != this.registry[t3] ? [3, 4] : (this.backendInstance = null, e2 = this.initializeBackend(t3), n2 = e2.success, e2.asyncInit ? [4, n2] : [3, 2]);
          case 1:
            return o2 = r2.sent(), [3, 3];
          case 2:
            o2 = n2, r2.label = 3;
          case 3:
            if (!o2)
              return [2, false];
            r2.label = 4;
          case 4:
            return this.backendInstance = this.registry[t3], this.setupRegisteredKernels(), this.profiler = new et(this.backendInstance), [2, true];
        }
      });
    });
  }, t2.prototype.setupRegisteredKernels = function() {
    var t3 = this;
    c(this.backendName).forEach(function(e2) {
      null != e2.setupFunc && e2.setupFunc(t3.backendInstance);
    });
  }, t2.prototype.disposeRegisteredKernels = function(t3) {
    var e2 = this;
    c(t3).forEach(function(n2) {
      null != n2.disposeFunc && n2.disposeFunc(e2.registry[t3]);
    });
  }, t2.prototype.initializeBackend = function(t3) {
    var e2 = this, n2 = this.registryFactory[t3];
    if (null == n2)
      throw new Error("Cannot initialize backend " + t3 + ", no registration found.");
    try {
      var r2 = n2.factory();
      if (Promise.resolve(r2) === r2) {
        var o2 = ++this.pendingBackendInitId, a2 = r2.then(function(n3) {
          return !(o2 < e2.pendingBackendInitId) && (e2.registry[t3] = n3, e2.pendingBackendInit = null, true);
        }).catch(function(n3) {
          return !(o2 < e2.pendingBackendInitId) && (e2.pendingBackendInit = null, console.warn("Initialization of backend " + t3 + " failed"), console.warn(n3.stack || n3.message), false);
        });
        return this.pendingBackendInit = a2, {success: a2, asyncInit: true};
      }
      return this.registry[t3] = r2, {success: true, asyncInit: false};
    } catch (e3) {
      return console.warn("Initialization of backend " + t3 + " failed"), console.warn(e3.stack || e3.message), {success: false, asyncInit: false};
    }
  }, t2.prototype.removeBackend = function(t3) {
    if (!(t3 in this.registryFactory))
      throw new Error(t3 + " backend not found in registry");
    this.backendName === t3 && null != this.pendingBackendInit && this.pendingBackendInitId++, t3 in this.registry && (this.disposeRegisteredKernels(t3), this.registry[t3].dispose(), delete this.registry[t3]), delete this.registryFactory[t3], this.backendName === t3 && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
  }, t2.prototype.getSortedBackends = function() {
    var t3 = this;
    if (0 === Object.keys(this.registryFactory).length)
      throw new Error("No backend found in registry.");
    return Object.keys(this.registryFactory).sort(function(e2, n2) {
      return t3.registryFactory[n2].priority - t3.registryFactory[e2].priority;
    });
  }, t2.prototype.initializeBackendsAndReturnBest = function() {
    for (var t3 = this.getSortedBackends(), e2 = 0; e2 < t3.length; e2++) {
      var n2 = t3[e2], r2 = this.initializeBackend(n2), o2 = r2.success, a2 = r2.asyncInit;
      if (a2 || o2)
        return {name: n2, asyncInit: a2};
    }
    throw new Error("Could not initialize any backends, all backend initializations failed.");
  }, t2.prototype.moveData = function(t3, e2) {
    var n2 = this.state.tensorInfo.get(e2), r2 = n2.backend, o2 = this.readSync(e2);
    r2.disposeData(e2), n2.backend = t3, t3.move(e2, o2, n2.shape, n2.dtype), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
  }, t2.prototype.tidy = function(t3, e2) {
    var n2, r2 = this, o2 = null;
    if (null == e2) {
      if ("function" != typeof t3)
        throw new Error("Please provide a function to tidy()");
      e2 = t3;
    } else {
      if ("string" != typeof t3 && !(t3 instanceof String))
        throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
      if ("function" != typeof e2)
        throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
      o2 = t3;
    }
    return this.scopedRun(function() {
      return r2.startScope(o2);
    }, function() {
      return r2.endScope(n2);
    }, function() {
      return (n2 = e2()) instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n2;
    });
  }, t2.prototype.scopedRun = function(t3, e2, n2) {
    t3();
    try {
      var r2 = n2();
      return e2(), r2;
    } catch (t4) {
      throw e2(), t4;
    }
  }, t2.prototype.nextTensorId = function() {
    return t2.nextTensorId++;
  }, t2.prototype.nextVariableId = function() {
    return t2.nextVariableId++;
  }, t2.prototype.clone = function(t3) {
    var e2 = this.makeTensorFromDataId(t3.dataId, t3.shape, t3.dtype), n2 = {x: t3};
    return this.addTapeNode(this.state.activeScope.name, n2, [e2], function(t4) {
      return {x: function() {
        return t4.toFloat();
      }};
    }, []), e2;
  }, t2.prototype.runKernel = function(t3, e2, n2, r2, o2) {
    return this.runKernelFunc(null, e2, null, t3, n2, r2, o2);
  }, t2.prototype.shouldCheckForMemLeaks = function() {
    return this.ENV.getBool("IS_TEST");
  }, t2.prototype.checkKernelForMemLeak = function(t3, e2, n2) {
    var r2 = this.backend.numDataIds(), o2 = 0;
    n2.forEach(function(t4) {
      o2 += "complex64" === t4.dtype ? 3 : 1;
    });
    var a2 = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], i2 = r2 - e2 - o2 - a2;
    if (i2 > 0)
      throw new Error("Backend '" + this.backendName + "' has an internal memory leak (" + i2 + " data ids) after running '" + t3 + "'");
  }, t2.prototype.runKernelFunc = function(t3, e2, n2, r2, o2, a2, i2) {
    var u2, c2 = this;
    void 0 === a2 && (a2 = []), void 0 === i2 && (i2 = []);
    var l2, h2 = [], f2 = this.isTapeOn(), p2 = null != this.state.activeScope ? this.state.activeScope.name : "", d2 = function(t4) {
      f2 && (h2 = t4.map(function(t5) {
        return c2.keep(c2.clone(t5));
      }));
    }, v2 = this.state.numBytes, m2 = this.state.numTensors;
    this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
    var g2, y2 = s(r2, this.backendName);
    return l2 = null != y2 ? function() {
      var t4 = c2.backend.numDataIds();
      g2 = y2.kernelFunc({inputs: e2, attrs: o2, backend: c2.backend});
      var n3 = Array.isArray(g2) ? g2 : [g2];
      c2.shouldCheckForMemLeaks() && c2.checkKernelForMemLeak(p2, t4, n3);
      var r3 = n3.map(function(t5) {
        var e3 = t5.dataId, n4 = t5.shape, r4 = t5.dtype;
        return c2.makeTensorFromDataId(e3, n4, r4);
      }), u3 = r3.filter(function(t5, e3) {
        return i2[e3];
      });
      return d2(a2.slice().concat(u3)), r3;
    } : function() {
      var e3 = c2.backend.numDataIds();
      g2 = c2.tidy(function() {
        return t3(c2.backend, d2);
      });
      var n3 = Array.isArray(g2) ? g2 : [g2];
      return c2.shouldCheckForMemLeaks() && c2.checkKernelForMemLeak(p2, e3, n3), n3;
    }, this.scopedRun(function() {
      return c2.state.kernelDepth++;
    }, function() {
      return c2.state.kernelDepth--;
    }, function() {
      u2 = c2.ENV.getBool("DEBUG") ? c2.profiler.profileKernel(p2, e2, function() {
        return l2();
      }) : l2();
    }), f2 && this.addTapeNode(p2, e2, u2, n2, h2), this.state.profiling && this.state.activeProfile.kernels.push({name: p2, bytesAdded: this.state.numBytes - v2, totalBytesSnapshot: this.state.numBytes, tensorsAdded: this.state.numTensors - m2, totalTensorsSnapshot: this.state.numTensors, inputShapes: Object.keys(e2).map(function(t4) {
      return e2[t4].shape;
    }), outputShapes: u2.map(function(t4) {
      return t4.shape;
    })}), Array.isArray(g2) ? u2 : u2[0];
  }, t2.prototype.makeTensor = function(t3, e2, n2, r2) {
    if (null == t3)
      throw new Error("Values passed to engine.makeTensor() are null");
    n2 = n2 || "float32", r2 = r2 || this.backend;
    var o2 = t3;
    "string" === n2 && W(t3[0]) && (o2 = t3.map(function(t4) {
      return J(t4);
    }));
    var a2 = r2.write(o2, e2, n2), i2 = new dt(e2, n2, a2, this.nextTensorId());
    if (this.incRef(i2, r2), "string" === n2) {
      var u2 = this.state.tensorInfo.get(a2), s2 = L(o2);
      this.state.numBytes += s2 - u2.bytes, u2.bytes = s2;
    }
    return i2;
  }, t2.prototype.makeTensorFromDataId = function(t3, e2, n2, r2) {
    var o2 = new dt(e2, n2 = n2 || "float32", t3, this.nextTensorId());
    return this.incRef(o2, r2), o2;
  }, t2.prototype.makeVariable = function(t3, e2, n2, r2) {
    void 0 === e2 && (e2 = true), n2 = n2 || this.nextVariableId().toString(), null != r2 && r2 !== t3.dtype && (t3 = t3.asType(r2));
    var o2 = new bt(t3, e2, n2, this.nextTensorId());
    if (null != this.state.registeredVariables[o2.name])
      throw new Error("Variable with name " + o2.name + " was already registered");
    return this.state.registeredVariables[o2.name] = o2, this.incRef(o2, this.backend), o2;
  }, t2.prototype.incRef = function(t3, e2) {
    var n2 = this.state.tensorInfo.has(t3.dataId) ? this.state.tensorInfo.get(t3.dataId).refCount : 0;
    if (this.state.numTensors++, "string" === t3.dtype && this.state.numStringTensors++, 0 === n2) {
      this.state.numDataBuffers++;
      var r2 = 0;
      "complex64" !== t3.dtype && "string" !== t3.dtype && (r2 = t3.size * P(t3.dtype)), this.state.tensorInfo.set(t3.dataId, {backend: e2 || this.backend, dtype: t3.dtype, shape: t3.shape, bytes: r2, refCount: 0}), this.state.numBytes += r2;
    }
    this.state.tensorInfo.get(t3.dataId).refCount++, t3 instanceof bt || this.track(t3);
  }, t2.prototype.disposeTensor = function(t3) {
    if (this.state.tensorInfo.has(t3.dataId)) {
      this.state.numTensors--, "string" === t3.dtype && this.state.numStringTensors--;
      var e2 = this.state.tensorInfo.get(t3.dataId);
      e2.refCount <= 1 ? ("complex64" !== t3.dtype && (this.state.numBytes -= e2.bytes), this.state.numDataBuffers--, e2.backend.disposeData(t3.dataId), this.state.tensorInfo.delete(t3.dataId)) : this.state.tensorInfo.get(t3.dataId).refCount--;
    }
  }, t2.prototype.disposeVariables = function() {
    for (var t3 in this.state.registeredVariables) {
      var e2 = this.state.registeredVariables[t3];
      this.disposeVariable(e2);
    }
  }, t2.prototype.disposeVariable = function(t3) {
    this.disposeTensor(t3), null != this.state.registeredVariables[t3.name] && delete this.state.registeredVariables[t3.name];
  }, t2.prototype.memory = function() {
    var t3 = this.backend.memory();
    return t3.numTensors = this.state.numTensors, t3.numDataBuffers = this.state.numDataBuffers, t3.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (t3.unreliable = true, null == t3.reasons && (t3.reasons = []), t3.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), t3;
  }, t2.prototype.profile = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2;
      return r(this, function(r2) {
        return this.state.profiling = true, e2 = this.state.numBytes, n2 = this.state.numTensors, this.state.activeProfile.kernels = [], this.state.activeProfile.result = t3(), this.state.profiling = false, this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map(function(t4) {
          return t4.totalBytesSnapshot;
        })), this.state.activeProfile.newBytes = this.state.numBytes - e2, this.state.activeProfile.newTensors = this.state.numTensors - n2, [2, this.state.activeProfile];
      });
    });
  }, t2.prototype.isTapeOn = function() {
    return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth;
  }, t2.prototype.addTapeNode = function(t3, e2, n2, r2, o2) {
    var a2 = this, i2 = {id: this.state.nextTapeNodeId++, name: t3, inputs: e2, outputs: n2, saved: o2};
    null != r2 && (i2.gradient = function(t4) {
      return t4 = t4.map(function(t5, e3) {
        if (null == t5) {
          var r3 = n2[e3], o3 = $(r3.size, r3.dtype);
          return a2.makeTensor(o3, r3.shape, r3.dtype);
        }
        return t5;
      }), r2(t4.length > 1 ? t4 : t4[0], o2);
    }), this.state.activeTape.push(i2);
  }, t2.prototype.keep = function(t3) {
    return t3.kept = true, t3;
  }, t2.prototype.startTape = function() {
    0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++;
  }, t2.prototype.endTape = function() {
    this.state.gradientDepth--;
  }, t2.prototype.startScope = function(t3) {
    var e2 = {track: [], name: "unnamed scope", id: this.state.nextScopeId++};
    t3 && (e2.name = t3), this.state.scopeStack.push(e2), this.state.activeScope = e2;
  }, t2.prototype.endScope = function(t3) {
    for (var e2 = this, n2 = kt(t3), r2 = new Set(n2.map(function(t4) {
      return t4.id;
    })), o2 = 0; o2 < this.state.activeScope.track.length; o2++) {
      var a2 = this.state.activeScope.track[o2];
      a2.kept || r2.has(a2.id) || a2.dispose();
    }
    var i2 = this.state.scopeStack.pop();
    this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n2.forEach(function(t4) {
      t4.kept || t4.scopeId !== i2.id || e2.track(t4);
    });
  }, t2.prototype.gradients = function(t3, e2, n2, r2) {
    var o2 = this;
    if (void 0 === r2 && (r2 = false), g(e2.length > 0, function() {
      return "gradients() received an empty list of xs.";
    }), null != n2 && "float32" !== n2.dtype)
      throw new Error("dy must have 'float32' dtype, but has '" + n2.dtype + "'");
    var a2 = this.scopedRun(function() {
      return o2.startTape();
    }, function() {
      return o2.endTape();
    }, function() {
      return o2.tidy("forward", t3);
    });
    g(a2 instanceof dt, function() {
      return "The result y returned by f() must be a tensor.";
    });
    var i2 = function(t4, e3, n3) {
      for (var r3 = {}, o3 = {}, a3 = 0; a3 < e3.length; a3++)
        r3[e3[a3].id] = true;
      for (a3 = 0; a3 < t4.length; a3++) {
        var i3 = (d2 = t4[a3]).inputs;
        for (var u2 in i3) {
          for (var s2 = i3[u2], c2 = false, l2 = 0; l2 < e3.length; l2++)
            if (r3[s2.id]) {
              d2.outputs.forEach(function(t5) {
                return r3[t5.id] = true;
              }), c2 = true, o3[d2.id] = true;
              break;
            }
          if (c2)
            break;
        }
      }
      var h2 = {};
      h2[n3.id] = true;
      var f2 = {};
      for (a3 = t4.length - 1; a3 >= 0; a3--)
        for (i3 = (d2 = t4[a3]).inputs, l2 = 0; l2 < d2.outputs.length; l2++)
          if (h2[d2.outputs[l2].id]) {
            for (var u2 in i3)
              h2[i3[u2].id] = true, f2[d2.id] = true;
            break;
          }
      var p2 = [];
      for (a3 = 0; a3 < t4.length; a3++) {
        var d2;
        if (o3[(d2 = t4[a3]).id] && f2[d2.id]) {
          var v2 = {};
          for (var u2 in d2.inputs) {
            var m2 = d2.inputs[u2];
            r3[m2.id] && (v2[u2] = m2);
          }
          var g2 = Object.assign({}, d2);
          g2.inputs = v2, g2.outputs = d2.outputs, p2.push(g2);
        }
      }
      return p2;
    }(this.state.activeTape, e2, a2);
    if (!r2 && 0 === i2.length && e2.length > 0)
      throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
    return this.tidy("backward", function() {
      var t4, r3, u2 = {};
      u2[a2.id] = null == n2 ? (t4 = a2.shape, r3 = X(w(t4), "float32"), Nt.makeTensor(r3, t4, "float32")) : n2, function(t5, e3, n3) {
        for (var r4 = function(r5) {
          var o4 = e3[r5], a3 = [];
          if (o4.outputs.forEach(function(e4) {
            var n4 = t5[e4.id];
            null != n4 ? a3.push(n4) : a3.push(null);
          }), null == o4.gradient)
            throw new Error("Cannot compute gradient: gradient function not found for " + o4.name + ".");
          var i3 = o4.gradient(a3), u3 = function(e4) {
            if (!(e4 in i3))
              throw new Error("Cannot backprop through input " + e4 + ". Available gradients found: " + Object.keys(i3) + ".");
            var r6 = n3(function() {
              return i3[e4]();
            });
            if ("float32" !== r6.dtype)
              throw new Error("Error in gradient for op " + o4.name + ". The gradient of input " + e4 + " must have 'float32' dtype, but has '" + r6.dtype + "'");
            var a4 = o4.inputs[e4];
            if (!C(r6.shape, a4.shape))
              throw new Error("Error in gradient for op " + o4.name + ". The gradient of input '" + e4 + "' has shape '" + r6.shape + "', which does not match the shape of the input '" + a4.shape + "'");
            if (null == t5[a4.id])
              t5[a4.id] = r6;
            else {
              var u4 = t5[a4.id];
              t5[a4.id] = u4.add(r6), u4.dispose();
            }
          };
          for (var s3 in o4.inputs)
            u3(s3);
        }, o3 = e3.length - 1; o3 >= 0; o3--)
          r4(o3);
      }(u2, i2, function(t5) {
        return o2.tidy(t5);
      });
      var s2 = e2.map(function(t5) {
        return u2[t5.id];
      });
      return 0 === o2.state.gradientDepth && (o2.state.activeTape.forEach(function(t5) {
        for (var e3 in t5.saved)
          t5.saved[e3].dispose();
      }), o2.state.activeTape = null), {value: a2, grads: s2};
    });
  }, t2.prototype.customGrad = function(t3) {
    var e2 = this;
    return g(G(t3), function() {
      return "The f passed in customGrad(f) must be a function.";
    }), function() {
      for (var n2, r2 = [], o2 = 0; o2 < arguments.length; o2++)
        r2[o2] = arguments[o2];
      g(r2.every(function(t4) {
        return t4 instanceof dt;
      }), function() {
        return "The args passed in customGrad(f)(x1, x2,...) must all be tensors";
      });
      var a2 = {};
      return r2.forEach(function(t4, e3) {
        a2[e3] = t4;
      }), e2.runKernelFunc(function(e3, o3) {
        return g((n2 = t3.apply(void 0, r2.concat([o3]))).value instanceof dt, function() {
          return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor";
        }), g(G(n2.gradFunc), function() {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.";
        }), n2.value;
      }, a2, function(t4, e3) {
        var o3 = n2.gradFunc(t4, e3), a3 = Array.isArray(o3) ? o3 : [o3];
        g(a3.length === r2.length, function() {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).";
        }), g(a3.every(function(t5) {
          return t5 instanceof dt;
        }), function() {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.";
        });
        var i2 = {};
        return a3.forEach(function(t5, e4) {
          i2[e4] = function() {
            return t5;
          };
        }), i2;
      });
    };
  }, t2.prototype.readSync = function(t3) {
    return this.state.tensorInfo.get(t3).backend.readSync(t3);
  }, t2.prototype.read = function(t3) {
    return this.state.tensorInfo.get(t3).backend.read(t3);
  }, t2.prototype.fromPixels = function(t3, e2) {
    return this.backend.fromPixels(t3, e2);
  }, t2.prototype.time = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            return e2 = Y(), [4, this.backend.time(t3)];
          case 1:
            return (n2 = r2.sent()).wallMs = Y() - e2, [2, n2];
        }
      });
    });
  }, t2.prototype.track = function(t3) {
    return null != this.state.activeScope && (t3.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(t3)), t3;
  }, Object.defineProperty(t2.prototype, "registeredVariables", {get: function() {
    return this.state.registeredVariables;
  }, enumerable: true, configurable: true}), t2.prototype.reset = function() {
    for (var t3 in (this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new Dt(), this.registry))
      this.disposeRegisteredKernels(t3), this.registry[t3].dispose(), delete this.registry[t3];
    this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
  }, t2.nextTensorId = 0, t2.nextVariableId = 0, t2;
}();
var Nt = function() {
  var t2 = function() {
    if (null == St) {
      var t3 = void 0;
      if ("undefined" != typeof window)
        t3 = window;
      else if ("undefined" != typeof global)
        t3 = global;
      else if ("undefined" != typeof process)
        t3 = process;
      else {
        if ("undefined" == typeof self)
          throw new Error("Could not find a global object");
        t3 = self;
      }
      St = t3;
    }
    return St;
  }();
  if (null == t2._tfengine) {
    var e2 = new o(t2);
    t2._tfengine = new Tt(e2);
  }
  return function(t3) {
    i = t3;
  }(t2._tfengine.ENV), ht = function() {
    return t2._tfengine;
  }, t2._tfengine;
}();
function Ft() {
  return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope;
}
var Ot = a();
Ot.registerFlag("DEBUG", function() {
  return false;
}, function(t2) {
  t2 && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
}), Ot.registerFlag("IS_BROWSER", function() {
  return Ft();
}), Ot.registerFlag("IS_NODE", function() {
  return "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node;
}), Ot.registerFlag("IS_CHROME", function() {
  return "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
}), Ot.registerFlag("PROD", function() {
  return false;
}), Ot.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", function() {
  return Ot.getBool("DEBUG");
}), Ot.registerFlag("DEPRECATION_WARNINGS_ENABLED", function() {
  return true;
}), Ot.registerFlag("IS_TEST", function() {
  return false;
});
var _t;
var Mt;
var Bt;
var Pt = {};
var Lt = {alpha: false, antialias: false, premultipliedAlpha: false, preserveDrawingBuffer: false, depth: false, stencil: false, failIfMajorPerformanceCaveat: true};
function Wt(t2, e2) {
  Pt[t2] = e2;
}
function Ut(t2) {
  t2 in Pt || (Pt[t2] = function(t3) {
    if (1 !== t3 && 2 !== t3)
      throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
    var e3 = Vt(t3);
    if (e3.addEventListener("webglcontextlost", function(e4) {
      e4.preventDefault(), delete Pt[t3];
    }, false), 1 === t3)
      return e3.getContext("webgl", Lt) || e3.getContext("experimental-webgl", Lt);
    return e3.getContext("webgl2", Lt);
  }(t2));
  var e2 = Pt[t2];
  return e2.isContextLost() ? (delete Pt[t2], Ut(t2)) : (e2.disable(e2.DEPTH_TEST), e2.disable(e2.STENCIL_TEST), e2.disable(e2.BLEND), e2.disable(e2.DITHER), e2.disable(e2.POLYGON_OFFSET_FILL), e2.disable(e2.SAMPLE_COVERAGE), e2.enable(e2.SCISSOR_TEST), e2.enable(e2.CULL_FACE), e2.cullFace(e2.BACK), Pt[t2]);
}
function Vt(t2) {
  if ("undefined" != typeof OffscreenCanvas && 2 === t2)
    return new OffscreenCanvas(300, 150);
  if ("undefined" != typeof document)
    return document.createElement("canvas");
  throw new Error("Cannot create a canvas in this context");
}
function zt(t2, e2) {
  return [e2, t2];
}
function Gt(t2) {
  var e2 = w(t2);
  return I(Math.ceil(e2 / 4));
}
function Ht(t2, e2) {
  return [Math.max(1, Math.ceil(e2 / 2)), Math.max(1, Math.ceil(t2 / 2))];
}
function qt(t2, e2) {
  var n2, r2, o2, i2, u2, s2, c2, l2, h2, f2 = t2;
  return 2 === a().getNumber("WEBGL_VERSION") ? (n2 = f2.R32F, r2 = f2.R16F, o2 = f2.RGBA16F, i2 = f2.RGBA32F, u2 = f2.RED, s2 = 4, c2 = 1, l2 = f2.HALF_FLOAT, h2 = f2.FLOAT) : (n2 = t2.RGBA, r2 = t2.RGBA, o2 = t2.RGBA, i2 = f2.RGBA, u2 = t2.RGBA, s2 = 4, c2 = 4, l2 = null != e2 ? e2.HALF_FLOAT_OES : null, h2 = t2.FLOAT), {internalFormatFloat: n2, internalFormatHalfFloat: r2, internalFormatPackedHalfFloat: o2, internalFormatPackedFloat: i2, textureFormatFloat: u2, downloadTextureFormat: t2.RGBA, downloadUnpackNumChannels: s2, defaultNumChannels: c2, textureTypeHalfFloat: l2, textureTypeFloat: h2};
}
function Kt(t2, e2, n2) {
  var r2 = n2();
  return e2 && function(t3) {
    var e3 = t3.getError();
    if (e3 !== t3.NO_ERROR)
      throw new Error("WebGL Error: " + Yt(t3, e3));
  }(t2), r2;
}
!function(t2) {
  t2[t2.DENSE = 0] = "DENSE", t2[t2.SHARED_BATCH = 1] = "SHARED_BATCH";
}(_t || (_t = {})), function(t2) {
  t2[t2.RENDER = 0] = "RENDER", t2[t2.UPLOAD = 1] = "UPLOAD", t2[t2.PIXELS = 2] = "PIXELS", t2[t2.DOWNLOAD = 3] = "DOWNLOAD";
}(Mt || (Mt = {})), function(t2) {
  t2[t2.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", t2[t2.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", t2[t2.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", t2[t2.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", t2[t2.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
}(Bt || (Bt = {}));
var jt = 596e-10;
var Xt = 65504;
function $t(t2) {
  return !!(a().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === t2 || jt < Math.abs(t2) && Math.abs(t2) < Xt);
}
function Yt(t2, e2) {
  switch (e2) {
    case t2.NO_ERROR:
      return "NO_ERROR";
    case t2.INVALID_ENUM:
      return "INVALID_ENUM";
    case t2.INVALID_VALUE:
      return "INVALID_VALUE";
    case t2.INVALID_OPERATION:
      return "INVALID_OPERATION";
    case t2.INVALID_FRAMEBUFFER_OPERATION:
      return "INVALID_FRAMEBUFFER_OPERATION";
    case t2.OUT_OF_MEMORY:
      return "OUT_OF_MEMORY";
    case t2.CONTEXT_LOST_WEBGL:
      return "CONTEXT_LOST_WEBGL";
    default:
      return "Unknown error code " + e2;
  }
}
function Qt(t2, e2, n2) {
  return be(t2, e2, function() {
    return t2.getExtension(n2);
  }, 'Extension "' + n2 + '" not supported on this browser.');
}
function Jt(t2, e2, n2) {
  var r2 = be(t2, e2, function() {
    return t2.createShader(t2.VERTEX_SHADER);
  }, "Unable to create vertex WebGLShader.");
  if (Kt(t2, e2, function() {
    return t2.shaderSource(r2, n2);
  }), Kt(t2, e2, function() {
    return t2.compileShader(r2);
  }), false === t2.getShaderParameter(r2, t2.COMPILE_STATUS))
    throw console.log(t2.getShaderInfoLog(r2)), new Error("Failed to compile vertex shader.");
  return r2;
}
function Zt(t2, e2, n2) {
  var r2 = be(t2, e2, function() {
    return t2.createShader(t2.FRAGMENT_SHADER);
  }, "Unable to create fragment WebGLShader.");
  if (Kt(t2, e2, function() {
    return t2.shaderSource(r2, n2);
  }), Kt(t2, e2, function() {
    return t2.compileShader(r2);
  }), false === t2.getShaderParameter(r2, t2.COMPILE_STATUS))
    throw function(t3, e3) {
      var n3 = ne.exec(e3);
      if (null == n3)
        return console.log("Couldn't parse line number in error: " + e3), void console.log(t3);
      for (var r3 = +n3[1], o2 = t3.split("\n"), a2 = o2.length.toString().length + 2, i2 = o2.map(function(t4, e4) {
        return k((e4 + 1).toString(), a2) + t4;
      }), u2 = 0, s2 = 0; s2 < i2.length; s2++)
        u2 = Math.max(i2[s2].length, u2);
      var c2 = i2.slice(0, r3 - 1), l2 = i2.slice(r3 - 1, r3), h2 = i2.slice(r3);
      console.log(c2.join("\n")), console.log(e3.split("\n")[0]), console.log("%c " + k(l2[0], u2), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(h2.join("\n"));
    }(n2, t2.getShaderInfoLog(r2)), new Error("Failed to compile fragment shader.");
  return r2;
}
var te;
var ee;
var ne = /ERROR: [0-9]+:([0-9]+):/g;
function re(t2, e2) {
  return be(t2, e2, function() {
    return t2.createProgram();
  }, "Unable to create WebGLProgram.");
}
function oe(t2, e2, n2) {
  if (Kt(t2, e2, function() {
    return t2.linkProgram(n2);
  }), false === t2.getProgramParameter(n2, t2.LINK_STATUS))
    throw console.log(t2.getProgramInfoLog(n2)), new Error("Failed to link vertex and fragment shaders.");
}
function ae(t2, e2, n2) {
  if (Kt(t2, e2, function() {
    return t2.validateProgram(n2);
  }), false === t2.getProgramParameter(n2, t2.VALIDATE_STATUS))
    throw console.log(t2.getProgramInfoLog(n2)), new Error("Shader program validation failed.");
}
function ie(t2, e2, n2) {
  var r2 = be(t2, e2, function() {
    return t2.createBuffer();
  }, "Unable to create WebGLBuffer");
  return Kt(t2, e2, function() {
    return t2.bindBuffer(t2.ARRAY_BUFFER, r2);
  }), Kt(t2, e2, function() {
    return t2.bufferData(t2.ARRAY_BUFFER, n2, t2.STATIC_DRAW);
  }), r2;
}
function ue(t2, e2, n2) {
  var r2 = be(t2, e2, function() {
    return t2.createBuffer();
  }, "Unable to create WebGLBuffer");
  return Kt(t2, e2, function() {
    return t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, r2);
  }), Kt(t2, e2, function() {
    return t2.bufferData(t2.ELEMENT_ARRAY_BUFFER, n2, t2.STATIC_DRAW);
  }), r2;
}
function se(t2, e2) {
  return be(t2, e2, function() {
    return t2.createTexture();
  }, "Unable to create WebGLTexture.");
}
function ce(t2, e2) {
  var n2 = a().getNumber("WEBGL_MAX_TEXTURE_SIZE");
  if (t2 <= 0 || e2 <= 0) {
    var r2 = "[" + t2 + "x" + e2 + "]";
    throw new Error("Requested texture size " + r2 + " is invalid.");
  }
  if (t2 > n2 || e2 > n2) {
    r2 = "[" + t2 + "x" + e2 + "]";
    throw new Error("Requested texture size " + r2 + " greater than WebGL maximum on this browser / GPU " + ("[" + n2 + "x" + n2 + "]") + ".");
  }
}
function le(t2, e2) {
  return be(t2, e2, function() {
    return t2.createFramebuffer();
  }, "Unable to create WebGLFramebuffer.");
}
function he(t2, e2, n2, r2, o2, a2, i2, u2) {
  var s2 = t2.getAttribLocation(n2, r2);
  return -1 !== s2 && (Kt(t2, e2, function() {
    return t2.bindBuffer(t2.ARRAY_BUFFER, o2);
  }), Kt(t2, e2, function() {
    return t2.vertexAttribPointer(s2, a2, t2.FLOAT, false, i2, u2);
  }), Kt(t2, e2, function() {
    return t2.enableVertexAttribArray(s2);
  }), true);
}
function fe(t2, e2, n2, r2) {
  we(t2, r2), Kt(t2, e2, function() {
    return t2.activeTexture(t2.TEXTURE0 + r2);
  }), Kt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, n2);
  });
}
function pe(t2, e2, n2, r2) {
  return be(t2, e2, function() {
    return t2.getUniformLocation(n2, r2);
  }, 'uniform "' + r2 + '" not present in program.');
}
function de(t2, e2, n2) {
  return t2.getUniformLocation(e2, n2);
}
function ve(t2, e2, n2, r2, o2, a2) {
  Kt(t2, e2, function() {
    return fe(t2, e2, r2, a2);
  }), Kt(t2, e2, function() {
    return t2.uniform1i(o2, a2);
  });
}
function me(t2, e2, n2, r2) {
  Kt(t2, e2, function() {
    return t2.bindFramebuffer(t2.FRAMEBUFFER, r2);
  }), Kt(t2, e2, function() {
    return t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, n2, 0);
  });
}
function ge(t2, e2, n2) {
  Kt(t2, e2, function() {
    return t2.bindFramebuffer(t2.FRAMEBUFFER, n2);
  }), Kt(t2, e2, function() {
    return t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, null, 0);
  });
}
function ye(t2) {
  var e2 = t2.checkFramebufferStatus(t2.FRAMEBUFFER);
  if (e2 !== t2.FRAMEBUFFER_COMPLETE)
    throw new Error("Error binding framebuffer: " + xe(t2, e2));
}
function xe(t2, e2) {
  switch (e2) {
    case t2.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    case t2.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    case t2.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
      return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    case t2.FRAMEBUFFER_UNSUPPORTED:
      return "FRAMEBUFFER_UNSUPPORTED";
    default:
      return "unknown error " + e2;
  }
}
function be(t2, e2, n2, r2) {
  var o2 = Kt(t2, e2, function() {
    return n2();
  });
  if (null == o2)
    throw new Error(r2);
  return o2;
}
function we(t2, e2) {
  var n2 = t2.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, r2 = e2 + t2.TEXTURE0;
  if (r2 < t2.TEXTURE0 || r2 > n2)
    throw new Error("textureUnit must be in " + ("[gl.TEXTURE0, gl.TEXTURE" + n2 + "]") + ".");
}
function Ce(t2, e2) {
  return void 0 === e2 && (e2 = 2), w(t2.slice(0, t2.length - e2));
}
function Ee(t2) {
  if (0 === t2.length)
    throw Error("Cannot get rows and columns of an empty shape array.");
  return [t2.length > 1 ? t2[t2.length - 2] : 1, t2[t2.length - 1]];
}
function Re(t2) {
  var e2 = [1, 1, 1];
  return 0 === t2.length || 1 === t2.length && 1 === t2[0] || (e2 = [Ce(t2)].concat(Ee(t2))), e2;
}
function Ie(t2, e2) {
  var n2;
  void 0 === e2 && (e2 = false);
  var r2 = a().getNumber("WEBGL_MAX_TEXTURE_SIZE");
  if (e2 && (r2 *= 2, 1 === (t2 = t2.map(function(e3, n3) {
    return n3 >= t2.length - 2 ? v(t2[n3]) : t2[n3];
  })).length && (t2 = [2, t2[0]])), 2 !== t2.length) {
    var o2 = T(t2);
    t2 = o2.newShape;
  }
  var i2 = w(t2);
  if (t2.length <= 1 && i2 <= r2)
    return [1, i2];
  if (2 === t2.length && t2[0] <= r2 && t2[1] <= r2)
    return t2;
  if (3 === t2.length && t2[0] * t2[1] <= r2 && t2[2] <= r2)
    return [t2[0] * t2[1], t2[2]];
  if (3 === t2.length && t2[0] <= r2 && t2[1] * t2[2] <= r2)
    return [t2[0], t2[1] * t2[2]];
  if (4 === t2.length && t2[0] * t2[1] * t2[2] <= r2 && t2[3] <= r2)
    return [t2[0] * t2[1] * t2[2], t2[3]];
  if (4 === t2.length && t2[0] <= r2 && t2[1] * t2[2] * t2[3] <= r2)
    return [t2[0], t2[1] * t2[2] * t2[3]];
  if (e2) {
    var u2 = Ce(t2), s2 = 2, c2 = 2;
    return t2.length && (s2 = (n2 = Ee(t2))[0], c2 = n2[1]), I(i2 = u2 * (s2 / 2) * (c2 / 2)).map(function(t3) {
      return 2 * t3;
    });
  }
  return I(i2);
}
function ke(t2) {
  return t2 % 2 == 0;
}
function Se(t2, e2) {
  if (C(t2 = t2.slice(-2), e2 = e2.slice(-2)))
    return true;
  if (!t2.length || !e2.length)
    return true;
  if (0 === t2[0] || 0 === t2[1] || 0 === e2[0] || 0 === e2[1])
    return true;
  if (t2.length !== e2.length) {
    var n2 = t2.slice(-1)[0], r2 = e2.slice(-1)[0];
    if (n2 === r2)
      return true;
    if (ke(n2) && ke(r2) && (1 === t2[0] || 1 === e2[0]))
      return true;
  }
  return t2[1] === e2[1] && ke(t2[0]) && ke(e2[0]);
}
function Ae(t2) {
  if (null == te) {
    var e2 = Ut(t2);
    te = e2.getParameter(e2.MAX_TEXTURE_SIZE);
  }
  return te;
}
function De(t2) {
  if (null == ee) {
    var e2 = Ut(t2);
    ee = e2.getParameter(e2.MAX_TEXTURE_IMAGE_UNITS);
  }
  return Math.min(16, ee);
}
function Te(t2) {
  if (0 === t2)
    return 0;
  var e2 = Ut(t2);
  return Ne(e2, "EXT_disjoint_timer_query_webgl2") && 2 === t2 ? 2 : Ne(e2, "EXT_disjoint_timer_query") ? 1 : 0;
}
function Ne(t2, e2) {
  return null != t2.getExtension(e2);
}
function Fe(t2) {
  try {
    if (null != Ut(t2))
      return true;
  } catch (t3) {
    return false;
  }
  return false;
}
function Oe(t2) {
  if (0 === t2)
    return false;
  var e2 = Ut(t2);
  if (1 === t2) {
    if (!Ne(e2, "OES_texture_float"))
      return false;
  } else if (!Ne(e2, "EXT_color_buffer_float"))
    return false;
  return Me(e2);
}
function _e(t2) {
  if (0 === t2)
    return false;
  var e2 = Ut(t2);
  if (1 !== t2) {
    if (Ne(e2, "EXT_color_buffer_float"))
      return Me(e2);
    if (Ne(e2, "EXT_color_buffer_half_float")) {
      var n2 = e2.getExtension("EXT_color_buffer_half_float");
      return function(t3, e3) {
        var n3 = qt(t3, e3), r2 = t3.createTexture();
        t3.bindTexture(t3.TEXTURE_2D, r2);
        t3.texImage2D(t3.TEXTURE_2D, 0, n3.internalFormatHalfFloat, 1, 1, 0, n3.textureFormatFloat, n3.textureTypeHalfFloat, null);
        var o2 = t3.createFramebuffer();
        t3.bindFramebuffer(t3.FRAMEBUFFER, o2), t3.framebufferTexture2D(t3.FRAMEBUFFER, t3.COLOR_ATTACHMENT0, t3.TEXTURE_2D, r2, 0);
        var a2 = t3.checkFramebufferStatus(t3.FRAMEBUFFER) === t3.FRAMEBUFFER_COMPLETE;
        return t3.bindTexture(t3.TEXTURE_2D, null), t3.bindFramebuffer(t3.FRAMEBUFFER, null), t3.deleteTexture(r2), t3.deleteFramebuffer(o2), a2;
      }(e2, n2);
    }
    return false;
  }
  return !!Ne(e2, "OES_texture_float") && (!!Ne(e2, "WEBGL_color_buffer_float") && Me(e2));
}
function Me(t2) {
  var e2 = qt(t2), n2 = t2.createTexture();
  t2.bindTexture(t2.TEXTURE_2D, n2);
  t2.texImage2D(t2.TEXTURE_2D, 0, e2.internalFormatFloat, 1, 1, 0, e2.textureFormatFloat, e2.textureTypeFloat, null);
  var r2 = t2.createFramebuffer();
  t2.bindFramebuffer(t2.FRAMEBUFFER, r2), t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, n2, 0);
  var o2 = t2.checkFramebufferStatus(t2.FRAMEBUFFER) === t2.FRAMEBUFFER_COMPLETE;
  return t2.bindTexture(t2.TEXTURE_2D, null), t2.bindFramebuffer(t2.FRAMEBUFFER, null), t2.deleteTexture(n2), t2.deleteFramebuffer(r2), o2;
}
function Be(t2) {
  return 2 === t2 && null != Ut(t2).fenceSync;
}
var Pe = Object.freeze({callAndCheck: Kt, canBeRepresented: $t, getWebGLErrorMessage: Yt, getExtensionOrThrow: Qt, createVertexShader: Jt, createFragmentShader: Zt, createProgram: re, linkProgram: oe, validateProgram: ae, createStaticVertexBuffer: ie, createStaticIndexBuffer: ue, getNumChannels: function() {
  return 2 === a().getNumber("WEBGL_VERSION") ? 1 : 4;
}, createTexture: se, validateTextureSize: ce, createFramebuffer: le, bindVertexBufferToProgramAttribute: he, bindTextureUnit: fe, unbindTextureUnit: function(t2, e2, n2) {
  we(t2, n2), Kt(t2, e2, function() {
    return t2.activeTexture(t2.TEXTURE0 + n2);
  }), Kt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, null);
  });
}, getProgramUniformLocationOrThrow: pe, getProgramUniformLocation: de, bindTextureToProgramUniformSampler: ve, bindCanvasToFramebuffer: function(t2, e2) {
  Kt(t2, e2, function() {
    return t2.bindFramebuffer(t2.FRAMEBUFFER, null);
  }), Kt(t2, e2, function() {
    return t2.viewport(0, 0, t2.canvas.width, t2.canvas.height);
  }), Kt(t2, e2, function() {
    return t2.scissor(0, 0, t2.canvas.width, t2.canvas.height);
  });
}, bindColorTextureToFramebuffer: me, unbindColorTextureFromFramebuffer: ge, validateFramebuffer: ye, getFramebufferErrorMessage: xe, getBatchDim: Ce, getRowsCols: Ee, getShapeAs3D: Re, getTextureShapeFromLogicalShape: Ie, isReshapeFree: Se, getWebGLMaxTextureSize: Ae, resetMaxTextureSize: function() {
  te = null;
}, resetMaxTexturesInShader: function() {
  ee = null;
}, getMaxTexturesInShader: De, getWebGLDisjointQueryTimerVersion: Te, hasExtension: Ne, isWebGLVersionEnabled: Fe, isCapableOfRenderingToFloatTexture: Oe, isDownloadFloatTextureEnabled: _e, isWebGLFenceEnabled: Be});
var Le = a();
function We() {
  a().set("PROD", true);
}
function Ue() {
  a().set("DEBUG", true);
}
function Ve() {
  a().set("DEPRECATION_WARNINGS_ENABLED", false), console.warn("TensorFlow.js deprecation warnings have been disabled.");
}
function ze(t2) {
  a().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(t2 + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
}
function Ge() {
  Nt.disposeVariables();
}
function He() {
  return Nt;
}
function qe() {
  return Nt.memory();
}
function Ke(t2) {
  return Nt.profile(t2);
}
function je(t2, e2) {
  return Nt.tidy(t2, e2);
}
function Xe(t2) {
  kt(t2).forEach(function(t3) {
    return t3.dispose();
  });
}
function $e(t2) {
  return Nt.keep(t2);
}
function Ye(t2) {
  return Nt.time(t2);
}
function Qe(t2) {
  return Nt.setBackend(t2);
}
function Je() {
  return Nt.ready();
}
function Ze() {
  return Nt.backendName;
}
function tn(t2) {
  Nt.removeBackend(t2);
}
function en(t2) {
  return Nt.findBackend(t2);
}
function nn(t2) {
  return Nt.findBackendFactory(t2);
}
function rn(t2, e2, n2) {
  return void 0 === n2 && (n2 = 1), Nt.registerBackend(t2, e2, n2);
}
function on() {
  return Nt.backend;
}
function an(t2, e2) {
  a().setPlatform(t2, e2);
}
function un() {
  for (var t2 = [], e2 = 0; e2 < arguments.length; e2++)
    t2[e2] = arguments[e2];
  a().getBool("IS_TEST") || console.warn.apply(console, t2);
}
function sn(t2, e2) {
  var n2 = t2;
  if (B(t2))
    return "string" === e2 ? [] : [t2.length];
  if (!Array.isArray(t2))
    return [];
  for (var r2 = []; Array.isArray(n2) || B(n2) && "string" !== e2; )
    r2.push(n2.length), n2 = n2[0];
  return Array.isArray(t2) && a().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && function t3(e3, n3, r3) {
    r3 = r3 || [];
    if (!Array.isArray(e3) && !B(e3))
      return void g(0 === n3.length, function() {
        return "Element arr[" + r3.join("][") + "] is a primitive, but should be an array/TypedArray of " + n3[0] + " elements";
      });
    g(n3.length > 0, function() {
      return "Element arr[" + r3.join("][") + "] should be a primitive, but is an array of " + e3.length + " elements";
    });
    g(e3.length === n3[0], function() {
      return "Element arr[" + r3.join("][") + "] should have " + n3[0] + " elements, but has " + e3.length + " elements";
    });
    var o2 = n3.slice(1);
    for (var a2 = 0; a2 < e3.length; ++a2)
      t3(e3[a2], o2, r3.concat(a2));
  }(t2, r2, []), r2;
}
function cn(t2, e2, n2, r2) {
  if (null != t2 && ("numeric" !== t2 && t2 !== e2 || "numeric" === t2 && "string" === e2))
    throw new Error("Argument '" + n2 + "' passed to '" + r2 + "' must be " + t2 + " tensor, but got " + e2 + " tensor");
}
function ln(t2, e2, n2, r2) {
  if (void 0 === r2 && (r2 = "numeric"), t2 instanceof dt)
    return cn(r2, t2.dtype, e2, n2), t2;
  var o2 = z(t2);
  if ("string" !== o2 && ["bool", "int32", "float32"].indexOf(r2) >= 0 && (o2 = r2), cn(r2, o2, e2, n2), null == t2 || !B(t2) && !Array.isArray(t2) && "number" != typeof t2 && "boolean" != typeof t2 && "string" != typeof t2) {
    var i2 = null == t2 ? "null" : t2.constructor.name;
    throw new Error("Argument '" + e2 + "' passed to '" + n2 + "' must be a Tensor or TensorLike, but got '" + i2 + "'");
  }
  var u2 = sn(t2, o2);
  B(t2) || Array.isArray(t2) || (t2 = [t2]);
  var s2 = "string" !== o2 ? K(t2, o2, a().getBool("DEBUG")) : b(t2, [], true);
  return Nt.makeTensor(s2, u2, o2);
}
function hn(t2, e2, n2, r2) {
  if (void 0 === r2 && (r2 = "numeric"), !Array.isArray(t2))
    throw new Error("Argument " + e2 + " passed to " + n2 + " must be a `Tensor[]` or `TensorLike[]`");
  return t2.map(function(t3, r3) {
    return ln(t3, e2 + "[" + r3 + "]", n2);
  }, r2);
}
function fn(t2, e2) {
  for (var n2 = 0; n2 < t2.length; ++n2)
    if (t2[t2.length - n2 - 1] !== e2 - 1 - n2)
      return false;
  return true;
}
function pn(t2, e2, n2) {
  for (var r2 = t2.length + e2.length, o2 = [], a2 = 0, i2 = 0, u2 = 0; u2 < r2; u2++)
    -1 === n2.indexOf(u2) ? o2.push(t2[a2++]) : o2.push(e2[i2++]);
  return o2;
}
function dn(t2, e2) {
  for (var n2 = [], r2 = t2.length, o2 = 0; o2 < r2; o2++)
    -1 === e2.indexOf(o2) && n2.push(t2[o2]);
  return [n2, e2.map(function(e3) {
    return t2[e3];
  })];
}
function vn(t2, e2) {
  return pn(t2, e2.map(function(t3) {
    return 1;
  }), e2);
}
function mn(t2, e2, n2) {
  g(fn(e2, n2), function() {
    return t2 + " supports only inner-most axes for now. Got axes " + e2 + " and rank-" + n2 + " input.";
  });
}
function gn(t2, e2) {
  if (fn(t2, e2))
    return null;
  for (var n2 = [], r2 = 0; r2 < e2; ++r2)
    -1 === t2.indexOf(r2) && n2.push(r2);
  return t2.forEach(function(t3) {
    return n2.push(t3);
  }), n2;
}
function yn(t2) {
  return t2.map(function(t3, e2) {
    return [e2, t3];
  }).sort(function(t3, e2) {
    return t3[1] - e2[1];
  }).map(function(t3) {
    return t3[0];
  });
}
function xn(t2, e2) {
  for (var n2 = [], r2 = e2 - t2; r2 < e2; ++r2)
    n2.push(r2);
  return n2;
}
function bn(t2, e2) {
  var n2 = t2[0].length;
  t2.forEach(function(t3, e3) {
    g(t3.length === n2, function() {
      return "Error in concat" + n2 + "D: rank of tensors[" + e3 + "] must be the same as the rank of the rest (" + n2 + ")";
    });
  }), g(e2 >= 0 && e2 < n2, function() {
    return "Error in concat" + n2 + "D: axis must be between 0 and " + (n2 - 1) + ".";
  });
  var r2 = t2[0];
  t2.forEach(function(t3, o2) {
    for (var a2 = 0; a2 < n2; a2++)
      g(a2 === e2 || t3[a2] === r2[a2], function() {
        return "Error in concat" + n2 + "D: Shape of tensors[" + o2 + "] (" + t3 + ") does not match the shape of the rest (" + r2 + ") along the non-concatenated axis " + o2 + ".";
      });
  });
}
function wn(t2, e2) {
  for (var n2 = t2[0].slice(), r2 = 1; r2 < t2.length; r2++)
    n2[e2] += t2[r2][e2];
  return n2;
}
function Cn(t2) {
  var e2 = Object.keys(t2);
  if (1 !== e2.length)
    throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + e2.length + " keys.");
  var n2 = e2[0], r2 = t2[n2];
  n2.endsWith("_") && (n2 = n2.substring(0, n2.length - 1));
  var o2 = function() {
    for (var t3 = [], e3 = 0; e3 < arguments.length; e3++)
      t3[e3] = arguments[e3];
    Nt.startScope(n2);
    try {
      var o3 = r2.apply(void 0, t3);
      return o3 instanceof Promise && console.error("Cannot return a Promise inside of tidy."), Nt.endScope(o3), o3;
    } catch (t4) {
      throw Nt.endScope(null), t4;
    }
  };
  return Object.defineProperty(o2, "name", {value: n2, configurable: true}), o2;
}
Le.registerFlag("HAS_WEBGL", function() {
  return Le.getNumber("WEBGL_VERSION") > 0;
}), Le.registerFlag("WEBGL_VERSION", function() {
  return Fe(2) ? 2 : Fe(1) ? 1 : 0;
}), Le.registerFlag("WEBGL_BUFFER_SUPPORTED", function() {
  return 2 === Le.get("WEBGL_VERSION");
}), Le.registerFlag("WEBGL_CPU_FORWARD", function() {
  return true;
}), Le.registerFlag("WEBGL_FORCE_F16_TEXTURES", function() {
  return false;
}), Le.registerFlag("WEBGL_PACK", function() {
  return Le.getBool("HAS_WEBGL");
}), Le.registerFlag("WEBGL_PACK_NORMALIZATION", function() {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_PACK_CLIP", function() {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_PACK_DEPTHWISECONV", function() {
  return false;
}), Le.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", function() {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", function() {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", function() {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", function() {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_PACK_REDUCE", function() {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_LAZILY_UNPACK", function() {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_CONV_IM2COL", function() {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_MAX_TEXTURE_SIZE", function() {
  return Ae(Le.getNumber("WEBGL_VERSION"));
}), Le.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", function() {
  return De(Le.getNumber("WEBGL_VERSION"));
}), Le.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", function() {
  var t2 = Le.getNumber("WEBGL_VERSION");
  return 0 === t2 ? 0 : Te(t2);
}), Le.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", function() {
  return Le.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && (t2 = navigator.userAgent || navigator.vendor || window.opera, !(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t2) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t2.substr(0, 4))));
  var t2;
}), Le.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", function() {
  return Oe(Le.getNumber("WEBGL_VERSION"));
}), Le.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", function() {
  return !Le.getBool("WEBGL_FORCE_F16_TEXTURES") && Le.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
}), Le.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", function() {
  return _e(Le.getNumber("WEBGL_VERSION"));
}), Le.registerFlag("WEBGL_FENCE_API_ENABLED", function() {
  return Be(Le.getNumber("WEBGL_VERSION"));
}), Le.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", function() {
  return Le.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0;
}), pt = ze;
var En = Cn({complex_: function(t2, e2) {
  var n2 = ln(t2, "real", "complex"), r2 = ln(e2, "imag", "complex");
  return y(n2.shape, r2.shape, "real and imag shapes, " + n2.shape + " and " + r2.shape + ", must match in call to tf.complex()."), Nt.runKernelFunc(function(t3) {
    return t3.complex(n2, r2);
  }, {$real: n2, $imag: r2});
}});
var Rn = Cn({real_: function(t2) {
  var e2 = ln(t2, "input", "real");
  return Nt.runKernelFunc(function(t3) {
    return t3.real(e2);
  }, {$input: e2});
}});
var In = Cn({imag_: function(t2) {
  var e2 = ln(t2, "input", "imag");
  return Nt.runKernelFunc(function(t3) {
    return t3.imag(e2);
  }, {$input: e2});
}});
function kn(t2, e2, n2) {
  return Sn(t2, e2, sn(t2, n2), n2);
}
function Sn(t2, e2, n2, r2) {
  if (null == r2 && (r2 = z(t2)), "complex64" === r2)
    throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
  if (!B(t2) && !Array.isArray(t2) && "number" != typeof t2 && "boolean" != typeof t2 && "string" != typeof t2)
    throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
  if (null != e2) {
    Q(e2);
    var o2 = w(e2), i2 = w(n2);
    g(o2 === i2, function() {
      return "Based on the provided shape, [" + e2 + "], the tensor should have " + o2 + " values but has " + i2;
    });
    for (var u2 = 0; u2 < n2.length; ++u2) {
      var s2 = n2[u2], c2 = u2 !== n2.length - 1 || s2 !== w(e2.slice(u2));
      g(n2[u2] === e2[u2] || !c2, function() {
        return "Error creating a new Tensor. Inferred shape (" + n2 + ") does not match the provided shape (" + e2 + "). ";
      });
    }
  }
  return B(t2) || Array.isArray(t2) || (t2 = [t2]), e2 = e2 || n2, t2 = "string" !== r2 ? K(t2, r2, a().getBool("DEBUG")) : b(t2, [], true), Nt.makeTensor(t2, e2, r2);
}
function An(t2, e2) {
  if ((B(t2) && "string" !== e2 || Array.isArray(t2)) && "complex64" !== e2)
    throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  if ("string" === e2 && B(t2) && !(t2 instanceof Uint8Array))
    throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  return Sn(t2, [], [], e2);
}
function Dn(t2, e2) {
  x(t2);
  var n2 = sn(t2, e2);
  if (1 !== n2.length)
    throw new Error("tensor1d() requires values to be a flat/TypedArray");
  return Sn(t2, null, n2, e2);
}
function Tn(t2, e2, n2) {
  if (x(t2), null != e2 && 2 !== e2.length)
    throw new Error("tensor2d() requires shape to have two numbers");
  var r2 = sn(t2, n2);
  if (2 !== r2.length && 1 !== r2.length)
    throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  if (1 === r2.length && null == e2)
    throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
  return Sn(t2, e2, r2, n2);
}
function Nn(t2, e2, n2) {
  if (x(t2), null != e2 && 3 !== e2.length)
    throw new Error("tensor3d() requires shape to have three numbers");
  var r2 = sn(t2, n2);
  if (3 !== r2.length && 1 !== r2.length)
    throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
  if (1 === r2.length && null == e2)
    throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
  return Sn(t2, e2, r2, n2);
}
function Fn(t2, e2, n2) {
  if (x(t2), null != e2 && 4 !== e2.length)
    throw new Error("tensor4d() requires shape to have four numbers");
  var r2 = sn(t2, n2);
  if (4 !== r2.length && 1 !== r2.length)
    throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
  if (1 === r2.length && null == e2)
    throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
  return Sn(t2, e2, r2, n2);
}
function On(t2, e2, n2) {
  if (x(t2), null != e2 && 5 !== e2.length)
    throw new Error("tensor5d() requires shape to have five numbers");
  var r2 = sn(t2, n2);
  if (5 !== r2.length && 1 !== r2.length)
    throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
  if (1 === r2.length && null == e2)
    throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
  return Sn(t2, e2, r2, n2);
}
function _n(t2, e2, n2) {
  if (x(t2), null != e2 && 6 !== e2.length)
    throw new Error("tensor6d() requires shape to have six numbers");
  var r2 = sn(t2, n2);
  if (6 !== r2.length && 1 !== r2.length)
    throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
  if (1 === r2.length && null == e2)
    throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
  return Sn(t2, e2 = e2 || r2, r2, n2);
}
function Mn(t2, e2, n2, r2) {
  return void 0 === e2 && (e2 = true), Nt.makeVariable(t2, e2, n2, r2);
}
function Bn(t2, e2) {
  if (void 0 === e2 && (e2 = "float32"), "complex64" === e2) {
    var n2 = Bn(t2, "float32"), r2 = Pn(t2, "float32");
    return En(n2, r2);
  }
  var o2 = X(w(t2), e2);
  return Nt.makeTensor(o2, t2, e2);
}
function Pn(t2, e2) {
  if (void 0 === e2 && (e2 = "float32"), "complex64" === e2) {
    var n2 = Pn(t2, "float32"), r2 = Pn(t2, "float32");
    return En(n2, r2);
  }
  var o2 = $(w(t2), e2);
  return Nt.makeTensor(o2, t2, e2);
}
function Ln(t2, e2, n2) {
  return Nt.runKernelFunc(function(r2) {
    return r2.fill(t2, e2, n2);
  }, {});
}
function Wn(t2, e2, n2) {
  if (n2 <= 0)
    throw new Error("The number of values should be positive.");
  return Nt.runKernelFunc(function(r2) {
    return r2.linspace(t2, e2, n2);
  }, {});
}
function Un(t2, e2, n2, r2) {
  if (void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = "float32"), 0 === n2)
    throw new Error("Cannot have a step of zero");
  if (t2 === e2 || t2 < e2 && n2 < 0 || e2 < t2 && n2 > 1)
    return Pn([0], r2);
  var o2 = $(Math.abs(Math.ceil((e2 - t2) / n2)), r2);
  e2 < t2 && 1 === n2 && (n2 = -1), o2[0] = t2;
  for (var a2 = 1; a2 < o2.length; a2++)
    o2[a2] = o2[a2 - 1] + n2;
  return Dn(o2, r2);
}
var Vn = Cn({onesLike_: function(t2) {
  var e2 = ln(t2, "x", "onesLike");
  if ("complex64" === e2.dtype) {
    var n2 = Vn(Rn(e2)), r2 = zn(In(e2));
    return En(n2, r2);
  }
  return Nt.runKernelFunc(function(t3) {
    return t3.onesLike(e2);
  }, {$x: e2}, function(t3, e3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var zn = Cn({zerosLike_: function(t2) {
  var e2 = ln(t2, "x", "zerosLike");
  return Nt.runKernelFunc(function(t3) {
    return t3.zerosLike(e2);
  }, {$x: e2}, function(t3, e3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var Gn = Cn({concat_: function(t2, e2) {
  void 0 === e2 && (e2 = 0), g(t2.length >= 1, function() {
    return "Pass at least one tensor to concat";
  });
  var n2 = hn(t2, "tensors", "concat");
  "complex64" === n2[0].dtype && n2.forEach(function(t3) {
    if ("complex64" !== t3.dtype)
      throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype " + t3.dtype + ". ");
  }), e2 = D(e2, n2[0].shape)[0];
  var r2 = wn(n2.map(function(t3) {
    return t3.shape;
  }), e2);
  if (0 === w(r2))
    return kn([], r2);
  if (1 === (n2 = n2.filter(function(t3) {
    return t3.size > 0;
  })).length)
    return n2[0];
  var o2 = n2.map(function(t3) {
    return t3.shape;
  });
  bn(o2, e2);
  var a2 = n2, i2 = {axis: e2};
  return Nt.runKernelFunc(function(t3) {
    return t3.concat(n2, e2);
  }, a2, function(t3) {
    var n3 = o2.map(function(t4) {
      return t4[e2];
    });
    return Xn(t3, n3, e2).map(function(t4) {
      return function() {
        return t4;
      };
    });
  }, "Concat", i2);
}});
var Hn = Cn({concat1d_: function(t2) {
  return Gn(t2, 0);
}});
var qn = Cn({concat2d_: function(t2, e2) {
  return Gn(t2, e2);
}});
var Kn = Cn({concat3d_: function(t2, e2) {
  return Gn(t2, e2);
}});
var jn = Cn({concat4d_: function(t2, e2) {
  return Gn(t2, e2);
}});
var Xn = Cn({split_: function(t2, e2, n2) {
  void 0 === n2 && (n2 = 0);
  var r2, o2 = ln(t2, "x", "split");
  return n2 = D(n2, o2.shape)[0], "number" == typeof e2 ? (g(o2.shape[n2] % e2 == 0, function() {
    return "Number of splits must evenly divide the axis.";
  }), r2 = new Array(e2).fill(o2.shape[n2] / e2)) : (g(o2.shape[n2] === e2.reduce(function(t3, e3) {
    return t3 + e3;
  }), function() {
    return "The sum of sizes must match the size of the axis dimension.";
  }), r2 = e2), Nt.runKernelFunc(function(t3) {
    return t3.split(o2, r2, n2);
  }, {$x: o2}, function(t3) {
    return {$x: function() {
      return Gn(t3, n2);
    }};
  });
}});
"undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self;
function $n(t2, e2) {
  return t2(e2 = {exports: {}}, e2.exports), e2.exports;
}
var Yn = $n(function(t2) {
  !function(t3, e2, n2) {
    function r2(t4) {
      var e3, n3 = this, r3 = (e3 = 4022871197, function(t5) {
        t5 = t5.toString();
        for (var n4 = 0; n4 < t5.length; n4++) {
          var r4 = 0.02519603282416938 * (e3 += t5.charCodeAt(n4));
          r4 -= e3 = r4 >>> 0, e3 = (r4 *= e3) >>> 0, e3 += 4294967296 * (r4 -= e3);
        }
        return 23283064365386963e-26 * (e3 >>> 0);
      });
      n3.next = function() {
        var t5 = 2091639 * n3.s0 + 23283064365386963e-26 * n3.c;
        return n3.s0 = n3.s1, n3.s1 = n3.s2, n3.s2 = t5 - (n3.c = 0 | t5);
      }, n3.c = 1, n3.s0 = r3(" "), n3.s1 = r3(" "), n3.s2 = r3(" "), n3.s0 -= r3(t4), n3.s0 < 0 && (n3.s0 += 1), n3.s1 -= r3(t4), n3.s1 < 0 && (n3.s1 += 1), n3.s2 -= r3(t4), n3.s2 < 0 && (n3.s2 += 1), r3 = null;
    }
    function o2(t4, e3) {
      return e3.c = t4.c, e3.s0 = t4.s0, e3.s1 = t4.s1, e3.s2 = t4.s2, e3;
    }
    function a2(t4, e3) {
      var n3 = new r2(t4), a3 = e3 && e3.state, i2 = n3.next;
      return i2.int32 = function() {
        return 4294967296 * n3.next() | 0;
      }, i2.double = function() {
        return i2() + 11102230246251565e-32 * (2097152 * i2() | 0);
      }, i2.quick = i2, a3 && ("object" == typeof a3 && o2(a3, n3), i2.state = function() {
        return o2(n3, {});
      }), i2;
    }
    e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
      return a2;
    }) : this.alea = a2;
  }(0, t2, false);
});
var Qn = $n(function(t2) {
  !function(t3, e2, n2) {
    function r2(t4) {
      var e3 = this, n3 = "";
      e3.x = 0, e3.y = 0, e3.z = 0, e3.w = 0, e3.next = function() {
        var t5 = e3.x ^ e3.x << 11;
        return e3.x = e3.y, e3.y = e3.z, e3.z = e3.w, e3.w ^= e3.w >>> 19 ^ t5 ^ t5 >>> 8;
      }, t4 === (0 | t4) ? e3.x = t4 : n3 += t4;
      for (var r3 = 0; r3 < n3.length + 64; r3++)
        e3.x ^= 0 | n3.charCodeAt(r3), e3.next();
    }
    function o2(t4, e3) {
      return e3.x = t4.x, e3.y = t4.y, e3.z = t4.z, e3.w = t4.w, e3;
    }
    function a2(t4, e3) {
      var n3 = new r2(t4), a3 = e3 && e3.state, i2 = function() {
        return (n3.next() >>> 0) / 4294967296;
      };
      return i2.double = function() {
        do {
          var t5 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t5);
        return t5;
      }, i2.int32 = n3.next, i2.quick = i2, a3 && ("object" == typeof a3 && o2(a3, n3), i2.state = function() {
        return o2(n3, {});
      }), i2;
    }
    e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
      return a2;
    }) : this.xor128 = a2;
  }(0, t2, false);
});
var Jn = $n(function(t2) {
  !function(t3, e2, n2) {
    function r2(t4) {
      var e3 = this, n3 = "";
      e3.next = function() {
        var t5 = e3.x ^ e3.x >>> 2;
        return e3.x = e3.y, e3.y = e3.z, e3.z = e3.w, e3.w = e3.v, (e3.d = e3.d + 362437 | 0) + (e3.v = e3.v ^ e3.v << 4 ^ t5 ^ t5 << 1) | 0;
      }, e3.x = 0, e3.y = 0, e3.z = 0, e3.w = 0, e3.v = 0, t4 === (0 | t4) ? e3.x = t4 : n3 += t4;
      for (var r3 = 0; r3 < n3.length + 64; r3++)
        e3.x ^= 0 | n3.charCodeAt(r3), r3 == n3.length && (e3.d = e3.x << 10 ^ e3.x >>> 4), e3.next();
    }
    function o2(t4, e3) {
      return e3.x = t4.x, e3.y = t4.y, e3.z = t4.z, e3.w = t4.w, e3.v = t4.v, e3.d = t4.d, e3;
    }
    function a2(t4, e3) {
      var n3 = new r2(t4), a3 = e3 && e3.state, i2 = function() {
        return (n3.next() >>> 0) / 4294967296;
      };
      return i2.double = function() {
        do {
          var t5 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t5);
        return t5;
      }, i2.int32 = n3.next, i2.quick = i2, a3 && ("object" == typeof a3 && o2(a3, n3), i2.state = function() {
        return o2(n3, {});
      }), i2;
    }
    e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
      return a2;
    }) : this.xorwow = a2;
  }(0, t2, false);
});
var Zn = $n(function(t2) {
  !function(t3, e2, n2) {
    function r2(t4) {
      var e3 = this;
      e3.next = function() {
        var t5, n3, r3 = e3.x, o3 = e3.i;
        return t5 = r3[o3], n3 = (t5 ^= t5 >>> 7) ^ t5 << 24, n3 ^= (t5 = r3[o3 + 1 & 7]) ^ t5 >>> 10, n3 ^= (t5 = r3[o3 + 3 & 7]) ^ t5 >>> 3, n3 ^= (t5 = r3[o3 + 4 & 7]) ^ t5 << 7, t5 = r3[o3 + 7 & 7], n3 ^= (t5 ^= t5 << 13) ^ t5 << 9, r3[o3] = n3, e3.i = o3 + 1 & 7, n3;
      }, function(t5, e4) {
        var n3, r3 = [];
        if (e4 === (0 | e4))
          r3[0] = e4;
        else
          for (e4 = "" + e4, n3 = 0; n3 < e4.length; ++n3)
            r3[7 & n3] = r3[7 & n3] << 15 ^ e4.charCodeAt(n3) + r3[n3 + 1 & 7] << 13;
        for (; r3.length < 8; )
          r3.push(0);
        for (n3 = 0; n3 < 8 && 0 === r3[n3]; ++n3)
          ;
        for (8 == n3 ? r3[7] = -1 : r3[n3], t5.x = r3, t5.i = 0, n3 = 256; n3 > 0; --n3)
          t5.next();
      }(e3, t4);
    }
    function o2(t4, e3) {
      return e3.x = t4.x.slice(), e3.i = t4.i, e3;
    }
    function a2(t4, e3) {
      null == t4 && (t4 = +new Date());
      var n3 = new r2(t4), a3 = e3 && e3.state, i2 = function() {
        return (n3.next() >>> 0) / 4294967296;
      };
      return i2.double = function() {
        do {
          var t5 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t5);
        return t5;
      }, i2.int32 = n3.next, i2.quick = i2, a3 && (a3.x && o2(a3, n3), i2.state = function() {
        return o2(n3, {});
      }), i2;
    }
    e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
      return a2;
    }) : this.xorshift7 = a2;
  }(0, t2, false);
});
var tr = $n(function(t2) {
  !function(t3, e2, n2) {
    function r2(t4) {
      var e3 = this;
      e3.next = function() {
        var t5, n3, r3 = e3.w, o3 = e3.X, a3 = e3.i;
        return e3.w = r3 = r3 + 1640531527 | 0, n3 = o3[a3 + 34 & 127], t5 = o3[a3 = a3 + 1 & 127], n3 ^= n3 << 13, t5 ^= t5 << 17, n3 ^= n3 >>> 15, t5 ^= t5 >>> 12, n3 = o3[a3] = n3 ^ t5, e3.i = a3, n3 + (r3 ^ r3 >>> 16) | 0;
      }, function(t5, e4) {
        var n3, r3, o3, a3, i2, u2 = [], s2 = 128;
        for (e4 === (0 | e4) ? (r3 = e4, e4 = null) : (e4 += "\0", r3 = 0, s2 = Math.max(s2, e4.length)), o3 = 0, a3 = -32; a3 < s2; ++a3)
          e4 && (r3 ^= e4.charCodeAt((a3 + 32) % e4.length)), 0 === a3 && (i2 = r3), r3 ^= r3 << 10, r3 ^= r3 >>> 15, r3 ^= r3 << 4, r3 ^= r3 >>> 13, a3 >= 0 && (i2 = i2 + 1640531527 | 0, o3 = 0 == (n3 = u2[127 & a3] ^= r3 + i2) ? o3 + 1 : 0);
        for (o3 >= 128 && (u2[127 & (e4 && e4.length || 0)] = -1), o3 = 127, a3 = 512; a3 > 0; --a3)
          r3 = u2[o3 + 34 & 127], n3 = u2[o3 = o3 + 1 & 127], r3 ^= r3 << 13, n3 ^= n3 << 17, r3 ^= r3 >>> 15, n3 ^= n3 >>> 12, u2[o3] = r3 ^ n3;
        t5.w = i2, t5.X = u2, t5.i = o3;
      }(e3, t4);
    }
    function o2(t4, e3) {
      return e3.i = t4.i, e3.w = t4.w, e3.X = t4.X.slice(), e3;
    }
    function a2(t4, e3) {
      null == t4 && (t4 = +new Date());
      var n3 = new r2(t4), a3 = e3 && e3.state, i2 = function() {
        return (n3.next() >>> 0) / 4294967296;
      };
      return i2.double = function() {
        do {
          var t5 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t5);
        return t5;
      }, i2.int32 = n3.next, i2.quick = i2, a3 && (a3.X && o2(a3, n3), i2.state = function() {
        return o2(n3, {});
      }), i2;
    }
    e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
      return a2;
    }) : this.xor4096 = a2;
  }(0, t2, false);
});
var er = $n(function(t2) {
  !function(t3, e2, n2) {
    function r2(t4) {
      var e3 = this, n3 = "";
      e3.next = function() {
        var t5 = e3.b, n4 = e3.c, r4 = e3.d, o3 = e3.a;
        return t5 = t5 << 25 ^ t5 >>> 7 ^ n4, n4 = n4 - r4 | 0, r4 = r4 << 24 ^ r4 >>> 8 ^ o3, o3 = o3 - t5 | 0, e3.b = t5 = t5 << 20 ^ t5 >>> 12 ^ n4, e3.c = n4 = n4 - r4 | 0, e3.d = r4 << 16 ^ n4 >>> 16 ^ o3, e3.a = o3 - t5 | 0;
      }, e3.a = 0, e3.b = 0, e3.c = -1640531527, e3.d = 1367130551, t4 === Math.floor(t4) ? (e3.a = t4 / 4294967296 | 0, e3.b = 0 | t4) : n3 += t4;
      for (var r3 = 0; r3 < n3.length + 20; r3++)
        e3.b ^= 0 | n3.charCodeAt(r3), e3.next();
    }
    function o2(t4, e3) {
      return e3.a = t4.a, e3.b = t4.b, e3.c = t4.c, e3.d = t4.d, e3;
    }
    function a2(t4, e3) {
      var n3 = new r2(t4), a3 = e3 && e3.state, i2 = function() {
        return (n3.next() >>> 0) / 4294967296;
      };
      return i2.double = function() {
        do {
          var t5 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t5);
        return t5;
      }, i2.int32 = n3.next, i2.quick = i2, a3 && ("object" == typeof a3 && o2(a3, n3), i2.state = function() {
        return o2(n3, {});
      }), i2;
    }
    e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
      return a2;
    }) : this.tychei = a2;
  }(0, t2, false);
});
var nr = $n(function(t2) {
  !function(e2, n2) {
    var r2, o2 = this, a2 = 256, i2 = 6, u2 = "random", s2 = n2.pow(a2, i2), c2 = n2.pow(2, 52), l2 = 2 * c2, h2 = a2 - 1;
    function f2(t3, h3, f3) {
      var g2 = [], y2 = v2(function t4(e3, n3) {
        var r3, o3 = [], a3 = typeof e3;
        if (n3 && "object" == a3)
          for (r3 in e3)
            try {
              o3.push(t4(e3[r3], n3 - 1));
            } catch (t5) {
            }
        return o3.length ? o3 : "string" == a3 ? e3 : e3 + "\0";
      }((h3 = 1 == h3 ? {entropy: true} : h3 || {}).entropy ? [t3, m2(e2)] : null == t3 ? function() {
        try {
          var t4;
          return r2 && (t4 = r2.randomBytes) ? t4 = t4(a2) : (t4 = new Uint8Array(a2), (o2.crypto || o2.msCrypto).getRandomValues(t4)), m2(t4);
        } catch (t5) {
          var n3 = o2.navigator, i3 = n3 && n3.plugins;
          return [+new Date(), o2, i3, o2.screen, m2(e2)];
        }
      }() : t3, 3), g2), x2 = new p2(g2), b2 = function() {
        for (var t4 = x2.g(i2), e3 = s2, n3 = 0; t4 < c2; )
          t4 = (t4 + n3) * a2, e3 *= a2, n3 = x2.g(1);
        for (; t4 >= l2; )
          t4 /= 2, e3 /= 2, n3 >>>= 1;
        return (t4 + n3) / e3;
      };
      return b2.int32 = function() {
        return 0 | x2.g(4);
      }, b2.quick = function() {
        return x2.g(4) / 4294967296;
      }, b2.double = b2, v2(m2(x2.S), e2), (h3.pass || f3 || function(t4, e3, r3, o3) {
        return o3 && (o3.S && d2(o3, x2), t4.state = function() {
          return d2(x2, {});
        }), r3 ? (n2[u2] = t4, e3) : t4;
      })(b2, y2, "global" in h3 ? h3.global : this == n2, h3.state);
    }
    function p2(t3) {
      var e3, n3 = t3.length, r3 = this, o3 = 0, i3 = r3.i = r3.j = 0, u3 = r3.S = [];
      for (n3 || (t3 = [n3++]); o3 < a2; )
        u3[o3] = o3++;
      for (o3 = 0; o3 < a2; o3++)
        u3[o3] = u3[i3 = h2 & i3 + t3[o3 % n3] + (e3 = u3[o3])], u3[i3] = e3;
      (r3.g = function(t4) {
        for (var e4, n4 = 0, o4 = r3.i, i4 = r3.j, u4 = r3.S; t4--; )
          e4 = u4[o4 = h2 & o4 + 1], n4 = n4 * a2 + u4[h2 & (u4[o4] = u4[i4 = h2 & i4 + e4]) + (u4[i4] = e4)];
        return r3.i = o4, r3.j = i4, n4;
      })(a2);
    }
    function d2(t3, e3) {
      return e3.i = t3.i, e3.j = t3.j, e3.S = t3.S.slice(), e3;
    }
    function v2(t3, e3) {
      for (var n3, r3 = t3 + "", o3 = 0; o3 < r3.length; )
        e3[h2 & o3] = h2 & (n3 ^= 19 * e3[h2 & o3]) + r3.charCodeAt(o3++);
      return m2(e3);
    }
    function m2(t3) {
      return String.fromCharCode.apply(0, t3);
    }
    if (n2["seed" + u2] = f2, v2(n2.random(), e2), t2.exports) {
      t2.exports = f2;
      try {
        r2 = require("crypto");
      } catch (t3) {
      }
    }
  }([], Math);
});
nr.alea = Yn, nr.xor128 = Qn, nr.xorwow = Jn, nr.xorshift7 = Zn, nr.xor4096 = tr, nr.tychei = er;
var rr = nr.alea;
var or = function() {
  function t2(t3, e2, n2, r2, o2) {
    this.mean = t3, this.stdDev = e2, this.dtype = n2, this.nextVal = NaN, this.truncated = r2, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
    var a2 = o2 || Math.random();
    this.random = rr(a2.toString());
  }
  return t2.prototype.nextValue = function() {
    if (!isNaN(this.nextVal)) {
      var t3 = this.nextVal;
      return this.nextVal = NaN, t3;
    }
    for (var e2, n2, r2 = false; !r2; ) {
      var o2 = void 0, a2 = void 0, i2 = void 0;
      do {
        i2 = (o2 = 2 * this.random() - 1) * o2 + (a2 = 2 * this.random() - 1) * a2;
      } while (i2 >= 1 || 0 === i2);
      var u2 = Math.sqrt(-2 * Math.log(i2) / i2);
      e2 = this.mean + this.stdDev * o2 * u2, n2 = this.mean + this.stdDev * a2 * u2, this.truncated && !this.isValidTruncated(e2) || (r2 = true);
    }
    return this.truncated && !this.isValidTruncated(n2) || (this.nextVal = this.convertValue(n2)), this.convertValue(e2);
  }, t2.prototype.convertValue = function(t3) {
    return null == this.dtype || "float32" === this.dtype ? t3 : Math.round(t3);
  }, t2.prototype.isValidTruncated = function(t3) {
    return t3 <= this.upper && t3 >= this.lower;
  }, t2;
}();
var ar = function() {
  function t2(t3, e2, n2, r2) {
    this.alpha = t3, this.beta = 1 / e2, this.dtype = n2;
    var o2 = r2 || Math.random();
    this.randu = rr(o2.toString()), this.randn = new or(0, 1, n2, false, this.randu()), this.d = t3 < 1 ? t3 + 2 / 3 : t3 - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);
  }
  return t2.prototype.nextValue = function() {
    for (var t3, e2, n2, r2, o2, a2; ; ) {
      do {
        r2 = this.randn.nextValue(), a2 = 1 + this.c * r2;
      } while (a2 <= 0);
      if (a2 *= a2 * a2, e2 = 1 - 0.331 * (t3 = r2 * r2) * t3, n2 = 0.5 * t3 + this.d * (1 - a2 + Math.log(a2)), (o2 = this.randu()) < e2 || Math.log(o2) < n2)
        break;
    }
    return a2 = 1 / this.beta * this.d * a2, this.alpha < 1 && (a2 *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(a2);
  }, t2.prototype.convertValue = function(t3) {
    return "float32" === this.dtype ? t3 : Math.round(t3);
  }, t2;
}();
var ir = function() {
  function t2(t3, e2, n2, r2) {
    var o2 = this;
    if (void 0 === t3 && (t3 = 0), void 0 === e2 && (e2 = 1), this.canReturnFloat = function() {
      return null == o2.dtype || "float32" === o2.dtype;
    }, this.min = t3, this.range = e2 - t3, this.dtype = n2, null == r2 && (r2 = Math.random()), "number" == typeof r2 && (r2 = r2.toString()), !this.canReturnFloat() && this.range <= 1)
      throw new Error("The difference between " + t3 + " - " + e2 + " <= 1 and dtype is not float");
    this.random = rr(r2);
  }
  return t2.prototype.convertValue = function(t3) {
    return this.canReturnFloat() ? t3 : Math.round(t3);
  }, t2.prototype.nextValue = function() {
    return this.convertValue(this.min + this.range * this.random());
  }, t2;
}();
function ur(t2, e2, n2) {
  return void 0 === e2 && (e2 = "float32"), e2 = e2 || "float32", Q(t2), new lt(t2, e2, n2);
}
function sr(t2, e2) {
  void 0 === e2 && (e2 = false), console.log(t2.toString(e2));
}
var cr = Cn({batchToSpaceND_: function(t2, e2, n2) {
  var r2 = ln(t2, "x", "batchToSpaceND"), o2 = e2.reduce(function(t3, e3) {
    return t3 * e3;
  });
  return g(r2.rank >= 1 + e2.length, function() {
    return "input rank is " + r2.rank + " but should be > than blockShape.length " + e2.length;
  }), g(n2.length === e2.length, function() {
    return "crops.length is " + n2.length + " but should be equal to blockShape.length  " + e2.length;
  }), g(r2.shape[0] % o2 == 0, function() {
    return "input tensor batch is " + r2.shape[0] + " but is not divisible by the product of the elements of blockShape " + e2.join(" * ") + " === " + o2;
  }), Nt.runKernelFunc(function(t3) {
    return t3.batchToSpaceND(r2, e2, n2);
  }, {$x: r2}, function(t3) {
    return {$x: function() {
      return t3.spaceToBatchND(e2, n2);
    }};
  });
}});
var lr = Cn({cast_: function(t2, e2) {
  var n2 = ln(t2, "x", "cast");
  if (!_(e2))
    throw new Error("Failed to cast to unknown dtype " + e2);
  if ("string" === e2 && "string" !== n2.dtype || "string" !== e2 && "string" === n2.dtype)
    throw new Error("Only strings can be casted to strings");
  var r2 = {dtype: e2};
  return Nt.runKernelFunc(function(t3) {
    return t3.cast(n2, e2);
  }, {x: n2}, function(t3) {
    return {x: function() {
      return t3.clone();
    }};
  }, "Cast", r2);
}});
var hr = Cn({clone_: function(t2) {
  var e2 = ln(t2, "x", "clone", null);
  return Nt.runKernelFunc(function() {
    return Nt.makeTensorFromDataId(e2.dataId, e2.shape, e2.dtype);
  }, {$x: e2}, function(t3) {
    return {$x: function() {
      return t3.toFloat();
    }};
  });
}});
var fr = Cn({cumsum_: function(t2, e2, n2, r2) {
  void 0 === e2 && (e2 = 0), void 0 === n2 && (n2 = false), void 0 === r2 && (r2 = false);
  var o2 = ln(t2, "x", "cumsum"), a2 = gn([e2 |= 0], o2.rank), i2 = o2;
  null != a2 && (i2 = o2.transpose(a2));
  var u2 = xn(1, o2.rank)[0], s2 = Nt.runKernelFunc(function(t3) {
    return t3.cumsum(i2, u2, n2, r2);
  }, {permutedX: i2}, function(t3) {
    return {permutedX: function() {
      return t3.cumsum(e2, n2, !r2);
    }};
  });
  return null != a2 && (s2 = s2.transpose(a2)), s2;
}});
var pr = Cn({depthToSpace_: function(t2, e2, n2) {
  void 0 === n2 && (n2 = "NHWC");
  var r2 = ln(t2, "x", "depthToSpace"), o2 = "NHWC" === n2 ? r2.shape[1] : r2.shape[2], a2 = "NHWC" === n2 ? r2.shape[2] : r2.shape[3], i2 = "NHWC" === n2 ? r2.shape[3] : r2.shape[1];
  return g(o2 * e2 >= 0, function() {
    return "Negative dimension size caused by overflow when multiplying\n      " + o2 + " and " + e2 + "  for depthToSpace with input shape\n      " + r2.shape;
  }), g(a2 * e2 >= 0, function() {
    return "Negative dimension size caused by overflow when multiplying\n      " + a2 + " and " + e2 + " for depthToSpace with input shape\n          " + r2.shape;
  }), g(i2 % (e2 * e2) == 0, function() {
    return "Dimension size must be evenly divisible by " + e2 * e2 + " but is " + i2 + " for depthToSpace with input shape " + r2.shape;
  }), Nt.runKernelFunc(function(t3) {
    return t3.depthToSpace(r2, e2, n2);
  }, {$x: r2});
}});
var dr = Cn({expandDims_: function(t2, e2) {
  void 0 === e2 && (e2 = 0);
  var n2 = ln(t2, "x", "expandDims", null);
  g(e2 <= n2.rank, function() {
    return "Axis must be <= rank of the tensor";
  });
  var r2 = n2.shape.slice();
  return e2 < 0 && (g(-(n2.rank + 1) <= e2, function() {
    return "Axis must be in the interval [" + -(n2.rank + 1) + ", " + n2.rank + "]";
  }), e2 = n2.rank + e2 + 1), r2.splice(e2, 0, 1), Sr(n2, r2);
}});
var vr = Cn({eye_: function(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = "float32"), null == e2 && (e2 = t2);
  for (var o2 = ur([t2, e2], r2), a2 = t2 <= e2 ? t2 : e2, i2 = 0; i2 < a2; ++i2)
    o2.set(1, i2, i2);
  var u2 = o2.toTensor().as2D(t2, e2);
  if (null == n2)
    return u2;
  if (1 === n2.length)
    return Nr(dr(u2, 0), [n2[0], 1, 1]);
  if (2 === n2.length)
    return Nr(dr(dr(u2, 0), 0), [n2[0], n2[1], 1, 1]);
  if (3 === n2.length)
    return Nr(dr(dr(dr(u2, 0), 0), 0), [n2[0], n2[1], n2[2], 1, 1]);
  throw new Error("eye() currently supports only 1D and 2D batchShapes, but received " + n2.length + "D.");
}});
var mr = Cn({multinomial_: function(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = false);
  var o2 = ln(t2, "logits", "multinomial"), a2 = o2.size, i2 = o2.rank;
  if (a2 < 2)
    throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + a2 + ".");
  if (i2 > 2)
    throw new Error("Rank of probabilities must be 1 or 2, but is " + i2);
  n2 = n2 || Math.random();
  var u2 = 1 === i2 ? o2.as2D(1, -1) : o2, s2 = Nt.runKernelFunc(function(t3) {
    return t3.multinomial(u2, r2, e2, n2);
  }, {logits2D: u2});
  return 1 === i2 ? s2.as1D() : s2;
}});
var gr = Cn({oneHot_: function(t2, e2, n2, r2) {
  if (void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = 0), e2 < 2)
    throw new Error("Error in oneHot: depth must be >=2, but it is " + e2);
  var o2 = ln(t2, "indices", "oneHot", "int32"), a2 = o2.shape.concat([e2]);
  return o2 = o2.flatten(), Nt.runKernelFunc(function(t3) {
    return t3.oneHot(o2, e2, n2, r2);
  }, {$indices: o2}, function(t3) {
    return {$indices: function() {
      return Pn(o2.shape, "float32");
    }};
  }).reshape(a2);
}});
var yr = Cn({pad_: function(t2, e2, n2) {
  void 0 === n2 && (n2 = 0);
  var r2 = ln(t2, "x", "pad");
  if (0 === r2.rank)
    throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
  var o2 = e2.map(function(t3) {
    return t3[0];
  });
  return Nt.runKernelFunc(function(t3) {
    return t3.pad(r2, e2, n2);
  }, {$x: r2}, function(t3) {
    return {$x: function() {
      return t3.slice(o2, r2.shape);
    }};
  });
}});
var xr = Cn({pad1d_: function(t2, e2, n2) {
  return void 0 === n2 && (n2 = 0), g(2 === e2.length, function() {
    return "Invalid number of paddings. Must be length of 2.";
  }), yr(t2, [e2], n2);
}});
var br = Cn({pad2d_: function(t2, e2, n2) {
  return void 0 === n2 && (n2 = 0), g(2 === e2.length && 2 === e2[0].length && 2 === e2[1].length, function() {
    return "Invalid number of paddings. Must be length of 2 each.";
  }), yr(t2, e2, n2);
}});
var wr = Cn({pad3d_: function(t2, e2, n2) {
  return void 0 === n2 && (n2 = 0), g(3 === e2.length && 2 === e2[0].length && 2 === e2[1].length && 2 === e2[2].length, function() {
    return "Invalid number of paddings. Must be length of 2 each.";
  }), yr(t2, e2, n2);
}});
var Cr = Cn({pad4d_: function(t2, e2, n2) {
  return void 0 === n2 && (n2 = 0), g(4 === e2.length && 2 === e2[0].length && 2 === e2[1].length && 2 === e2[2].length && 2 === e2[3].length, function() {
    return "Invalid number of paddings. Must be length of 2 each.";
  }), yr(t2, e2, n2);
}});
var Er = Cn({rand_: function(t2, e2, n2) {
  var r2 = w(t2), o2 = null;
  if (null == n2 || "float32" === n2)
    o2 = new Float32Array(r2);
  else if ("int32" === n2)
    o2 = new Int32Array(r2);
  else {
    if ("bool" !== n2)
      throw new Error("Unknown data type " + n2);
    o2 = new Uint8Array(r2);
  }
  for (var a2 = 0; a2 < r2; a2++)
    o2[a2] = e2();
  return Nt.makeTensor(o2, t2, n2);
}});
var Rr = Cn({randomNormal_: function(t2, e2, n2, r2, o2) {
  if (void 0 === e2 && (e2 = 0), void 0 === n2 && (n2 = 1), null != r2 && "bool" === r2)
    throw new Error("Unsupported data type " + r2);
  for (var a2 = new or(e2, n2, r2, false, o2), i2 = ur(t2, r2), u2 = 0; u2 < i2.values.length; u2++)
    i2.values[u2] = a2.nextValue();
  return i2.toTensor();
}});
var Ir = Cn({randomGamma_: function(t2, e2, n2, r2, o2) {
  if (void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = "float32"), null == n2 && (n2 = 1), null == r2 && (r2 = "float32"), "float32" !== r2 && "int32" !== r2)
    throw new Error("Unsupported data type " + r2);
  for (var a2 = new ar(e2, n2, r2, o2), i2 = ur(t2, r2), u2 = 0; u2 < i2.values.length; u2++)
    i2.values[u2] = a2.nextValue();
  return i2.toTensor();
}});
var kr = Cn({randomUniform_: function(t2, e2, n2, r2, o2) {
  void 0 === e2 && (e2 = 0), void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = "float32");
  for (var a2 = ur(t2, r2), i2 = new ir(e2, n2, null, o2), u2 = 0; u2 < a2.values.length; u2++)
    a2.values[u2] = i2.nextValue();
  return a2.toTensor();
}});
var Sr = Cn({reshape_: function(t2, e2) {
  var n2 = ln(t2, "x", "reshape", null);
  e2 = A(e2, n2.size), g(n2.size === w(e2), function() {
    return "new shape and old shape must have the same number of elements.";
  });
  var r2 = {shape: e2};
  return Nt.runKernelFunc(function(t3) {
    return t3.reshape(n2, e2);
  }, {x: n2}, function(t3) {
    return {x: function() {
      return t3.reshape(n2.shape);
    }};
  }, "Reshape", r2);
}});
var Ar = Cn({spaceToBatchND_: function(t2, e2, n2) {
  var r2 = ln(t2, "x", "spaceToBatchND");
  return g(r2.rank >= 1 + e2.length, function() {
    return "input rank " + r2.rank + " should be > than [blockShape] " + e2.length;
  }), g(n2.length === e2.length, function() {
    return "paddings.shape[0] " + n2.length + " must be equal to [blockShape] " + e2.length;
  }), g(r2.shape.reduce(function(t3, r3, o2) {
    return o2 > 0 && o2 <= e2.length ? t3 && (r3 + n2[o2 - 1][0] + n2[o2 - 1][1]) % e2[o2 - 1] == 0 : t3;
  }, true), function() {
    return "input spatial dimensions " + r2.shape.slice(1) + " with paddings " + n2.toString() + " must be divisible by blockShapes " + e2.toString();
  }), Nt.runKernelFunc(function(t3) {
    return t3.spaceToBatchND(r2, e2, n2);
  }, {$x: r2}, function(t3) {
    return {$x: function() {
      return t3.batchToSpaceND(e2, n2);
    }};
  });
}});
var Dr = Cn({squeeze_: function(t2, e2) {
  var n2 = ln(t2, "x", "squeeze");
  return Sr(n2, T(n2.shape, e2).newShape);
}});
var Tr = Cn({stack_: function(t2, e2) {
  void 0 === e2 && (e2 = 0);
  var n2 = hn(t2, "tensors", "stack");
  if (g(n2.length >= 1, function() {
    return "Pass at least one tensor to tf.stack";
  }), 1 === n2.length)
    return n2[0].expandDims(e2);
  var r2 = n2[0].rank, o2 = n2[0].shape, a2 = n2[0].dtype;
  g(e2 <= r2, function() {
    return "Axis must be <= rank of the tensor";
  }), n2.forEach(function(t3) {
    y(o2, t3.shape, "All tensors passed to stack must have matching shapes");
  }), n2.forEach(function(t3) {
    g(a2 === t3.dtype, function() {
      return "All tensors passed to stack must have matching dtypes";
    });
  });
  var i2 = n2.map(function(t3) {
    return t3.expandDims(e2);
  });
  return Gn(i2, e2);
}});
var Nr = Cn({tile_: function(t2, e2) {
  var n2 = ln(t2, "x", "tile", null);
  return g(n2.rank === e2.length, function() {
    return "Error in transpose: rank of input " + n2.rank + " must match length of reps " + e2 + ".";
  }), Nt.runKernelFunc(function(t3, r2) {
    var o2 = t3.tile(n2, e2);
    return r2([n2]), o2;
  }, {$x: n2}, function(t3, n3) {
    var r2 = n3[0];
    return {$x: function() {
      var n4 = zn(r2);
      if (1 === r2.rank)
        for (var o2 = 0; o2 < e2[0]; ++o2)
          n4 = n4.add(t3.slice([o2 * r2.shape[0]], [r2.shape[0]]));
      else if (2 === r2.rank)
        for (o2 = 0; o2 < e2[0]; ++o2)
          for (var a2 = 0; a2 < e2[1]; ++a2)
            n4 = n4.add(t3.slice([o2 * r2.shape[0], a2 * r2.shape[1]], [r2.shape[0], r2.shape[1]]));
      else if (3 === r2.rank)
        for (o2 = 0; o2 < e2[0]; ++o2)
          for (a2 = 0; a2 < e2[1]; ++a2)
            for (var i2 = 0; i2 < e2[2]; ++i2)
              n4 = n4.add(t3.slice([o2 * r2.shape[0], a2 * r2.shape[1], i2 * r2.shape[2]], [r2.shape[0], r2.shape[1], r2.shape[2]]));
      else {
        if (4 !== r2.rank)
          throw new Error("Gradient for tile operation is not implemented for rank-" + r2.rank + " tensors yet.");
        for (o2 = 0; o2 < e2[0]; ++o2)
          for (a2 = 0; a2 < e2[1]; ++a2)
            for (i2 = 0; i2 < e2[2]; ++i2)
              for (var u2 = 0; u2 < e2[3]; ++u2)
                n4 = n4.add(t3.slice([o2 * r2.shape[0], a2 * r2.shape[1], i2 * r2.shape[2], u2 * r2.shape[3]], [r2.shape[0], r2.shape[1], r2.shape[2], r2.shape[3]]));
      }
      return n4;
    }};
  });
}});
var Fr = Cn({truncatedNormal_: function(t2, e2, n2, r2, o2) {
  if (void 0 === e2 && (e2 = 0), void 0 === n2 && (n2 = 1), null != r2 && "bool" === r2)
    throw new Error("Unsupported data type " + r2);
  for (var a2 = new or(e2, n2, r2, true, o2), i2 = ur(t2, r2), u2 = 0; u2 < i2.values.length; u2++)
    i2.values[u2] = a2.nextValue();
  return i2.toTensor();
}});
var Or = Cn({unstack_: function(t2, e2) {
  void 0 === e2 && (e2 = 0), e2 = e2 || 0;
  var n2 = ln(t2, "x", "unstack");
  return g(e2 >= -n2.shape.length && e2 < n2.shape.length, function() {
    return "Axis = " + e2 + " is not in [-" + n2.shape.length + ", " + n2.shape.length + ")";
  }), e2 < 0 && (e2 += n2.shape.length), Nt.runKernelFunc(function(t3) {
    return t3.unstack(n2, e2);
  }, {$x: n2}, function(t3) {
    return {$x: function() {
      return Tr(t3, e2);
    }};
  });
}});
var _r = function(t2, e2) {
  return n(this, void 0, void 0, function() {
    var n2, o2, a2, i2, u2, s2, c2, l2, h2, f2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          return n2 = ln(t2, "x", "setdiff1d"), o2 = ln(e2, "y", "setdiff1d"), g(n2.dtype === o2.dtype, function() {
            return "x and y should have the same dtype, but got x (" + n2.dtype + ") and y (" + o2.dtype + ").";
          }), g(1 === n2.rank, function() {
            return "x should be 1D tensor, but got x (" + n2.shape + ").";
          }), g(1 === o2.rank, function() {
            return "y should be 1D tensor, but got y (" + o2.shape + ").";
          }), [4, n2.data()];
        case 1:
          return a2 = r2.sent(), [4, o2.data()];
        case 2:
          for (i2 = r2.sent(), u2 = new Set(i2), s2 = 0, h2 = 0; h2 < a2.length; h2++)
            u2.has(a2[h2]) || s2++;
          for (c2 = new lt([s2], n2.dtype), l2 = new lt([s2], "int32"), h2 = 0, f2 = 0; h2 < a2.length; h2++)
            u2.has(a2[h2]) || (c2.values[f2] = a2[h2], l2.values[f2] = h2, f2++);
          return [2, [c2.toTensor(), l2.toTensor()]];
      }
    });
  });
};
function Mr(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = true);
  var o2 = [];
  if (r2)
    (o2 = o2.concat(e2.slice(0))).push(t2[0] / n2), o2 = o2.concat(t2.slice(1));
  else {
    o2 = o2.concat(t2[0]);
    for (var a2 = e2.length, i2 = 0; i2 < a2; ++i2)
      o2 = o2.concat([t2[i2 + 1] / e2[i2], e2[i2]]);
    o2 = o2.concat(t2.slice(a2 + 1));
  }
  return o2;
}
function Br(t2, e2, n2) {
  void 0 === n2 && (n2 = true);
  var r2 = [];
  if (n2) {
    r2.push(e2);
    for (var o2 = e2 + 1; o2 < t2; ++o2)
      o2 <= 2 * e2 ? (r2.push(o2), r2.push(o2 - (e2 + 1))) : r2.push(o2);
  } else {
    var a2 = [], i2 = [];
    for (o2 = 1; o2 < t2; ++o2)
      o2 >= 2 * e2 + 1 || o2 % 2 == 1 ? i2.push(o2) : a2.push(o2);
    r2.push.apply(r2, a2), r2.push(0), r2.push.apply(r2, i2);
  }
  return r2;
}
function Pr(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = true);
  var o2 = [];
  r2 ? o2.push(t2[0] / n2) : o2.push(t2[0] * n2);
  for (var a2 = 1; a2 < t2.length; ++a2)
    a2 <= e2.length ? r2 ? o2.push(e2[a2 - 1] * t2[a2]) : o2.push(t2[a2] / e2[a2 - 1]) : o2.push(t2[a2]);
  return o2;
}
function Lr(t2, e2) {
  for (var n2 = [0], r2 = 0; r2 < e2; ++r2)
    n2.push(t2[r2][0]);
  return n2;
}
function Wr(t2, e2, n2) {
  for (var r2 = t2.slice(0, 1), o2 = 0; o2 < n2; ++o2)
    r2.push(t2[o2 + 1] - e2[o2][0] - e2[o2][1]);
  return r2;
}
function Ur(t2, e2) {
  if (t2.rank < 1)
    throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was " + t2.rank + ".");
  if (e2.rank < 1)
    throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was " + e2.rank + ".");
  if ("int32" !== e2.dtype)
    throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was " + e2.dtype + ".");
  if (e2.shape[e2.rank - 1] > t2.rank)
    throw new Error("index innermost dimension length must be <= tensor rank; saw: " + e2.shape[e2.rank - 1] + " vs. " + t2.rank);
  if (0 === t2.size)
    throw new Error("Requested more than 0 entries, but input is empty. Input shape: " + t2.shape + ".");
  for (var n2 = e2.shape, r2 = n2[n2.length - 1], o2 = 1, a2 = 0; a2 < n2.length - 1; ++a2)
    o2 *= n2[a2];
  var i2 = t2.shape, u2 = n2.slice();
  u2.pop();
  var s2 = 1;
  for (a2 = r2; a2 < t2.rank; ++a2)
    s2 *= i2[a2], u2.push(i2[a2]);
  var c2 = q(t2.shape).map(function(t3) {
    return t3 / s2;
  }).concat([1]).slice(0, r2);
  return [u2, o2, s2, c2];
}
var Vr = 30;
function zr(t2) {
  return t2 <= Vr ? t2 : H(t2, Math.floor(Math.sqrt(t2)));
}
function Gr(t2, e2, n2) {
  if (e2.rank < 1)
    throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was " + e2.rank + ".");
  if (t2.rank < 1)
    throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was " + t2.rank + ".");
  if ("int32" !== e2.dtype)
    throw new Error("The dtype of 'indices' should be int32, but got dtype: " + e2.dtype);
  if (n2.length < 1)
    throw new Error("Output rank must be greater or equal to 1, but got shape: " + n2);
  if (0 === n2.length) {
    if (0 === e2.size)
      throw new Error("Indices specified for empty output. indices shape: " + e2.shape);
    if (0 === t2.size)
      throw new Error("Updates specified for empty output. updates shape: " + t2.shape);
  }
  !function(t3, e3, n3) {
    var r2 = e3.rank > 1 ? e3.shape[e3.rank - 1] : 1, o2 = e3.rank > 1 ? e3.rank - 1 : 1, a2 = "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: " + n3.shape + ", indices.shape: " + e3.shape + ", shape: " + t3 + ", sliceDim: " + r2 + ", and batchDim: " + o2 + ".";
    if (n3.rank < o2)
      throw new Error(a2 + " update.rank < " + o2 + ". ");
    if (t3.length < r2 + (n3.rank - o2))
      throw new Error(a2 + " Output shape length < " + (r2 + (n3.rank - o2)));
    if (n3.rank !== o2 + t3.length - r2)
      throw new Error(a2 + " update.rank != " + (o2 + t3.length - r2));
    for (var i2 = 0; i2 < o2; ++i2)
      if (n3.shape[i2] !== e3.shape[i2])
        throw new Error(a2 + " updates.shape[" + i2 + "] (" + n3.shape[i2] + ") != indices.shape[" + i2 + "] (" + e3.shape[i2] + ").");
    for (i2 = 0; i2 < n3.rank - o2; ++i2)
      if (n3.shape[i2 + o2] !== t3[i2 + r2])
        throw new Error(a2 + " updates.shape[" + (i2 + o2) + "] (" + n3.shape[i2 + o2] + ") != shape[" + (i2 + o2) + "] (" + t3[i2 + o2] + ")");
  }(n2, e2, t2);
}
function Hr(t2, e2, n2) {
  for (var r2 = e2.rank > 1 ? e2.shape[e2.rank - 1] : 1, o2 = n2.length, a2 = 1, i2 = r2; i2 < o2; ++i2)
    a2 *= n2[i2];
  var u2 = r2 < 1 ? 1 : r2;
  return {sliceRank: r2, numUpdates: e2.size / u2, sliceSize: a2, strides: q(n2.slice(0, r2)).concat([1]), outputSize: w(n2)};
}
function qr(t2, e2, n2) {
  g(t2.rank === e2.length, function() {
    return "Error in slice" + t2.rank + "D: Length of begin " + e2 + " must match the rank of the array (" + t2.rank + ").";
  }), g(t2.rank === n2.length, function() {
    return "Error in slice" + t2.rank + "D: Length of size " + n2 + " must match the rank of the array (" + t2.rank + ").";
  });
  for (var r2 = function(r3) {
    g(e2[r3] + n2[r3] <= t2.shape[r3], function() {
      return "Error in slice" + t2.rank + "D: begin[" + r3 + "] + size[" + r3 + "] (" + (e2[r3] + n2[r3]) + ") would overflow input.shape[" + r3 + "] (" + t2.shape[r3] + ")";
    });
  }, o2 = 0; o2 < t2.rank; ++o2)
    r2(o2);
}
function Kr(t2) {
  for (var e2 = [], n2 = 0; t2 > 0; )
    1 & t2 && e2.push(n2), t2 /= 2, n2++;
  return e2;
}
function jr(t2, e2, n2) {
  for (var r2 = [], o2 = 0; o2 < t2.length; o2++)
    r2[o2] = Math.ceil((e2[o2] - t2[o2]) / n2[o2]);
  return r2;
}
function Xr(t2, e2, n2, r2, o2) {
  var a2 = e2[o2], i2 = n2[o2] || 1;
  (t2 & 1 << o2 || null == a2) && (a2 = i2 > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
  var u2 = r2[o2];
  return a2 < 0 && (a2 += u2), a2 = d(0, a2, u2 - 1);
}
function $r(t2, e2, n2, r2, o2) {
  var a2 = e2[o2], i2 = n2[o2] || 1;
  (t2 & 1 << o2 || null == a2) && (a2 = i2 > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
  var u2 = r2[o2];
  return a2 < 0 && (a2 += u2), a2 = i2 > 0 ? d(0, a2, u2) : d(-1, a2, u2 - 1);
}
function Yr(t2, e2, n2) {
  for (var r2 = n2.length, o2 = 0; o2 < n2.length; o2++)
    if (n2[o2] > 1) {
      r2 = o2;
      break;
    }
  for (o2 = r2 + 1; o2 < n2.length; o2++)
    if (e2[o2] > 0 || n2[o2] !== t2[o2])
      return false;
  return true;
}
function Qr(t2, e2) {
  for (var n2 = t2.length > 0 ? t2[t2.length - 1] : 1, r2 = 0; r2 < t2.length - 1; r2++)
    n2 += t2[r2] * e2[r2];
  return n2;
}
var Jr = Object.freeze({assertParamsValid: qr, maskToAxes: Kr, computeOutShape: jr, startForAxis: Xr, stopForAxis: $r, isSliceContinous: Yr, computeFlatOffset: Qr});
function Zr(t2) {
  return g(G(t2), function() {
    return "The f passed in grad(f) must be a function";
  }), function(e2, n2) {
    var r2 = ln(e2, "x", "tf.grad", null), o2 = null != n2 ? ln(n2, "dy", "tf.grad") : null;
    return Nt.tidy(function() {
      var e3 = Nt.gradients(function() {
        return t2(r2);
      }, [r2], o2), n3 = e3.value, a2 = e3.grads;
      return null != o2 && y(n3.shape, o2.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"), ao(a2), a2[0];
    });
  };
}
function to(t2) {
  return g(G(t2), function() {
    return "The f passed in grads(f) must be a function";
  }), function(e2, n2) {
    g(Array.isArray(e2), function() {
      return "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s";
    });
    var r2 = hn(e2, "args", "tf.grads", null), o2 = null != n2 ? ln(n2, "dy", "tf.grads") : null;
    return Nt.tidy(function() {
      var e3 = Nt.gradients(function() {
        return t2.apply(void 0, r2);
      }, r2, o2), n3 = e3.value, a2 = e3.grads;
      return null != o2 && y(n3.shape, o2.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), ao(a2), a2;
    });
  };
}
function eo(t2) {
  return g(G(t2), function() {
    return "The f passed in valueAndGrad(f) must be a function";
  }), function(e2, n2) {
    g(e2 instanceof dt, function() {
      return "The x passed in valueAndGrad(f)(x) must be a tensor";
    }), g(null == n2 || n2 instanceof dt, function() {
      return "The dy passed in valueAndGrad(f)(x, dy) must be a tensor";
    });
    var r2 = Nt.gradients(function() {
      return t2(e2);
    }, [e2], n2), o2 = r2.grads, a2 = r2.value;
    return ao(o2), {grad: o2[0], value: a2};
  };
}
function no(t2) {
  return g(G(t2), function() {
    return "The f passed in valueAndGrads(f) must be a function";
  }), function(e2, n2) {
    g(Array.isArray(e2) && e2.every(function(t3) {
      return t3 instanceof dt;
    }), function() {
      return "The args passed in valueAndGrads(f)(args) must be array of tensors";
    }), g(null == n2 || n2 instanceof dt, function() {
      return "The dy passed in valueAndGrads(f)(args, dy) must be a tensor";
    });
    var r2 = Nt.gradients(function() {
      return t2.apply(void 0, e2);
    }, e2, n2);
    return null != n2 && y(r2.value.shape, n2.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), ao(r2.grads), r2;
  };
}
function ro(t2, e2) {
  g(G(t2), function() {
    return "The f passed in variableGrads(f) must be a function";
  }), g(null == e2 || Array.isArray(e2) && e2.every(function(t3) {
    return t3 instanceof bt;
  }), function() {
    return "The varList passed in variableGrads(f, varList) must be an array of variables";
  });
  var n2 = null != e2;
  if (!n2)
    for (var r2 in (e2 = [], Nt.registeredVariables))
      e2.push(Nt.registeredVariables[r2]);
  var o2 = n2 ? e2.filter(function(t3) {
    return !t3.trainable;
  }) : null, a2 = e2.length;
  g((e2 = e2.filter(function(t3) {
    return t3.trainable;
  })).length > 0, function() {
    return "variableGrads() expects at least one of the input variables to be trainable, but none of the " + a2 + " variables is trainable.";
  });
  var i2 = Nt.gradients(t2, e2, null, true), u2 = i2.value, s2 = i2.grads;
  g(s2.some(function(t3) {
    return null != t3;
  }), function() {
    return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().";
  }), g(0 === u2.rank, function() {
    return "The f passed in variableGrads(f) must return a scalar, but it returned a rank-" + u2.rank + " tensor";
  });
  var c2 = {};
  return e2.forEach(function(t3, e3) {
    null != s2[e3] && (c2[t3.name] = s2[e3]);
  }), null != o2 && o2.forEach(function(t3) {
    return c2[t3.name] = null;
  }), {value: u2, grads: c2};
}
function oo(t2) {
  return Nt.customGrad(t2);
}
function ao(t2) {
  if (t2.filter(function(t3) {
    return null == t3;
  }).length > 0)
    throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.");
}
var io = Cn({softmax_: function(t2, e2) {
  void 0 === e2 && (e2 = -1);
  var n2 = ln(t2, "logits", "softmax");
  if (-1 === e2 && (e2 = n2.rank - 1), e2 !== n2.rank - 1)
    throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank " + n2.rank + " and dim was " + e2);
  return oo(function(t3, n3) {
    var r2 = t3.logSumExp([e2], true), o2 = t3.toFloat().sub(r2).exp();
    return n3([o2]), {value: o2, gradFunc: function(t4, n4) {
      var r3 = n4[0], o3 = t4.mul(r3);
      return o3.sub(o3.sum([e2], true).mul(r3));
    }};
  })(n2);
}});
var uo = Cn({logSoftmax_: function(t2, e2) {
  void 0 === e2 && (e2 = -1);
  var n2 = ln(t2, "logits", "logSoftmax");
  if (-1 === e2 && (e2 = n2.rank - 1), e2 !== n2.rank - 1)
    throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank " + n2.rank + " and axis was " + e2);
  return oo(function(t3, n3) {
    var r2 = t3.max(e2, true), o2 = t3.sub(r2), a2 = o2.toFloat().sub(o2.exp().sum(e2, true).log());
    return n3([a2]), {value: a2, gradFunc: function(t4, n4) {
      var r3 = n4[0].exp();
      return t4.sub(t4.sum(e2, true).mul(r3));
    }};
  })(n2);
}});
var so = function() {
  function t2(t3, e2) {
    this.backend = t3, this.dataMover = e2, this.data = new WeakMap(), this.dataIdsCount = 0;
  }
  return t2.prototype.get = function(t3) {
    return this.data.has(t3) || this.dataMover.moveData(this.backend, t3), this.data.get(t3);
  }, t2.prototype.set = function(t3, e2) {
    this.dataIdsCount++, this.data.set(t3, e2);
  }, t2.prototype.has = function(t3) {
    return this.data.has(t3);
  }, t2.prototype.delete = function(t3) {
    return this.dataIdsCount--, this.data.delete(t3);
  }, t2.prototype.numDataIds = function() {
    return this.dataIdsCount;
  }, t2;
}();
var co = function() {
  function t2() {
  }
  return t2.prototype.time = function(t3) {
    return lo("time");
  }, t2.prototype.read = function(t3) {
    return lo("read");
  }, t2.prototype.readSync = function(t3) {
    return lo("readSync");
  }, t2.prototype.numDataIds = function() {
    return lo("numDataIds");
  }, t2.prototype.disposeData = function(t3) {
    return lo("disposeData");
  }, t2.prototype.fromPixels = function(t3, e2) {
    return lo("fromPixels");
  }, t2.prototype.write = function(t3, e2, n2) {
    return lo("write");
  }, t2.prototype.move = function(t3, e2, n2, r2) {
    return lo("move");
  }, t2.prototype.memory = function() {
    return lo("memory");
  }, t2.prototype.floatPrecision = function() {
    return lo("floatPrecision");
  }, t2.prototype.epsilon = function() {
    return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
  }, t2.prototype.batchMatMul = function(t3, e2, n2, r2) {
    return lo("batchMatMul");
  }, t2.prototype.fusedBatchMatMul = function(t3) {
    t3.a, t3.b, t3.transposeA, t3.transposeB, t3.bias, t3.activation, t3.preluActivationWeights;
    return lo("fusedBatchMatMul");
  }, t2.prototype.slice = function(t3, e2, n2) {
    return lo("slice");
  }, t2.prototype.stridedSlice = function(t3, e2, n2, r2) {
    return lo("stridedSlice");
  }, t2.prototype.unstack = function(t3, e2) {
    return lo("unstack");
  }, t2.prototype.reverse = function(t3, e2) {
    return lo("reverse");
  }, t2.prototype.concat = function(t3, e2) {
    return lo("concat");
  }, t2.prototype.neg = function(t3) {
    return lo("neg");
  }, t2.prototype.add = function(t3, e2) {
    return lo("add");
  }, t2.prototype.addN = function(t3) {
    return lo("addN");
  }, t2.prototype.subtract = function(t3, e2) {
    return lo("subtract");
  }, t2.prototype.multiply = function(t3, e2) {
    return lo("multiply");
  }, t2.prototype.realDivide = function(t3, e2) {
    return lo("realDivide");
  }, t2.prototype.floorDiv = function(t3, e2) {
    return lo("floorDiv");
  }, t2.prototype.sum = function(t3, e2) {
    return lo("sum");
  }, t2.prototype.prod = function(t3, e2) {
    return lo("prod");
  }, t2.prototype.unsortedSegmentSum = function(t3, e2, n2) {
    return lo("unsortedSegmentSum");
  }, t2.prototype.argMin = function(t3, e2) {
    return lo("argMin");
  }, t2.prototype.argMax = function(t3, e2) {
    return lo("argMax");
  }, t2.prototype.equal = function(t3, e2) {
    return lo("equal");
  }, t2.prototype.notEqual = function(t3, e2) {
    return lo("notEqual");
  }, t2.prototype.less = function(t3, e2) {
    return lo("less");
  }, t2.prototype.lessEqual = function(t3, e2) {
    return lo("lessEqual");
  }, t2.prototype.greater = function(t3, e2) {
    return lo("greater");
  }, t2.prototype.greaterEqual = function(t3, e2) {
    return lo("greaterEqual");
  }, t2.prototype.logicalNot = function(t3) {
    return lo("logicalNot");
  }, t2.prototype.logicalAnd = function(t3, e2) {
    return lo("logicalAnd");
  }, t2.prototype.logicalOr = function(t3, e2) {
    return lo("logicalOr");
  }, t2.prototype.where = function(t3) {
    return lo("where");
  }, t2.prototype.select = function(t3, e2, n2) {
    return lo("select");
  }, t2.prototype.topk = function(t3, e2, n2) {
    return lo("topk");
  }, t2.prototype.min = function(t3, e2) {
    return lo("min");
  }, t2.prototype.minimum = function(t3, e2) {
    return lo("minimum");
  }, t2.prototype.mod = function(t3, e2) {
    return lo("mod");
  }, t2.prototype.max = function(t3, e2) {
    return lo("max");
  }, t2.prototype.maximum = function(t3, e2) {
    return lo("maximum");
  }, t2.prototype.all = function(t3, e2) {
    return lo("all");
  }, t2.prototype.any = function(t3, e2) {
    return lo("any");
  }, t2.prototype.squaredDifference = function(t3, e2) {
    return lo("squaredDifference");
  }, t2.prototype.ceil = function(t3) {
    return lo("ceil");
  }, t2.prototype.floor = function(t3) {
    return lo("floor");
  }, t2.prototype.round = function(t3) {
    return lo("round");
  }, t2.prototype.sign = function(t3) {
    return lo("sign");
  }, t2.prototype.isNaN = function(t3) {
    return lo("isNaN");
  }, t2.prototype.isInf = function(t3) {
    return lo("isInf");
  }, t2.prototype.isFinite = function(t3) {
    return lo("isFinite");
  }, t2.prototype.pow = function(t3, e2) {
    return lo("pow");
  }, t2.prototype.exp = function(t3) {
    return lo("exp");
  }, t2.prototype.expm1 = function(t3) {
    return lo("expm1");
  }, t2.prototype.log = function(t3) {
    return lo("log");
  }, t2.prototype.log1p = function(t3) {
    return lo("log1p");
  }, t2.prototype.sqrt = function(t3) {
    return lo("sqrt");
  }, t2.prototype.rsqrt = function(t3) {
    return lo("rsqrt");
  }, t2.prototype.square = function(t3) {
    return lo("square");
  }, t2.prototype.reciprocal = function(t3) {
    return lo("reciprocal");
  }, t2.prototype.relu = function(t3) {
    return lo("relu");
  }, t2.prototype.relu6 = function(t3) {
    return lo("relu6");
  }, t2.prototype.prelu = function(t3, e2) {
    return lo("prelu");
  }, t2.prototype.elu = function(t3) {
    return lo("elu");
  }, t2.prototype.eluDer = function(t3, e2) {
    return lo("eluDer");
  }, t2.prototype.selu = function(t3) {
    return lo("selu");
  }, t2.prototype.int = function(t3) {
    return lo("int");
  }, t2.prototype.clip = function(t3, e2, n2) {
    return lo("clip");
  }, t2.prototype.abs = function(t3) {
    return lo("abs");
  }, t2.prototype.complexAbs = function(t3) {
    return lo("complexAbs");
  }, t2.prototype.sigmoid = function(t3) {
    return lo("sigmoid");
  }, t2.prototype.softplus = function(t3) {
    return lo("softplus");
  }, t2.prototype.sin = function(t3) {
    return lo("sin");
  }, t2.prototype.cos = function(t3) {
    return lo("cos");
  }, t2.prototype.tan = function(t3) {
    return lo("tan");
  }, t2.prototype.asin = function(t3) {
    return lo("asin");
  }, t2.prototype.acos = function(t3) {
    return lo("acos");
  }, t2.prototype.atan = function(t3) {
    return lo("atan");
  }, t2.prototype.atan2 = function(t3, e2) {
    return lo("atan2");
  }, t2.prototype.sinh = function(t3) {
    return lo("sinh");
  }, t2.prototype.cosh = function(t3) {
    return lo("cosh");
  }, t2.prototype.tanh = function(t3) {
    return lo("tanh");
  }, t2.prototype.asinh = function(t3) {
    return lo("asinh");
  }, t2.prototype.acosh = function(t3) {
    return lo("acosh");
  }, t2.prototype.atanh = function(t3) {
    return lo("atanh");
  }, t2.prototype.erf = function(t3) {
    return lo("erf");
  }, t2.prototype.step = function(t3, e2) {
    return lo("step");
  }, t2.prototype.fusedConv2d = function(t3) {
    t3.input, t3.filter, t3.convInfo, t3.bias, t3.activation, t3.preluActivationWeights;
    return lo("fusedConv2d");
  }, t2.prototype.conv2d = function(t3, e2, n2) {
    return lo("conv2d");
  }, t2.prototype.conv2dDerInput = function(t3, e2, n2) {
    return lo("conv2dDerInput");
  }, t2.prototype.conv2dDerFilter = function(t3, e2, n2) {
    return lo("conv2dDerFilter");
  }, t2.prototype.fusedDepthwiseConv2D = function(t3) {
    t3.input, t3.filter, t3.convInfo, t3.bias, t3.activation, t3.preluActivationWeights;
    return lo("fusedDepthwiseConv2D");
  }, t2.prototype.depthwiseConv2D = function(t3, e2, n2) {
    return lo("depthwiseConv2D");
  }, t2.prototype.depthwiseConv2DDerInput = function(t3, e2, n2) {
    return lo("depthwiseConv2DDerInput");
  }, t2.prototype.depthwiseConv2DDerFilter = function(t3, e2, n2) {
    return lo("depthwiseConv2DDerFilter");
  }, t2.prototype.conv3d = function(t3, e2, n2) {
    return lo("conv3d");
  }, t2.prototype.conv3dDerInput = function(t3, e2, n2) {
    return lo("conv3dDerInput");
  }, t2.prototype.conv3dDerFilter = function(t3, e2, n2) {
    return lo("conv3dDerFilter");
  }, t2.prototype.maxPool = function(t3, e2) {
    return lo("maxPool");
  }, t2.prototype.maxPoolBackprop = function(t3, e2, n2, r2) {
    return lo("maxPoolBackprop");
  }, t2.prototype.avgPool = function(t3, e2) {
    return lo("avgPool");
  }, t2.prototype.avgPoolBackprop = function(t3, e2, n2) {
    return lo("avgPoolBackprop");
  }, t2.prototype.avgPool3d = function(t3, e2) {
    return lo("avgPool3d");
  }, t2.prototype.avgPool3dBackprop = function(t3, e2, n2) {
    return lo("avgPool3dBackprop");
  }, t2.prototype.maxPool3d = function(t3, e2) {
    return lo("maxPool3d");
  }, t2.prototype.maxPool3dBackprop = function(t3, e2, n2, r2) {
    return lo("maxPool3dBackprop");
  }, t2.prototype.reshape = function(t3, e2) {
    return lo("reshape");
  }, t2.prototype.cast = function(t3, e2) {
    return lo("cast");
  }, t2.prototype.tile = function(t3, e2) {
    return lo("tile");
  }, t2.prototype.pad = function(t3, e2, n2) {
    return lo("pad");
  }, t2.prototype.transpose = function(t3, e2) {
    return lo("transpose");
  }, t2.prototype.gather = function(t3, e2, n2) {
    return lo("gather");
  }, t2.prototype.gatherND = function(t3, e2) {
    return lo("gatherND");
  }, t2.prototype.scatterND = function(t3, e2, n2) {
    return lo("scatterND");
  }, t2.prototype.batchToSpaceND = function(t3, e2, n2) {
    return lo("batchToSpaceND");
  }, t2.prototype.spaceToBatchND = function(t3, e2, n2) {
    return lo("spaceToBatchND");
  }, t2.prototype.resizeBilinear = function(t3, e2, n2, r2) {
    return lo("resizeBilinear");
  }, t2.prototype.resizeBilinearBackprop = function(t3, e2, n2) {
    return lo("resizeBilinearBackprop");
  }, t2.prototype.resizeNearestNeighbor = function(t3, e2, n2, r2) {
    return lo("resizeNearestNeighbor");
  }, t2.prototype.resizeNearestNeighborBackprop = function(t3, e2, n2) {
    return lo("resizeNearestNeighborBackprop");
  }, t2.prototype.batchNormalization = function(t3, e2, n2, r2, o2, a2) {
    return lo("batchNormalization");
  }, t2.prototype.localResponseNormalization4D = function(t3, e2, n2, r2, o2) {
    return lo("localResponseNormalization4D");
  }, t2.prototype.LRNGrad = function(t3, e2, n2, r2, o2, a2, i2) {
    return lo("LRNGrad");
  }, t2.prototype.multinomial = function(t3, e2, n2, r2) {
    return lo("multinomial");
  }, t2.prototype.oneHot = function(t3, e2, n2, r2) {
    return lo("oneHot");
  }, t2.prototype.cumsum = function(t3, e2, n2, r2) {
    return lo("cumsum");
  }, t2.prototype.nonMaxSuppression = function(t3, e2, n2, r2, o2) {
    return lo("nonMaxSuppression");
  }, t2.prototype.fft = function(t3) {
    return lo("fft");
  }, t2.prototype.ifft = function(t3) {
    return lo("ifft");
  }, t2.prototype.complex = function(t3, e2) {
    return lo("complex");
  }, t2.prototype.real = function(t3) {
    return lo("real");
  }, t2.prototype.imag = function(t3) {
    return lo("imag");
  }, t2.prototype.cropAndResize = function(t3, e2, n2, r2, o2, a2) {
    return lo("cropAndResize");
  }, t2.prototype.depthToSpace = function(t3, e2, n2) {
    return lo("depthToSpace");
  }, t2.prototype.split = function(t3, e2, n2) {
    return lo("split");
  }, t2.prototype.sparseToDense = function(t3, e2, n2, r2) {
    return lo("sparseToDense");
  }, t2.prototype.diag = function(t3) {
    return lo("diag");
  }, t2.prototype.fill = function(t3, e2, n2) {
    return lo("fill");
  }, t2.prototype.onesLike = function(t3) {
    return lo("onesLike");
  }, t2.prototype.zerosLike = function(t3) {
    return lo("zerosLike");
  }, t2.prototype.linspace = function(t3, e2, n2) {
    return lo("linspace");
  }, t2.prototype.dispose = function() {
    return lo("dispose");
  }, t2;
}();
function lo(t2) {
  throw new Error("'" + t2 + "' not yet implemented or not found in the registry. Did you forget to import the kernel?");
}
function ho(t2, e2) {
  for (var n2 = t2.length, r2 = [], o2 = 0; o2 < n2; o2++) {
    var a2 = n2 - 1 - o2, i2 = t2[a2] || 1;
    (e2[e2.length - 1 - o2] || 1) > 1 && 1 === i2 && r2.unshift(a2);
  }
  return r2;
}
function fo(t2, e2) {
  for (var n2 = [], r2 = 0; r2 < e2.length; r2++) {
    var o2 = t2[t2.length - r2 - 1], a2 = e2.length - r2 - 1, i2 = e2[a2];
    (null == o2 || 1 === o2 && i2 > 1) && n2.unshift(a2);
  }
  return n2;
}
function po(t2, e2) {
  for (var n2 = [], r2 = Math.max(t2.length, e2.length), o2 = 0; o2 < r2; o2++) {
    var a2 = t2[t2.length - o2 - 1];
    null == a2 && (a2 = 1);
    var i2 = e2[e2.length - o2 - 1];
    if (null == i2 && (i2 = 1), 1 === a2)
      n2.unshift(i2);
    else if (1 === i2)
      n2.unshift(a2);
    else {
      if (a2 !== i2)
        throw Error("Operands could not be broadcast together with shapes " + t2 + " and " + e2 + ".");
      n2.unshift(a2);
    }
  }
  return n2;
}
function vo(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === i2 && (i2 = "channelsLast");
  var u2, s2 = bo(e2), c2 = s2[0], l2 = s2[1];
  if ("channelsLast" === i2)
    u2 = [c2, l2, t2[3], t2[3]];
  else {
    if ("channelsFirst" !== i2)
      throw new Error("Unknown dataFormat " + i2);
    u2 = [c2, l2, t2[1], t2[1]];
  }
  return go(t2, u2, n2, r2, o2, a2, false, i2);
}
function mo(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === i2 && (i2 = "NDHWC");
  var u2, s2, c2 = wo(e2), l2 = c2[0], h2 = c2[1], f2 = c2[2];
  if ("NDHWC" === i2)
    s2 = "channelsLast", u2 = [l2, h2, f2, t2[4], t2[4]];
  else {
    if ("NCDHW" !== i2)
      throw new Error("Unknown dataFormat " + i2);
    s2 = "channelsFirst", u2 = [l2, h2, f2, t2[1], t2[1]];
  }
  return yo(t2, u2, n2, r2, o2, false, s2, a2);
}
function go(t2, e2, n2, r2, o2, a2, i2, u2) {
  void 0 === i2 && (i2 = false), void 0 === u2 && (u2 = "channelsLast");
  var s2 = [-1, -1, -1, -1], c2 = s2[0], l2 = s2[1], h2 = s2[2], f2 = s2[3];
  if ("channelsLast" === u2)
    c2 = t2[0], l2 = t2[1], h2 = t2[2], f2 = t2[3];
  else {
    if ("channelsFirst" !== u2)
      throw new Error("Unknown dataFormat " + u2);
    c2 = t2[0], f2 = t2[1], l2 = t2[2], h2 = t2[3];
  }
  var p2, d2 = e2[0], v2 = e2[1], m2 = e2[3], y2 = bo(n2), x2 = y2[0], b2 = y2[1], w2 = bo(r2), C2 = w2[0], R2 = w2[1], I2 = Co(d2, C2), k2 = Co(v2, R2), S2 = function(t3, e3, n3, r3, o3, a3, i3, u3) {
    var s3, c3, l3;
    if ("number" == typeof t3) {
      var h3 = 0 === t3 ? "VALID" : "NUMBER";
      s3 = {top: t3, bottom: t3, left: t3, right: t3, type: h3};
      var f3 = function(t4, e4, n4, r4, o4) {
        null == r4 && (r4 = xo(t4, e4, n4));
        var a4 = t4[0], i4 = t4[1], u4 = Eo((a4 - e4 + 2 * r4) / n4 + 1, o4);
        g(E(u4), function() {
          return "The output # of rows (" + u4 + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var s4 = Eo((i4 - e4 + 2 * r4) / n4 + 1, o4);
        return g(E(s4), function() {
          return "The output # of columns (" + s4 + ") must be an integer. Change the stride and/or zero pad parameters";
        }), [u4, s4];
      }([e3, n3], a3, r3, t3, u3);
      c3 = f3[0], l3 = f3[1];
    } else if ("same" === t3) {
      c3 = Math.ceil(e3 / r3), l3 = Math.ceil(n3 / o3);
      var p3 = Math.max(0, (c3 - 1) * r3 + a3 - e3), d3 = Math.max(0, (l3 - 1) * o3 + i3 - n3), v3 = Math.floor(p3 / 2), m3 = p3 - v3, y3 = Math.floor(d3 / 2), x3 = d3 - y3;
      s3 = {top: v3, bottom: m3, left: y3, right: x3, type: "SAME"};
    } else {
      if ("valid" !== t3)
        throw Error("Unknown padding parameter: " + t3);
      s3 = {top: 0, bottom: 0, left: 0, right: 0, type: "VALID"}, c3 = Math.ceil((e3 - a3 + 1) / r3), l3 = Math.ceil((n3 - i3 + 1) / o3);
    }
    return {padInfo: s3, outHeight: c3, outWidth: l3};
  }(o2, l2, h2, x2, b2, I2, k2, a2), A2 = S2.padInfo, D2 = S2.outHeight, T2 = S2.outWidth, N2 = i2 ? m2 * f2 : m2;
  return "channelsFirst" === u2 ? p2 = [c2, N2, D2, T2] : "channelsLast" === u2 && (p2 = [c2, D2, T2, N2]), {batchSize: c2, dataFormat: u2, inHeight: l2, inWidth: h2, inChannels: f2, outHeight: D2, outWidth: T2, outChannels: N2, padInfo: A2, strideHeight: x2, strideWidth: b2, filterHeight: d2, filterWidth: v2, effectiveFilterHeight: I2, effectiveFilterWidth: k2, dilationHeight: C2, dilationWidth: R2, inShape: t2, outShape: p2, filterShape: e2};
}
function yo(t2, e2, n2, r2, o2, a2, i2, u2) {
  void 0 === a2 && (a2 = false), void 0 === i2 && (i2 = "channelsLast");
  var s2 = [-1, -1, -1, -1, -1], c2 = s2[0], l2 = s2[1], h2 = s2[2], f2 = s2[3], p2 = s2[4];
  if ("channelsLast" === i2)
    c2 = t2[0], l2 = t2[1], h2 = t2[2], f2 = t2[3], p2 = t2[4];
  else {
    if ("channelsFirst" !== i2)
      throw new Error("Unknown dataFormat " + i2);
    c2 = t2[0], p2 = t2[1], l2 = t2[2], h2 = t2[3], f2 = t2[4];
  }
  var d2, v2 = e2[0], m2 = e2[1], y2 = e2[2], x2 = e2[4], b2 = wo(n2), w2 = b2[0], C2 = b2[1], R2 = b2[2], I2 = wo(r2), k2 = I2[0], S2 = I2[1], A2 = I2[2], D2 = Co(v2, k2), T2 = Co(m2, S2), N2 = Co(y2, A2), F2 = function(t3, e3, n3, r3, o3, a3, i3, u3, s3, c3, l3) {
    var h3, f3, p3, d3;
    if ("number" == typeof t3) {
      var v3 = 0 === t3 ? "VALID" : "NUMBER";
      h3 = {top: t3, bottom: t3, left: t3, right: t3, front: t3, back: t3, type: v3};
      var m3 = function(t4, e4, n4, r4, o4, a4) {
        null == o4 && (o4 = xo(t4, e4, r4));
        var i4 = t4[0], u4 = t4[1], s4 = t4[2], c4 = Eo((i4 - e4 + 2 * o4) / r4 + 1, a4);
        g(E(c4), function() {
          return "The output # of depths (" + c4 + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var l4 = Eo((u4 - e4 + 2 * o4) / r4 + 1, a4);
        g(E(l4), function() {
          return "The output # of rows (" + l4 + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var h4 = Eo((s4 - e4 + 2 * o4) / r4 + 1, a4);
        return g(E(h4), function() {
          return "The output # of columns (" + h4 + ") must be an integer. Change the stride and/or zero pad parameters";
        }), [c4, l4, h4, n4];
      }([e3, n3, r3, 1], u3, 1, o3, t3, l3);
      f3 = m3[0], p3 = m3[1], d3 = m3[2];
    } else if ("same" === t3) {
      f3 = Math.ceil(e3 / o3), p3 = Math.ceil(n3 / a3), d3 = Math.ceil(r3 / i3);
      var y3 = (f3 - 1) * o3 + u3 - e3, x3 = (p3 - 1) * a3 + s3 - n3, b3 = (d3 - 1) * i3 + c3 - r3, w3 = Math.floor(y3 / 2), C3 = y3 - w3, R3 = Math.floor(x3 / 2), I3 = x3 - R3, k3 = Math.floor(b3 / 2), S3 = b3 - k3;
      h3 = {top: R3, bottom: I3, left: k3, right: S3, front: w3, back: C3, type: "SAME"};
    } else {
      if ("valid" !== t3)
        throw Error("Unknown padding parameter: " + t3);
      h3 = {top: 0, bottom: 0, left: 0, right: 0, front: 0, back: 0, type: "VALID"}, f3 = Math.ceil((e3 - u3 + 1) / o3), p3 = Math.ceil((n3 - s3 + 1) / a3), d3 = Math.ceil((r3 - c3 + 1) / i3);
    }
    return {padInfo: h3, outDepth: f3, outHeight: p3, outWidth: d3};
  }(o2, l2, h2, f2, w2, C2, R2, D2, T2, N2, u2), O2 = F2.padInfo, _2 = F2.outDepth, M2 = F2.outHeight, B2 = F2.outWidth, P2 = a2 ? x2 * p2 : x2;
  return "channelsFirst" === i2 ? d2 = [c2, P2, _2, M2, B2] : "channelsLast" === i2 && (d2 = [c2, _2, M2, B2, P2]), {batchSize: c2, dataFormat: i2, inDepth: l2, inHeight: h2, inWidth: f2, inChannels: p2, outDepth: _2, outHeight: M2, outWidth: B2, outChannels: P2, padInfo: O2, strideDepth: w2, strideHeight: C2, strideWidth: R2, filterDepth: v2, filterHeight: m2, filterWidth: y2, effectiveFilterDepth: D2, effectiveFilterHeight: T2, effectiveFilterWidth: N2, dilationDepth: k2, dilationHeight: S2, dilationWidth: A2, inShape: t2, outShape: d2, filterShape: e2};
}
function xo(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = 1);
  var o2 = Co(e2, r2);
  return Math.floor((t2[0] * (n2 - 1) - n2 + o2) / 2);
}
function bo(t2) {
  return "number" == typeof t2 ? [t2, t2, t2] : 2 === t2.length ? [t2[0], t2[1], 1] : t2;
}
function wo(t2) {
  return "number" == typeof t2 ? [t2, t2, t2] : t2;
}
function Co(t2, e2) {
  return e2 <= 1 ? t2 : t2 + (t2 - 1) * (e2 - 1);
}
function Eo(t2, e2) {
  if (!e2)
    return t2;
  switch (e2) {
    case "round":
      return Math.round(t2);
    case "ceil":
      return Math.ceil(t2);
    case "floor":
      return Math.floor(t2);
    default:
      throw new Error("Unknown roundingMode " + e2);
  }
}
function Ro(t2) {
  var e2 = bo(t2), n2 = e2[0], r2 = e2[1], o2 = e2[2];
  return 1 === n2 && 1 === r2 && 1 === o2;
}
function Io(t2, e2) {
  return Ro(t2) || Ro(e2);
}
function ko(t2) {
  if ("NHWC" === t2)
    return "channelsLast";
  if ("NCHW" === t2)
    return "channelsFirst";
  throw new Error("Unknown dataFormat " + t2);
}
function So(t2, e2, n2) {
  if ("complex64" === e2) {
    if ("complex64" === t2.dtype)
      return t2.clone();
    var r2 = Pn(t2.shape), o2 = t2.toFloat(), a2 = n2.complex(o2, r2);
    return r2.dispose(), o2.dispose(), a2;
  }
  if (!M(t2.dtype, e2))
    return Nt.makeTensorFromDataId(t2.dataId, t2.shape, e2);
  if ("complex64" === t2.dtype) {
    var i2 = n2.real(t2);
    a2 = i2.cast(e2);
    return i2.dispose(), a2;
  }
  if ("int32" === e2)
    return n2.int(t2);
  if ("bool" === e2) {
    var u2 = An(0, t2.dtype);
    a2 = n2.notEqual(t2, u2);
    return u2.dispose(), a2;
  }
  throw new Error("Error in Cast: failed to cast " + t2.dtype + " to " + e2);
}
function Ao(t2, e2) {
  return Nt.makeTensorFromDataId(t2.dataId, e2, t2.dtype);
}
function Do(t2, e2, n2) {
  var r2 = (e2 - t2) / (n2 - 1), o2 = $(n2, "float32");
  o2[0] = t2;
  for (var a2 = 1; a2 < o2.length; a2++)
    o2[a2] = o2[a2 - 1] + r2;
  return Dn(o2, "float32");
}
var To = Object.freeze({castTensor: So, reshapeTensor: Ao, linspaceImpl: Do, upcastType: Ct, axesAreInnerMostDims: fn, combineLocations: pn, computeOutAndReduceShapes: dn, expandShapeToKeepDim: vn, assertAxesAreInnerMostDims: mn, getAxesPermutation: gn, getUndoAxesPermutation: yn, getInnerMostAxes: xn, getBroadcastDims: ho, getReductionAxes: fo, assertAndGetBroadcastShape: po, assertParamsConsistent: bn, computeOutShape: wn, computePool2DInfo: vo, computePool3DInfo: mo, computeConv2DInfo: go, computeConv3DInfo: yo, computeDefaultPad: xo, tupleValuesAreOne: Ro, eitherStridesOrDilationsAreOne: Io, convertConv2DDataFormat: ko});
function No(t2, e2) {
  if (t2.length !== e2.length)
    throw new Error("Cannot merge real and imag arrays of different lengths. real:" + t2.length + ", imag: " + e2.length + ".");
  for (var n2 = new Float32Array(2 * t2.length), r2 = 0; r2 < n2.length; r2 += 2)
    n2[r2] = t2[r2 / 2], n2[r2 + 1] = e2[r2 / 2];
  return n2;
}
function Fo(t2, e2) {
  return {real: t2[2 * e2], imag: t2[2 * e2 + 1]};
}
function Oo(t2, e2, n2, r2) {
  t2[2 * r2] = e2, t2[2 * r2 + 1] = n2;
}
function _o(t2, e2, n2) {
  var r2 = (n2 ? 2 : -2) * Math.PI * (t2 / e2);
  return {real: Math.cos(r2), imag: Math.sin(r2)};
}
function Mo(t2, e2, n2, r2, o2) {
  for (var a2 = Array.from(e2).map(function(t3, e3) {
    return {score: t3, boxIndex: e3};
  }).filter(function(t3) {
    return t3.score > o2;
  }).sort(function(t3, e3) {
    return e3.score - t3.score;
  }), i2 = [], u2 = 0; u2 < a2.length; u2++) {
    var s2 = a2[u2], c2 = s2.score, l2 = s2.boxIndex;
    if (c2 < o2)
      break;
    for (var h2 = false, f2 = i2.length - 1; f2 >= 0; --f2) {
      if (Bo(t2, l2, i2[f2]) >= r2) {
        h2 = true;
        break;
      }
    }
    if (!h2 && (i2.push(l2), i2.length >= n2))
      break;
  }
  return Dn(i2, "int32");
}
function Bo(t2, e2, n2) {
  var r2 = t2.subarray(4 * e2, 4 * e2 + 4), o2 = t2.subarray(4 * n2, 4 * n2 + 4), a2 = Math.min(r2[0], r2[2]), i2 = Math.min(r2[1], r2[3]), u2 = Math.max(r2[0], r2[2]), s2 = Math.max(r2[1], r2[3]), c2 = Math.min(o2[0], o2[2]), l2 = Math.min(o2[1], o2[3]), h2 = Math.max(o2[0], o2[2]), f2 = Math.max(o2[1], o2[3]), p2 = (u2 - a2) * (s2 - i2), d2 = (h2 - c2) * (f2 - l2);
  if (p2 <= 0 || d2 <= 0)
    return 0;
  var v2 = Math.max(a2, c2), m2 = Math.max(i2, l2), g2 = Math.min(u2, h2), y2 = Math.min(s2, f2), x2 = Math.max(g2 - v2, 0) * Math.max(y2 - m2, 0);
  return x2 / (p2 + d2 - x2);
}
function Po(t2, e2, n2) {
  var r2 = new Array(t2.rank).fill(0), o2 = t2.shape.slice();
  return e2.map(function(e3) {
    o2[n2] = e3;
    var a2 = t2.slice(r2, o2);
    return r2[n2] += e3, a2;
  });
}
function Lo(t2, e2) {
  for (var n2 = new Array(t2.rank), r2 = 0; r2 < n2.length; r2++)
    n2[r2] = t2.shape[r2] * e2[r2];
  var o2 = ur(n2, t2.dtype);
  for (r2 = 0; r2 < o2.values.length; ++r2) {
    for (var a2 = o2.indexToLoc(r2), i2 = new Array(t2.rank), u2 = 0; u2 < i2.length; u2++)
      i2[u2] = a2[u2] % t2.shape[u2];
    var s2 = t2.locToIndex(i2);
    o2.values[r2] = t2.values[s2];
  }
  return o2.toTensor();
}
function Wo(t2, e2, n2, r2, o2) {
  for (var a2 = e2[e2.length - 1], i2 = [t2.length / a2, a2], u2 = i2[0], s2 = i2[1], c2 = N(n2, u2 * r2), l2 = N("int32", u2 * r2), h2 = 0; h2 < u2; h2++) {
    for (var f2 = h2 * s2, p2 = t2.subarray(f2, f2 + s2), d2 = [], v2 = 0; v2 < p2.length; v2++)
      d2.push({value: p2[v2], index: v2});
    d2.sort(function(t3, e3) {
      return e3.value - t3.value;
    });
    var m2 = h2 * r2, g2 = c2.subarray(m2, m2 + r2), y2 = l2.subarray(m2, m2 + r2);
    for (v2 = 0; v2 < r2; v2++)
      g2[v2] = d2[v2].value, y2[v2] = d2[v2].index;
  }
  var x2 = e2.slice();
  return x2[x2.length - 1] = r2, [kn(c2, x2, n2), kn(l2, x2, "int32")];
}
function Uo(t2, e2) {
  for (var n2 = [], r2 = 0; r2 < e2.length; r2++)
    e2[r2] && n2.push(r2);
  var o2 = ur(t2, "int32"), a2 = ur([n2.length, t2.length], "int32");
  for (r2 = 0; r2 < n2.length; r2++) {
    var i2 = o2.indexToLoc(n2[r2]), u2 = r2 * t2.length;
    a2.values.set(i2, u2);
  }
  return a2.toTensor();
}
var Vo = function() {
  return function(t2, e2) {
    this.outputShape = [], this.outputShape = t2, this.variableNames = e2.map(function(t3, e3) {
      return "T" + e3;
    });
    var n2 = [];
    this.variableNames.forEach(function(t3) {
      n2.push("float v" + t3 + " = get" + t3 + "AtOutCoords();");
    });
    var r2 = this.variableNames.map(function(t3) {
      return "v" + t3;
    }).join(" + ");
    this.userCode = "\n      void main() {\n        " + n2.join("\n        ") + "\n\n        float result = " + r2 + ";\n        setOutput(result);\n      }\n    ";
  };
}();
var zo = function() {
  return function(t2, e2) {
    this.outputShape = [], this.packedInputs = true, this.packedOutput = true, this.outputShape = t2, this.variableNames = e2.map(function(t3, e3) {
      return "T" + e3;
    });
    var n2 = [];
    this.variableNames.forEach(function(t3) {
      n2.push("vec4 v" + t3 + " = get" + t3 + "AtOutCoords();");
    });
    var r2 = this.variableNames.map(function(t3) {
      return "v" + t3;
    }).join(" + ");
    this.userCode = "\n      void main() {\n        " + n2.join("\n        ") + "\n\n        vec4 result = " + r2 + ";\n        setOutput(result);\n      }\n    ";
  };
}();
var Go = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["A"];
    var r2 = t2.windowSize, o2 = t2.batchSize, a2 = t2.inSize, i2 = Math.ceil(a2 / r2);
    n2 || this.variableNames.push("bestIndicesA"), this.outputShape = [o2, i2];
    var u2 = "max" === e2 ? ">" : "<", s2 = n2 ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
    this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + r2 + ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < " + r2 + "; i++) {\n          int inIdx = " + s2 + ";\n          float candidate = getA(batch, inIdx);\n          if (candidate " + u2 + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
  };
}();
function Ho(t2, e2) {
  return ["x", "y", "z", "w", "u", "v"].slice(0, e2).map(function(e3) {
    return t2 + "." + e3;
  });
}
function qo(t2, e2) {
  return 1 === e2 ? [t2] : Ho(t2, e2);
}
function Ko() {
  var t2, e2, n2, r2, o2, i2, u2, s2, c2, l2;
  return 2 === a().getNumber("WEBGL_VERSION") ? (t2 = "#version 300 es", e2 = "in", n2 = "out", r2 = "in", o2 = "texture", i2 = "outputColor", u2 = "out vec4 outputColor;", s2 = "\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ", c2 = "", l2 = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (t2 = "", e2 = "attribute", n2 = "varying", r2 = "varying", o2 = "texture2D", i2 = "gl_FragColor", u2 = "", s2 = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", c2 = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", l2 = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), {version: t2, attribute: e2, varyingVs: n2, varyingFs: r2, texture2D: o2, output: i2, defineOutput: u2, defineSpecialNaN: s2, defineSpecialInf: c2, defineRound: l2};
}
function jo(t2, e2, n2) {
  void 0 === n2 && (n2 = "index");
  var r2 = q(e2);
  return r2.map(function(e3, o2) {
    return "int " + t2[o2] + " = " + n2 + " / " + e3 + "; " + (o2 === r2.length - 1 ? "int " + t2[o2 + 1] + " = " + n2 + " - " + t2[o2] + " * " + e3 : "index -= " + t2[o2] + " * " + e3) + ";";
  }).join("");
}
function Xo(t2) {
  var e2 = q(t2).map(function(t3) {
    return t3.toString();
  });
  return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * " + e2[0] + " + coords.y * " + e2[1] + " + coords.z;\n  }\n";
}
var $o = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";
function Yo(t2, e2, n2, r2) {
  var o2 = [];
  t2.forEach(function(t3) {
    var e3 = w(t3.shapeInfo.logicalShape);
    t3.shapeInfo.isUniform ? o2.push("uniform float " + t3.name + (e3 > 1 ? "[" + e3 + "]" : "") + ";") : (o2.push("uniform sampler2D " + t3.name + ";"), o2.push("uniform int offset" + t3.name + ";"));
  });
  var a2, i2, u2 = o2.join("\n"), s2 = t2.map(function(t3) {
    return function(t4, e3, n3) {
      void 0 === n3 && (n3 = false);
      var r3 = "";
      r3 += n3 ? Jo(t4) : Qo(t4);
      var o3 = t4.shapeInfo.logicalShape, a3 = e3.logicalShape;
      o3.length <= a3.length && (r3 += n3 ? function(t5, e4) {
        var n4, r4 = t5.name, o4 = r4.charAt(0).toUpperCase() + r4.slice(1), a4 = "get" + o4 + "AtOutCoords", i3 = t5.shapeInfo.logicalShape.length, u3 = e4.logicalShape.length, s3 = ho(t5.shapeInfo.logicalShape, e4.logicalShape), c3 = aa(u3), l3 = u3 - i3, h3 = ["x", "y", "z", "w", "u", "v"];
        n4 = 0 === i3 ? "" : u3 < 2 && s3.length >= 1 ? "coords = 0;" : s3.map(function(t6) {
          return "coords." + h3[t6 + l3] + " = 0;";
        }).join("\n");
        var f3 = "";
        f3 = u3 < 2 && i3 > 0 ? "coords" : t5.shapeInfo.logicalShape.map(function(t6, e5) {
          return "coords." + h3[e5 + l3];
        }).join(", ");
        var p2 = "return outputValue;", d2 = 1 === w(t5.shapeInfo.logicalShape), v2 = 1 === w(e4.logicalShape);
        if (1 !== i3 || d2 || v2) {
          if (d2 && !v2)
            p2 = 1 === u3 ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";
          else if (s3.length) {
            var m2 = i3 - 2, g2 = i3 - 1;
            s3.indexOf(m2) > -1 && s3.indexOf(g2) > -1 ? p2 = "return vec4(outputValue.x);" : s3.indexOf(m2) > -1 ? p2 = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : s3.indexOf(g2) > -1 && (p2 = "return vec4(outputValue.xx, outputValue.zz);");
          }
        } else
          p2 = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
        return "\n    vec4 " + a4 + "() {\n      " + c3 + " coords = getOutputCoords();\n      " + n4 + "\n      vec4 outputValue = get" + o4 + "(" + f3 + ");\n      " + p2 + "\n    }\n  ";
      }(t4, e3) : function(t5, e4) {
        var n4 = t5.name, r4 = n4.charAt(0).toUpperCase() + n4.slice(1), o4 = "get" + r4 + "AtOutCoords", a4 = e4.texShape, i3 = t5.shapeInfo.texShape, u3 = t5.shapeInfo.logicalShape.length, s3 = e4.logicalShape.length;
        if (!t5.shapeInfo.isUniform && u3 === s3 && null == t5.shapeInfo.flatOffset && C(i3, a4))
          return "\n      float " + o4 + "() {\n        return sampleTexture(" + n4 + ", resultUV);\n      }\n    ";
        var c3, l3 = aa(s3), h3 = ho(t5.shapeInfo.logicalShape, e4.logicalShape), f3 = s3 - u3, p2 = ["x", "y", "z", "w", "u", "v"];
        c3 = 0 === u3 ? "" : s3 < 2 && h3.length >= 1 ? "coords = 0;" : h3.map(function(t6) {
          return "coords." + p2[t6 + f3] + " = 0;";
        }).join("\n");
        var d2 = "";
        d2 = s3 < 2 && u3 > 0 ? "coords" : t5.shapeInfo.logicalShape.map(function(t6, e5) {
          return "coords." + p2[e5 + f3];
        }).join(", ");
        return "\n    float " + o4 + "() {\n      " + l3 + " coords = getOutputCoords();\n      " + c3 + "\n      return get" + r4 + "(" + d2 + ");\n    }\n  ";
      }(t4, e3));
      return r3;
    }(t3, e2, r2);
  }).join("\n"), c2 = e2.texShape, l2 = Ko(), h2 = function(t3) {
    return "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return " + t3.texture2D + "(textureSampler, uv).r;\n    }\n  ";
  }(l2), f2 = function(t3) {
    return t3.version + "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    " + t3.varyingFs + " vec2 resultUV;\n    " + t3.defineOutput + "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    " + t3.defineSpecialNaN + "\n    " + t3.defineSpecialInf + "\n    " + t3.defineRound + "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    " + Zo + "\n    " + ta + "\n    " + ea + "\n  ";
  }(l2);
  return e2.isPacked ? (a2 = function(t3, e3) {
    switch (t3.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
      case 1:
        return function(t4, e4) {
          var n4 = [Math.ceil(e4[0] / 2), Math.ceil(e4[1] / 2)];
          if (1 === n4[0])
            return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * " + n4[1] + ".0);\n      }\n    ";
          if (1 === n4[1])
            return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * " + n4[0] + ".0);\n      }\n    ";
          return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n4[0] + ", " + n4[1] + "));\n      return 2 * (resTexRC.x * " + n4[1] + " + resTexRC.y);\n    }\n  ";
        }(0, e3);
      case 2:
        return function(t4, e4) {
          var n4 = [Math.ceil(e4[0] / 2), Math.ceil(e4[1] / 2)];
          if (C(t4, e4))
            return "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(" + n4[0] + ", " + n4[1] + "));\n      }\n    ";
          var r4 = Math.ceil(t4[1] / 2);
          return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n4[0] + ", " + n4[1] + "));\n\n      int index = resTexRC.x * " + n4[1] + " + resTexRC.y;\n      int r = 2 * (index / " + r4 + ");\n      int c = imod(index, " + r4 + ") * 2;\n\n      return ivec2(r, c);\n    }\n  ";
        }(t3, e3);
      case 3:
        return n3 = t3, r3 = e3, o3 = [Math.ceil(r3[0] / 2), Math.ceil(r3[1] / 2)], a3 = Math.ceil(n3[2] / 2), i3 = a3 * Math.ceil(n3[1] / 2), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + o3[0] + ", " + o3[1] + "));\n      int index = resTexRC.x * " + o3[1] + " + resTexRC.y;\n\n      int b = index / " + i3 + ";\n      index -= b * " + i3 + ";\n\n      int r = 2 * (index / " + a3 + ");\n      int c = imod(index, " + a3 + ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
      default:
        return function(t4, e4) {
          for (var n4 = [Math.ceil(e4[0] / 2), Math.ceil(e4[1] / 2)], r4 = Math.ceil(t4[t4.length - 1] / 2), o4 = r4 * Math.ceil(t4[t4.length - 2] / 2), a4 = o4, i4 = "", u3 = "b, r, c", s3 = 2; s3 < t4.length - 1; s3++)
            a4 *= t4[t4.length - s3 - 1], i4 = "\n      int b" + s3 + " = index / " + a4 + ";\n      index -= b" + s3 + " * " + a4 + ";\n    " + i4, u3 = "b" + s3 + ", " + u3;
          return "\n    ivec" + t4.length + " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n4[0] + ", " + n4[1] + "));\n      int index = resTexRC.x * " + n4[1] + " + resTexRC.y;\n\n      " + i4 + "\n\n      int b = index / " + o4 + ";\n      index -= b * " + o4 + ";\n\n      int r = 2 * (index / " + r4 + ");\n      int c = imod(index, " + r4 + ") * 2;\n\n      return ivec" + t4.length + "(" + u3 + ");\n    }\n  ";
        }(t3, e3);
    }
    var n3, r3, o3, a3, i3;
  }(e2.logicalShape, c2), i2 = function(t3) {
    return "\n    void setOutput(vec4 val) {\n      " + t3.output + " = val;\n    }\n  ";
  }(l2)) : (a2 = function(t3, e3) {
    switch (t3.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
      case 1:
        return function(t4, e4) {
          if (1 === e4[0])
            return "\n      int getOutputCoords() {\n        return int(resultUV.x * " + e4[1] + ".0);\n      }\n    ";
          if (1 === e4[1])
            return "\n      int getOutputCoords() {\n        return int(resultUV.y * " + e4[0] + ".0);\n      }\n    ";
          return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e4[0] + ", " + e4[1] + "));\n      return resTexRC.x * " + e4[1] + " + resTexRC.y;\n    }\n  ";
        }(0, e3);
      case 2:
        return function(t4, e4) {
          if (C(t4, e4))
            return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + e4[0] + ", " + e4[1] + "));\n      }\n    ";
          if (1 === t4[1])
            return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e4[0] + ", " + e4[1] + "));\n        int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";
          if (1 === t4[0])
            return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e4[0] + ", " + e4[1] + "));\n        int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";
          return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e4[0] + ", " + e4[1] + "));\n      int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n      int r = index / " + t4[1] + ";\n      int c = index - r * " + t4[1] + ";\n      return ivec2(r, c);\n    }\n  ";
        }(t3, e3);
      case 3:
        return n3 = e3, r3 = jo(["r", "c", "d"], t3), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n3[0] + ", " + n3[1] + "));\n      int index = resTexRC.x * " + n3[1] + " + resTexRC.y;\n      " + r3 + "\n      return ivec3(r, c, d);\n    }\n  ";
      case 4:
        return function(t4, e4) {
          var n4 = jo(["r", "c", "d", "d2"], t4);
          return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e4[0] + ", " + e4[1] + "));\n      int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n      " + n4 + "\n      return ivec4(r, c, d, d2);\n    }\n  ";
        }(t3, e3);
      case 5:
        return function(t4, e4) {
          var n4 = jo(["r", "c", "d", "d2", "d3"], t4);
          return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(" + e4[0] + ",\n                             " + e4[1] + "));\n\n      int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n\n      " + n4 + "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ";
        }(t3, e3);
      case 6:
        return function(t4, e4) {
          var n4 = jo(["r", "c", "d", "d2", "d3", "d4"], t4);
          return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e4[0] + ", " + e4[1] + "));\n      int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n\n      " + n4 + "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ";
        }(t3, e3);
      default:
        throw new Error(t3.length + "-D output sampling is not yet supported");
    }
    var n3, r3;
  }(e2.logicalShape, c2), i2 = function(t3) {
    return "\n    void setOutput(float val) {\n      " + t3.output + " = vec4(val, 0, 0, 0);\n    }\n  ";
  }(l2)), r2 && (f2 += na), [f2, h2, i2, u2, a2, s2, n2].join("\n");
}
function Qo(t2) {
  var e2 = t2.shapeInfo.logicalShape;
  switch (e2.length) {
    case 0:
      return function(t3) {
        var e3 = t3.name, n2 = "get" + e3.charAt(0).toUpperCase() + e3.slice(1);
        if (t3.shapeInfo.isUniform)
          return "float " + n2 + "() {return " + e3 + ";}";
        var r2 = t3.shapeInfo.texShape, o2 = r2[0], a2 = r2[1];
        if (1 === o2 && 1 === a2)
          return "\n      float " + n2 + "() {\n        return sampleTexture(" + e3 + ", halfCR);\n      }\n    ";
        var i2 = t3.shapeInfo.texShape, u2 = i2[0], s2 = i2[1], c2 = ra(e3);
        return "\n    float " + n2 + "() {\n      vec2 uv = uvFromFlat(" + u2 + ", " + s2 + ", " + c2 + ");\n      return sampleTexture(" + e3 + ", uv);\n    }\n  ";
      }(t2);
    case 1:
      return function(t3) {
        var e3 = t3.name, n2 = "get" + e3.charAt(0).toUpperCase() + e3.slice(1);
        if (t3.shapeInfo.isUniform)
          return "\n      float " + n2 + "(int index) {\n        " + oa(t3) + "\n      }\n    ";
        var r2 = t3.shapeInfo.texShape, o2 = r2[0], a2 = r2[1];
        if (1 === a2 && 1 === o2)
          return "\n      float " + n2 + "(int index) {\n        return sampleTexture(" + e3 + ", halfCR);\n      }\n    ";
        var i2 = ra(e3);
        if (1 === a2)
          return "\n      float " + n2 + "(int index) {\n        vec2 uv = vec2(0.5, (float(index + " + i2 + ") + 0.5) / " + o2 + ".0);\n        return sampleTexture(" + e3 + ", uv);\n      }\n    ";
        if (1 === o2)
          return "\n      float " + n2 + "(int index) {\n        vec2 uv = vec2((float(index + " + i2 + ") + 0.5) / " + a2 + ".0, 0.5);\n        return sampleTexture(" + e3 + ", uv);\n      }\n    ";
        return "\n    float " + n2 + "(int index) {\n      vec2 uv = uvFromFlat(" + o2 + ", " + a2 + ", index + " + i2 + ");\n      return sampleTexture(" + e3 + ", uv);\n    }\n  ";
      }(t2);
    case 2:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n2 = t3.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = t3.shapeInfo.texShape;
        if (null != o2 && C(e3, o2)) {
          var a2 = o2[0], i2 = o2[1];
          return "\n    float " + r2 + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + i2 + ".0, " + a2 + ".0);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
        }
        var u2 = T(e3), s2 = u2.newShape, c2 = u2.keptDims, l2 = s2;
        if (l2.length < e3.length) {
          var h2 = ia(t3, l2);
          return "\n      " + Qo(h2) + "\n      float " + r2 + "(int row, int col) {\n        return " + r2 + "(" + ua(["row", "col"], c2) + ");\n      }\n    ";
        }
        if (t3.shapeInfo.isUniform)
          return "\n      float " + r2 + "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(" + e3[1] + ", 1)));\n        " + oa(t3) + "\n      }\n    ";
        var f2 = o2[0], p2 = o2[1], d2 = ra(n2);
        if (1 === p2)
          return "\n    float " + r2 + "(int row, int col) {\n      float index = dot(vec3(row, col, " + d2 + "), vec3(" + e3[1] + ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / " + f2 + ".0);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
        if (1 === f2)
          return "\n    float " + r2 + "(int row, int col) {\n      float index = dot(vec3(row, col, " + d2 + "), vec3(" + e3[1] + ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / " + p2 + ".0, 0.5);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
        return "\n  float " + r2 + "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * " + e3[1] + " + col + " + d2 + ";\n    vec2 uv = uvFromFlat(" + f2 + ", " + p2 + ", index);\n    return sampleTexture(" + n2 + ", uv);\n  }\n";
      }(t2);
    case 3:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n2 = t3.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = e3[1] * e3[2], a2 = e3[2], i2 = T(e3), u2 = i2.newShape, s2 = i2.keptDims, c2 = u2;
        if (c2.length < e3.length) {
          var l2 = ia(t3, c2);
          return "\n        " + Qo(l2) + "\n        float " + r2 + "(int row, int col, int depth) {\n          return " + r2 + "(" + ua(["row", "col", "depth"], s2) + ");\n        }\n      ";
        }
        if (t3.shapeInfo.isUniform)
          return "\n      float " + r2 + "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(" + o2 + ", " + a2 + ", 1)));\n        " + oa(t3) + "\n      }\n    ";
        var h2 = t3.shapeInfo.texShape, f2 = h2[0], p2 = h2[1], d2 = t3.shapeInfo.flatOffset;
        if (p2 === o2 && null == d2)
          return "\n        float " + r2 + "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(" + a2 + ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + p2 + ".0, " + f2 + ".0);\n          return sampleTexture(" + n2 + ", uv);\n        }\n      ";
        if (p2 === a2 && null == d2)
          return "\n    float " + r2 + "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(" + e3[1] + ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + p2 + ".0, " + f2 + ".0);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
        var v2 = ra(n2);
        return "\n      float " + r2 + "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * " + o2 + " + col * " + a2 + " + depth + " + v2 + ";\n        vec2 uv = uvFromFlat(" + f2 + ", " + p2 + ", index);\n        return sampleTexture(" + n2 + ", uv);\n      }\n  ";
      }(t2);
    case 4:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n2 = t3.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = e3[3], a2 = e3[2] * o2, i2 = e3[1] * a2, u2 = T(e3), s2 = u2.newShape, c2 = u2.keptDims;
        if (s2.length < e3.length) {
          var l2 = ia(t3, s2);
          return "\n      " + Qo(l2) + "\n      float " + r2 + "(int row, int col, int depth, int depth2) {\n        return " + r2 + "(" + ua(["row", "col", "depth", "depth2"], c2) + ");\n      }\n    ";
        }
        if (t3.shapeInfo.isUniform)
          return "\n      float " + r2 + "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(" + i2 + ", " + a2 + ", " + o2 + ", 1)));\n        " + oa(t3) + "\n      }\n    ";
        var h2 = t3.shapeInfo.flatOffset, f2 = t3.shapeInfo.texShape, p2 = f2[0], d2 = f2[1];
        if (d2 === i2 && null == h2)
          return "\n      float " + r2 + "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(" + a2 + ", " + o2 + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + d2 + ".0, " + p2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
        if (d2 === o2 && null == h2)
          return "\n      float " + r2 + "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(" + e3[1] * e3[2] + ", " + e3[2] + ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + d2 + ".0, " + p2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
        var v2 = ra(n2);
        return "\n    float " + r2 + "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + i2 + " + col * " + a2 + " +\n          depth * " + o2 + " + depth2;\n      vec2 uv = uvFromFlat(" + p2 + ", " + d2 + ", index + " + v2 + ");\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
      }(t2);
    case 5:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n2 = t3.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = e3[4], a2 = e3[3] * o2, i2 = e3[2] * a2, u2 = e3[1] * i2, s2 = T(e3), c2 = s2.newShape, l2 = s2.keptDims;
        if (c2.length < e3.length) {
          var h2 = ia(t3, c2);
          return "\n      " + Qo(h2) + "\n      float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n        return " + r2 + "(" + ua(["row", "col", "depth", "depth2", "depth3"], l2) + ");\n      }\n    ";
        }
        if (t3.shapeInfo.isUniform)
          return "\n      float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + u2 + ", " + i2 + ", " + a2 + ", " + o2 + ")) +\n          depth3;\n        " + oa(t3) + "\n      }\n    ";
        var f2 = t3.shapeInfo.flatOffset, p2 = t3.shapeInfo.texShape, d2 = p2[0], v2 = p2[1];
        if (v2 === u2 && null == f2)
          return "\n      float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(" + i2 + ", " + a2 + ", " + o2 + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + v2 + ".0, " + d2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
        if (v2 === o2 && null == f2)
          return "\n      float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + e3[1] * e3[2] * e3[3] + ",\n               " + e3[2] * e3[3] + ", " + e3[3] + ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + v2 + ".0, " + d2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
        var m2 = ra(n2);
        return "\n    float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + u2 + " + col * " + i2 + " + depth * " + a2 + " +\n          depth2 * " + o2 + " + depth3 + " + m2 + ";\n      vec2 uv = uvFromFlat(" + d2 + ", " + v2 + ", index);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
      }(t2);
    case 6:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n2 = t3.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = T(e3), a2 = o2.newShape, i2 = o2.keptDims;
        if (a2.length < e3.length) {
          var u2 = ia(t3, a2);
          return "\n      " + Qo(u2) + "\n      float " + r2 + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return " + r2 + "(" + ua(["row", "col", "depth", "depth2", "depth3", "depth4"], i2) + ");\n      }\n    ";
        }
        var s2 = e3[5], c2 = e3[4] * s2, l2 = e3[3] * c2, h2 = e3[2] * l2, f2 = e3[1] * h2;
        if (t3.shapeInfo.isUniform)
          return "\n      float " + r2 + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + f2 + ", " + h2 + ", " + l2 + ", " + c2 + ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(" + s2 + ", 1)));\n        " + oa(t3) + "\n      }\n    ";
        var p2 = t3.shapeInfo.flatOffset, d2 = t3.shapeInfo.texShape, v2 = d2[0], m2 = d2[1];
        if (m2 === f2 && null == p2)
          return "\n      float " + r2 + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(" + h2 + ", " + l2 + ", " + c2 + ", " + s2 + ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + m2 + ".0, " + v2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
        if (m2 === s2 && null == p2)
          return "\n      float " + r2 + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(" + e3[1] * e3[2] * e3[3] * e3[4] + ",\n               " + e3[2] * e3[3] * e3[4] + ",\n               " + e3[3] * e3[4] + ",\n               " + e3[4] + ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + m2 + ".0, " + v2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
        var g2 = ra(n2);
        return "\n    float " + r2 + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + f2 + " + col * " + h2 + " + depth * " + l2 + " +\n          depth2 * " + c2 + " + depth3 * " + s2 + " + depth4 + " + g2 + ";\n      vec2 uv = uvFromFlat(" + v2 + ", " + m2 + ", index);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
      }(t2);
    default:
      throw new Error(e2.length + "-D input sampling is not yet supported");
  }
}
function Jo(t2) {
  var e2, n2, r2;
  switch (t2.shapeInfo.logicalShape.length) {
    case 0:
      return e2 = t2.name, n2 = "get" + e2.charAt(0).toUpperCase() + e2.slice(1), r2 = Ko(), "\n    vec4 " + n2 + "() {\n      return " + r2.texture2D + "(" + e2 + ", halfCR);\n    }\n  ";
    case 1:
      return function(t3) {
        var e3 = t3.name, n3 = "get" + e3.charAt(0).toUpperCase() + e3.slice(1), r3 = t3.shapeInfo.texShape, o2 = [Math.ceil(r3[0] / 2), Math.ceil(r3[1] / 2)], a2 = Ko();
        return "\n    vec4 " + n3 + "(int index) {\n      vec2 uv = packedUVfrom1D(\n        " + o2[0] + ", " + o2[1] + ", index);\n      return " + a2.texture2D + "(" + e3 + ", uv);\n    }\n  ";
      }(t2);
    case 2:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n3 = t3.name, r3 = "get" + n3.charAt(0).toUpperCase() + n3.slice(1), o2 = t3.shapeInfo.texShape, a2 = o2[0], i2 = o2[1], u2 = Ko();
        if (null != o2 && C(e3, o2))
          return "\n      vec4 " + r3 + "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + i2 + ".0, " + a2 + ".0);\n\n        return " + u2.texture2D + "(" + n3 + ", uv);\n      }\n    ";
        var s2 = [Math.ceil(o2[0] / 2), Math.ceil(o2[1] / 2)], c2 = Math.ceil(e3[1] / 2);
        return "\n    vec4 " + r3 + "(int row, int col) {\n      vec2 uv = packedUVfrom2D(" + c2 + ", " + s2[0] + ", " + s2[1] + ", row, col);\n      return " + u2.texture2D + "(" + n3 + ", uv);\n    }\n  ";
      }(t2);
    case 3:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n3 = t3.name, r3 = "get" + n3.charAt(0).toUpperCase() + n3.slice(1), o2 = t3.shapeInfo.texShape, a2 = [Math.ceil(o2[0] / 2), Math.ceil(o2[1] / 2)];
        if (1 === e3[0]) {
          var i2 = e3.slice(1), u2 = ia(t3, i2);
          return "\n        " + Jo(u2) + "\n        vec4 " + r3 + "(int b, int row, int col) {\n          return " + r3 + "(" + ua(["b", "row", "col"], [1, 2]) + ");\n        }\n      ";
        }
        var s2 = a2[0], c2 = a2[1], l2 = Math.ceil(e3[2] / 2), h2 = l2 * Math.ceil(e3[1] / 2), f2 = Ko();
        return "\n    vec4 " + r3 + "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        " + s2 + ", " + c2 + ", " + h2 + ", " + l2 + ", b, row, col);\n      return " + f2.texture2D + "(" + n3 + ", uv);\n    }\n  ";
      }(t2);
    default:
      return function(t3) {
        for (var e3 = t3.shapeInfo.logicalShape, n3 = e3.length, r3 = t3.name, o2 = "get" + r3.charAt(0).toUpperCase() + r3.slice(1), a2 = t3.shapeInfo.texShape, i2 = [Math.ceil(a2[0] / 2), Math.ceil(a2[1] / 2)], u2 = i2[0], s2 = i2[1], c2 = Math.ceil(e3[n3 - 1] / 2), l2 = c2 * Math.ceil(e3[n3 - 2] / 2), h2 = "int b, int row, int col", f2 = "b * " + l2 + " + (row / 2) * " + c2 + " + (col / 2)", p2 = 2; p2 < n3 - 1; p2++)
          h2 = "int b" + p2 + ", " + h2, l2 *= e3[n3 - p2 - 1], f2 = "b" + p2 + " * " + l2 + " + " + f2;
        var d2 = Ko();
        return "\n    vec4 " + o2 + "(" + h2 + ") {\n      int index = " + f2 + ";\n      int texR = index / " + s2 + ";\n      int texC = index - texR * " + s2 + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + s2 + ", " + u2 + ");\n      return " + d2.texture2D + "(" + r3 + ", uv);\n    }\n  ";
      }(t2);
  }
}
var Zo = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var ta = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var ea = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var na = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";
function ra(t2) {
  return "offset" + t2;
}
function oa(t2) {
  var e2 = t2.name, n2 = w(t2.shapeInfo.logicalShape);
  return n2 < 2 ? "return " + e2 + ";" : "\n    for (int i = 0; i < " + n2 + "; i++) {\n      if (i == index) {\n        return " + e2 + "[i];\n      }\n    }\n  ";
}
function aa(t2) {
  if (t2 <= 1)
    return "int";
  if (2 === t2)
    return "ivec2";
  if (3 === t2)
    return "ivec3";
  if (4 === t2)
    return "ivec4";
  if (5 === t2)
    return "ivec5";
  if (6 === t2)
    return "ivec6";
  throw Error("GPU for rank " + t2 + " is not yet supported");
}
function ia(t2, e2) {
  var n2 = JSON.parse(JSON.stringify(t2));
  return n2.shapeInfo.logicalShape = e2, n2;
}
function ua(t2, e2) {
  return e2.map(function(e3) {
    return t2[e3];
  }).join(", ");
}
var sa = function() {
  return function(t2, e2, n2, r2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, g(t2.length > 2, function() {
      return "Packed arg" + (n2.charAt(0).toUpperCase() + n2.slice(1)) + " supports only inputs with rank above 2.";
    });
    var o2 = t2[t2.length - 1], a2 = Math.ceil(o2 / e2);
    this.outputShape = t2.slice(0, -1), a2 > 1 && this.outputShape.push(a2), r2 || this.variableNames.push("bestIndicesA");
    var i2, u2, s2 = this.outputShape, c2 = s2.length, l2 = aa(c2), h2 = qo("coords", c2);
    if (1 === a2) {
      var f2 = aa(u2 = c2 + 1);
      i2 = "\n        " + f2 + " sourceLocR = " + f2 + "(" + h2.join() + ", 0);\n        ++" + h2[c2 - 1] + ";\n        " + f2 + " sourceLocG = " + f2 + "(" + h2.join() + ", 0);\n        ++" + h2[c2 - 2] + ";\n        " + f2 + " sourceLocA = " + f2 + "(" + h2.join() + ", 0);\n        --" + h2[c2 - 1] + ";\n        " + f2 + " sourceLocB = " + f2 + "(" + h2.join() + ", 0);\n        --" + h2[c2 - 2] + ";";
    } else
      u2 = c2, i2 = "\n        " + l2 + " sourceLocR = coords;\n        ++" + h2[c2 - 1] + ";\n        " + l2 + " sourceLocG = coords;\n        ++" + h2[c2 - 2] + ";\n        " + l2 + " sourceLocA = coords;\n        --" + h2[c2 - 1] + ";\n        " + l2 + " sourceLocB = coords;\n        --" + h2[c2 - 2] + ";";
    var p2 = ["x", "y", "z", "w", "u", "v"].slice(0, u2), d2 = "." + p2[u2 - 1], v2 = p2.map(function(t3) {
      return "int " + t3;
    }), m2 = qo("sourceLocR", u2 - 1).concat("inIdx.r"), y2 = qo("sourceLocG", u2 - 1).concat("inIdx.g"), x2 = qo("sourceLocB", u2 - 1).concat("inIdx.b"), b2 = qo("sourceLocA", u2 - 1).concat("inIdx.a"), w2 = "max" === n2 ? "greaterThan" : "lessThan", C2 = r2 ? "" : "\n          inIdx = round(vec4(getBestIndicesAChannel(" + m2.join() + "),\n                             getBestIndicesAChannel(" + y2.join() + "),\n                             getBestIndicesAChannel(" + x2.join() + "),\n                             getBestIndicesAChannel(" + b2.join() + ")));", E2 = "vec4(\n            getAChannel(" + m2.join() + "),\n            hasNextCol ? getAChannel(" + y2.join() + ") : 0.,\n            hasNextRow ? getAChannel(" + x2.join() + ") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(" + b2.join() + ") : 0.)", R2 = r2 ? "" : "\n      float getBestIndicesAChannel(" + v2.join() + ") {\n        return getChannel(getBestIndicesA(" + p2.join() + "),\n                                          vec2(" + p2.slice(-2).join() + "));\n      }";
    this.userCode = "\n      float getAChannel(" + v2.join() + ") {\n        return getChannel(getA(" + p2.join() + "),\n                               vec2(" + p2.slice(-2).join() + "));\n      }\n      " + R2 + "\n      void main() {\n        " + l2 + " coords = getOutputCoords();\n        bool hasNextCol = " + h2[c2 - 1] + " < " + (s2[c2 - 1] - 1) + ";\n        bool hasNextRow = " + h2[c2 - 2] + " < " + (s2[c2 - 2] - 1) + ";\n        " + i2 + "\n        ivec4 srcIdx = ivec4(sourceLocR" + d2 + ", sourceLocG" + d2 + ",\n          sourceLocB" + d2 + ", sourceLocA" + d2 + ") * " + e2 + ";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = " + E2 + ";\n\n        for (int i = 0; i < " + e2 + "; i++) {\n          inIdx = srcIdx;\n          " + C2 + "\n          vec4 candidate = " + E2 + ";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(" + w2 + "(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ";
  };
}();
var ca = function() {
  return function(t2) {
    this.variableNames = ["dy"], this.outputShape = t2.inShape;
    var e2 = t2.filterHeight, n2 = t2.filterWidth, r2 = t2.strideHeight, o2 = t2.strideWidth, a2 = t2.dilationHeight, i2 = t2.dilationWidth, u2 = t2.effectiveFilterHeight, s2 = t2.effectiveFilterWidth, c2 = u2 - 1 - t2.padInfo.top, l2 = s2 - 1 - t2.padInfo.left, h2 = 1 / (e2 * n2);
    this.userCode = "\n      const ivec2 pads = ivec2(" + c2 + ", " + l2 + ");\n      const float avgMultiplier = float(" + h2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + u2 + ";\n            wR += " + a2 + ") {\n          float dyR = float(dyRCorner + wR) / " + r2 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + s2 + ";\n            wC+= " + i2 + ") {\n            float dyC = float(dyCCorner + wC) / " + o2 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var la = function() {
  return function(t2) {
    this.variableNames = ["dy"], this.outputShape = t2.inShape;
    var e2 = t2.filterDepth, n2 = t2.filterHeight, r2 = t2.filterWidth, o2 = t2.strideDepth, a2 = t2.strideHeight, i2 = t2.strideWidth, u2 = t2.dilationDepth, s2 = t2.dilationHeight, c2 = t2.dilationWidth, l2 = t2.effectiveFilterDepth, h2 = t2.effectiveFilterHeight, f2 = t2.effectiveFilterWidth, p2 = l2 - 1 - t2.padInfo.front, d2 = h2 - 1 - t2.padInfo.top, v2 = f2 - 1 - t2.padInfo.left, m2 = 1 / (e2 * n2 * r2);
    this.userCode = "\n      const ivec3 pads = ivec3(" + p2 + ", " + d2 + ", " + v2 + ");\n      const float avgMultiplier = float(" + m2 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + l2 + ";\n            wD += " + u2 + ") {\n          float dyD = float(dyDCorner + wD) / " + o2 + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t2.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + h2 + ";\n              wR += " + s2 + ") {\n            float dyR = float(dyRCorner + wR) / " + a2 + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + f2 + ";\n                wC += " + c2 + ") {\n              float dyC = float(dyCCorner + wC) / " + i2 + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var ha = function() {
  return function(t2, e2, n2, r2, o2, a2) {
    this.outputShape = [], this.variableNames = ["x", "mean", "variance"], po(t2, e2), po(t2, n2);
    var i2 = "0.0";
    null != r2 && (po(t2, r2), this.variableNames.push("offset"), i2 = "getOffsetAtOutCoords()");
    var u2 = "1.0";
    null != o2 && (po(t2, o2), this.variableNames.push("scale"), u2 = "getScaleAtOutCoords()"), this.outputShape = t2, this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + i2 + ";\n        float scale = " + u2 + ";\n        float inv = scale * inversesqrt(variance + float(" + a2 + "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ";
  };
}();
var fa = function() {
  return function(t2, e2, n2, r2, o2, a2) {
    this.packedInputs = true, this.packedOutput = true, this.variableNames = ["x", "mean", "variance"], po(t2, e2), po(t2, n2);
    var i2 = "vec4(0.0)";
    null != r2 && (po(t2, r2), this.variableNames.push("offset"), i2 = "getOffsetAtOutCoords()");
    var u2 = "vec4(1.0)";
    null != o2 && (po(t2, o2), this.variableNames.push("scale"), u2 = "getScaleAtOutCoords()"), this.outputShape = t2, this.userCode = "\n      void main() {\n        vec4 offset = " + i2 + ";\n        vec4 scale = " + u2 + ";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(" + a2 + "));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ";
  };
}();
var pa = "return areal * breal - aimag * bimag;";
var da = "return areal * bimag + aimag * breal;";
var va = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = po(e2, n2), this.userCode = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        " + t2 + "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ";
  };
}();
var ma = "return a + b;";
var ga = "return a - b;";
var ya = "return a * b;";
var xa = "return (a < 0.) ? b * a : a;";
var ba = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["A", "B"], this.outputShape = po(e2, n2), this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + t2 + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";
  };
}();
var wa = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
var Ca = function() {
  return function(t2, e2, n2, r2) {
    void 0 === r2 && (r2 = false), this.variableNames = ["A", "B"], this.supportsBroadcasting = true, this.packedInputs = true, this.packedOutput = true, this.outputShape = po(e2, n2);
    var o2 = this.outputShape.length, a2 = "";
    if (r2)
      if (0 === o2 || 1 === w(this.outputShape))
        a2 = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
      else if (a2 = "\n          " + aa(o2) + " coords = getOutputCoords();\n        ", 1 === o2)
        a2 += "\n            result.y = (coords + 1) >= " + this.outputShape[0] + " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";
      else {
        var i2 = qo("coords", o2);
        a2 += "\n            bool nextRowOutOfBounds =\n              (" + i2[o2 - 2] + " + 1) >= " + this.outputShape[o2 - 2] + ";\n            bool nextColOutOfBounds =\n              (" + i2[o2 - 1] + " + 1) >= " + this.outputShape[o2 - 1] + ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ";
      }
    this.userCode = "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        " + t2 + "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        " + a2 + "\n\n        setOutput(result);\n      }\n    ";
  };
}();
var Ea = function() {
  function t2(t3) {
    this.variableNames = ["A"], this.outputShape = t3, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    ";
  }
  return t2.prototype.getCustomSetupFunc = function(t3, e2) {
    var n2 = this;
    return function(r2, o2) {
      null == n2.minLoc && (n2.minLoc = r2.getUniformLocationNoThrow(o2, "minVal"), n2.maxLoc = r2.getUniformLocationNoThrow(o2, "maxVal")), r2.gl.uniform1f(n2.minLoc, t3), r2.gl.uniform1f(n2.maxLoc, e2);
    };
  }, t2;
}();
var Ra = function() {
  function t2(t3) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t3, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    ";
  }
  return t2.prototype.getCustomSetupFunc = function(t3, e2) {
    var n2 = this;
    return function(r2, o2) {
      null == n2.minLoc && (n2.minLoc = r2.getUniformLocationNoThrow(o2, "minVal"), n2.maxLoc = r2.getUniformLocationNoThrow(o2, "maxVal")), r2.gl.uniform1f(n2.minLoc, t3), r2.gl.uniform1f(n2.maxLoc, e2);
    };
  }, t2;
}();
var Ia = function() {
  return function(t2) {
    this.variableNames = ["real", "imag"], this.outputShape = t2, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    ";
  };
}();
var ka = function() {
  return function(t2) {
    this.outputShape = [], this.outputShape = wn(t2, 1), this.variableNames = t2.map(function(t3, e3) {
      return "T" + e3;
    });
    var e2 = new Array(t2.length - 1);
    e2[0] = t2[0][1];
    for (var n2 = 1; n2 < e2.length; n2++)
      e2[n2] = e2[n2 - 1] + t2[n2][1];
    var r2 = ["if (yC < " + e2[0] + ") setOutput(getT0(yR, yC));"];
    for (n2 = 1; n2 < e2.length; n2++) {
      var o2 = e2[n2 - 1];
      r2.push("else if (yC < " + e2[n2] + ") setOutput(getT" + n2 + "(yR, yC-" + o2 + "));");
    }
    var a2 = e2.length, i2 = e2[e2.length - 1];
    r2.push("else setOutput(getT" + a2 + "(yR, yC-" + i2 + "));"), this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        " + r2.join("\n        ") + "\n      }\n    ";
  };
}();
var Sa = function() {
  return function(t2, e2) {
    this.packedInputs = true, this.packedOutput = true, this.outputShape = [], this.outputShape = wn(t2, e2);
    var n2 = this.outputShape, r2 = n2.length, o2 = aa(r2), a2 = qo("coords", r2), i2 = ["x", "y", "z", "w", "u", "v"].slice(0, r2);
    this.variableNames = t2.map(function(t3, e3) {
      return "T" + e3;
    });
    var u2 = new Array(t2.length - 1);
    u2[0] = t2[0][e2];
    for (var s2 = 1; s2 < u2.length; s2++)
      u2[s2] = u2[s2 - 1] + t2[s2][e2];
    var c2 = i2[e2], l2 = i2.slice(-2), h2 = i2.join(), f2 = "if (" + c2 + " < " + u2[0] + ") {\n        return getChannel(\n            getT0(" + h2 + "), vec2(" + l2.join() + "));\n        }";
    for (s2 = 1; s2 < u2.length; s2++) {
      var p2 = u2[s2 - 1];
      f2 += "\n        if (" + c2 + " < " + u2[s2] + "  && " + c2 + " >= " + u2[s2 - 1] + ") {\n          return getChannel(\n            getT" + s2 + "(" + Aa(i2, c2, p2) + "),\n            vec2(" + Aa(l2, c2, p2) + "));\n        }";
    }
    var d2 = u2.length, v2 = u2[u2.length - 1];
    f2 += "\n        return getChannel(\n          getT" + d2 + "(" + Aa(i2, c2, v2) + "),\n          vec2(" + Aa(l2, c2, v2) + "));", this.userCode = "\n      float getValue(" + i2.map(function(t3) {
      return "int " + t3;
    }) + ") {\n        " + f2 + "\n      }\n\n      void main() {\n        " + o2 + " coords = getOutputCoords();\n        vec4 result = vec4(getValue(" + a2 + "), 0., 0., 0.);\n\n        " + a2[r2 - 1] + " = " + a2[r2 - 1] + " + 1;\n        if (" + a2[r2 - 1] + " < " + n2[r2 - 1] + ") {\n          result.g = getValue(" + a2 + ");\n        }\n\n        " + a2[r2 - 2] + " = " + a2[r2 - 2] + " + 1;\n        if (" + a2[r2 - 2] + " < " + n2[r2 - 2] + ") {\n          result.a = getValue(" + a2 + ");\n        }\n\n        " + a2[r2 - 1] + " = " + a2[r2 - 1] + " - 1;\n        if (" + a2[r2 - 2] + " < " + n2[r2 - 2] + " &&\n            " + a2[r2 - 1] + " < " + n2[r2 - 1] + ") {\n          result.b = getValue(" + a2 + ");\n        }\n        setOutput(result);\n      }\n    ";
  };
}();
function Aa(t2, e2, n2) {
  var r2 = t2.indexOf(e2);
  return t2.map(function(t3, e3) {
    return e3 === r2 ? t3 + " - " + n2 : t3;
  }).join();
}
var Da = function() {
  return function(t2) {
    this.variableNames = ["x", "dy"], this.outputShape = t2.filterShape;
    var e2 = t2.strideHeight, n2 = t2.strideWidth, r2 = t2.padInfo.top, o2 = t2.padInfo.left, a2 = "channelsLast" === t2.dataFormat;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t2.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t2.outHeight + "; yR++) {\n            int xR = wR + yR * " + e2 + " - " + r2 + ";\n\n            if (xR < 0 || xR >= " + t2.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t2.outWidth + "; yC++) {\n              int xC = wC + yC * " + n2 + " - " + o2 + ";\n\n              if (xC < 0 || xC >= " + t2.inWidth + ") {\n                continue;\n              }\n\n              if (" + a2 + ") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var Ta = function() {
  return function(t2) {
    this.variableNames = ["dy", "W"], this.outputShape = t2.inShape;
    var e2 = t2.filterHeight, n2 = t2.filterWidth, r2 = t2.strideHeight, o2 = t2.strideWidth, a2 = "channelsLast" === t2.dataFormat, i2 = e2 - 1 - t2.padInfo.top, u2 = n2 - 1 - t2.padInfo.left, s2 = a2 ? 1 : 2, c2 = a2 ? 2 : 3, l2 = a2 ? 3 : 1;
    this.userCode = "\n      const ivec2 pads = ivec2(" + i2 + ", " + u2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[" + l2 + "];\n\n        ivec2 dyCorner = ivec2(coords[" + s2 + "], coords[" + c2 + "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + e2 + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r2 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e2 + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n2 + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + o2 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n2 + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + t2.outChannels + "; d2++) {\n\n              if (" + a2 + ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var Na = function() {
  return function(t2) {
    this.variableNames = ["x", "dy"], this.outputShape = t2.filterShape;
    var e2 = t2.strideDepth, n2 = t2.strideHeight, r2 = t2.strideWidth, o2 = t2.padInfo.front, a2 = t2.padInfo.top, i2 = t2.padInfo.left;
    this.userCode = "\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t2.batchSize + "; b++) {\n          for (int yF = 0; yF < " + t2.outDepth + "; yF++) {\n            int xF = wF + yF * " + e2 + " - " + o2 + ";\n\n            if (xF < 0 || xF >= " + t2.inDepth + ") {\n              continue;\n            }\n\n            for (int yR = 0; yR < " + t2.outHeight + "; yR++) {\n              int xR = wR + yR * " + n2 + " - " + a2 + ";\n\n              if (xR < 0 || xR >= " + t2.inHeight + ") {\n                continue;\n              }\n\n              for (int yC = 0; yC < " + t2.outWidth + "; yC++) {\n                int xC = wC + yC * " + r2 + " - " + i2 + ";\n\n                if (xC < 0 || xC >= " + t2.inWidth + ") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var Fa = function() {
  return function(t2) {
    this.variableNames = ["dy", "W"], this.outputShape = t2.inShape;
    var e2 = t2.filterDepth, n2 = t2.filterHeight, r2 = t2.filterWidth, o2 = t2.strideDepth, a2 = t2.strideHeight, i2 = t2.strideWidth, u2 = e2 - 1 - t2.padInfo.front, s2 = n2 - 1 - t2.padInfo.top, c2 = r2 - 1 - t2.padInfo.left;
    this.userCode = "\n      const ivec3 pads = ivec3(" + u2 + ", " + s2 + ", " + c2 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + e2 + "; wF++) {\n          float dyF = float(dyFCorner + wF) / " + o2 + ".0;\n\n          if (dyF < 0.0 || dyF >= " + t2.outDepth + ".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = " + e2 + " - 1 - wF;\n\n          for (int wR = 0; wR < " + n2 + "; wR++) {\n            float dyR = float(dyRCorner + wR) / " + a2 + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = " + n2 + " - 1 - wR;\n\n            for (int wC = 0; wC < " + r2 + "; wC++) {\n              float dyC = float(dyCCorner + wC) / " + i2 + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = " + r2 + " - 1 - wC;\n\n              for (int d2 = 0; d2 < " + t2.outChannels + "; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var Oa = function() {
  return function(t2) {
    this.variableNames = ["x", "dy"], this.outputShape = t2.filterShape;
    var e2 = t2.strideHeight, n2 = t2.strideWidth, r2 = t2.padInfo.top, o2 = t2.padInfo.left, a2 = t2.outChannels / t2.inChannels;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * " + a2 + " + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < " + t2.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t2.outHeight + "; yR++) {\n            int xR = wR + yR * " + e2 + " - " + r2 + ";\n\n            if (xR < 0 || xR >= " + t2.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t2.outWidth + "; yC++) {\n              int xC = wC + yC * " + n2 + " - " + o2 + ";\n\n              if (xC < 0 || xC >= " + t2.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var _a = function() {
  return function(t2) {
    this.variableNames = ["dy", "W"], this.outputShape = t2.inShape;
    var e2 = t2.filterHeight, n2 = t2.filterWidth, r2 = t2.strideHeight, o2 = t2.strideWidth, a2 = e2 - 1 - t2.padInfo.top, i2 = n2 - 1 - t2.padInfo.left, u2 = t2.outChannels / t2.inChannels;
    this.userCode = "\n      const ivec2 pads = ivec2(" + a2 + ", " + i2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < " + e2 + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r2 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e2 + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n2 + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + o2 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n2 + " - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < " + u2 + "; dm++) {\n              int d2 = d1 * " + u2 + " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var Ma = function() {
  return function(t2, e2, n2, r2) {
    void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = null), void 0 === r2 && (r2 = false), this.variableNames = ["x", "W"], this.outputShape = t2.outShape;
    var o2 = t2.padInfo.top, a2 = t2.padInfo.left, i2 = t2.strideHeight, u2 = t2.strideWidth, s2 = t2.dilationHeight, c2 = t2.dilationWidth, l2 = t2.filterHeight, h2 = t2.filterWidth, f2 = 4 * Math.floor(t2.inChannels / 4), p2 = t2.inChannels % 4, d2 = "channelsLast" === t2.dataFormat, v2 = d2 ? 1 : 2, m2 = d2 ? 2 : 3, g2 = d2 ? 3 : 1, y2 = "", x2 = "";
    n2 && (y2 = r2 ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n2 + "\n        }" : "\n          float activation(float x) {\n            " + n2 + "\n          }\n        ", x2 = "result = activation(result);");
    var b2 = e2 ? "result += getBiasAtOutCoords();" : "";
    e2 && this.variableNames.push("bias"), r2 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + y2 + "\n\n      const ivec2 strides = ivec2(" + i2 + ", " + u2 + ");\n      const ivec2 pads = ivec2(" + o2 + ", " + a2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[" + g2 + "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[" + v2 + "], coords[" + m2 + "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + l2 + "; wR++) {\n          int xR = xRCorner + wR * " + s2 + ";\n\n          if (xR < 0 || xR >= " + t2.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + h2 + "; wC++) {\n            int xC = xCCorner + wC * " + c2 + ";\n\n            if (xC < 0 || xC >= " + t2.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + f2 + "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (" + d2 + ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (" + (1 === p2) + ") {\n\n              if (" + d2 + ") {\n                dotProd +=\n                    getX(batch, xR, xC, " + f2 + ") *\n                    getW(wR, wC, " + f2 + ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, " + f2 + ", xR, xC) *\n                    getW(wR, wC, " + f2 + ", d2);\n              }\n\n            } else if (" + (2 === p2) + ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, " + f2 + ", d2),\n                getW(wR, wC, " + f2 + " + 1, d2)\n              );\n\n              if (" + d2 + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, " + f2 + "),\n                  getX(batch, xR, xC, " + f2 + " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, " + f2 + ", xR, xC),\n                  getX(batch, " + f2 + " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (" + (3 === p2) + ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, " + f2 + ", d2),\n                getW(wR, wC, " + f2 + " + 1, d2),\n                getW(wR, wC, " + f2 + " + 2, d2)\n              );\n\n              if (" + d2 + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, " + f2 + "),\n                  getX(batch, xR, xC, " + f2 + " + 1),\n                  getX(batch, xR, xC, " + f2 + " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, " + f2 + ", xR, xC),\n                  getX(batch, " + f2 + " + 1, xR, xC),\n                  getX(batch, " + f2 + " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        " + b2 + "\n        " + x2 + "\n        setOutput(result);\n      }\n    ";
  };
}();
var Ba = function() {
  return function(t2) {
    this.variableNames = ["x", "W"], this.outputShape = t2.outShape;
    var e2 = t2.padInfo.front, n2 = t2.padInfo.top, r2 = t2.padInfo.left, o2 = t2.strideDepth, a2 = t2.strideHeight, i2 = t2.strideWidth, u2 = t2.dilationDepth, s2 = t2.dilationHeight, c2 = t2.dilationWidth, l2 = t2.filterDepth, h2 = t2.filterHeight, f2 = t2.filterWidth, p2 = 4 * Math.floor(t2.inChannels / 4), d2 = t2.inChannels % 4;
    this.userCode = "\n      const ivec3 strides = ivec3(" + o2 + ", " + a2 + ", " + i2 + ");\n      const ivec3 pads = ivec3(" + e2 + ", " + n2 + ", " + r2 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + l2 + "; wF++) {\n          int xF = xFCorner + wF * " + u2 + ";\n\n          if (xF < 0 || xF >= " + t2.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h2 + "; wR++) {\n            int xR = xRCorner + wR * " + s2 + ";\n\n            if (xR < 0 || xR >= " + t2.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + f2 + "; wC++) {\n              int xC = xCCorner + wC * " + c2 + ";\n\n              if (xC < 0 || xC >= " + t2.inWidth + ") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < " + p2 + "; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (" + (1 === d2) + ") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, " + p2 + ") *\n                  getW(wF, wR, wC, " + p2 + ", d2);\n              } else if (" + (2 === d2) + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, " + p2 + "),\n                  getX(batch, xF, xR, xC, " + p2 + " + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, " + p2 + ", d2),\n                  getW(wF, wR, wC, " + p2 + " + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (" + (3 === d2) + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, " + p2 + "),\n                  getX(batch, xF, xR, xC, " + p2 + " + 1),\n                  getX(batch, xF, xR, xC, " + p2 + " + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, " + p2 + ", d2),\n                  getW(wF, wR, wC, " + p2 + " + 1, d2),\n                  getW(wF, wR, wC, " + p2 + " + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var Pa = function() {
  return function(t2, e2, n2, r2) {
    void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = null), void 0 === r2 && (r2 = false), this.variableNames = ["x", "W"], this.outputShape = t2.outShape;
    var o2 = t2.inHeight, a2 = t2.inWidth, i2 = t2.padInfo.top, u2 = t2.padInfo.left, s2 = t2.strideHeight, c2 = t2.strideWidth, l2 = t2.dilationHeight, h2 = t2.dilationWidth, f2 = t2.filterHeight, p2 = t2.filterWidth, d2 = t2.outChannels / t2.inChannels, v2 = "", m2 = "";
    n2 && (v2 = r2 ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n2 + "\n        }" : "\n          float activation(float x) {\n            " + n2 + "\n          }\n        ", m2 = "result = activation(result);");
    var g2 = e2 ? "result += getBiasAtOutCoords();" : "";
    e2 && this.variableNames.push("bias"), r2 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + v2 + "\n\n      const ivec2 strides = ivec2(" + s2 + ", " + c2 + ");\n      const ivec2 pads = ivec2(" + i2 + ", " + u2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + d2 + ";\n        int q = d2 - d1 * " + d2 + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + f2 + "; wR++) {\n          int xR = xRCorner + wR * " + l2 + ";\n\n          if (xR < 0 || xR >= " + o2 + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + p2 + "; wC++) {\n            int xC = xCCorner + wC * " + h2 + ";\n\n            if (xC < 0 || xC >= " + a2 + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        " + g2 + "\n        " + m2 + "\n        setOutput(result);\n      }\n    ";
  };
}();
var La = function() {
  return function(t2, e2, n2, r2) {
    void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = null), void 0 === r2 && (r2 = false), this.variableNames = ["x", "W"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t2.outShape;
    for (var o2 = t2.inHeight, a2 = t2.inWidth, i2 = t2.padInfo.top, u2 = t2.padInfo.left, s2 = t2.strideHeight, c2 = t2.strideWidth, l2 = t2.dilationHeight, h2 = t2.dilationWidth, f2 = t2.filterHeight, p2 = t2.filterWidth, d2 = p2, m2 = "int xR; int xC; int xCOffset;", g2 = 0; g2 < f2; g2++)
      for (var y2 = 0; y2 < p2; y2++)
        m2 += "\n          vec4 xTexelR" + g2 + "C" + 2 * y2 + " = vec4(0.);\n          vec4 wR" + g2 + "C" + y2 + " = vec4(0.);\n          vec4 xR" + g2 + "C" + y2 + " = vec4(0.);";
    for (g2 = 0; g2 < f2; g2++)
      for (var x2 = 0; x2 < d2; x2++) {
        if (m2 += "\n          xR = xRCorner + " + g2 * l2 + ";\n          xC = xCCorner + " + (y2 = 2 * x2) * h2 + ";\n        ", 1 === c2) {
          if (y2 < p2 && (m2 += u2 % 2 == 1 ? "\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < " + o2 + " && xCOffset >= 0 && xCOffset < " + a2 + ") {\n                  xTexelR" + g2 + "C" + y2 + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + g2 + "C" + y2 + " = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < " + o2 + " && xCOffset >= 0 && xCOffset < " + a2 + ") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n                  xR" + g2 + "C" + y2 + " = vec4(previous.zw, xTexelR" + g2 + "C" + y2 + ".xy);\n                } else {\n                  xR" + g2 + "C" + y2 + " = vec4(0, 0, xTexelR" + g2 + "C" + y2 + ".xy);\n                }\n              " : "\n                if(xR >= 0 && xR < " + o2 + " && xC >= 0 && xC < " + a2 + ") {\n                  xTexelR" + g2 + "C" + y2 + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + g2 + "C" + y2 + " = vec4(0.);\n                }\n\n                xR" + g2 + "C" + y2 + " = xTexelR" + g2 + "C" + y2 + ";\n              ", y2 + 1 < p2)) {
            var b2 = u2 % 2 == 0 ? v(h2) : h2;
            h2 % 2 == 0 && u2 % 2 == 1 || h2 % 2 != 0 && u2 % 2 != 1 ? (m2 += "\n                  xCOffset = xC + " + u2 % 2 + " + " + b2 + ";\n\n                  if(xR >= 0 && xR < " + o2 + " &&\n                    xCOffset >= 0 && xCOffset < " + a2 + ") {\n                    xTexelR" + g2 + "C" + (y2 + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n                ", h2 > 1 && (m2 += "\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < " + o2 + " &&\n                      xCOffset >= 0 && xCOffset < " + a2 + ") {\n                      xTexelR" + g2 + "C" + y2 + " = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR" + g2 + "C" + y2 + " = vec4(0.);\n                    }\n                  "), m2 += "\n                  xR" + g2 + "C" + (y2 + 1) + " = vec4(\n                    xTexelR" + g2 + "C" + y2 + ".zw, xTexelR" + g2 + "C" + (y2 + 2) + ".xy);\n                ") : m2 += "\n                  xCOffset = xC + " + b2 + ";\n\n                  if(xR >= 0 && xR < " + o2 + " &&\n                    xCOffset >= 0 && xCOffset < " + a2 + ") {\n                    xTexelR" + g2 + "C" + (y2 + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR" + g2 + "C" + (y2 + 1) + " = xTexelR" + g2 + "C" + (y2 + 2) + ";\n                ";
          }
        } else
          y2 < p2 && (m2 += "\n              if(xR >= 0 && xR < " + o2 + ") {\n            ", u2 % 2 == 1 ? (m2 += "\n                xCOffset = xC + 1 - " + c2 + ";\n                if(xCOffset >= 0 && xCOffset < " + a2 + ") {\n                  xTexelR" + g2 + "C" + y2 + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + g2 + "C" + y2 + " = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < " + a2 + ") {\n                  xTexelR" + g2 + "C" + (y2 + 2) + " = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR" + g2 + "C" + (y2 + 2) + " = vec4(0.);\n                }\n\n                xR" + g2 + "C" + y2 + " = vec4(\n                  xTexelR" + g2 + "C" + y2 + ".zw, xTexelR" + g2 + "C" + (y2 + 2) + ".zw);\n              ", y2 + 1 < p2 && (m2 += "\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + " + c2 + ";\n                  if(xCOffset >= 0 && xCOffset < " + a2 + ") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR" + g2 + "C" + (y2 + 1) + " = vec4(xTexelR" + g2 + "C" + (y2 + 2) + ".xy, final.xy);\n                ")) : (m2 += "\n                if(xC >= 0 && xC < " + a2 + ") {\n                  xTexelR" + g2 + "C" + y2 + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + g2 + "C" + y2 + " = vec4(0.);\n                }\n\n                xCOffset = xC + " + c2 + ";\n                if(xCOffset >= 0 && xCOffset < " + a2 + ") {\n                  xTexelR" + g2 + "C" + (y2 + 2) + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + g2 + "C" + (y2 + 2) + " = vec4(0.);\n                }\n\n                xR" + g2 + "C" + y2 + " = vec4(\n                  xTexelR" + g2 + "C" + y2 + ".xy, xTexelR" + g2 + "C" + (y2 + 2) + ".xy);\n              ", y2 + 1 < p2 && (m2 += "\n                  xR" + g2 + "C" + (y2 + 1) + " = vec4(\n                    xTexelR" + g2 + "C" + y2 + ".zw, xTexelR" + g2 + "C" + (y2 + 2) + ".zw);\n                ")), m2 += "}");
        y2 < p2 && (m2 += "\n            vec4 wTexelR" + g2 + "C" + y2 + " = getW(" + g2 + ", " + y2 + ", d1, q);\n            wR" + g2 + "C" + y2 + " = vec4(wTexelR" + g2 + "C" + y2 + ".xz, wTexelR" + g2 + "C" + y2 + ".xz);\n          ", y2 + 1 < p2 && (m2 += "\n              vec4 wTexelR" + g2 + "C" + (y2 + 1) + " = getW(" + g2 + ", " + (y2 + 1) + ", d1, q);\n              wR" + g2 + "C" + (y2 + 1) + " =\n                vec4(wTexelR" + g2 + "C" + (y2 + 1) + ".xz, wTexelR" + g2 + "C" + (y2 + 1) + ".xz);"));
      }
    for (g2 = 0; g2 < f2; g2++)
      for (y2 = 0; y2 < p2; y2++)
        m2 += "dotProd += xR" + g2 + "C" + y2 + " * wR" + g2 + "C" + y2 + ";";
    var w2 = "", C2 = "";
    n2 && (w2 = r2 ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + n2 + "\n        }" : "vec4 activation(vec4 x) {\n          " + n2 + "\n        }", C2 = "result = activation(result);");
    var E2 = e2 ? "result += getBiasAtOutCoords();" : "";
    e2 && this.variableNames.push("bias"), r2 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + w2 + "\n\n      const ivec2 strides = ivec2(" + s2 + ", " + c2 + ");\n      const ivec2 pads = ivec2(" + i2 + ", " + u2 + ");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        " + m2 + "\n\n        vec4 result = dotProd;\n        " + E2 + "\n        " + C2 + "\n        setOutput(result);\n      }\n    ";
  };
}();
var Wa = function() {
  return function(t2, e2, n2, r2, o2) {
    this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
    var a2 = t2[0], i2 = t2[1], u2 = t2[2], s2 = t2[3], c2 = e2[0], l2 = n2[0], h2 = n2[1];
    this.outputShape = [c2, l2, h2, s2];
    var f2 = "bilinear" === r2 ? 1 : 0, p2 = [i2 - 1 + ".0", u2 - 1 + ".0"], d2 = p2[0], v2 = p2[1], m2 = l2 > 1 ? ["" + (i2 - 1) / (l2 - 1), "(y2-y1) * height_ratio", "y1*" + d2 + " + float(y)*(height_scale)"] : ["0.0", "0.0", "0.5 * (y1+y2) * " + d2], g2 = m2[0], y2 = m2[1], x2 = m2[2], b2 = h2 > 1 ? ["" + (u2 - 1) / (h2 - 1), "(x2-x1) * width_ratio", "x1*" + v2 + " + float(x)*(width_scale)"] : ["0.0", "0.0", "0.5 * (x1+x2) * " + v2], w2 = b2[0], C2 = b2[1], E2 = b2[2];
    this.userCode = "\n      const float height_ratio = float(" + g2 + ");\n      const float width_ratio = float(" + w2 + ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= " + a2 + ") {\n          return;\n        }\n\n        float height_scale = " + y2 + ";\n        float width_scale = " + C2 + ";\n\n        float in_y = " + x2 + ";\n        if( in_y < 0.0 || in_y > " + d2 + " ) {\n          setOutput(float(" + o2 + "));\n          return;\n        }\n        float in_x = " + E2 + ";\n        if( in_x < 0.0 || in_x > " + v2 + " ) {\n          setOutput(float(" + o2 + "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(" + f2 + " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ";
  };
}();
var Ua = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["x"], this.outputShape = t2;
    var r2 = t2.length, o2 = t2[t2.length - 1], a2 = n2 ? "<" : ">";
    this.userCode = "\n      int getIndex(int i) {\n        " + (n2 ? "return " + o2 + " -i - 1;" : "return i;") + "\n      }\n\n      void main() {\n        " + aa(r2) + " coords = getOutputCoords();\n        int end = " + Va(r2, "coords") + ";\n        float val = 0.0;\n        for (int i = " + o2 + " - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx " + a2 + " end) {\n            continue;\n          }\n          if (idx == end && " + e2 + ") {\n            continue;\n          }\n          " + Va(r2, "coords") + " = idx;\n          val += getX(" + function(t3, e3) {
      if (1 === t3)
        return "" + e3;
      if (2 === t3)
        return e3 + ".x, " + e3 + ".y";
      if (3 === t3)
        return e3 + ".x, " + e3 + ".y, " + e3 + ".z";
      if (4 === t3)
        return e3 + ".x, " + e3 + ".y, " + e3 + ".z, " + e3 + ".w";
      throw Error("Cumulative sum for rank " + t3 + " is not yet supported");
    }(r2, "coords") + ");\n        }\n        setOutput(val);\n      }\n    ";
  };
}();
function Va(t2, e2) {
  if (1 === t2)
    return "" + e2;
  if (2 === t2)
    return e2 + ".y";
  if (3 === t2)
    return e2 + ".z";
  if (4 === t2)
    return e2 + ".w";
  throw Error("Cumulative sum for rank " + t2 + " is not yet supported");
}
var za = function() {
  return function(t2) {
    this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outPackingScheme = _t.DENSE;
    var e2 = Gt(t2), n2 = Ko();
    this.outputShape = t2, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + jo(["r", "c", "d"], t2) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e2[0] + ", " + e2[1] + "));\n        int index = 4 * (resTexRC.x * " + e2[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        " + n2.output + " = result;\n      }\n    ";
  };
}();
var Ga = function() {
  return function(t2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outPackingScheme = _t.DENSE;
    var e2 = Gt(t2), n2 = Ko();
    this.outputShape = t2, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + jo(["r", "c", "d"], t2) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e2[0] + ", " + e2[1] + "));\n        int index = 4 * (resTexRC.x * " + e2[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        " + n2.output + " = result;\n      }\n    ";
  };
}();
var Ha = function() {
  function t2(t3, e2, n2) {
    this.variableNames = ["x"], this.outputShape = [], this.outputShape = t3, this.blockSize = e2, this.dataFormat = n2, this.userCode = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = " + this.getHeightCoordString() + ";\n      int w = " + this.getWidthCoordString() + ";\n      int d = " + this.getDepthCoordString() + ";\n\n      int in_h = h / " + e2 + ";\n      int offset_h = imod(h, " + e2 + ");\n      int in_w = w / " + e2 + ";\n      int offset_w = imod(w, " + e2 + ");\n      int offset_d = (offset_h * " + e2 + " + offset_w) *\n        " + this.getOutputDepthSize() + ";\n      int in_d = d + offset_d;\n\n      float result = " + this.getInputSamplingString() + ";\n      setOutput(result);\n    }\n  ";
  }
  return t2.prototype.getHeightCoordString = function() {
    return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]";
  }, t2.prototype.getWidthCoordString = function() {
    return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]";
  }, t2.prototype.getDepthCoordString = function() {
    return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]";
  }, t2.prototype.getOutputDepthSize = function() {
    return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];
  }, t2.prototype.getInputSamplingString = function() {
    return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
  }, t2;
}();
var qa = function() {
  return function(t2) {
    this.variableNames = ["X"], this.outputShape = [t2, t2], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    ";
  };
}();
var Ka = function() {
  return function(t2) {
    this.variableNames = ["A"], this.outTexUsage = Mt.DOWNLOAD;
    var e2 = Ko();
    this.outputShape = t2, this.userCode = "\n      " + $o + "\n\n      void main() {\n        float x = getAAtOutCoords();\n        " + e2.output + " = encode_float(x);\n      }\n    ";
  };
}();
var ja = function() {
  return function(t2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outTexUsage = Mt.DOWNLOAD;
    var e2 = Ko();
    this.outputShape = t2, this.userCode = "\n      " + $o + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        " + e2.output + " = encode_float(x);\n      }\n    ";
  };
}();
var Xa = function() {
  return function(t2, e2, n2) {
    void 0 === n2 && (n2 = false), this.variableNames = ["A"];
    var r2 = Ko(), o2 = e2[0], a2 = e2[1];
    this.outputShape = t2;
    var i2 = "result";
    n2 && (i2 = "floor(result * 255. + 0.5)"), this.userCode = "\n      " + Xo(t2) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / " + a2 + ";\n        int c = imod(flatIndex, " + a2 + ");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(" + a2 + ".0, " + o2 + ".0);\n        vec4 values = " + r2.texture2D + "(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        " + r2.output + " = vec4(" + i2 + ", 0., 0., 0.);\n      }\n    ";
  };
}();
var $a = function() {
  return function(t2, e2, n2) {
    void 0 === n2 && (n2 = false), this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true;
    var r2 = Ko(), o2 = e2[0], a2 = e2[1];
    this.outputShape = t2;
    var i2 = "", u2 = "result";
    n2 && (u2 = "floor(result * 255. + 0.5)");
    for (var s2 = 0; s2 <= 1; s2++)
      for (var c2 = 0; c2 <= 1; c2++) {
        var l2 = 2 * s2 + c2;
        i2 += "\n          localCoords = coords;\n          if(localCoords[2] + " + c2 + " < " + t2[2] + ") {\n            localCoords[2] += " + c2 + ";\n            if(localCoords[1] + " + s2 + " < " + t2[1] + ") {\n              localCoords[1] += " + s2 + ";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / " + a2 + ";\n              c = imod(flatIndex, " + a2 + ");\n              uv = (vec2(c, r) + halfCR) / vec2(" + a2 + ".0, " + o2 + ".0);\n              values = " + r2.texture2D + "(A, uv);\n\n              if(offset == 0) {\n                result[" + l2 + "] = values[0];\n              } else if(offset == 1) {\n                result[" + l2 + "] = values[1];\n              } else if(offset == 2) {\n                result[" + l2 + "] = values[2];\n              } else {\n                result[" + l2 + "] = values[3];\n              }\n            }\n          }\n        ";
      }
    this.userCode = "\n      " + Xo(t2) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        " + i2 + "\n\n        " + r2.output + " = " + u2 + ";\n      }\n    ";
  };
}();
var Ya = "return real * expR - imag * expI;";
var Qa = "return real * expI + imag * expR;";
var Ja = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["real", "imag"];
    var r2 = e2[1];
    this.outputShape = e2;
    var o2 = n2 ? "2.0 * " + Math.PI : "-2.0 * " + Math.PI, a2 = n2 ? r2 + ".0" : "1.0";
    this.userCode = "\n      const float exponentMultiplier = " + o2 + ";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        " + t2 + "\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(" + r2 + ");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < " + r2 + "; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / " + a2 + ";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ";
  };
}();
var Za = function() {
  function t2(t3, e2) {
    this.outputShape = [], this.variableNames = ["x"], this.outputShape = t3, this.userCode = "\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    ";
  }
  return t2.prototype.getCustomSetupFunc = function(t3) {
    var e2 = this;
    return function(n2, r2) {
      null == e2.valueLoc && (e2.valueLoc = n2.getUniformLocationNoThrow(r2, "value")), n2.gl.uniform1f(e2.valueLoc, t3);
    };
  }, t2;
}();
var ti = function() {
  return function(t2) {
    this.variableNames = ["A"];
    var e2 = Ko(), n2 = t2[0], r2 = t2[1];
    this.outputShape = t2, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + r2 + ".0, " + n2 + ".0);\n\n        vec4 values = " + e2.texture2D + "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ";
  };
}();
var ei = function() {
  return function(t2) {
    this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true;
    var e2 = Ko(), n2 = t2[0], r2 = t2[1];
    this.outputShape = t2, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(" + r2 + ".0, " + n2 + ".0);\n            vec4 values = " + e2.texture2D + "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        " + e2.output + " = result;\n      }\n    ";
  };
}();
var ni = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["A", "indices"];
    var r2 = t2.slice();
    r2[n2] = e2, this.outputShape = r2, this.rank = r2.length;
    var o2 = aa(this.rank), a2 = function(t3, e3) {
      var n3 = t3.length;
      if (n3 > 4)
        throw Error("Gather for rank " + n3 + " is not yet supported");
      if (1 === n3)
        return "int(getIndices(resRC))";
      for (var r3 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], o3 = [], a3 = 0; a3 < t3.length; a3++)
        a3 === e3 ? o3.push("int(getIndices(" + r3[a3] + "))") : o3.push("" + r3[a3]);
      return o3.join();
    }(t2, n2);
    this.userCode = "\n      void main() {\n        " + o2 + " resRC = getOutputCoords();\n        setOutput(getA(" + a2 + "));\n      }\n    ";
  };
}();
var ri = function() {
  return function(t2, e2, n2) {
    this.sliceDim = t2, this.strides = e2, this.variableNames = ["x", "indices"], this.outputShape = n2;
    var r2 = aa(e2.length), o2 = aa(n2.length), a2 = this.sliceDim > 1 ? "strides[j]" : "strides";
    this.userCode = "\n        " + r2 + " strides = " + r2 + "(" + this.strides + ");\n         void main() {\n          " + o2 + " coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < " + this.sliceDim + "; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * " + a2 + ";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      ";
  };
}();
function oi(t2, e2) {
  var n2 = Ko();
  return Jt(t2, e2, n2.version + "\n    precision highp float;\n    " + n2.attribute + " vec3 clipSpacePos;\n    " + n2.attribute + " vec2 uv;\n    " + n2.varyingVs + " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }");
}
function ai(t2, e2) {
  return ie(t2, e2, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]));
}
function ii(t2, e2) {
  return ue(t2, e2, new Uint16Array([0, 1, 2, 2, 1, 3]));
}
function ui(t2, e2, n2, r2, o2, a2, i2) {
  ce(n2, r2);
  var u2 = se(t2, e2), s2 = t2.TEXTURE_2D;
  return Kt(t2, e2, function() {
    return t2.bindTexture(s2, u2);
  }), Kt(t2, e2, function() {
    return t2.texParameteri(s2, t2.TEXTURE_WRAP_S, t2.CLAMP_TO_EDGE);
  }), Kt(t2, e2, function() {
    return t2.texParameteri(s2, t2.TEXTURE_WRAP_T, t2.CLAMP_TO_EDGE);
  }), Kt(t2, e2, function() {
    return t2.texParameteri(s2, t2.TEXTURE_MIN_FILTER, t2.NEAREST);
  }), Kt(t2, e2, function() {
    return t2.texParameteri(s2, t2.TEXTURE_MAG_FILTER, t2.NEAREST);
  }), Kt(t2, e2, function() {
    return t2.texImage2D(s2, 0, o2, n2, r2, 0, a2, i2, null);
  }), Kt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, null);
  }), u2;
}
function si(t2, e2, n2, r2, o2) {
  var a2 = zt(n2, r2);
  return ui(t2, e2, a2[0], a2[1], o2.internalFormatFloat, o2.textureFormatFloat, t2.FLOAT);
}
function ci(t2, e2, n2, r2, o2) {
  var a2 = zt(n2, r2);
  return ui(t2, e2, a2[0], a2[1], o2.internalFormatHalfFloat, o2.textureFormatFloat, o2.textureTypeHalfFloat);
}
function li(t2, e2, n2, r2, o2) {
  var a2 = zt(n2, r2);
  return ui(t2, e2, a2[0], a2[1], t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE);
}
function hi(t2, e2, n2, r2, o2) {
  var a2 = Ht(n2, r2);
  return ui(t2, e2, a2[0], a2[1], o2.internalFormatPackedFloat, t2.RGBA, t2.FLOAT);
}
function fi(t2, e2, n2, r2, o2) {
  var a2 = Ht(n2, r2);
  return ui(t2, e2, a2[0], a2[1], o2.internalFormatPackedHalfFloat, t2.RGBA, o2.textureTypeHalfFloat);
}
function pi(t2, e2, n2, r2) {
  return Kt(t2, e2, function() {
    return t2.bindBuffer(t2.ARRAY_BUFFER, r2);
  }), he(t2, e2, n2, "clipSpacePos", r2, 3, 20, 0) && he(t2, e2, n2, "uv", r2, 2, 20, 12);
}
function di(t2, e2, n2, r2, o2, a2, i2) {
  var u2, s2, c2;
  Kt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, n2);
  }), a2 instanceof Uint8Array ? (u2 = new Uint8Array(r2 * o2 * 4), s2 = t2.UNSIGNED_BYTE, c2 = t2.RGBA) : (u2 = new Float32Array(r2 * o2 * 4), s2 = t2.FLOAT, c2 = i2.internalFormatPackedFloat), u2.set(a2), Kt(t2, e2, function() {
    return t2.texImage2D(t2.TEXTURE_2D, 0, c2, r2, o2, 0, t2.RGBA, s2, u2);
  }), Kt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, null);
  });
}
function vi(t2, e2, n2, r2) {
  Kt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, n2);
  }), r2.data instanceof Uint8Array ? Kt(t2, e2, function() {
    return t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, r2.width, r2.height, 0, t2.RGBA, t2.UNSIGNED_BYTE, r2.data);
  }) : Kt(t2, e2, function() {
    return t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, r2);
  }), Kt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, null);
  });
}
function mi(t2, e2, n2, r2, o2) {
  var a2 = t2.createBuffer();
  Kt(t2, e2, function() {
    return t2.bindBuffer(t2.PIXEL_PACK_BUFFER, a2);
  });
  var i2 = 16 * n2 * r2;
  return Kt(t2, e2, function() {
    return t2.bufferData(t2.PIXEL_PACK_BUFFER, i2, t2.STREAM_READ);
  }), Kt(t2, e2, function() {
    return t2.readPixels(0, 0, r2, n2, t2.RGBA, t2.FLOAT, 0);
  }), Kt(t2, e2, function() {
    return t2.bindBuffer(t2.PIXEL_PACK_BUFFER, null);
  }), a2;
}
function gi(t2, e2, n2) {
  var r2 = t2, o2 = new Float32Array(n2);
  return r2.bindBuffer(r2.PIXEL_PACK_BUFFER, e2), r2.getBufferSubData(r2.PIXEL_PACK_BUFFER, 0, o2), r2.bindBuffer(r2.PIXEL_PACK_BUFFER, null), o2;
}
function yi(t2, e2, n2, r2, o2) {
  var a2 = zt(n2, r2), i2 = a2[0], u2 = a2[1], s2 = new Uint8Array(n2 * r2 * 4);
  return Kt(t2, e2, function() {
    return t2.readPixels(0, 0, i2, u2, o2.downloadTextureFormat, t2.UNSIGNED_BYTE, s2);
  }), new Float32Array(s2.buffer);
}
function xi(t2, e2, n2, r2, o2, a2, i2, u2) {
  var s2 = t2, c2 = new Float32Array(function(t3, e3) {
    var n3 = Ht(t3, e3);
    return n3[0] * n3[1] * 4;
  }(a2, i2));
  return s2.bindBuffer(s2.PIXEL_PACK_BUFFER, e2), s2.getBufferSubData(s2.PIXEL_PACK_BUFFER, 0, c2), s2.bindBuffer(s2.PIXEL_PACK_BUFFER, null), c2;
}
function bi(t2, e2, n2, r2) {
  var o2 = new Float32Array(n2 * r2 * 4);
  return Kt(t2, e2, function() {
    return t2.readPixels(0, 0, r2, n2, t2.RGBA, t2.FLOAT, o2);
  }), o2;
}
var wi = Object.freeze({createVertexShader: oi, createVertexBuffer: ai, createIndexBuffer: ii, createFloat32MatrixTexture: si, createFloat16MatrixTexture: ci, createUnsignedBytesMatrixTexture: li, createPackedMatrixTexture: hi, createFloat16PackedMatrixTexture: fi, bindVertexProgramAttributeStreams: pi, uploadDenseMatrixToTexture: di, uploadPixelDataToTexture: vi, createBufferFromOutputTexture: mi, downloadFloat32MatrixFromBuffer: gi, downloadByteEncodedFloatMatrixFromOutputTexture: yi, downloadPackedMatrixFromBuffer: xi, downloadMatrixFromPackedOutputTexture: bi});
var Ci = function() {
  function t2(t3) {
    this.outputTexture = null, this.program = null, this.disposed = false, this.vertexAttrsAreBound = false, this.itemsToPoll = [];
    var e2 = a().getNumber("WEBGL_VERSION");
    if (null != t3 ? (this.gl = t3, Wt(e2, t3)) : this.gl = Ut(e2), 1 === a().getNumber("WEBGL_VERSION"))
      this.textureFloatExtension = Qt(this.gl, this.debug, "OES_texture_float"), this.colorBufferFloatExtension = this.gl.getExtension("WEBGL_color_buffer_float"), this.textureHalfFloatExtension = Qt(this.gl, this.debug, "OES_texture_half_float"), this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float");
    else {
      if (Ne(this.gl, "EXT_color_buffer_float"))
        this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float");
      else {
        if (!Ne(this.gl, "EXT_color_buffer_half_float"))
          throw new Error("GL context does not support color renderable floats");
        this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float");
      }
    }
    this.vertexBuffer = ai(this.gl, this.debug), this.indexBuffer = ii(this.gl, this.debug), this.framebuffer = le(this.gl, this.debug), this.textureConfig = qt(this.gl, this.textureHalfFloatExtension);
  }
  return Object.defineProperty(t2.prototype, "debug", {get: function() {
    return a().getBool("DEBUG");
  }, enumerable: true, configurable: true}), t2.prototype.dispose = function() {
    var t3 = this;
    if (!this.disposed) {
      null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
      var e2 = this.gl;
      Kt(e2, this.debug, function() {
        return e2.finish();
      }), Kt(e2, this.debug, function() {
        return e2.bindFramebuffer(e2.FRAMEBUFFER, null);
      }), Kt(e2, this.debug, function() {
        return e2.deleteFramebuffer(t3.framebuffer);
      }), Kt(e2, this.debug, function() {
        return e2.bindBuffer(e2.ARRAY_BUFFER, null);
      }), Kt(e2, this.debug, function() {
        return e2.bindBuffer(e2.ELEMENT_ARRAY_BUFFER, null);
      }), Kt(e2, this.debug, function() {
        return e2.deleteBuffer(t3.indexBuffer);
      }), this.disposed = true;
    }
  }, t2.prototype.createFloat32MatrixTexture = function(t3, e2) {
    return this.throwIfDisposed(), si(this.gl, this.debug, t3, e2, this.textureConfig);
  }, t2.prototype.createFloat16MatrixTexture = function(t3, e2) {
    return this.throwIfDisposed(), ci(this.gl, this.debug, t3, e2, this.textureConfig);
  }, t2.prototype.createUnsignedBytesMatrixTexture = function(t3, e2) {
    return this.throwIfDisposed(), li(this.gl, this.debug, t3, e2, this.textureConfig);
  }, t2.prototype.uploadPixelDataToTexture = function(t3, e2) {
    this.throwIfDisposed(), vi(this.gl, this.debug, t3, e2);
  }, t2.prototype.uploadDenseMatrixToTexture = function(t3, e2, n2, r2) {
    this.throwIfDisposed(), di(this.gl, this.debug, t3, e2, n2, r2, this.textureConfig);
  }, t2.prototype.createFloat16PackedMatrixTexture = function(t3, e2) {
    return this.throwIfDisposed(), fi(this.gl, this.debug, t3, e2, this.textureConfig);
  }, t2.prototype.createPackedMatrixTexture = function(t3, e2) {
    return this.throwIfDisposed(), hi(this.gl, this.debug, t3, e2, this.textureConfig);
  }, t2.prototype.deleteMatrixTexture = function(t3) {
    var e2 = this;
    this.throwIfDisposed(), this.outputTexture === t3 && (ge(this.gl, this.debug, this.framebuffer), this.outputTexture = null), Kt(this.gl, this.debug, function() {
      return e2.gl.deleteTexture(t3);
    });
  }, t2.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function(t3, e2, n2) {
    var r2 = this;
    return this.downloadMatrixDriver(t3, function() {
      return yi(r2.gl, r2.debug, e2, n2, r2.textureConfig);
    });
  }, t2.prototype.downloadPackedMatrixFromBuffer = function(t3, e2, n2, r2, o2, a2) {
    return xi(this.gl, t3, 0, 0, 0, o2, a2, this.textureConfig);
  }, t2.prototype.downloadFloat32MatrixFromBuffer = function(t3, e2) {
    return gi(this.gl, t3, e2);
  }, t2.prototype.createBufferFromTexture = function(t3, e2, n2) {
    this.bindTextureToFrameBuffer(t3);
    var r2 = mi(this.gl, this.debug, e2, n2, this.textureConfig);
    return this.unbindTextureToFrameBuffer(), r2;
  }, t2.prototype.createAndWaitForFence = function() {
    var t3 = this.createFence(this.gl);
    return this.pollFence(t3);
  }, t2.prototype.createFence = function(t3) {
    var e2, n2, r2 = this;
    if (a().getBool("WEBGL_FENCE_API_ENABLED")) {
      var o2 = t3, i2 = o2.fenceSync(o2.SYNC_GPU_COMMANDS_COMPLETE, 0);
      t3.flush(), n2 = function() {
        var t4 = o2.clientWaitSync(i2, 0, 0);
        return t4 === o2.ALREADY_SIGNALED || t4 === o2.CONDITION_SATISFIED;
      }, e2 = i2;
    } else
      a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (e2 = this.beginQuery(), this.endQuery(), n2 = function() {
        return r2.isQueryAvailable(e2, a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
      }) : n2 = function() {
        return true;
      };
    return {query: e2, isFencePassed: n2};
  }, t2.prototype.downloadMatrixFromPackedTexture = function(t3, e2, n2) {
    var r2 = this;
    return this.downloadMatrixDriver(t3, function() {
      return bi(r2.gl, r2.debug, e2, n2);
    });
  }, t2.prototype.createProgram = function(t3) {
    this.throwIfDisposed();
    var e2 = this.gl, n2 = Zt(e2, this.debug, t3), r2 = oi(e2, this.debug), o2 = re(e2, this.debug);
    return Kt(e2, this.debug, function() {
      return e2.attachShader(o2, r2);
    }), Kt(e2, this.debug, function() {
      return e2.attachShader(o2, n2);
    }), oe(e2, this.debug, o2), this.debug && ae(e2, this.debug, o2), this.vertexAttrsAreBound || (this.setProgram(o2), this.vertexAttrsAreBound = pi(e2, this.debug, this.program, this.vertexBuffer)), o2;
  }, t2.prototype.deleteProgram = function(t3) {
    var e2 = this;
    this.throwIfDisposed(), t3 === this.program && (this.program = null), null != t3 && Kt(this.gl, this.debug, function() {
      return e2.gl.deleteProgram(t3);
    });
  }, t2.prototype.setProgram = function(t3) {
    var e2 = this;
    this.throwIfDisposed(), this.program = t3, null != this.program && this.debug && ae(this.gl, this.debug, this.program), Kt(this.gl, this.debug, function() {
      return e2.gl.useProgram(t3);
    });
  }, t2.prototype.getUniformLocation = function(t3, e2, n2) {
    return void 0 === n2 && (n2 = true), this.throwIfDisposed(), n2 ? pe(this.gl, this.debug, t3, e2) : de(this.gl, t3, e2);
  }, t2.prototype.getAttributeLocation = function(t3, e2) {
    var n2 = this;
    return this.throwIfDisposed(), Kt(this.gl, this.debug, function() {
      return n2.gl.getAttribLocation(t3, e2);
    });
  }, t2.prototype.getUniformLocationNoThrow = function(t3, e2) {
    return this.throwIfDisposed(), this.gl.getUniformLocation(t3, e2);
  }, t2.prototype.setInputMatrixTexture = function(t3, e2, n2) {
    this.throwIfDisposed(), this.throwIfNoProgram(), ve(this.gl, this.debug, this.program, t3, e2, n2);
  }, t2.prototype.setOutputMatrixTexture = function(t3, e2, n2) {
    this.setOutputMatrixTextureDriver(t3, n2, e2);
  }, t2.prototype.setOutputPackedMatrixTexture = function(t3, e2, n2) {
    this.throwIfDisposed();
    var r2 = Ht(e2, n2), o2 = r2[0], a2 = r2[1];
    this.setOutputMatrixTextureDriver(t3, o2, a2);
  }, t2.prototype.setOutputMatrixWriteRegion = function(t3, e2, n2, r2) {
    this.setOutputMatrixWriteRegionDriver(n2, t3, r2, e2);
  }, t2.prototype.setOutputPackedMatrixWriteRegion = function(t3, e2, n2, r2) {
    throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
  }, t2.prototype.debugValidate = function() {
    null != this.program && ae(this.gl, this.debug, this.program), ye(this.gl);
  }, t2.prototype.executeProgram = function() {
    this.throwIfDisposed(), this.throwIfNoProgram();
    var t3 = this.gl;
    this.debug && this.debugValidate(), Kt(t3, this.debug, function() {
      return t3.drawElements(t3.TRIANGLES, 6, t3.UNSIGNED_SHORT, 0);
    });
  }, t2.prototype.blockUntilAllProgramsCompleted = function() {
    var t3 = this;
    this.throwIfDisposed(), Kt(this.gl, this.debug, function() {
      return t3.gl.finish();
    });
  }, t2.prototype.getQueryTimerExtension = function() {
    return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = Qt(this.gl, this.debug, 2 === a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
  }, t2.prototype.getQueryTimerExtensionWebGL2 = function() {
    return this.getQueryTimerExtension();
  }, t2.prototype.getQueryTimerExtensionWebGL1 = function() {
    return this.getQueryTimerExtension();
  }, t2.prototype.beginQuery = function() {
    if (2 === a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
      var t3 = this.gl, e2 = this.getQueryTimerExtensionWebGL2(), n2 = t3.createQuery();
      return t3.beginQuery(e2.TIME_ELAPSED_EXT, n2), n2;
    }
    var r2 = this.getQueryTimerExtensionWebGL1(), o2 = r2.createQueryEXT();
    return r2.beginQueryEXT(r2.TIME_ELAPSED_EXT, o2), o2;
  }, t2.prototype.endQuery = function() {
    if (2 !== a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
      var t3 = this.getQueryTimerExtensionWebGL1();
      t3.endQueryEXT(t3.TIME_ELAPSED_EXT);
    } else {
      var e2 = this.gl, n2 = this.getQueryTimerExtensionWebGL2();
      e2.endQuery(n2.TIME_ELAPSED_EXT);
    }
  }, t2.prototype.waitForQueryAndGetTime = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2 = this;
      return r(this, function(n2) {
        switch (n2.label) {
          case 0:
            return [4, S(function() {
              return e2.disposed || e2.isQueryAvailable(t3, a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
            })];
          case 1:
            return n2.sent(), [2, this.getQueryTime(t3, a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))];
        }
      });
    });
  }, t2.prototype.getQueryTime = function(t3, e2) {
    if (0 === e2)
      return null;
    if (2 === e2) {
      var n2 = this.gl;
      return n2.getQueryParameter(t3, n2.QUERY_RESULT) / 1e6;
    }
    var r2 = this.getQueryTimerExtensionWebGL1();
    return r2.getQueryObjectEXT(t3, r2.QUERY_RESULT_EXT) / 1e6;
  }, t2.prototype.isQueryAvailable = function(t3, e2) {
    if (0 === e2)
      return true;
    if (2 === e2) {
      var n2 = this.gl, r2 = this.getQueryTimerExtensionWebGL2(), o2 = n2.getQueryParameter(t3, n2.QUERY_RESULT_AVAILABLE);
      return null == this.disjoint && (this.disjoint = this.gl.getParameter(r2.GPU_DISJOINT_EXT)), o2 && !this.disjoint;
    }
    o2 = (r2 = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t3, r2.QUERY_RESULT_AVAILABLE_EXT);
    return null == this.disjoint && (this.disjoint = this.gl.getParameter(r2.GPU_DISJOINT_EXT)), o2 && !this.disjoint;
  }, t2.prototype.pollFence = function(t3) {
    var e2 = this;
    return new Promise(function(n2) {
      e2.addItemToPoll(function() {
        return t3.isFencePassed();
      }, function() {
        return n2();
      });
    });
  }, t2.prototype.pollItems = function() {
    for (var t3 = function(t4) {
      for (var e3 = 0; e3 < t4.length; ++e3) {
        var n2 = t4[e3]();
        if (!n2)
          break;
      }
      return e3 - 1;
    }(this.itemsToPoll.map(function(t4) {
      return t4.isDoneFn;
    })), e2 = 0; e2 <= t3; ++e2) {
      (0, this.itemsToPoll[e2].resolveFn)();
    }
    this.itemsToPoll = this.itemsToPoll.slice(t3 + 1);
  }, t2.prototype.addItemToPoll = function(t3, e2) {
    var n2 = this;
    this.itemsToPoll.push({isDoneFn: t3, resolveFn: e2}), this.itemsToPoll.length > 1 || S(function() {
      return n2.pollItems(), 0 === n2.itemsToPoll.length;
    });
  }, t2.prototype.bindTextureToFrameBuffer = function(t3) {
    this.throwIfDisposed(), me(this.gl, this.debug, t3, this.framebuffer), this.debug && ye(this.gl);
  }, t2.prototype.unbindTextureToFrameBuffer = function() {
    null != this.outputTexture ? (me(this.gl, this.debug, this.outputTexture, this.framebuffer), this.debug && ye(this.gl)) : ge(this.gl, this.debug, this.framebuffer);
  }, t2.prototype.downloadMatrixDriver = function(t3, e2) {
    this.bindTextureToFrameBuffer(t3);
    var n2 = e2();
    return this.unbindTextureToFrameBuffer(), n2;
  }, t2.prototype.setOutputMatrixTextureDriver = function(t3, e2, n2) {
    this.throwIfDisposed();
    var r2 = this.gl;
    me(r2, this.debug, t3, this.framebuffer), this.debug && ye(r2), this.outputTexture = t3, Kt(r2, this.debug, function() {
      return r2.viewport(0, 0, e2, n2);
    }), Kt(r2, this.debug, function() {
      return r2.scissor(0, 0, e2, n2);
    });
  }, t2.prototype.setOutputMatrixWriteRegionDriver = function(t3, e2, n2, r2) {
    var o2 = this;
    this.throwIfDisposed(), Kt(this.gl, this.debug, function() {
      return o2.gl.scissor(t3, e2, n2, r2);
    });
  }, t2.prototype.throwIfDisposed = function() {
    if (this.disposed)
      throw new Error("Attempted to use disposed GPGPUContext.");
  }, t2.prototype.throwIfNoProgram = function() {
    if (null == this.program)
      throw new Error("No GPU program is currently set.");
  }, t2;
}();
function Ei(t2, e2) {
  if (t2.length !== e2.length)
    throw Error("Binary was compiled with " + t2.length + " inputs, but was executed with " + e2.length + " inputs");
  t2.forEach(function(t3, n2) {
    var r2 = t3.logicalShape, o2 = e2[n2], a2 = o2.shape;
    if (!C(r2, a2))
      throw Error("Binary was compiled with different shapes than the current args. Shapes " + r2 + " and " + a2 + " must match");
    if (!t3.isUniform || !o2.isUniform) {
      var i2 = t3.texShape, u2 = o2.isUniform ? null : o2.texData.texShape;
      if (!C(i2, u2))
        throw Error("Binary was compiled with different texture shapes than the current args. Shape " + i2 + " and " + u2 + " must match");
    }
  });
}
var Ri = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t2;
    for (var r2 = n2.filterWidth, o2 = n2.inChannels, a2 = n2.strideWidth, i2 = n2.strideHeight, u2 = n2.padInfo, s2 = n2.outWidth, c2 = n2.dilationWidth, l2 = n2.dilationHeight, h2 = n2.dataFormat, f2 = u2.left, p2 = u2.top, d2 = o2 * r2, v2 = Ko(), m2 = "channelsLast" === h2, g2 = m2 ? 0 : 1, y2 = m2 ? 1 : 2, x2 = "", b2 = 0; b2 <= 1; b2++)
      for (var w2 = 0; w2 <= 1; w2++)
        x2 += "\n          blockIndex = rc.y + " + w2 + ";\n          pos = rc.x + " + b2 + ";\n\n          if(blockIndex < " + t2[1] + " && pos < " + t2[0] + ") {\n            offsetY = int(blockIndex / (" + s2 + ")) * " + i2 + " - " + p2 + ";\n            d0 = offsetY + " + l2 + " * (pos / " + d2 + ");\n\n            if(d0 < " + e2[g2] + " && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), " + s2 + ".) * " + a2 + ". - " + f2 + ".);\n              d1 = offsetX + " + c2 + " * (int(mod(float(pos), " + d2 + ".) / " + o2 + ".));\n\n              if(d1 < " + e2[y2] + " && d1 >= 0) {\n\n                ch = int(mod(float(pos), " + o2 + ".));\n\n                if (" + m2 + ") {\n                  innerDims = vec2(d1, ch);\n                  result[" + (2 * b2 + w2) + "] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[" + (2 * b2 + w2) + "] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";
    this.userCode = "\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        " + x2 + "\n\n        " + v2.output + " = result;\n      }\n    ";
  };
}();
var Ii = function() {
  return function(t2, e2, n2, r2, o2) {
    this.variableNames = ["x"], this.outputShape = [];
    var a2, i2 = e2, u2 = t2[3] - 1;
    this.outputShape = t2;
    var s2 = "float(" + n2 + ") + float(" + r2 + ") * sum";
    a2 = 0.5 === o2 ? "inversesqrt(" + s2 + ")" : 1 === o2 ? "1.0/(" + s2 + ")" : "exp(log(" + s2 + ") * float(-" + o2 + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -" + i2 + "; j <= " + i2 + "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  " + u2 + ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * " + a2 + ";\n        setOutput(val);\n      }\n    ";
  };
}();
var ki = function() {
  return function(t2, e2, n2, r2, o2) {
    this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = t2, this.depth = t2[3], this.depthRadius = e2, this.bias = n2, this.alpha = r2, this.beta = o2, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < " + this.depth + "; ++d) {\n          int depthBegin = int(max(0.0, float(d - " + e2 + ")));\n          int depthEnd = int(min(float(" + this.depth + "),\n              float(d + " + e2 + " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = " + this.depth + ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(" + r2 + ") * norm + float(" + n2 + ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(" + r2 + ")\n                * float(" + o2 + ")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * " + o2 + ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ";
  };
}();
var Si = function() {
  return function(t2, e2, n2, r2, o2) {
    this.variableNames = ["x"], this.outputShape = [], this.packedInputs = true, this.packedOutput = true;
    var a2, i2 = e2, u2 = t2[3] - 1;
    this.outputShape = t2;
    var s2 = "float(" + n2 + ") + float(" + r2 + ") * sum";
    a2 = 0.5 === o2 ? "inversesqrt(" + s2 + ")" : 1 === o2 ? "1.0/(" + s2 + ")" : "exp(log(" + s2 + ") * float(-" + o2 + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < " + this.outputShape[3] + ";\n        bool hasNextRow = c < " + this.outputShape[2] + ";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - " + i2 + ";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - " + i2 + "; j <= " + i2 + "; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(" + u2 + "));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * " + a2 + ";\n        setOutput(result);\n      }\n    ";
  };
}();
var Ai = function() {
  return function(t2) {
    this.variableNames = ["dy", "maxPos"], this.outputShape = t2.inShape;
    var e2 = t2.strideHeight, n2 = t2.strideWidth, r2 = t2.dilationHeight, o2 = t2.effectiveFilterHeight, a2 = t2.effectiveFilterWidth, i2 = o2 - 1 - t2.padInfo.top, u2 = a2 - 1 - t2.padInfo.left, s2 = o2 * a2 - 1;
    this.userCode = "\n      const ivec2 pads = ivec2(" + i2 + ", " + u2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + o2 + ";\n          wR += " + r2 + ") {\n          float dyR = float(dyRCorner + wR) / " + e2 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + a2 + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + n2 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + s2 + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + a2 + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var Di = function() {
  return function(t2) {
    this.variableNames = ["dy", "maxPos"], this.outputShape = t2.inShape;
    var e2 = t2.strideDepth, n2 = t2.strideHeight, r2 = t2.strideWidth, o2 = t2.dilationDepth, a2 = t2.dilationHeight, i2 = t2.dilationWidth, u2 = t2.effectiveFilterDepth, s2 = t2.effectiveFilterHeight, c2 = t2.effectiveFilterWidth, l2 = u2 - 1 - t2.padInfo.front, h2 = s2 - 1 - t2.padInfo.top, f2 = c2 - 1 - t2.padInfo.left, p2 = u2 * s2 * c2 - 1;
    this.userCode = "\n      const ivec3 pads = ivec3(" + l2 + ", " + h2 + ", " + f2 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + u2 + ";\n           wD += " + o2 + ") {\n          float dyD = float(dyDCorner + wD) / " + e2 + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t2.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + s2 + ";\n              wR += " + a2 + ") {\n            float dyR = float(dyRCorner + wR) / " + n2 + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + c2 + ";\n                wC += " + i2 + ") {\n              float dyC = float(dyCCorner + wC) / " + r2 + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = " + p2 + " -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * " + s2 + " * " + c2 + " +\n                  wR * " + c2 + " + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var Ti = function() {
  return function(t2, e2, n2, r2, o2, a2, i2) {
    void 0 === n2 && (n2 = false), void 0 === r2 && (r2 = false), void 0 === o2 && (o2 = false), void 0 === a2 && (a2 = null), void 0 === i2 && (i2 = false), this.variableNames = ["matrixA", "matrixB"], this.packedInputs = true, this.packedOutput = true, this.outputShape = e2;
    var u2 = n2 ? t2[1] : t2[2], s2 = Math.ceil(u2 / 2), c2 = n2 ? "i * 2, rc.y" : "rc.y, i * 2", l2 = r2 ? "rc.z, i * 2" : "i * 2, rc.z", h2 = n2 ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"], f2 = r2 ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"], p2 = "", d2 = "";
    a2 && (p2 = i2 ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + a2 + "\n        }" : "vec4 activation(vec4 x) {\n          " + a2 + "\n        }", d2 = "result = activation(result);");
    var v2 = o2 ? "result += getBiasAtOutCoords();" : "";
    o2 && this.variableNames.push("bias"), i2 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + p2 + "\n\n      const float sharedDimension = " + s2 + ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < " + s2 + "; i++) {\n          vec4 a = getMatrixA(rc.x, " + c2 + ");\n          vec4 b = getMatrixB(rc.x, " + l2 + ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (" + h2[0] + " * " + f2[0] + ");\n          result += (" + h2[1] + " * " + f2[1] + ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        " + v2 + "\n\n        " + d2 + "\n\n        setOutput(result);\n      }\n    ";
  };
}();
var Ni = function() {
  function t2(t3, e2, n2) {
    this.variableNames = ["probs"], this.outputShape = [t3, n2], this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (e2 - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (e2 - 1) + "));\n      }\n    ";
  }
  return t2.prototype.getCustomSetupFunc = function(t3) {
    var e2 = this;
    return function(n2, r2) {
      null == e2.seedLoc && (e2.seedLoc = n2.getUniformLocation(r2, "seed")), n2.gl.uniform1f(e2.seedLoc, t3);
    };
  }, t2;
}();
var Fi = function() {
  return function(t2, e2, n2, r2) {
    this.variableNames = ["indices"], this.outputShape = [t2, e2], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + r2 + "), float(" + n2 + "),\n                      float(index == coords.y)));\n      }\n    ";
  };
}();
var Oi = function() {
  return function(t2) {
    this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outputShape = t2;
    var e2 = t2.length;
    if (0 === e2)
      this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
    else {
      var n2 = qo("rc", e2), r2 = aa(e2), o2 = function(t3, e3, n3) {
        if (1 === t3)
          return "rc > " + e3[0];
        for (var r3 = "", o3 = t3 - 2; o3 < t3; o3++)
          r3 += n3[o3] + " >= " + e3[o3], o3 < t3 - 1 && (r3 += "||");
        return r3;
      }(e2, t2, n2), a2 = function(t3, e3, n3, r3) {
        if (1 === t3)
          return "";
        var o3 = r3.slice(-2);
        return "\n    int r = " + o3[0] + ";\n    int c = " + o3[1] + ";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= " + e3 + ";\n    bool rEdge = rp1 >= " + n3 + ";\n  ";
      }(e2, t2[t2.length - 1], t2[t2.length - 2], n2), i2 = function(t3, e3) {
        var n3 = t3.length, r3 = function(t4, e4) {
          for (var n4 = [], r4 = 0; r4 <= 1; r4++)
            for (var o3 = 0; o3 <= 1; o3++) {
              for (var a3 = (0 === r4 ? "r" : "rp1") + ", " + (0 === o3 ? "c" : "cp1"), i3 = 2; i3 < t4; i3++)
                a3 = e4[e4.length - 1 - i3] + "," + a3;
              n4.push(a3);
            }
          return n4;
        }(n3, e3);
        return 1 === n3 ? "getA(rc),\n            rc + 1 >= " + t3[0] + " ? 0. : getA(rc + 1),\n            0, 0" : "getA(" + r3[0] + "),\n          cEdge ? 0. : getA(" + r3[1] + "),\n          rEdge ? 0. : getA(" + r3[2] + "),\n          rEdge || cEdge ? 0. : getA(" + r3[3] + ")";
      }(t2, n2);
      this.userCode = "\n        void main() {\n          " + r2 + " rc = getOutputCoords();\n\n          if(" + o2 + ") {\n            setOutput(vec4(0));\n          } else {\n            " + a2 + "\n\n            setOutput(vec4(" + i2 + "));\n          }\n        }\n      ";
    }
  };
}();
var _i = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["x"], this.outputShape = e2.map(function(e3, n3) {
      return e3[0] + t2[n3] + e3[1];
    });
    var r2 = t2.length, o2 = aa(r2), a2 = e2.map(function(t3) {
      return t3[0];
    }).join(","), i2 = e2.map(function(e3, n3) {
      return e3[0] + t2[n3];
    }).join(","), u2 = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, r2);
    this.userCode = 1 !== r2 ? "\n      " + o2 + " start = " + o2 + "(" + a2 + ");\n      " + o2 + " end = " + o2 + "(" + i2 + ");\n\n      void main() {\n        " + o2 + " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(" + n2 + "));\n        } else {\n          " + o2 + " coords = outC - start;\n          setOutput(getX(" + u2 + "));\n        }\n      }\n    " : "\n        int start = " + a2 + ";\n        int end = " + i2 + ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(" + n2 + "));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ";
  };
}();
var Mi = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true, this.outputShape = e2.map(function(e3, n3) {
      return e3[0] + t2[n3] + e3[1];
    });
    for (var r2 = t2.length, o2 = aa(r2), a2 = e2.map(function(t3) {
      return t3[0];
    }).join(","), i2 = e2.map(function(e3, n3) {
      return e3[0] + t2[n3];
    }).join(","), u2 = qo("rc", r2), s2 = qo("source", r2), c2 = u2[r2 - 1] + " < " + this.outputShape[r2 - 1], l2 = 1 === r2 ? "source" : "vec2(" + s2.slice(-2).join() + ")", h2 = [o2 + " rc = outputLoc;", u2[r2 - 1] + " += 1;\n       if(" + c2 + ") {\n      ", 1 === r2 ? "" : "}\n       rc = outputLoc;\n       " + u2[r2 - 2] + " += 1;\n       if(" + u2[r2 - 2] + " < " + this.outputShape[r2 - 2] + ") {", 1 === r2 ? "" : "  " + u2[r2 - 1] + " += 1;\n         if(" + c2 + ") {"], f2 = 1 === r2 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", p2 = "", d2 = 0, v2 = 1 === r2 ? 2 : 4; d2 < v2; d2++)
      p2 += "\n        " + h2[d2] + "\n        if (" + f2 + ") {\n          result[" + d2 + "] = float(" + n2 + ");\n        } else {\n          " + o2 + " source = rc - start;\n          result[" + d2 + "] = getChannel(getX(" + s2.join() + "), " + l2 + ");\n        }\n      ";
    p2 += 1 === r2 ? "} " : "}}", this.userCode = "\n      const " + o2 + " start = " + o2 + "(" + a2 + ");\n      const " + o2 + " end = " + o2 + "(" + i2 + ");\n\n      void main() {\n        " + o2 + " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        " + p2 + "\n        setOutput(result);\n      }\n    ";
  };
}();
var Bi = function() {
  return function(t2, e2, n2) {
    if (this.variableNames = ["x"], "avg" === e2 && n2)
      throw new Error("Cannot compute positions for average pool.");
    var r2 = t2.filterWidth, o2 = t2.strideHeight, a2 = t2.strideWidth, i2 = t2.dilationHeight, u2 = t2.dilationWidth, s2 = t2.effectiveFilterHeight, c2 = t2.effectiveFilterWidth, l2 = t2.padInfo.top, h2 = t2.padInfo.left;
    this.outputShape = t2.outShape;
    var f2 = "avg" === e2, p2 = "0.0";
    if (f2 || (p2 = "-1.0 / 1e-20"), n2)
      this.userCode = "\n        const ivec2 strides = ivec2(" + o2 + ", " + a2 + ");\n        const ivec2 pads = ivec2(" + l2 + ", " + h2 + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + s2 + ";\n              wR += " + i2 + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t2.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + c2 + ";\n                wC += " + u2 + ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + t2.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + c2 + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
    else {
      var d2 = e2 + "(" + e2 + "(" + e2 + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
      "avg" === e2 && (d2 = "avgValue / count");
      var v2 = 4 * Math.floor(r2 / 4), m2 = r2 % 4, g2 = "\n      if (" + f2 + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
      this.userCode = "\n      const ivec2 strides = ivec2(" + o2 + ", " + a2 + ");\n      const ivec2 pads = ivec2(" + l2 + ", " + h2 + ");\n      const float initializationValue = " + p2 + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + t2.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + p2 + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " + s2 + ";\n            wR += " + i2 + ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + t2.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + v2 + "; wC += 4) {\n            int xC = xCCorner + wC * " + u2 + ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + u2 + ", d),\n              getValue(batch, xR, xC + 2 * " + u2 + ", d),\n              getValue(batch, xR, xC + 3 * " + u2 + ", d)\n            );\n\n            " + g2 + "\n          }\n\n          int xC = xCCorner + " + v2 + ";\n          if (" + (1 === m2) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " + g2 + "\n          } else if (" + (2 === m2) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + u2 + ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + g2 + "\n          } else if (" + (3 === m2) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + u2 + ", d),\n              getValue(batch, xR, xC + 2 * " + u2 + ", d),\n              initializationValue\n            );\n\n            " + g2 + "\n          }\n        }\n        setOutput(" + d2 + ");\n      }\n    ";
    }
  };
}();
var Pi = function() {
  return function(t2, e2, n2) {
    if (this.variableNames = ["x"], "avg" === e2 && n2)
      throw new Error("Cannot compute positions for average pool.");
    var r2 = t2.filterWidth, o2 = t2.strideDepth, a2 = t2.strideHeight, i2 = t2.strideWidth, u2 = t2.dilationDepth, s2 = t2.dilationHeight, c2 = t2.dilationWidth, l2 = t2.effectiveFilterDepth, h2 = t2.effectiveFilterHeight, f2 = t2.effectiveFilterWidth, p2 = t2.padInfo.front, d2 = t2.padInfo.top, v2 = t2.padInfo.left;
    this.outputShape = t2.outShape;
    var m2 = "avg" === e2, g2 = "0.0";
    if (m2 || (g2 = "-1.0 / 1e-20"), n2)
      this.userCode = "\n        const ivec3 strides =\n            ivec3(" + o2 + ", " + a2 + ", " + i2 + ");\n        const ivec3 pads = ivec3(" + p2 + ", " + d2 + ", " + v2 + ");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < " + l2 + ";\n              wD += " + u2 + ") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= " + t2.inDepth + ") {\n              continue;\n            }\n\n            for (int wR = 0; wR < " + h2 + ";\n                wR += " + s2 + ") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= " + t2.inHeight + ") {\n                continue;\n              }\n\n              for (int wC = 0; wC < " + f2 + ";\n                  wC += " + c2 + ") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= " + t2.inWidth + ") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition =\n                      wD * " + h2 + " * " + f2 + " +\n                      wR * " + f2 + " + wC;;\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
    else {
      var y2 = e2 + "(" + e2 + "(" + e2 + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
      "avg" === e2 && (y2 = "avgValue / count");
      var x2 = 4 * Math.floor(r2 / 4), b2 = r2 % 4, w2 = "\n      if (" + m2 + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
      this.userCode = "\n      const ivec3 strides =\n        ivec3(" + o2 + ", " + a2 + ", " + i2 + ");\n      const ivec3 pads = ivec3(" + p2 + ", " + d2 + ", " + v2 + ");\n      const float initializationValue = " + g2 + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= " + t2.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + g2 + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < " + l2 + ";\n            wD += " + u2 + ") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= " + t2.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h2 + ";\n            wR += " + s2 + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t2.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + x2 + "; wC += 4) {\n              int xC = xCCorner + wC * " + c2 + ";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c2 + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c2 + ", ch),\n                getValue(batch, xD, xR, xC + 3 * " + c2 + ", ch)\n              );\n\n              " + w2 + "\n            }\n\n            int xC = xCCorner + " + x2 + ";\n            if (" + (1 === b2) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              " + w2 + "\n            } else if (" + (2 === b2) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c2 + ", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              " + w2 + "\n            } else if (" + (3 === b2) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c2 + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c2 + ", ch),\n                initializationValue\n              );\n\n              " + w2 + "\n            }\n          }\n          setOutput(" + y2 + ");\n        }\n      }\n    ";
    }
  };
}();
var Li = function() {
  return function(t2, e2) {
    this.variableNames = ["x"];
    var n2 = t2.windowSize, r2 = t2.batchSize, o2 = t2.inSize, a2 = Math.ceil(o2 / n2);
    this.outputShape = [r2, a2];
    var i2 = "0.0", u2 = "";
    "prod" === e2 ? i2 = "1.0" : "min" === e2 ? (i2 = "1.0 / 1e-20", u2 = "min") : "max" === e2 && (i2 = "-1.0 / 1e-20", u2 = "max");
    var s2 = e2 + "(" + e2 + "(" + e2 + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
    "sum" === e2 ? s2 = "sumValue" : "prod" === e2 ? s2 = "prodValue" : "all" === e2 ? s2 = "allValue" : "any" === e2 && (s2 = "anyValue");
    var c2 = 4 * Math.floor(n2 / 4), l2 = n2 % 4, h2 = "\n      if (" + ("sum" === e2) + ") {\n        sumValue += dot(values, ones);\n      } else if (" + ("prod" === e2) + ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = " + u2 + "(values, minMaxValue);\n      }\n    ", f2 = "vec4";
    "all" === e2 ? (i2 = "1.0", h2 = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", f2 = "bvec4") : "any" === e2 && (i2 = "0.0", h2 = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", f2 = "bvec4");
    var p2 = "";
    o2 % n2 > 0 && (p2 = "\n        if (inIdx < 0 || inIdx >= " + o2 + ") {\n          return initializationValue;\n        }\n      "), this.userCode = "\n      const float initializationValue = " + i2 + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + p2 + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + n2 + ";\n\n        vec4 minMaxValue = vec4(" + i2 + ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < " + c2 + "; i += 4) {\n          int inIdx = inOffset + i;\n          " + f2 + " values = " + f2 + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + h2 + "\n        }\n\n        int inIdx = inOffset + " + c2 + ";\n        if (" + (1 === l2) + ") {\n          " + f2 + " values = " + f2 + "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          " + h2 + "\n        } else if (" + (2 === l2) + ") {\n          " + f2 + " values = " + f2 + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          " + h2 + "\n        } else if (" + (3 === l2) + ") {\n          " + f2 + " values = " + f2 + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          " + h2 + "\n        }\n        setOutput(" + s2 + ");\n      }\n    ";
  };
}();
var Wi = function() {
  return function(t2, e2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t2;
    for (var n2 = "", r2 = 0; r2 < 4; r2++) {
      var o2 = "thisRC = rc;";
      r2 % 2 == 1 && (o2 += "thisRC.z += 1;"), r2 > 1 && (o2 += "thisRC.y += 1;"), n2 += "\n        " + o2 + "\n        " + (r2 > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "") + "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[" + r2 + "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        " + (r2 > 0 ? "}" : "") + "\n      ";
    }
    this.userCode = "\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      " + jo(["r", "c", "d"], e2) + "\n      return ivec3(r, c, d);\n    }\n  \n      " + Xo(t2) + "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = " + t2[1] + ";\n        int cols = " + t2[2] + ";\n\n        " + n2 + "\n\n        setOutput(result);\n      }\n    ";
  };
}();
var Ui = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e2.shape;
    var r2 = e2.shape, o2 = r2[1], a2 = r2[2], i2 = t2.shape, u2 = i2[1], s2 = i2[2], c2 = [n2 && u2 > 1 ? o2 - 1 : o2, n2 && s2 > 1 ? a2 - 1 : a2], l2 = [n2 && u2 > 1 ? u2 - 1 : u2, n2 && s2 > 1 ? s2 - 1 : s2], h2 = c2[0] / l2[0], f2 = c2[1] / l2[1], p2 = 1 / h2, d2 = 1 / f2, v2 = 2 * Math.ceil(p2) + 2, m2 = 2 * Math.ceil(d2) + 2;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h2 + ");\n        const float widthScale = float(" + f2 + ");\n\n        const float invHeightScale = float(" + p2 + ");\n        const float invWidthScale = float(" + d2 + ");\n\n        const int winHeight = int(" + v2 + ");\n        const int winWidth = int(" + m2 + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + u2 + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + s2 + ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), " + (o2 - 1) + ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), " + (a2 - 1) + ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
  };
}();
var Vi = function() {
  return function(t2, e2, n2, r2) {
    this.variableNames = ["A"], this.outputShape = [];
    var o2 = t2[0], a2 = t2[1], i2 = t2[2], u2 = t2[3];
    this.outputShape = [o2, e2, n2, u2];
    var s2 = [r2 && e2 > 1 ? a2 - 1 : a2, r2 && n2 > 1 ? i2 - 1 : i2], c2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2];
    this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + s2[0] / c2[0] + ",\n          " + s2[1] / c2[1] + ");\n      const vec2 inputShapeRC = vec2(" + a2 + ".0, " + i2 + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
  };
}();
var zi = function() {
  return function(t2, e2, n2, r2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
    var o2 = t2[0], a2 = t2[1], i2 = t2[2], u2 = t2[3];
    this.outputShape = [o2, e2, n2, u2];
    var s2 = [r2 && e2 > 1 ? a2 - 1 : a2, r2 && n2 > 1 ? i2 - 1 : i2], c2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2];
    this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          " + s2[0] / c2[0] + ",\n          " + s2[1] / c2[1] + ",\n          " + s2[1] / c2[1] + ");\n      const vec3 inputShapeRC = vec3(" + a2 + ".0, " + i2 + ".0,\n                                     " + i2 + ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < " + (u2 - 1) + ";\n        bool hasNextRow = coords.z < " + (n2 - 1) + ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ";
  };
}();
var Gi = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e2.shape;
    var r2 = e2.shape, o2 = r2[1], a2 = r2[2], i2 = t2.shape, u2 = i2[1], s2 = i2[2], c2 = [n2 && u2 > 1 ? o2 - 1 : o2, n2 && s2 > 1 ? a2 - 1 : a2], l2 = [n2 && u2 > 1 ? u2 - 1 : u2, n2 && s2 > 1 ? s2 - 1 : s2], h2 = c2[0] / l2[0], f2 = c2[1] / l2[1], p2 = 1 / h2, d2 = 1 / f2, v2 = 2 * Math.ceil(p2) + 2, m2 = 2 * Math.ceil(d2) + 2;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h2 + ");\n        const float widthScale = float(" + f2 + ");\n\n        const float invHeightScale = float(" + p2 + ");\n        const float invWidthScale = float(" + d2 + ");\n\n        const int winHeight = int(" + v2 + ");\n        const int winWidth = int(" + m2 + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + u2 + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + s2 + ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(" + c2[0] + ") *\n                (float(dyR) / float(" + l2[0] + "));\n\n            float sourceFracCol =\n                float(" + c2[1] + ") *\n                  (float(dyC) / float(" + l2[1] + "));\n\n            int sourceNearestRow = int(min(\n                float(int(" + o2 + ") - 1),\n                " + n2 + " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(" + a2 + ") - 1),\n                " + n2 + " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
  };
}();
var Hi = function() {
  return function(t2, e2, n2, r2) {
    this.variableNames = ["A"], this.outputShape = [];
    var o2 = t2[0], a2 = t2[1], i2 = t2[2], u2 = t2[3];
    this.outputShape = [o2, e2, n2, u2];
    var s2 = [r2 && e2 > 1 ? a2 - 1 : a2, r2 && n2 > 1 ? i2 - 1 : i2], c2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2], l2 = r2 ? "0.5" : "0.0";
    this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + s2[0] / c2[0] + ",\n          " + s2[1] / c2[1] + ");\n      const vec2 inputShapeRC = vec2(" + a2 + ".0, " + i2 + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " + l2 + ")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ";
  };
}();
var qi = function() {
  return function(t2, e2) {
    this.variableNames = ["x"];
    var n2 = t2.length;
    if (n2 > 4)
      throw new Error("WebGL backend: Reverse of rank-" + n2 + " tensor is not yet supported");
    if (this.outputShape = t2, 1 !== n2) {
      var r2 = t2.map(function(n3, r3) {
        return function(n4) {
          return -1 !== e2.indexOf(n4) && 1 !== t2[n4] ? t2[n4] + " - coords[" + n4 + "] - 1" : "coords[" + n4 + "]";
        }(r3);
      }).join(","), o2 = aa(n2);
      this.userCode = "\n      void main() {\n        " + o2 + " coords = getOutputCoords();\n        setOutput(getX(" + r2 + "));\n      }\n    ";
    } else
      this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" + t2[0] + " - coord - 1));\n        }\n      ";
  };
}();
var Ki = function() {
  return function(t2, e2) {
    this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true;
    var n2 = t2.length;
    if (n2 > 4)
      throw new Error("WebGL backend: Reverse of rank-" + n2 + " tensor is not yet supported");
    this.outputShape = t2;
    var r2 = qo("rc", n2), o2 = r2[n2 - 1] + " + 1 < " + this.outputShape[n2 - 1], a2 = r2[n2 - 2] + " + 1 < " + this.outputShape[n2 - 2], i2 = aa(n2);
    function u2(n3) {
      var r3 = t2.map(function(r4, o3) {
        return function(n4, r5) {
          return -1 !== e2.indexOf(n4) && 1 !== t2[n4] ? t2[n4] + " - " + r5[n4] + " - 1" : "" + r5[n4];
        }(o3, n3);
      });
      return "getChannel(getX(" + r3.join(",") + "), vec2(" + r3.slice(-2).join(",") + "))";
    }
    this.userCode = 1 === n2 ? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(" + t2[0] + " - rc - 1),\n            " + t2[0] + " - rc - 1);\n          if(" + o2 + "){\n              result.g = getChannel(getX(" + t2[0] + " - (rc  + 1) - 1),\n                " + t2[0] + " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      " : "\n        void main() {\n          " + i2 + " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = " + function(t3) {
      return u2(t3);
    }(r2.slice()) + ";\n          if(" + o2 + "){\n            result.g = " + function(t3) {
      return t3[n2 - 1] = "(" + t3[n2 - 1] + " + 1)", u2(t3);
    }(r2.slice()) + ";\n          }\n          if(" + a2 + ") {\n            result.b = " + function(t3) {
      return t3[n2 - 2] = "(" + t3[n2 - 2] + " + 1)", u2(t3);
    }(r2.slice()) + ";\n            if(" + o2 + ") {\n              result.a = " + function(t3) {
      return t3[n2 - 1] = "(" + t3[n2 - 1] + " + 1)", t3[n2 - 2] = "(" + t3[n2 - 2] + " + 1)", u2(t3);
    }(r2.slice()) + ";\n            }\n          }\n          setOutput(result);\n        }\n    ";
  };
}();
var ji = function() {
  return function(t2, e2, n2, r2, o2, a2, i2) {
    void 0 === i2 && (i2 = true), this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = a2;
    var u2 = aa(o2.length), s2 = aa(a2.length), c2 = "";
    1 === n2 ? c2 = "i" : 2 === n2 && (c2 = "i, j");
    var l2 = "getIndices(" + c2 + ")", h2 = "";
    1 === r2 ? h2 = "i" : 2 === r2 && (h2 = "i, coords[1]");
    var f2 = "getUpdates(" + h2 + ")", p2 = e2 > 1 ? "strides[j]" : "strides";
    this.userCode = "\n        " + u2 + " strides = " + u2 + "(" + o2 + ");\n\n        void main() {\n          " + s2 + " coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < " + t2 + "; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < " + e2 + "; j++) {\n              int index = round(" + l2 + ");\n              flattenedIndex += index * " + p2 + ";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += " + f2 + ";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      ";
  };
}();
var Xi = function() {
  return function(t2, e2) {
    this.variableNames = ["x", "segmentIds"];
    var n2 = t2.windowSize, r2 = t2.batchSize, o2 = t2.inSize, a2 = t2.numSegments, i2 = a2 * Math.ceil(o2 / n2);
    this.outputShape = [r2, i2];
    var u2 = 4 * Math.floor(n2 / 4), s2 = n2 % 4, c2 = "\n        sumValue += dot(values, segFilter);\n    ", l2 = "";
    o2 % n2 > 0 && (l2 = "\n        if (inIdx < 0 || inIdx >= " + o2 + ") {\n          return initializationValue;\n        }\n      ");
    var h2 = "";
    o2 % n2 > 0 && (h2 = "\n        if (inIdx < 0 || inIdx >= " + o2 + ") {\n          return -1.0;\n        }\n      "), this.userCode = "\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        " + l2 + "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        " + h2 + "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          " + a2 + ")) * float(" + n2 + "));\n        int currentSeg = int(mod(float(outIdx), float(" + a2 + ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + u2 + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          " + c2 + "\n        }\n\n        int inIdx = inOffset + " + u2 + ";\n        if (" + (1 === s2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          " + c2 + "\n        } else if (" + (2 === s2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          " + c2 + "\n        } else if (" + (3 === s2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          " + c2 + "\n        }\n        setOutput(sumValue);\n      }\n    ";
  };
}();
var $i = function() {
  return function(t2, e2, n2) {
    var r2, o2;
    if (this.variableNames = ["c", "a", "b"], this.outputShape = e2, n2 > 4)
      throw Error("Where for rank " + n2 + " is not yet supported");
    if (1 === n2)
      o2 = "resRC", r2 = "resRC";
    else {
      for (var a2 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], i2 = [], u2 = [], s2 = 0; s2 < e2.length; s2++)
        u2.push("" + a2[s2]), s2 < t2 && i2.push("" + a2[s2]);
      r2 = i2.join(), o2 = u2.join();
    }
    var c2 = aa(n2);
    this.userCode = "\n      void main() {\n        " + c2 + " resRC = getOutputCoords();\n        float cVal = getC(" + r2 + ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" + o2 + "));\n        } else {\n          setOutput(getB(" + o2 + "));\n        }\n      }\n    ";
  };
}();
var Yi = function() {
  function t2(t3) {
    this.variableNames = ["source"], this.outputShape = t3, this.rank = t3.length;
    var e2, n2 = aa(this.rank), r2 = "uniform int start[" + this.rank + "];", o2 = function(t4) {
      if (1 === t4)
        return "sourceLoc";
      if (t4 <= 6)
        return Qi.slice(0, t4).map(function(t5) {
          return "sourceLoc." + t5;
        }).join(",");
      throw Error("Slicing for rank " + t4 + " is not yet supported");
    }(this.rank);
    e2 = "\n        " + n2 + " sourceLoc;\n        " + n2 + " coords = getOutputCoords();\n        " + t3.map(function(t4, e3) {
      return "sourceLoc." + Qi[e3] + " = start[" + e3 + "] + coords." + Qi[e3] + ";";
    }).join("\n") + "\n      ", this.userCode = "\n      " + r2 + "\n      void main() {\n        " + e2 + "\n        setOutput(getSource(" + o2 + "));\n      }\n    ";
  }
  return t2.prototype.getCustomSetupFunc = function(t3) {
    var e2 = this;
    if (t3.length !== this.rank)
      throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t3.length + ")");
    return function(n2, r2) {
      null == e2.startLoc && (e2.startLoc = n2.getUniformLocationNoThrow(r2, "start"), null == e2.startLoc) || n2.gl.uniform1iv(e2.startLoc, t3);
    };
  }, t2;
}();
var Qi = ["x", "y", "z", "w", "u", "v"];
var Ji = function() {
  function t2(t3) {
    this.variableNames = ["source"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t3, this.rank = t3.length;
    var e2 = aa(this.rank), n2 = qo("coords", this.rank), r2 = qo("sourceLoc", this.rank), o2 = 1 === this.rank ? "sourceLoc" : "vec2(" + r2.slice(-2).join() + ")", a2 = "getChannel(getSource(" + r2.join() + "), " + o2 + ")", i2 = "\n      result.x = " + a2 + ";\n      if (++" + n2[this.rank - 1] + " < " + t3[this.rank - 1] + ") {\n        ++" + r2[this.rank - 1] + ";\n        result.y = " + a2 + ";\n        --" + r2[this.rank - 1] + ";\n      }\n    ", u2 = 1 === this.rank ? "" : "\n      --" + n2[this.rank - 1] + ";\n      if (++" + n2[this.rank - 2] + " < " + t3[this.rank - 2] + ") {\n        ++" + r2[this.rank - 2] + ";\n        result.z = " + a2 + ";\n        if (++" + n2[this.rank - 1] + " < " + t3[this.rank - 1] + ") {\n          ++" + r2[this.rank - 1] + ";\n          result.w = " + a2 + ";\n        }\n      }\n    ", s2 = this.rank <= 4 ? "sourceLoc = coords +\n            " + e2 + "(" + t3.map(function(t4, e3) {
      return "start[" + e3 + "]";
    }).join() + ");" : t3.map(function(t4, e3) {
      return r2[e3] + " = " + n2[e3] + " + start[" + e3 + "];";
    }).join("\n");
    this.userCode = "\n      uniform int start[" + this.rank + "];\n      void main() {\n        " + e2 + " coords = getOutputCoords();\n        " + e2 + " sourceLoc;\n        " + s2 + "\n        vec4 result = vec4(0.);\n        " + i2 + "\n        " + u2 + "\n        setOutput(result);\n      }\n    ";
  }
  return t2.prototype.getCustomSetupFunc = function(t3) {
    var e2 = this;
    if (t3.length !== this.rank)
      throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t3.length + ")");
    return function(n2, r2) {
      null == e2.startLoc && (e2.startLoc = n2.getUniformLocationNoThrow(r2, "start"), null == e2.startLoc) || n2.gl.uniform1iv(e2.startLoc, t3);
    };
  }, t2;
}();
var Zi = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["x"], this.outputShape = n2;
    var r2 = n2.length, o2 = aa(n2.length), a2 = aa(n2.length), i2 = "";
    if (1 === r2)
      i2 = "coords * strides + begin";
    else {
      var u2 = 0;
      i2 = n2.map(function(t3, e3) {
        return u2++, 1 === n2.length ? "coords * strides[" + e3 + "] + begin[" + e3 + "]" : "coords[" + (u2 - 1) + "] * strides[" + e3 + "] + begin[" + e3 + "]";
      }).join(",");
    }
    this.userCode = "\n      " + o2 + " begin = " + o2 + "(" + t2 + ");\n      " + o2 + " strides = " + o2 + "(" + e2 + ");\n\n      void main() {\n        " + a2 + " coords = getOutputCoords();\n        setOutput(getX(" + i2 + "));\n      }\n    ";
  };
}();
var tu = function() {
  function t2(t3) {
    this.gpgpu = t3, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {}, this.logEnabled = false, this.usedTextures = {};
  }
  return t2.prototype.acquireTexture = function(t3, e2, n2) {
    var r2, o2 = eu(e2, n2), a2 = nu(t3, o2, n2);
    if (a2 in this.freeTextures || (this.freeTextures[a2] = []), a2 in this.usedTextures || (this.usedTextures[a2] = []), this.freeTextures[a2].length > 0) {
      this.numFreeTextures--, this.numUsedTextures++, this.log();
      var i2 = this.freeTextures[a2].shift();
      return this.usedTextures[a2].push(i2), i2;
    }
    return this.numUsedTextures++, this.log(), o2 === Bt.PACKED_2X2_FLOAT32 ? r2 = this.gpgpu.createPackedMatrixTexture(t3[0], t3[1]) : o2 === Bt.PACKED_2X2_FLOAT16 ? r2 = this.gpgpu.createFloat16PackedMatrixTexture(t3[0], t3[1]) : o2 === Bt.UNPACKED_FLOAT32 ? r2 = this.gpgpu.createFloat32MatrixTexture(t3[0], t3[1]) : o2 === Bt.UNPACKED_FLOAT16 ? r2 = this.gpgpu.createFloat16MatrixTexture(t3[0], t3[1]) : o2 === Bt.PACKED_4X1_UNSIGNED_BYTE && (r2 = this.gpgpu.createUnsignedBytesMatrixTexture(t3[0], t3[1])), this.usedTextures[a2].push(r2), r2;
  }, t2.prototype.releaseTexture = function(t3, e2, n2, r2) {
    if (null != this.freeTextures) {
      var o2 = nu(e2, eu(n2, r2), r2);
      o2 in this.freeTextures || (this.freeTextures[o2] = []), this.freeTextures[o2].push(t3), this.numFreeTextures++, this.numUsedTextures--;
      var a2 = this.usedTextures[o2], i2 = a2.indexOf(t3);
      if (i2 < 0)
        throw new Error("Cannot release a texture that was never provided by this texture manager");
      a2.splice(i2, 1), this.log();
    }
  }, t2.prototype.log = function() {
    if (this.logEnabled) {
      var t3 = this.numFreeTextures + this.numUsedTextures;
      console.log("Free/Used", this.numFreeTextures + " / " + this.numUsedTextures, "(" + t3 + ")");
    }
  }, t2.prototype.getNumUsedTextures = function() {
    return this.numUsedTextures;
  }, t2.prototype.getNumFreeTextures = function() {
    return this.numFreeTextures;
  }, t2.prototype.dispose = function() {
    var t3 = this;
    if (null != this.freeTextures) {
      for (var e2 in this.freeTextures)
        this.freeTextures[e2].forEach(function(e3) {
          t3.gpgpu.deleteMatrixTexture(e3);
        });
      for (var e2 in this.usedTextures)
        this.usedTextures[e2].forEach(function(e3) {
          t3.gpgpu.deleteMatrixTexture(e3);
        });
      this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0;
    }
  }, t2;
}();
function eu(t2, e2) {
  if (t2 === Mt.UPLOAD)
    return Bt.PACKED_2X2_FLOAT32;
  if (t2 === Mt.RENDER || null == t2)
    return function(t3) {
      return a().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? t3 ? Bt.PACKED_2X2_FLOAT32 : Bt.UNPACKED_FLOAT32 : t3 ? Bt.PACKED_2X2_FLOAT16 : Bt.UNPACKED_FLOAT16;
    }(e2);
  if (t2 === Mt.DOWNLOAD || t2 === Mt.PIXELS)
    return Bt.PACKED_4X1_UNSIGNED_BYTE;
  throw new Error("Unknown logical texture type " + t2);
}
function nu(t2, e2, n2) {
  return t2[0] + "_" + t2[1] + "_" + e2 + "_" + n2;
}
var ru = function() {
  return function(t2, e2) {
    this.variableNames = ["A"];
    for (var n2 = new Array(t2.length), r2 = 0; r2 < n2.length; r2++)
      n2[r2] = t2[r2] * e2[r2];
    this.outputShape = n2, this.rank = n2.length;
    var o2 = aa(this.rank), a2 = function(t3) {
      var e3 = t3.length;
      if (e3 > 5)
        throw Error("Tile for rank " + e3 + " is not yet supported");
      if (1 === e3)
        return "imod(resRC, " + t3[0] + ")";
      for (var n3 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], r3 = [], o3 = 0; o3 < t3.length; o3++)
        r3.push("imod(" + n3[o3] + ", " + t3[o3] + ")");
      return r3.join();
    }(t2);
    this.userCode = "\n      void main() {\n        " + o2 + " resRC = getOutputCoords();\n        setOutput(getA(" + a2 + "));\n      }\n    ";
  };
}();
var ou = function() {
  return function(t2, e2) {
    this.variableNames = ["A"];
    for (var n2 = new Array(t2.length), r2 = 0; r2 < n2.length; r2++)
      n2[r2] = t2[e2[r2]];
    this.outputShape = n2, this.rank = n2.length;
    var o2 = aa(this.rank), a2 = function(t3) {
      var e3 = t3.length;
      if (e3 > 6)
        throw Error("Transpose for rank " + e3 + " is not yet supported");
      for (var n3 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], r3 = new Array(e3), o3 = 0; o3 < t3.length; o3++)
        r3[t3[o3]] = n3[o3];
      return r3.join();
    }(e2);
    this.userCode = "\n    void main() {\n      " + o2 + " resRC = getOutputCoords();\n      setOutput(getA(" + a2 + "));\n    }\n    ";
  };
}();
var au = function() {
  return function(t2, e2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true;
    for (var n2 = new Array(t2.length), r2 = 0; r2 < n2.length; r2++)
      n2[r2] = t2[e2[r2]];
    if (this.outputShape = n2, this.rank = n2.length, this.rank > 6)
      throw Error("Packed transpose for rank " + this.rank + " is not yet supported.");
    var o2 = aa(this.rank), a2 = Ho("rc", this.rank), i2 = new Array(this.rank);
    for (r2 = 0; r2 < e2.length; r2++)
      i2[e2[r2]] = a2[r2];
    var u2 = "vec2(" + i2.slice(-2).join() + ")", s2 = "++" + a2[this.rank - 1] + " < " + n2[this.rank - 1], c2 = "getChannel(getA(" + i2.join() + "), " + u2 + ")";
    this.userCode = "\n    void main() {\n      " + o2 + " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = " + c2 + ";\n      if(" + s2 + ") {\n        result[1] = " + c2 + ";\n      }\n      --" + a2[this.rank - 1] + ";\n      if(++" + a2[this.rank - 2] + " < " + n2[this.rank - 2] + ") {\n        result[2] = " + c2 + ";\n        if(" + s2 + ") {\n          result[3] = " + c2 + ";\n        }\n      }\n      setOutput(result);\n    }\n    ";
  };
}();
var iu = 1.7580993408473768;
var uu = 1.0507009873554805;
var su = function() {
  return function(t2, e2) {
    this.variableNames = ["A"], this.outputShape = t2, this.userCode = "\n      float unaryOperation(float x) {\n        " + e2 + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
  };
}();
var cu = "if (isnan(x)) return x;";
var lu = "return x;";
var hu = "return abs(x);";
var fu = cu + "\n  return (x < 0.0) ? 0.0 : x;\n";
var pu = cu + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";
var du = "return (x >= 0.0) ? x : (exp(x) - 1.0);";
var vu = "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = " + iu + ";\n  float scale = " + uu + ";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";
var mu = "return -x;";
var gu = "return ceil(x);";
var yu = "return floor(x);";
var xu = "return exp(x);";
var bu = "return exp(x) - 1.0;";
var wu = cu + "\n  return sin(x);\n";
var Cu = cu + "\n  return cos(x);\n";
var Eu = cu + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n";
var Ru = cu + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n";
var Iu = cu + "\n  return atan(x);\n";
var ku = cu + "return log(x + sqrt(x * x + 1.0));";
var Su = cu + "\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));";
var Au = cu + "\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;";
var Du = "return x;";
var Tu = "return x;";
var Nu = "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";
var Fu = "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";
var Ou = "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n";
var _u = function() {
  return function(t2, e2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t2, this.userCode = "\n      vec4 unaryOperation(vec4 x) {\n        " + e2 + "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
  };
}();
var Mu = function() {
  return function(t2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outputShape = t2;
    var e2 = t2.length, n2 = qo("rc", e2), r2 = aa(e2), o2 = function(t3, e3) {
      if (1 === t3)
        return "rc";
      for (var n3 = "", r3 = 0; r3 < t3; r3++)
        n3 += e3[r3], r3 < t3 - 1 && (n3 += ",");
      return n3;
    }(e2, n2), a2 = n2.slice(-2), i2 = e2 <= 1 ? "rc" : "vec2(" + a2.join(",") + ")";
    this.userCode = "\n      void main() {\n        " + r2 + " rc = getOutputCoords();\n        vec4 packedInput = getA(" + o2 + ");\n\n        setOutput(getChannel(packedInput, " + i2 + "));\n      }\n    ";
  };
}();
var Bu = {};
function Pu(t2, e2) {
  if (void 0 === e2 && (e2 = false), "linear" === t2)
    return e2 ? Tu : lu;
  if ("relu" === t2)
    return e2 ? Nu : fu;
  if ("elu" === t2)
    return e2 ? Ou : du;
  if ("relu6" === t2)
    return e2 ? Fu : pu;
  if ("prelu" === t2)
    return e2 ? wa : xa;
  throw new Error("Activation " + t2 + " has not been implemented for the WebGL backend.");
}
var Lu = 600;
var Wu = function(t2) {
  function o2(e2) {
    var n2, r2 = t2.call(this) || this;
    if (r2.gpgpu = e2, r2.pendingRead = new WeakMap(), r2.pendingDisposal = new WeakSet(), r2.dataRefCount = new WeakMap(), r2.numBytesInGPU = 0, r2.uploadWaitMs = 0, r2.downloadWaitMs = 0, r2.warnedAboutMemory = false, r2.pendingDeletes = 0, r2.disposed = false, !a().getBool("HAS_WEBGL"))
      throw new Error("WebGL is not supported on this device");
    if (null == e2) {
      var o3 = Ut(a().getNumber("WEBGL_VERSION"));
      r2.binaryCache = (n2 = a().getNumber("WEBGL_VERSION")) in Bu ? Bu[n2] : (Bu[n2] = {}, Bu[n2]), r2.gpgpu = new Ci(o3), r2.canvas = o3.canvas, r2.gpgpuCreatedLocally = true;
    } else
      r2.binaryCache = {}, r2.gpgpuCreatedLocally = false, r2.canvas = e2.gl.canvas;
    return r2.textureManager = new tu(r2.gpgpu), r2.numMBBeforeWarning = null == a().global.screen ? 1024 : a().global.screen.height * a().global.screen.width * window.devicePixelRatio * Lu / 1024 / 1024, r2.texData = new so(r2, Nt), r2;
  }
  return e(o2, t2), o2.prototype.numDataIds = function() {
    return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes;
  }, o2.prototype.fromPixels = function(t3, e2) {
    if (null == t3)
      throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
    var n2 = "undefined" != typeof OffscreenCanvas && t3 instanceof OffscreenCanvas || "undefined" != typeof HTMLCanvasElement && t3 instanceof HTMLCanvasElement, r2 = t3.data instanceof Uint8Array, o3 = "undefined" != typeof ImageData && t3 instanceof ImageData, i2 = "undefined" != typeof HTMLVideoElement && t3 instanceof HTMLVideoElement, u2 = "undefined" != typeof HTMLImageElement && t3 instanceof HTMLImageElement, s2 = i2 ? [t3.videoWidth, t3.videoHeight] : [t3.width, t3.height], c2 = s2[0], l2 = s2[1], h2 = [l2, c2], f2 = [l2, c2, e2];
    if (!(n2 || r2 || o3 || i2 || u2))
      throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was " + t3.constructor.name);
    (u2 || i2) && (null == this.fromPixels2DContext && (this.fromPixels2DContext = Vt(a().getNumber("WEBGL_VERSION")).getContext("2d")), this.fromPixels2DContext.canvas.width = c2, this.fromPixels2DContext.canvas.height = l2, this.fromPixels2DContext.drawImage(t3, 0, 0, c2, l2), t3 = this.fromPixels2DContext.canvas);
    var p2, d2, v2 = this.makeTensorInfo(h2, "int32");
    return this.texData.get(v2.dataId).usage = Mt.PIXELS, this.gpgpu.uploadPixelDataToTexture(this.getTexture(v2.dataId), t3), a().getBool("WEBGL_PACK") ? (p2 = new ei(f2), d2 = this.compileAndRun(p2, [v2])) : (p2 = new ti(f2), d2 = this.compileAndRun(p2, [v2])), this.disposeData(v2.dataId), d2;
  }, o2.prototype.write = function(t3, e2, n2) {
    if (a().getBool("DEBUG") && this.checkNumericalProblems(t3), "complex64" === n2 && null != t3)
      throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    var r2 = {};
    return this.texData.set(r2, {shape: e2, dtype: n2, values: t3, usage: Mt.UPLOAD}), r2;
  }, o2.prototype.move = function(t3, e2, n2, r2) {
    if (a().getBool("DEBUG") && this.checkNumericalProblems(e2), "complex64" === r2)
      throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    this.texData.set(t3, {shape: n2, dtype: r2, values: e2, usage: Mt.UPLOAD});
  }, o2.prototype.readSync = function(t3) {
    var e2 = this.texData.get(t3), n2 = e2.values, r2 = e2.dtype, o3 = e2.complexTensors, a2 = e2.slice, i2 = e2.shape, u2 = e2.isPacked;
    if (null != a2) {
      var s2 = void 0;
      s2 = u2 ? new _u(i2, Du) : new su(i2, Du);
      var c2 = this.runWebGLProgram(s2, [{dataId: t3, shape: i2, dtype: r2}], r2), l2 = this.readSync(c2.dataId);
      return this.disposeData(c2.dataId), l2;
    }
    if (null != n2)
      return this.convertAndCacheOnCPU(t3);
    if ("string" === r2)
      return n2;
    var h2, f2, p2 = null != this.activeTimers;
    (p2 && (h2 = Y()), "complex64" === r2) ? f2 = No(o3.real.dataSync(), o3.imag.dataSync()) : f2 = this.getValuesFromTexture(t3);
    return p2 && (this.downloadWaitMs += Y() - h2), this.convertAndCacheOnCPU(t3, f2);
  }, o2.prototype.read = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2, o3, i2, u2, s2, c2, l2, h2, f2, p2, d2, v2, m2, g2, y2, x2, b2, C2, E2, R2, I2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (this.pendingRead.has(t3))
              return e2 = this.pendingRead.get(t3), [2, new Promise(function(t4) {
                return e2.push(t4);
              })];
            if (n2 = this.texData.get(t3), o3 = n2.values, i2 = n2.shape, u2 = n2.slice, s2 = n2.dtype, c2 = n2.complexTensors, l2 = n2.isPacked, null != u2)
              return h2 = void 0, h2 = l2 ? new _u(i2, Du) : new su(i2, Du), f2 = this.runWebGLProgram(h2, [{dataId: t3, shape: i2, dtype: s2}], s2), p2 = this.read(f2.dataId), this.disposeData(f2.dataId), [2, p2];
            if (null != o3)
              return [2, this.convertAndCacheOnCPU(t3)];
            if (!a().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && 2 === a().getNumber("WEBGL_VERSION"))
              throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
            return d2 = null, "complex64" !== s2 && a().get("WEBGL_BUFFER_SUPPORTED") && (v2 = this.decode(t3), m2 = this.texData.get(v2.dataId), d2 = (I2 = this.gpgpu).createBufferFromTexture.apply(I2, [m2.texture].concat(Gt(i2)))), this.pendingRead.set(t3, []), "complex64" === s2 ? [3, 2] : [4, this.gpgpu.createAndWaitForFence()];
          case 1:
            r2.sent(), r2.label = 2;
          case 2:
            return "complex64" !== s2 ? [3, 4] : [4, Promise.all([c2.real.data(), c2.imag.data()])];
          case 3:
            return y2 = r2.sent(), x2 = y2[0], b2 = y2[1], g2 = No(x2, b2), [3, 5];
          case 4:
            null == d2 ? g2 = this.getValuesFromTexture(t3) : (C2 = w(i2), g2 = this.gpgpu.downloadFloat32MatrixFromBuffer(d2, C2)), r2.label = 5;
          case 5:
            return null != v2 && this.disposeData(v2.dataId), E2 = this.convertAndCacheOnCPU(t3, g2), R2 = this.pendingRead.get(t3), this.pendingRead.delete(t3), R2.forEach(function(t4) {
              return t4(E2);
            }), this.pendingDisposal.has(t3) && (this.pendingDisposal.delete(t3), this.disposeData(t3), this.pendingDeletes--), [2, E2];
        }
      });
    });
  }, o2.prototype.checkNumericalProblems = function(t3) {
    if (null != t3)
      for (var e2 = 0; e2 < t3.length; e2++) {
        var n2 = t3[e2];
        if (!$t(n2)) {
          if (a().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))
            throw Error("The value " + n2 + " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");
          throw Error("The value " + n2 + " cannot be represented on this device.");
        }
      }
  }, o2.prototype.getValuesFromTexture = function(t3) {
    var e2, n2 = this.texData.get(t3), r2 = n2.shape, o3 = n2.dtype, i2 = n2.isPacked, u2 = w(r2);
    if (a().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
      var s2 = this.decode(t3), c2 = this.texData.get(s2.dataId), l2 = (e2 = this.gpgpu).downloadMatrixFromPackedTexture.apply(e2, [c2.texture].concat(Gt(r2))).subarray(0, u2);
      return this.disposeData(s2.dataId), l2;
    }
    var h2 = a().getBool("WEBGL_PACK") && true === i2, f2 = h2 ? Re(r2) : r2, p2 = h2 ? new ja(f2) : new Ka(f2), d2 = this.runWebGLProgram(p2, [{shape: f2, dtype: o3, dataId: t3}], "float32"), v2 = this.texData.get(d2.dataId), m2 = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(v2.texture, v2.texShape[0], v2.texShape[1]).subarray(0, u2);
    return this.disposeData(d2.dataId), m2;
  }, o2.prototype.time = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2, o3, a2, i2, u2, s2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            return e2 = this.activeTimers, n2 = [], o3 = false, null == this.programTimersStack ? (this.programTimersStack = n2, o3 = true) : this.activeTimers.push(n2), this.activeTimers = n2, t3(), a2 = b(this.activeTimers.map(function(t4) {
              return t4.query;
            })).filter(function(t4) {
              return null != t4;
            }), i2 = b(this.activeTimers.map(function(t4) {
              return t4.name;
            })).filter(function(t4) {
              return null != t4;
            }), this.activeTimers = e2, o3 && (this.programTimersStack = null), [4, Promise.all(a2)];
          case 1:
            return u2 = r2.sent(), s2 = {uploadWaitMs: this.uploadWaitMs, downloadWaitMs: this.downloadWaitMs, kernelMs: m(u2), getExtraProfileInfo: function() {
              return u2.map(function(t4, e3) {
                return {name: i2[e3], ms: t4};
              }).map(function(t4) {
                return t4.name + ": " + t4.ms;
              }).join(", ");
            }, wallMs: null}, this.uploadWaitMs = 0, this.downloadWaitMs = 0, [2, s2];
        }
      });
    });
  }, o2.prototype.memory = function() {
    return {unreliable: false, numBytesInGPU: this.numBytesInGPU};
  }, o2.prototype.startTimer = function() {
    return a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? this.gpgpu.beginQuery() : {startMs: Y(), endMs: null};
  }, o2.prototype.endTimer = function(t3) {
    return a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (this.gpgpu.endQuery(), t3) : (t3.endMs = Y(), t3);
  }, o2.prototype.getQueryTime = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2;
      return r(this, function(n2) {
        return a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? [2, this.gpgpu.waitForQueryAndGetTime(t3)] : [2, (e2 = t3).endMs - e2.startMs];
      });
    });
  }, o2.prototype.disposeData = function(t3) {
    if (!this.pendingDisposal.has(t3)) {
      if (this.pendingRead.has(t3))
        return this.pendingDisposal.add(t3), void this.pendingDeletes++;
      if (this.texData.has(t3)) {
        this.releaseGPUData(t3);
        var e2 = this.texData.get(t3).complexTensors;
        null != e2 && (e2.real.dispose(), e2.imag.dispose()), this.texData.delete(t3);
      }
    }
  }, o2.prototype.releaseGPUData = function(t3) {
    var e2 = this.texData.get(t3), n2 = e2.texture, r2 = e2.dtype, o3 = e2.texShape, a2 = e2.usage, i2 = e2.isPacked, u2 = e2.slice, s2 = u2 && u2.origDataId || t3, c2 = this.dataRefCount.get(s2);
    c2 > 1 ? this.dataRefCount.set(s2, c2 - 1) : (this.dataRefCount.delete(s2), null != n2 && (this.numBytesInGPU -= this.computeBytes(o3, r2), this.textureManager.releaseTexture(n2, o3, a2, i2)));
    var l2 = this.texData.get(t3);
    l2.texture = null, l2.texShape = null, l2.isPacked = false, l2.slice = null;
  }, o2.prototype.getTexture = function(t3) {
    return this.uploadToGPU(t3), this.texData.get(t3).texture;
  }, o2.prototype.getDataInfo = function(t3) {
    return this.texData.get(t3);
  }, o2.prototype.getCPUBackend = function() {
    return a().getBool("WEBGL_CPU_FORWARD") ? (null == this.cpuBackend && (this.cpuBackend = Nt.findBackend("cpu")), this.cpuBackend) : null;
  }, o2.prototype.shouldExecuteOnCPU = function(t3, e2) {
    var n2 = this;
    return void 0 === e2 && (e2 = 128), null != this.getCPUBackend() && t3.every(function(t4) {
      return null == n2.texData.get(t4.dataId).texture && t4.size < e2;
    });
  }, o2.prototype.getGPGPUContext = function() {
    return this.gpgpu;
  }, o2.prototype.complex = function(t3, e2) {
    var n2 = this.makeOutput(t3.shape, "complex64");
    return this.texData.get(n2.dataId).complexTensors = {real: Nt.keep(t3.clone()), imag: Nt.keep(e2.clone())}, n2;
  }, o2.prototype.real = function(t3) {
    return this.texData.get(t3.dataId).complexTensors.real.clone();
  }, o2.prototype.imag = function(t3) {
    return this.texData.get(t3.dataId).complexTensors.imag.clone();
  }, o2.prototype.slice = function(t3, e2, n2) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.slice(t3, e2, n2);
    if (0 === w(n2))
      return kn([], n2, t3.dtype);
    var r2 = this.texData.get(t3.dataId).isPacked, o3 = Yr(t3.shape, e2, n2);
    if (r2 || !o3) {
      var i2 = a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Ji(n2) : new Yi(n2), u2 = i2.getCustomSetupFunc(e2);
      return this.compileAndRun(i2, [t3], null, u2);
    }
    return this.uploadToGPU(t3.dataId), this.shallowSlice(t3, e2, n2);
  }, o2.prototype.shallowSlice = function(t3, e2, n2) {
    var r2 = this.texData.get(t3.dataId), o3 = this.makeOutput(n2, t3.dtype), a2 = this.texData.get(o3.dataId);
    Object.assign(a2, r2), a2.shape = n2, a2.dtype = t3.dtype;
    var i2 = Qr(e2, t3.strides);
    r2.slice && (i2 += r2.slice.flatOffset), a2.slice = {flatOffset: i2, origDataId: r2.slice && r2.slice.origDataId || t3.dataId};
    var u2 = this.dataRefCount.get(a2.slice.origDataId) || 1;
    return this.dataRefCount.set(a2.slice.origDataId, u2 + 1), o3;
  }, o2.prototype.stridedSlice = function(t3, e2, n2, r2) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.stridedSlice(t3, e2, n2, r2);
    var o3 = jr(e2, n2, r2);
    if (o3.some(function(t4) {
      return 0 === t4;
    }))
      return kn([], o3);
    var a2 = new Zi(e2, r2, o3);
    return this.compileAndRun(a2, [t3]);
  }, o2.prototype.reverse = function(t3, e2) {
    var n2 = a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Ki(t3.shape, e2) : new qi(t3.shape, e2);
    return this.compileAndRun(n2, [t3]);
  }, o2.prototype.concat = function(t3, e2) {
    if ("complex64" === t3[0].dtype) {
      var n2 = t3.map(function(t4) {
        return Rn(t4);
      }), r2 = t3.map(function(t4) {
        return In(t4);
      });
      return En(this.concat(n2, e2), this.concat(r2, e2));
    }
    if (this.shouldExecuteOnCPU(t3))
      return this.cpuBackend.concat(t3, e2);
    if (1 === t3.length)
      return t3[0];
    if (t3.length > a().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      var o3 = Math.floor(t3.length / 2), i2 = this.concat(t3.slice(0, o3), e2), u2 = this.concat(t3.slice(o3), e2);
      return this.concat([i2, u2], e2);
    }
    if (a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && t3[0].rank > 1) {
      var s2 = new Sa(t3.map(function(t4) {
        return t4.shape;
      }), e2);
      return this.compileAndRun(s2, t3);
    }
    var c2 = wn(t3.map(function(t4) {
      return t4.shape;
    }), e2), l2 = t3.map(function(t4) {
      return t4.as2D(-1, w(t4.shape.slice(e2)));
    }), h2 = new ka(l2.map(function(t4) {
      return t4.shape;
    }));
    return this.compileAndRun(h2, l2).reshape(c2);
  }, o2.prototype.neg = function(t3) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.neg(t3);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
      return this.packedUnaryOp(t3, mu, t3.dtype);
    var e2 = new su(t3.shape, mu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.batchMatMul = function(t3, e2, n2, r2) {
    var o3 = n2 ? t3.shape[2] : t3.shape[1], a2 = r2 ? e2.shape[1] : e2.shape[2], i2 = n2 ? t3.shape[1] : t3.shape[2], u2 = t3.shape[0];
    if ((1 === o3 || 1 === a2) && i2 > 1e3) {
      n2 && (t3 = t3.transpose([0, 2, 1])), r2 && (e2 = e2.transpose([0, 2, 1]));
      var s2 = 1 === a2 ? t3 : t3.as3D(u2, i2, 1), c2 = 1 === a2 ? 2 : 1, l2 = 1 === a2 ? e2.as3D(u2, 1, i2) : e2;
      return this.multiply(s2, l2).sum(c2, true);
    }
    var h2 = Ct(t3.dtype, e2.dtype), f2 = new Ti(t3.shape, [u2, o3, a2], n2, r2);
    return this.compileAndRun(f2, [t3, e2], h2);
  }, o2.prototype.fusedBatchMatMul = function(t3) {
    var e2 = t3.a, n2 = t3.b, r2 = t3.transposeA, o3 = t3.transposeB, a2 = t3.bias, i2 = t3.activation, u2 = t3.preluActivationWeights, s2 = r2 ? e2.shape[2] : e2.shape[1], c2 = o3 ? n2.shape[1] : n2.shape[2], l2 = e2.shape[0], h2 = Ct(e2.dtype, n2.dtype), f2 = null != a2, p2 = null != u2, d2 = i2 ? Pu(i2, true) : null, v2 = new Ti(e2.shape, [l2, s2, c2], r2, o3, f2, d2, p2), m2 = [e2, n2];
    return a2 && m2.push(a2), u2 && m2.push(u2), this.compileAndRun(v2, m2, h2);
  }, o2.prototype.multiply = function(t3, e2) {
    if ("complex64" === t3.dtype) {
      var n2 = this.texData.get(t3.dataId), r2 = this.texData.get(e2.dataId), o3 = new va(pa, t3.shape, e2.shape), i2 = new va(da, t3.shape, e2.shape), u2 = [this.makeComplexComponentTensorInfo(t3, n2.complexTensors.real), this.makeComplexComponentTensorInfo(t3, n2.complexTensors.imag), this.makeComplexComponentTensorInfo(e2, r2.complexTensors.real), this.makeComplexComponentTensorInfo(e2, r2.complexTensors.imag)], s2 = this.compileAndRun(o3, u2), c2 = this.compileAndRun(i2, u2), l2 = this.complex(s2, c2);
      return s2.dispose(), c2.dispose(), l2;
    }
    if (this.shouldExecuteOnCPU([t3, e2]))
      return this.cpuBackend.multiply(t3, e2);
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, ya, t3.dtype);
    var h2 = new ba(ya, t3.shape, e2.shape);
    return this.compileAndRun(h2, [t3, e2], t3.dtype);
  }, o2.prototype.batchNormalization = function(t3, e2, n2, r2, o3, i2) {
    var u2 = [t3, e2, n2], s2 = null;
    null != i2 && (s2 = i2.shape, u2.push(i2));
    var c2 = null;
    if (null != o3 && (c2 = o3.shape, u2.push(o3)), a().getBool("WEBGL_PACK_NORMALIZATION")) {
      var l2 = new fa(t3.shape, e2.shape, n2.shape, s2, c2, r2);
      return this.compileAndRun(l2, u2);
    }
    var h2 = new ha(t3.shape, e2.shape, n2.shape, s2, c2, r2);
    return this.compileAndRun(h2, u2);
  }, o2.prototype.localResponseNormalization4D = function(t3, e2, n2, r2, o3) {
    var i2 = a().getBool("WEBGL_PACK_NORMALIZATION") ? new Si(t3.shape, e2, n2, r2, o3) : new Ii(t3.shape, e2, n2, r2, o3);
    return this.compileAndRun(i2, [t3]);
  }, o2.prototype.LRNGrad = function(t3, e2, n2, r2, o3, a2, i2) {
    var u2 = new ki(e2.shape, r2, o3, a2, i2);
    return this.compileAndRun(u2, [e2, n2, t3]);
  }, o2.prototype.tile = function(t3, e2) {
    if ("string" === t3.dtype) {
      var n2 = this.readSync(t3.dataId).map(function(t4) {
        return Z(t4);
      });
      return Lo(ur(t3.shape, t3.dtype, n2), e2);
    }
    var r2 = new ru(t3.shape, e2);
    return this.compileAndRun(r2, [t3]);
  }, o2.prototype.pad = function(t3, e2, n2) {
    var r2 = a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Mi(t3.shape, e2, n2) : new _i(t3.shape, e2, n2);
    return this.compileAndRun(r2, [t3]);
  }, o2.prototype.transpose = function(t3, e2) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.transpose(t3, e2);
    var n2 = a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new au(t3.shape, e2) : new ou(t3.shape, e2);
    return this.compileAndRun(n2, [t3]);
  }, o2.prototype.gather = function(t3, e2, n2) {
    if (this.shouldExecuteOnCPU([t3, e2]))
      return this.cpuBackend.gather(t3, e2, n2);
    var r2 = new ni(t3.shape, e2.size, n2);
    return this.compileAndRun(r2, [t3, e2]);
  }, o2.prototype.batchToSpaceND = function(t3, e2, n2) {
    g(t3.rank <= 4, function() {
      return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet";
    });
    var r2 = e2.reduce(function(t4, e3) {
      return t4 * e3;
    }), o3 = Mr(t3.shape, e2, r2), a2 = Br(o3.length, e2.length), i2 = Pr(t3.shape, e2, r2), u2 = Lr(n2, e2.length), s2 = Wr(i2, n2, e2.length);
    return t3.reshape(o3).transpose(a2).reshape(i2).slice(u2, s2);
  }, o2.prototype.spaceToBatchND = function(t3, e2, n2) {
    g(t3.rank <= 4, function() {
      return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet";
    });
    var r2 = e2.reduce(function(t4, e3) {
      return t4 * e3;
    }), o3 = [[0, 0]];
    o3.push.apply(o3, n2);
    for (var a2 = 1 + e2.length; a2 < t3.shape.length; ++a2)
      o3.push([0, 0]);
    var i2 = t3.pad(o3), u2 = Mr(i2.shape, e2, r2, false), s2 = Br(u2.length, e2.length, false), c2 = Pr(i2.shape, e2, r2, false);
    return i2.reshape(u2).transpose(s2).reshape(c2);
  }, o2.prototype.reduce = function(t3, e2, n2) {
    var r2 = t3.shape[0], o3 = t3.shape[1], a2 = zr(o3), i2 = new Li({windowSize: a2, inSize: o3, batchSize: r2}, e2), u2 = this.compileAndRun(i2, [t3], n2);
    return 1 === u2.shape[1] ? u2 : this.reduce(u2, e2, n2);
  }, o2.prototype.argReduce = function(t3, e2, n2) {
    void 0 === n2 && (n2 = null);
    var r2 = t3.shape[0], o3 = t3.shape[1];
    null != n2 && (r2 = n2.shape[0], o3 = n2.shape[1]);
    var a2 = zr(o3), i2 = new Go({windowSize: a2, inSize: o3, batchSize: r2}, e2, null == n2), u2 = [t3];
    null != n2 && u2.push(n2);
    var s2 = this.compileAndRun(i2, u2, "int32");
    return 1 === s2.shape[1] ? s2 : this.argReduce(t3, e2, s2);
  }, o2.prototype.argReducePacked = function(t3, e2, n2) {
    void 0 === n2 && (n2 = null);
    var r2 = null != n2 ? n2.shape : t3.shape, o3 = zr(r2[r2.length - 1]), a2 = new sa(r2, o3, e2, null == n2), i2 = null == n2 ? [t3] : [t3, n2], u2 = this.compileAndRun(a2, i2, "int32");
    return u2.rank === t3.rank ? this.argReducePacked(t3, e2, u2) : u2;
  }, o2.prototype.sum = function(t3, e2) {
    mn("sum", e2, t3.rank);
    var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = w(n2[1]), a2 = t3.as2D(-1, o3), i2 = Et(t3.dtype);
    return this.reduce(a2, "sum", i2).reshape(r2);
  }, o2.prototype.prod = function(t3, e2) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.prod(t3, e2);
    var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = w(n2[1]), a2 = t3.as2D(-1, o3), i2 = Et(t3.dtype);
    return this.reduce(a2, "prod", i2).reshape(r2);
  }, o2.prototype.unsortedSegmentSum = function(t3, e2, n2) {
    var r2 = 0, o3 = gn([r2], t3.rank), a2 = t3;
    null != o3 && (a2 = t3.transpose(o3), r2 = xn(1, t3.rank)[0]);
    var i2 = function(t4, e3, n3) {
      for (var r3 = [], o4 = t4.length, a3 = 0; a3 < o4; a3++)
        a3 !== e3 ? r3.push(t4[a3]) : r3.push(n3);
      return r3;
    }(a2.shape, r2, n2), u2 = w([a2.shape[r2]]), s2 = a2.as2D(-1, u2), c2 = Et(t3.dtype), l2 = this.segOpCompute(s2, "unsortedSegmentSum", e2, c2, n2).reshape(i2);
    return null != o3 && (l2 = l2.transpose(yn(o3))), l2;
  }, o2.prototype.segOpCompute = function(t3, e2, n2, r2, o3) {
    var a2 = t3.shape[0], i2 = t3.shape[1], u2 = function(t4, e3) {
      var n3, r3 = false;
      for (t4 <= Vr ? (n3 = t4, r3 = true) : n3 = H(t4, Math.floor(Math.sqrt(t4))); !r3; )
        n3 > e3 || n3 === t4 ? r3 = true : n3 = H(t4, n3 + 1);
      return n3;
    }(i2, o3), s2 = new Xi({windowSize: u2, inSize: i2, batchSize: a2, numSegments: o3}, e2), c2 = this.compileAndRun(s2, [t3, n2], r2);
    return c2.shape[1] === o3 ? c2 : (n2 = Un(0, o3).tile([i2 / u2]), this.segOpCompute(c2, e2, n2, r2, o3));
  }, o2.prototype.argMinMaxReduce = function(t3, e2, n2) {
    var r2 = [e2];
    if (mn("arg" + n2.charAt(0).toUpperCase() + n2.slice(1), r2, t3.rank), !a().getBool("WEBGL_PACK_REDUCE") || t3.rank <= 2) {
      var o3 = dn(t3.shape, r2), i2 = o3[0], u2 = w(o3[1]), s2 = t3.as2D(-1, u2);
      return this.argReduce(s2, n2).reshape(i2);
    }
    return this.argReducePacked(t3, n2);
  }, o2.prototype.argMin = function(t3, e2) {
    return this.argMinMaxReduce(t3, e2, "min");
  }, o2.prototype.argMax = function(t3, e2) {
    return this.argMinMaxReduce(t3, e2, "max");
  }, o2.prototype.cumsum = function(t3, e2, n2, r2) {
    if (e2 !== t3.rank - 1)
      throw new Error("WebGL cumsum shader expects an inner-most axis=" + (t3.rank - 1) + " but got axis=" + e2);
    var o3 = new Ua(t3.shape, n2, r2);
    return this.compileAndRun(o3, [t3]);
  }, o2.prototype.equal = function(t3, e2) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, "\n  return vec4(equal(a, b));\n", "bool");
    var n2 = new ba("return float(a == b);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "bool");
  }, o2.prototype.notEqual = function(t3, e2) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, "\n  return vec4(notEqual(a, b));\n", "bool");
    var n2 = new ba("return float(a != b);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "bool");
  }, o2.prototype.less = function(t3, e2) {
    if (this.shouldExecuteOnCPU([t3, e2]))
      return this.cpuBackend.less(t3, e2);
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, "\n  return vec4(lessThan(a, b));\n", "bool");
    var n2 = new ba("return float(a < b);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "bool");
  }, o2.prototype.lessEqual = function(t3, e2) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, "\n  return vec4(lessThanEqual(a, b));\n", "bool");
    var n2 = new ba("return float(a <= b);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "bool");
  }, o2.prototype.greater = function(t3, e2) {
    if (this.shouldExecuteOnCPU([t3, e2]))
      return this.cpuBackend.greater(t3, e2);
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, "\n  return vec4(greaterThan(a, b));\n", "bool");
    var n2 = new ba("return float(a > b);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "bool");
  }, o2.prototype.greaterEqual = function(t3, e2) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, "\n  return vec4(greaterThanEqual(a, b));\n", "bool");
    var n2 = new ba("return float(a >= b);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "bool");
  }, o2.prototype.logicalNot = function(t3) {
    var e2 = new su(t3.shape, "return float(!(x >= 1.0));");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.logicalAnd = function(t3, e2) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n", "bool");
    var n2 = new ba("return float(a >= 1.0 && b >= 1.0);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "bool");
  }, o2.prototype.logicalOr = function(t3, e2) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n", "bool");
    var n2 = new ba("return float(a >= 1.0 || b >= 1.0);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "bool");
  }, o2.prototype.select = function(t3, e2, n2) {
    var r2 = new $i(t3.rank, e2.shape, e2.rank);
    return this.compileAndRun(r2, [t3, e2, n2], Ct(e2.dtype, n2.dtype));
  }, o2.prototype.where = function(t3) {
    un("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
    var e2 = t3.dataSync();
    return Uo(t3.shape, e2);
  }, o2.prototype.topk = function(t3, e2, n2) {
    return Wo(t3.dataSync(), t3.shape, t3.dtype, e2);
  }, o2.prototype.min = function(t3, e2) {
    mn("min", e2, t3.rank);
    var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = w(n2[1]), a2 = t3.as2D(-1, o3);
    return this.reduce(a2, "min", a2.dtype).reshape(r2);
  }, o2.prototype.minimum = function(t3, e2) {
    if (this.shouldExecuteOnCPU([t3, e2]))
      return this.cpuBackend.minimum(t3, e2);
    var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t3.shape, e2.shape) : new ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2]);
  }, o2.prototype.mod = function(t3, e2) {
    var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t3.shape, e2.shape) : new ba("if (b == 0.0) return NAN;\n  return mod(a, b);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2]);
  }, o2.prototype.max = function(t3, e2) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.max(t3, e2);
    mn("max", e2, t3.rank);
    var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = w(n2[1]), a2 = t3.as2D(-1, o3);
    return this.reduce(a2, "max", a2.dtype).reshape(r2);
  }, o2.prototype.maximum = function(t3, e2) {
    if (this.shouldExecuteOnCPU([t3, e2]))
      return this.cpuBackend.maximum(t3, e2);
    var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t3.shape, e2.shape) : new ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2]);
  }, o2.prototype.all = function(t3, e2) {
    mn("all", e2, t3.rank);
    var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = w(n2[1]), a2 = t3.as2D(-1, o3);
    return this.reduce(a2, "all", a2.dtype).reshape(r2);
  }, o2.prototype.any = function(t3, e2) {
    mn("any", e2, t3.rank);
    var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = w(n2[1]), a2 = t3.as2D(-1, o3);
    return this.reduce(a2, "any", a2.dtype).reshape(r2);
  }, o2.prototype.squaredDifference = function(t3, e2) {
    var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("return (a - b) * (a - b);", t3.shape, e2.shape) : new ba("return (a - b) * (a - b);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2]);
  }, o2.prototype.realDivide = function(t3, e2) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
      return this.packedBinaryOp(t3, e2, "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n", "float32", true);
    }
    var n2 = new ba("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "float32");
  }, o2.prototype.floorDiv = function(t3, e2) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n", "int32");
    var n2 = new ba("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "int32");
  }, o2.prototype.add = function(t3, e2) {
    if ("complex64" === t3.dtype && "complex64" === e2.dtype)
      return this.complexSeparableBinaryOp(t3, e2, ma);
    if (this.shouldExecuteOnCPU([t3, e2]))
      return this.cpuBackend.add(t3, e2);
    var n2 = Ct(t3.dtype, e2.dtype);
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, ma, n2);
    var r2 = new ba(ma, t3.shape, e2.shape);
    return this.compileAndRun(r2, [t3, e2], n2);
  }, o2.prototype.packedUnaryOp = function(t3, e2, n2) {
    var r2 = new _u(t3.shape, e2);
    return this.compileAndRun(r2, [t3], n2);
  }, o2.prototype.packedBinaryOp = function(t3, e2, n2, r2, o3) {
    void 0 === o3 && (o3 = false);
    var a2 = new Ca(n2, t3.shape, e2.shape, o3);
    return this.compileAndRun(a2, [t3, e2], r2);
  }, o2.prototype.complexSeparableBinaryOp = function(t3, e2, n2) {
    var r2 = this, o3 = this.texData.get(t3.dataId), a2 = this.texData.get(e2.dataId), i2 = [[o3.complexTensors.real, a2.complexTensors.real], [o3.complexTensors.imag, a2.complexTensors.imag]].map(function(o4) {
      var a3 = o4[0], i3 = o4[1], u3 = r2.makeComplexComponentTensorInfo(t3, a3), s3 = r2.makeComplexComponentTensorInfo(e2, i3), c3 = new ba(n2, t3.shape, e2.shape);
      return r2.compileAndRun(c3, [u3, s3], Ct(a3.dtype, i3.dtype));
    }), u2 = i2[0], s2 = i2[1], c2 = this.complex(u2, s2);
    return u2.dispose(), s2.dispose(), c2;
  }, o2.prototype.makeComplexComponentTensorInfo = function(t3, e2) {
    return {dataId: e2.dataId, dtype: e2.dtype, shape: t3.shape};
  }, o2.prototype.addN = function(t3) {
    if (1 === t3.length)
      return t3[0];
    if (t3.length > a().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      var e2 = Math.floor(t3.length / 2), n2 = this.addN(t3.slice(0, e2)), r2 = this.addN(t3.slice(e2));
      return this.addN([n2, r2]);
    }
    var o3 = t3.map(function(t4) {
      return t4.dtype;
    }).reduce(function(t4, e3) {
      return Ct(t4, e3);
    }), i2 = t3.map(function(t4) {
      return t4.shape;
    }), u2 = a().getBool("WEBGL_PACK") ? new zo(t3[0].shape, i2) : new Vo(t3[0].shape, i2);
    return this.compileAndRun(u2, t3, o3);
  }, o2.prototype.subtract = function(t3, e2) {
    if ("complex64" === t3.dtype && "complex64" === e2.dtype)
      return this.complexSeparableBinaryOp(t3, e2, ga);
    if (this.shouldExecuteOnCPU([t3, e2]))
      return this.cpuBackend.subtract(t3, e2);
    var n2 = Ct(t3.dtype, e2.dtype);
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, ga, t3.dtype);
    var r2 = new ba(ga, t3.shape, e2.shape);
    return this.compileAndRun(r2, [t3, e2], n2);
  }, o2.prototype.pow = function(t3, e2) {
    var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t3.shape, e2.shape) : new ba("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n", t3.shape, e2.shape), r2 = Ct(t3.dtype, e2.dtype);
    return this.compileAndRun(n2, [t3, e2], r2);
  }, o2.prototype.ceil = function(t3) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.ceil(t3);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
      return this.packedUnaryOp(t3, gu, t3.dtype);
    var e2 = new su(t3.shape, gu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.floor = function(t3) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.floor(t3);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
      return this.packedUnaryOp(t3, yu, t3.dtype);
    var e2 = new su(t3.shape, yu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.sign = function(t3) {
    var e2 = new su(t3.shape, "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.isNaN = function(t3) {
    var e2 = new su(t3.shape, "return float(isnan(x));");
    return this.compileAndRun(e2, [t3], "bool");
  }, o2.prototype.isInf = function(t3) {
    var e2 = new su(t3.shape, "return float(isinf(x));");
    return this.compileAndRun(e2, [t3], "bool");
  }, o2.prototype.isFinite = function(t3) {
    var e2 = new su(t3.shape, "return float(!isnan(x) && !isinf(x));");
    return this.compileAndRun(e2, [t3], "bool");
  }, o2.prototype.round = function(t3) {
    var e2 = new su(t3.shape, "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.exp = function(t3) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.exp(t3);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
      return this.packedUnaryOp(t3, xu, t3.dtype);
    var e2 = new su(t3.shape, xu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.expm1 = function(t3) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.expm1(t3);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
      return this.packedUnaryOp(t3, bu, t3.dtype);
    var e2 = new su(t3.shape, bu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.log = function(t3) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.log(t3);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
      return this.packedUnaryOp(t3, "\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n", t3.dtype);
    var e2 = new su(t3.shape, "if (x < 0.0) return NAN;\n  return log(x);");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.log1p = function(t3) {
    var e2 = new su(t3.shape, "return log(1.0 + x);");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.sqrt = function(t3) {
    var e2 = new su(t3.shape, "return sqrt(x);");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.rsqrt = function(t3) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.rsqrt(t3);
    var e2 = new su(t3.shape, "return inversesqrt(x);");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.reciprocal = function(t3) {
    var e2 = new su(t3.shape, "return 1.0 / x;");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.relu = function(t3) {
    var e2;
    return e2 = a().getBool("WEBGL_PACK") ? new _u(t3.shape, Nu) : new su(t3.shape, fu), this.compileAndRun(e2, [t3]);
  }, o2.prototype.relu6 = function(t3) {
    var e2;
    return e2 = a().getBool("WEBGL_PACK") ? new _u(t3.shape, Fu) : new su(t3.shape, pu), this.compileAndRun(e2, [t3]);
  }, o2.prototype.prelu = function(t3, e2) {
    var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca(wa, t3.shape, e2.shape) : new ba(xa, t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2]);
  }, o2.prototype.elu = function(t3) {
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
      return this.packedUnaryOp(t3, Ou, t3.dtype);
    var e2 = new su(t3.shape, du);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.eluDer = function(t3, e2) {
    var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", t3.shape, e2.shape) : new ba("return (b >= 1.0) ? a : a * (b + 1.0);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2]);
  }, o2.prototype.selu = function(t3) {
    var e2 = new su(t3.shape, vu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.int = function(t3) {
    var e2 = new su(t3.shape, "return float(int(x));");
    return this.compileAndRun(e2, [t3], "int32");
  }, o2.prototype.clip = function(t3, e2, n2) {
    var r2, o3 = (r2 = a().getBool("WEBGL_PACK_CLIP") ? new Ra(t3.shape) : new Ea(t3.shape)).getCustomSetupFunc(e2, n2);
    return this.compileAndRun(r2, [t3], null, o3);
  }, o2.prototype.abs = function(t3) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.abs(t3);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
      return this.packedUnaryOp(t3, hu, t3.dtype);
    var e2 = new su(t3.shape, hu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.complexAbs = function(t3) {
    var e2 = this.texData.get(t3.dataId), n2 = new Ia(t3.shape), r2 = [this.makeComplexComponentTensorInfo(t3, e2.complexTensors.real), this.makeComplexComponentTensorInfo(t3, e2.complexTensors.imag)];
    return this.compileAndRun(n2, r2);
  }, o2.prototype.sigmoid = function(t3) {
    var e2 = new su(t3.shape, "return 1.0 / (1.0 + exp(-1.0 * x));");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.softplus = function(t3) {
    var e2 = new su(t3.shape, "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.sin = function(t3) {
    var e2 = new su(t3.shape, wu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.cos = function(t3) {
    var e2 = new su(t3.shape, Cu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.tan = function(t3) {
    var e2 = new su(t3.shape, "return tan(x);");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.asin = function(t3) {
    var e2 = new su(t3.shape, Eu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.acos = function(t3) {
    var e2 = new su(t3.shape, Ru);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.atan = function(t3) {
    var e2 = new su(t3.shape, Iu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.atan2 = function(t3, e2) {
    var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t3.shape, e2.shape) : new ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2]);
  }, o2.prototype.sinh = function(t3) {
    var e2 = new su(t3.shape, "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.cosh = function(t3) {
    var e2 = new su(t3.shape, "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.tanh = function(t3) {
    var e2 = new su(t3.shape, "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.asinh = function(t3) {
    var e2 = new su(t3.shape, ku);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.acosh = function(t3) {
    var e2 = new su(t3.shape, Su);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.atanh = function(t3) {
    var e2 = new su(t3.shape, Au);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.erf = function(t3) {
    var e2 = new su(t3.shape, '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n');
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.step = function(t3, e2) {
    var n2 = new su(t3.shape, function(t4) {
      return void 0 === t4 && (t4 = 0), cu + "\n    return x > 0.0 ? 1.0 : float(" + t4 + ");\n  ";
    }(e2));
    return this.compileAndRun(n2, [t3]);
  }, o2.prototype.conv2dByMatMul = function(t3, e2, n2, r2, o3, i2) {
    var u2 = t3.shape, s2 = this.texData.get(t3.dataId), c2 = n2.inChannels, l2 = u2[0] * u2[1] * u2[2], h2 = n2.outChannels, f2 = "channelsLast" === n2.dataFormat, p2 = (1 === l2 || 1 === h2) && c2 > 1e3, d2 = u2[2] % 2 != 0 && !!s2.isPacked;
    if (p2 || !a().getBool("WEBGL_LAZILY_UNPACK") || !a().getBool("WEBGL_PACK_BINARY_OPERATIONS") || !d2) {
      var v2 = f2 ? u2[0] * u2[1] * u2[2] : u2[0] * u2[2] * u2[3], m2 = this.reshape(t3, [1, v2, n2.inChannels]), y2 = this.reshape(e2, [1, n2.inChannels, n2.outChannels]);
      return this.reshape(this.fusedBatchMatMul({a: m2, b: y2, transposeA: false, transposeB: false, bias: r2, activation: o3, preluActivationWeights: i2}), n2.outShape);
    }
    var x2 = f2 ? u2[0] * u2[1] * (u2[2] + 1) : u2[0] * u2[2] * (u2[3] + 1), b2 = {dataId: t3.dataId, shape: [1, x2, n2.inChannels], dtype: t3.dtype}, w2 = s2.shape;
    s2.shape = s2.shape.slice(), s2.shape[s2.shape.length - 2]++, g(Se(s2.shape, b2.shape), function() {
      return "packed reshape " + s2.shape + " to " + b2.shape + " isn't free";
    });
    var C2 = this.reshape(e2, [1, n2.inChannels, n2.outChannels]), E2 = this.fusedBatchMatMul({a: b2, b: C2, transposeA: false, transposeB: false, bias: r2, activation: o3, preluActivationWeights: i2}), R2 = this.texData.get(E2.dataId);
    return g(R2.isPacked, function() {
      return "batchMatMul result is expected to be packed";
    }), s2.shape = w2, R2.shape = n2.outShape, Nt.makeTensorFromDataId(E2.dataId, n2.outShape, E2.dtype);
  }, o2.prototype.conv2dWithIm2Row = function(t3, e2, n2, r2, o3, a2) {
    var i2 = n2.filterWidth, u2 = n2.filterHeight, s2 = n2.inChannels, c2 = n2.outWidth, l2 = n2.outHeight, h2 = "channelsLast" === n2.dataFormat, f2 = i2 * u2 * s2, p2 = l2 * c2, d2 = [f2, p2], v2 = t3.squeeze([0]), m2 = e2.reshape([1, f2, -1]), g2 = new Ri(d2, v2.shape, n2), y2 = this.compileAndRun(g2, [v2]).reshape([1, d2[0], d2[1]]), x2 = null != r2, b2 = null != a2, w2 = o3 ? Pu(o3, true) : null, C2 = new Ti(y2.shape, [1, p2, n2.outChannels], true, false, x2, w2, b2), E2 = [y2, m2];
    r2 && E2.push(r2), b2 && E2.push(a2);
    var R2 = this.compileAndRun(C2, E2);
    return h2 ? R2.reshape([1, l2, c2, n2.outChannels]) : R2.reshape([1, n2.outChannels, l2, c2]);
  }, o2.prototype.fusedConv2d = function(t3) {
    var e2 = t3.input, n2 = t3.filter, r2 = t3.convInfo, o3 = t3.bias, i2 = t3.activation, u2 = t3.preluActivationWeights;
    if (1 === r2.filterHeight && 1 === r2.filterWidth && 1 === r2.dilationHeight && 1 === r2.dilationWidth && 1 === r2.strideHeight && 1 === r2.strideWidth && ("SAME" === r2.padInfo.type || "VALID" === r2.padInfo.type))
      return this.conv2dByMatMul(e2, n2, r2, o3, i2, u2);
    if (a().getBool("WEBGL_CONV_IM2COL") && 1 === e2.shape[0])
      return this.conv2dWithIm2Row(e2, n2, r2, o3, i2, u2);
    var s2 = null != o3, c2 = null != u2, l2 = i2 ? Pu(i2, false) : null, h2 = new Ma(r2, s2, l2, c2), f2 = [e2, n2];
    return o3 && f2.push(o3), u2 && f2.push(u2), this.compileAndRun(h2, f2);
  }, o2.prototype.conv2d = function(t3, e2, n2) {
    if (1 === n2.filterHeight && 1 === n2.filterWidth && 1 === n2.dilationHeight && 1 === n2.dilationWidth && 1 === n2.strideHeight && 1 === n2.strideWidth && ("SAME" === n2.padInfo.type || "VALID" === n2.padInfo.type))
      return this.conv2dByMatMul(t3, e2, n2);
    if (a().getBool("WEBGL_CONV_IM2COL") && 1 === t3.shape[0])
      return this.conv2dWithIm2Row(t3, e2, n2);
    var r2 = new Ma(n2);
    return this.compileAndRun(r2, [t3, e2]);
  }, o2.prototype.conv2dDerInput = function(t3, e2, n2) {
    var r2 = new Ta(n2);
    return this.compileAndRun(r2, [t3, e2]);
  }, o2.prototype.conv2dDerFilter = function(t3, e2, n2) {
    var r2 = new Da(n2);
    return this.compileAndRun(r2, [t3, e2]);
  }, o2.prototype.fusedDepthwiseConv2D = function(t3) {
    var e2, n2 = t3.input, r2 = t3.filter, o3 = t3.convInfo, i2 = t3.bias, u2 = t3.activation, s2 = t3.preluActivationWeights, c2 = a().getBool("WEBGL_PACK_DEPTHWISECONV") && o3.strideWidth <= 2 && o3.outChannels / o3.inChannels == 1, l2 = u2 ? Pu(u2, c2) : null, h2 = [n2, r2], f2 = null != i2, p2 = null != s2;
    return f2 && h2.push(i2), p2 && h2.push(s2), c2 ? (e2 = new La(o3, f2, l2, p2), this.compileAndRun(e2, h2)) : (e2 = new Pa(o3, f2, l2, p2), this.compileAndRun(e2, h2));
  }, o2.prototype.depthwiseConv2D = function(t3, e2, n2) {
    var r2;
    return a().getBool("WEBGL_PACK_DEPTHWISECONV") && n2.strideWidth <= 2 && n2.outChannels / n2.inChannels == 1 ? (r2 = new La(n2), this.compileAndRun(r2, [t3, e2])) : (r2 = new Pa(n2), this.compileAndRun(r2, [t3, e2]));
  }, o2.prototype.depthwiseConv2DDerInput = function(t3, e2, n2) {
    var r2 = new _a(n2);
    return this.compileAndRun(r2, [t3, e2]);
  }, o2.prototype.depthwiseConv2DDerFilter = function(t3, e2, n2) {
    var r2 = new Oa(n2);
    return this.compileAndRun(r2, [t3, e2]);
  }, o2.prototype.conv3d = function(t3, e2, n2) {
    var r2 = new Ba(n2);
    return this.compileAndRun(r2, [t3, e2]);
  }, o2.prototype.conv3dDerInput = function(t3, e2, n2) {
    var r2 = new Fa(n2);
    return this.compileAndRun(r2, [t3, e2]);
  }, o2.prototype.conv3dDerFilter = function(t3, e2, n2) {
    var r2 = new Na(n2);
    return this.compileAndRun(r2, [t3, e2]);
  }, o2.prototype.maxPool = function(t3, e2) {
    var n2 = new Bi(e2, "max", false);
    return this.compileAndRun(n2, [t3]);
  }, o2.prototype.avgPool = function(t3, e2) {
    var n2 = new Bi(e2, "avg", false);
    return this.compileAndRun(n2, [t3], "float32");
  }, o2.prototype.maxPoolBackprop = function(t3, e2, n2, r2) {
    var o3 = new Bi(r2, "max", true), a2 = this.compileAndRun(o3, [e2]), i2 = new Ai(r2), u2 = this.compileAndRun(i2, [t3, a2], e2.dtype);
    return a2.dispose(), u2;
  }, o2.prototype.avgPoolBackprop = function(t3, e2, n2) {
    var r2 = new ca(n2);
    return this.compileAndRun(r2, [t3], e2.dtype);
  }, o2.prototype.cast = function(t3, e2) {
    return So(t3, e2, this);
  }, o2.prototype.unstack = function(t3, e2) {
    for (var n2 = t3.shape[e2], r2 = new Array(t3.rank - 1), o3 = 0, a2 = 0; a2 < t3.rank; a2++)
      a2 !== e2 && (r2[o3++] = t3.shape[a2]);
    var i2 = new Array(t3.rank).fill(0), u2 = t3.shape.slice();
    u2[e2] = 1;
    var s2 = new Array(n2);
    for (a2 = 0; a2 < s2.length; a2++)
      i2[e2] = a2, s2[a2] = this.slice(t3, i2, u2).reshape(r2);
    return s2;
  }, o2.prototype.avgPool3d = function(t3, e2) {
    var n2 = new Pi(e2, "avg", false);
    return this.compileAndRun(n2, [t3], "float32");
  }, o2.prototype.avgPool3dBackprop = function(t3, e2, n2) {
    var r2 = new la(n2);
    return this.compileAndRun(r2, [t3], e2.dtype);
  }, o2.prototype.maxPool3d = function(t3, e2) {
    var n2 = new Pi(e2, "max", false);
    return this.compileAndRun(n2, [t3], "float32");
  }, o2.prototype.maxPool3dBackprop = function(t3, e2, n2, r2) {
    var o3 = new Pi(r2, "max", true), a2 = this.compileAndRun(o3, [e2]), i2 = new Di(r2), u2 = this.compileAndRun(i2, [t3, a2], e2.dtype);
    return a2.dispose(), u2;
  }, o2.prototype.reshape = function(t3, e2) {
    var n2 = this.texData.get(t3.dataId);
    if (n2.isPacked && !Se(t3.shape, e2) && (null === n2.texture || !Se(n2.shape, e2))) {
      var r2 = this.packedReshape(t3, e2);
      return Nt.makeTensorFromDataId(r2.dataId, r2.shape, r2.dtype);
    }
    return Ao(t3, e2);
  }, o2.prototype.resizeBilinear = function(t3, e2, n2, r2) {
    var o3 = a().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new zi(t3.shape, e2, n2, r2) : new Vi(t3.shape, e2, n2, r2);
    return this.compileAndRun(o3, [t3]);
  }, o2.prototype.resizeBilinearBackprop = function(t3, e2, n2) {
    var r2 = new Ui(t3, e2, n2);
    return this.compileAndRun(r2, [t3]);
  }, o2.prototype.resizeNearestNeighbor = function(t3, e2, n2, r2) {
    var o3 = new Hi(t3.shape, e2, n2, r2);
    return this.compileAndRun(o3, [t3]);
  }, o2.prototype.resizeNearestNeighborBackprop = function(t3, e2, n2) {
    var r2 = new Gi(t3, e2, n2);
    return this.compileAndRun(r2, [t3]);
  }, o2.prototype.multinomial = function(t3, e2, n2, r2) {
    var o3 = e2 ? t3 : io(t3), a2 = o3.shape[0], i2 = o3.shape[1], u2 = new Ni(a2, i2, n2), s2 = u2.getCustomSetupFunc(r2);
    return this.compileAndRun(u2, [o3], "int32", s2);
  }, o2.prototype.oneHot = function(t3, e2, n2, r2) {
    var o3 = new Fi(t3.size, e2, n2, r2);
    return this.compileAndRun(o3, [t3]);
  }, o2.prototype.diag = function(t3) {
    var e2 = new qa(t3.size);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.nonMaxSuppression = function(t3, e2, n2, r2, o3) {
    return un("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"), Mo(t3.dataSync(), e2.dataSync(), n2, r2, o3);
  }, o2.prototype.cropAndResize = function(t3, e2, n2, r2, o3, a2) {
    var i2 = new Wa(t3.shape, e2.shape, r2, o3, a2);
    return this.compileAndRun(i2, [t3, e2, n2]);
  }, o2.prototype.depthToSpace = function(t3, e2, n2) {
    g(e2 > 1, function() {
      return "blockSize should be > 1 for depthToSpace, but was: " + e2;
    });
    var r2 = t3.shape[0], o3 = "NHWC" === n2 ? t3.shape[1] : t3.shape[2], a2 = "NHWC" === n2 ? t3.shape[2] : t3.shape[3], i2 = "NHWC" === n2 ? t3.shape[3] : t3.shape[1], u2 = o3 * e2, s2 = a2 * e2, c2 = i2 / (e2 * e2), l2 = new Ha("NHWC" === n2 ? [r2, u2, s2, c2] : [r2, c2, u2, s2], e2, n2);
    return this.compileAndRun(l2, [t3]);
  }, o2.prototype.split = function(t3, e2, n2) {
    return Po(t3, e2, n2);
  }, o2.prototype.scatterND = function(t3, e2, n2) {
    var r2 = Hr(0, t3, n2), o3 = r2.sliceRank, a2 = r2.numUpdates, i2 = r2.sliceSize, u2 = r2.strides, s2 = r2.outputSize, c2 = [s2 / i2, i2], l2 = t3.reshape([a2, o3]), h2 = e2.reshape([a2, i2]);
    if (0 === s2)
      return Ao(kn([]), n2);
    var f2 = An(0), p2 = new ji(a2, o3, l2.rank, h2.rank, u2, c2);
    return this.compileAndRun(p2, [h2, l2, f2]).reshape(n2);
  }, o2.prototype.sparseToDense = function(t3, e2, n2, r2) {
    var o3 = Hr(0, t3, n2), a2 = o3.sliceRank, i2 = o3.numUpdates, u2 = o3.strides, s2 = o3.outputSize, c2 = new ji(i2, a2, t3.rank, e2.rank, u2, [s2, 1], false);
    return this.compileAndRun(c2, [e2, t3, r2]).reshape(n2);
  }, o2.prototype.fft = function(t3) {
    return this.fftImpl(t3, false);
  }, o2.prototype.ifft = function(t3) {
    return this.fftImpl(t3, true);
  }, o2.prototype.fftImpl = function(t3, e2) {
    var n2 = this.texData.get(t3.dataId), r2 = new Ja(Ya, t3.shape, e2), o3 = new Ja(Qa, t3.shape, e2), a2 = [this.makeComplexComponentTensorInfo(t3, n2.complexTensors.real), this.makeComplexComponentTensorInfo(t3, n2.complexTensors.imag)], i2 = this.compileAndRun(r2, a2), u2 = this.compileAndRun(o3, a2), s2 = this.complex(i2, u2).as2D(t3.shape[0], t3.shape[1]);
    return i2.dispose(), u2.dispose(), s2;
  }, o2.prototype.gatherND = function(t3, e2) {
    var n2 = e2.shape, r2 = n2[n2.length - 1], o3 = Ur(t3, e2), a2 = o3[0], i2 = o3[1], u2 = o3[2], s2 = o3[3], c2 = e2.reshape([i2, r2]), l2 = t3.reshape([t3.size / u2, u2]), h2 = new ri(r2, s2, [i2, u2]);
    return this.compileAndRun(h2, [l2, c2]).reshape(a2);
  }, o2.prototype.fill = function(t3, e2, n2) {
    if ("string" === (n2 = n2 || z(e2))) {
      var r2 = F(n2, w(t3));
      return r2.fill(e2), Nt.makeTensor(r2, t3, n2, this);
    }
    var o3 = new Za(t3, e2), a2 = o3.getCustomSetupFunc(e2);
    return this.compileAndRun(o3, [], n2, a2);
  }, o2.prototype.onesLike = function(t3) {
    if ("string" === t3.dtype)
      throw new Error("onesLike is not supported under string dtype");
    return this.fill(t3.shape, 1, t3.dtype);
  }, o2.prototype.zerosLike = function(t3) {
    return this.fill(t3.shape, "string" === t3.dtype ? "" : 0, t3.dtype);
  }, o2.prototype.linspace = function(t3, e2, n2) {
    return Do(t3, e2, n2);
  }, o2.prototype.makeTensorInfo = function(t3, e2) {
    var n2 = this.write(null, t3, e2);
    return this.texData.get(n2).usage = null, {dataId: n2, shape: t3, dtype: e2};
  }, o2.prototype.makeOutput = function(t3, e2) {
    var n2 = this.makeTensorInfo(t3, e2).dataId;
    return Nt.makeTensorFromDataId(n2, t3, e2, this);
  }, o2.prototype.unpackTensor = function(t3) {
    var e2 = new Mu(t3.shape);
    return this.runWebGLProgram(e2, [t3], t3.dtype);
  }, o2.prototype.packTensor = function(t3) {
    var e2 = new Oi(t3.shape);
    return this.runWebGLProgram(e2, [t3], t3.dtype, null, true);
  }, o2.prototype.packedReshape = function(t3, e2) {
    var n2 = [Ce(t3.shape)].concat(Ee(t3.shape)), r2 = {dtype: t3.dtype, shape: n2, dataId: t3.dataId}, o3 = [Ce(e2)].concat(Ee(e2)), a2 = new Wi(o3, n2), i2 = this.runWebGLProgram(a2, [r2], t3.dtype, null, true);
    return {dataId: i2.dataId, shape: e2, dtype: i2.dtype};
  }, o2.prototype.decode = function(t3) {
    var e2, n2 = this.texData.get(t3), r2 = n2.isPacked, o3 = n2.shape, a2 = n2.dtype, i2 = Re(o3);
    e2 = r2 ? new Ga(i2) : new za(i2);
    return {dtype: a2, shape: o3, dataId: this.runWebGLProgram(e2, [{shape: i2, dtype: a2, dataId: t3}], a2, null, true).dataId};
  }, o2.prototype.runWebGLProgram = function(t3, e2, n2, r2, o3) {
    var i2 = this;
    void 0 === o3 && (o3 = false);
    var u2 = this.makeTensorInfo(t3.outputShape, n2), s2 = this.texData.get(u2.dataId);
    if (t3.packedOutput && (s2.isPacked = true), t3.outPackingScheme === _t.DENSE) {
      var c2 = Gt(t3.outputShape);
      s2.texShape = c2.map(function(t4) {
        return 2 * t4;
      });
    }
    if (null != t3.outTexUsage && (s2.usage = t3.outTexUsage), 0 === w(u2.shape))
      return s2.values = N(u2.dtype, 0), u2;
    var l2 = [], h2 = e2.map(function(e3) {
      if ("complex64" === e3.dtype)
        throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
      var n3 = i2.texData.get(e3.dataId);
      if (null == n3.texture) {
        if (!t3.packedInputs && w(e3.shape) <= a().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))
          return {shape: e3.shape, texData: null, isUniform: true, uniformValues: n3.values};
        t3.packedInputs && (n3.isPacked = true, n3.shape = e3.shape);
      } else if (!!n3.isPacked != !!t3.packedInputs)
        e3 = n3.isPacked ? i2.unpackTensor(e3) : i2.packTensor(e3), l2.push(e3), n3 = i2.texData.get(e3.dataId);
      else if (n3.isPacked && !Se(n3.shape, e3.shape)) {
        var r3 = e3, o4 = e3.shape;
        e3.shape = n3.shape, e3 = i2.packedReshape(e3, o4), l2.push(e3), n3 = i2.texData.get(e3.dataId), r3.shape = o4;
      }
      return i2.uploadToGPU(e3.dataId), {shape: e3.shape, texData: n3, isUniform: false};
    });
    this.uploadToGPU(u2.dataId);
    var f2, p2 = {shape: u2.shape, texData: s2, isUniform: false}, d2 = function(t4, e3, n3) {
      var r3 = "";
      e3.concat(n3).forEach(function(t5) {
        var e4 = null != t5.texData && null != t5.texData.slice && t5.texData.slice.flatOffset > 0, n4 = t5.isUniform ? "uniform" : t5.texData.texShape;
        r3 += t5.shape + "_" + n4 + "_" + e4;
      });
      var o4 = t4.userCode, a2 = t4.constructor.name;
      return a2 += "_" + r3 + "_" + o4;
    }(t3, h2, p2), v2 = this.getAndSaveBinary(d2, function() {
      return function(t4, e3, n3, r3) {
        var o4 = e3.userCode, i3 = n3.map(function(t5, n4) {
          var r4 = {logicalShape: t5.shape, texShape: t5.isUniform ? null : t5.texData.texShape, isUniform: t5.isUniform, isPacked: !t5.isUniform && t5.texData.isPacked, flatOffset: null};
          return null != t5.texData && null != t5.texData.slice && t5.texData.slice.flatOffset > 0 && (r4.flatOffset = t5.texData.slice.flatOffset), {name: e3.variableNames[n4], shapeInfo: r4};
        }), u3 = i3.map(function(t5) {
          return t5.shapeInfo;
        }), s3 = {logicalShape: r3.shape, texShape: r3.texData.texShape, isUniform: false, isPacked: r3.texData.isPacked, flatOffset: null}, c3 = Yo(i3, s3, o4, e3.packedInputs), l3 = t4.createProgram(c3), h3 = null, f3 = t4.getUniformLocation(l3, "NAN", false);
        1 === a().getNumber("WEBGL_VERSION") && (h3 = t4.getUniformLocation(l3, "INFINITY", false));
        for (var p3 = {}, d3 = 0; d3 < e3.variableNames.length; d3++) {
          var v3 = e3.variableNames[d3];
          p3[v3] = t4.getUniformLocation(l3, v3, false), p3["offset" + v3] = t4.getUniformLocation(l3, "offset" + v3, false);
        }
        return {program: e3, source: c3, webGLProgram: l3, uniformLocations: p3, inShapeInfos: u3, outShapeInfo: s3, infLoc: h3, nanLoc: f3};
      }(i2.gpgpu, t3, h2, p2);
    }), m2 = null != this.activeTimers;
    if (m2 && (f2 = this.startTimer()), function(t4, e3, n3, r3, o4) {
      Ei(e3.inShapeInfos, n3), Ei([e3.outShapeInfo], [r3]);
      var i3 = r3.texData.texture, u3 = r3.texData.texShape;
      r3.texData.isPacked ? t4.setOutputPackedMatrixTexture(i3, u3[0], u3[1]) : t4.setOutputMatrixTexture(i3, u3[0], u3[1]), t4.setProgram(e3.webGLProgram), 1 === a().getNumber("WEBGL_VERSION") && null !== e3.infLoc && t4.gl.uniform1f(e3.infLoc, 1 / 0), null !== e3.nanLoc && t4.gl.uniform1f(e3.nanLoc, NaN), n3.forEach(function(n4, r4) {
        var o5 = e3.program.variableNames[r4], a2 = e3.uniformLocations[o5], i4 = e3.uniformLocations["offset" + o5];
        if (null != a2)
          if (n4.isUniform)
            if (w(n4.shape) < 2)
              t4.gl.uniform1f(a2, n4.uniformValues[0]);
            else {
              var u4 = n4.uniformValues;
              u4 instanceof Float32Array || (u4 = new Float32Array(u4)), t4.gl.uniform1fv(a2, u4);
            }
          else
            null != n4.texData.slice && null != i4 && t4.gl.uniform1i(i4, n4.texData.slice.flatOffset), t4.setInputMatrixTexture(n4.texData.texture, a2, r4);
      }), null != o4 && o4(t4, e3.webGLProgram), t4.executeProgram();
    }(this.gpgpu, v2, h2, p2, r2), l2.forEach(function(t4) {
      return i2.disposeData(t4.dataId);
    }), m2 && (f2 = this.endTimer(f2), this.activeTimers.push({name: t3.constructor.name, query: this.getQueryTime(f2)})), !a().getBool("WEBGL_LAZILY_UNPACK") && s2.isPacked && false === o3) {
      var g2 = this.unpackTensor(u2);
      return this.disposeData(u2.dataId), g2;
    }
    return u2;
  }, o2.prototype.compileAndRun = function(t3, e2, n2, r2, o3) {
    void 0 === o3 && (o3 = false), n2 = n2 || e2[0].dtype;
    var a2 = this.runWebGLProgram(t3, e2, n2, r2, o3);
    return Nt.makeTensorFromDataId(a2.dataId, a2.shape, a2.dtype);
  }, o2.prototype.getAndSaveBinary = function(t3, e2) {
    return t3 in this.binaryCache || (this.binaryCache[t3] = e2()), this.binaryCache[t3];
  }, o2.prototype.getTextureManager = function() {
    return this.textureManager;
  }, o2.prototype.dispose = function() {
    this.disposed || (this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, null != this.fromPixels2DContext && this.fromPixels2DContext.canvas.remove && this.fromPixels2DContext.canvas.remove(), this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = true);
  }, o2.prototype.floatPrecision = function() {
    var t3 = this;
    return null == this.floatPrecisionValue && (this.floatPrecisionValue = je(function() {
      if (!a().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
        var e2 = a().getBool("DEBUG");
        a().set("DEBUG", false);
        var n2 = t3.abs(An(1e-8)).dataSync()[0];
        if (a().set("DEBUG", e2), n2 > 0)
          return 32;
      }
      return 16;
    })), this.floatPrecisionValue;
  }, o2.prototype.epsilon = function() {
    return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
  }, o2.prototype.uploadToGPU = function(t3) {
    var e2, n2 = this.texData.get(t3), r2 = n2.shape, o3 = n2.dtype, a2 = n2.values, i2 = n2.texture, u2 = n2.usage, s2 = n2.isPacked;
    if (null == i2) {
      var c2, l2 = null != this.activeTimers;
      l2 && (c2 = Y());
      var h2 = n2.texShape;
      if (null == h2 && (h2 = Ie(r2, s2), n2.texShape = h2), null != a2) {
        var f2 = Re(r2), p2 = void 0, d2 = h2[1], v2 = h2[0], m2 = a2 instanceof Uint8Array;
        s2 ? (d2 = (e2 = Ht(h2[0], h2[1]))[0], v2 = e2[1], p2 = new $a(f2, [v2, d2], m2)) : p2 = new Xa(f2, [v2, d2], m2);
        var g2 = this.makeTensorInfo([v2, d2], o3);
        this.texData.get(g2.dataId).usage = m2 ? Mt.PIXELS : Mt.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g2.dataId), d2, v2, a2);
        var y2 = this.runWebGLProgram(p2, [g2], o3, null, true), x2 = this.texData.get(y2.dataId);
        n2.texture = x2.texture, n2.texShape = x2.texShape, n2.isPacked = x2.isPacked, n2.usage = x2.usage, this.disposeData(g2.dataId), this.texData.delete(y2.dataId), n2.values = null, l2 && (this.uploadWaitMs += Y() - c2);
      } else {
        var b2 = this.acquireTexture(h2, u2, o3, s2);
        n2.texture = b2;
      }
    }
  }, o2.prototype.convertAndCacheOnCPU = function(t3, e2) {
    var n2 = this.texData.get(t3), r2 = n2.dtype;
    return this.releaseGPUData(t3), null != e2 && (n2.values = function(t4, e3) {
      if ("float32" === e3 || "complex64" === e3)
        return t4;
      if ("int32" === e3 || "bool" === e3) {
        for (var n3 = "int32" === e3 ? new Int32Array(t4.length) : new Uint8Array(t4.length), r3 = 0; r3 < n3.length; ++r3)
          n3[r3] = Math.round(t4[r3]);
        return n3;
      }
      throw new Error("Unknown dtype " + e3);
    }(e2, r2)), n2.values;
  }, o2.prototype.acquireTexture = function(t3, e2, n2, r2) {
    if (this.numBytesInGPU += this.computeBytes(t3, n2), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
      var o3 = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
      this.warnedAboutMemory = true, console.warn("High memory usage in GPU: " + o3 + " MB, most likely due to a memory leak");
    }
    return this.textureManager.acquireTexture(t3, e2, r2);
  }, o2.prototype.computeBytes = function(t3, e2) {
    return t3[0] * t3[1] * P(e2);
  }, o2;
}(co);
Ft() && Nt.registerBackend("webgl", function() {
  return new Wu();
}, 2);
var Uu = Cn({square_: function(t2) {
  var e2 = ln(t2, "x", "square"), n2 = [e2];
  return Nt.runKernelFunc(function(t3, n3) {
    return n3([e2]), t3.square(e2);
  }, {x: e2}, function(t3, e3) {
    var n3 = e3[0];
    return {x: function() {
      return t3.mul(n3.toFloat().mul(2));
    }};
  }, "Square", {}, n2, []);
}});
var Vu = Cn({abs_: function(t2) {
  var e2 = ln(t2, "x", "abs");
  return "complex64" === e2.dtype ? Nt.runKernelFunc(function(t3) {
    return t3.complexAbs(e2);
  }, {$x: e2}) : Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.abs(e2);
    return n2([e2]), r2;
  }, {x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {x: function() {
      return t3.mul(n2.toFloat().step(-1));
    }};
  }, "Abs");
}});
var zu = Cn({acos_: function(t2) {
  var e2 = ln(t2, "x", "acos");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.acos(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.divStrict(An(1).sub(n2.toFloat().square()).sqrt()).neg();
    }};
  });
}});
var Gu = Cn({acosh_: function(t2) {
  var e2 = ln(t2, "x", "acosh");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.acosh(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.divStrict(n2.toFloat().square().sub(1).sqrt());
    }};
  });
}});
var Hu = Cn({asin_: function(t2) {
  var e2 = ln(t2, "x", "asin");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.asin(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.divStrict(An(1).sub(n2.toFloat().square()).sqrt());
    }};
  });
}});
var qu = Cn({asinh_: function(t2) {
  var e2 = ln(t2, "x", "asinh");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.asinh(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.divStrict(An(1).add(n2.toFloat().square()).sqrt());
    }};
  });
}});
var Ku = Cn({atan_: function(t2) {
  var e2 = ln(t2, "x", "atan");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.atan(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.div(n2.toFloat().square().add(1));
    }};
  });
}});
var ju = Cn({atanh_: function(t2) {
  var e2 = ln(t2, "x", "atanh");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.atanh(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.div(An(1).sub(n2.toFloat().square()));
    }};
  });
}});
var Xu = Cn({ceil_: function(t2) {
  var e2 = ln(t2, "x", "ceil");
  return Nt.runKernelFunc(function(t3) {
    return t3.ceil(e2);
  }, {$x: e2}, function(t3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var $u = Cn({clipByValue_: function(t2, e2, n2) {
  var r2 = ln(t2, "x", "clipByValue");
  return g(e2 <= n2, function() {
    return "Error in clip: min (" + e2 + ") must be less than or equal to max (" + n2 + ").";
  }), Nt.runKernelFunc(function(t3, o2) {
    var a2 = t3.clip(r2, e2, n2);
    return o2([r2]), a2;
  }, {$x: r2}, function(t3, r3) {
    var o2 = r3[0];
    return {$x: function() {
      return t3.where(o2.greaterEqual(e2).logicalAnd(o2.lessEqual(n2)), zn(t3));
    }};
  });
}});
var Yu = Cn({cos_: function(t2) {
  var e2 = ln(t2, "x", "cos");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.cos(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return n2.toFloat().sin().neg().mul(t3);
    }};
  });
}});
var Qu = Cn({cosh_: function(t2) {
  var e2 = ln(t2, "x", "cosh");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.cosh(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return n2.toFloat().sinh().mulStrict(t3);
    }};
  });
}});
var Ju = Cn({erf_: function(t2) {
  var e2 = ln(t2, "x", "erf");
  return g("int32" === e2.dtype || "float32" === e2.dtype, function() {
    return "Input dtype must be `int32` or `float32`.";
  }), "int32" === e2.dtype && (e2 = e2.toFloat()), Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.erf(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.mul(n2.square().neg().exp().mul(2 / Math.sqrt(Math.PI)));
    }};
  });
}});
var Zu = Cn({exp_: function(t2) {
  var e2 = ln(t2, "x", "exp");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.exp(e2);
    return n2([r2]), r2;
  }, {$x: e2}, function(t3, e3) {
    return {$x: function() {
      return t3.mulStrict(e3[0]);
    }};
  });
}});
var ts = Cn({expm1_: function(t2) {
  var e2 = ln(t2, "x", "expm1");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.expm1(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.mul(n2.exp());
    }};
  });
}});
var es = Cn({floor_: function(t2) {
  var e2 = ln(t2, "x", "floor");
  return Nt.runKernelFunc(function(t3) {
    return t3.floor(e2);
  }, {$x: e2}, function(t3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var ns = Cn({log_: function(t2) {
  var e2 = ln(t2, "x", "log");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.log(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.div(n2.toFloat());
    }};
  });
}});
var rs = Cn({log1p_: function(t2) {
  var e2 = ln(t2, "x", "log1p");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.log1p(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.div(n2.add(1));
    }};
  });
}});
var os = Cn({logSigmoid_: function(t2) {
  var e2 = ln(t2, "x", "logSigmoid");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.softplus(e2.neg()).neg();
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.mul(n2.neg().sigmoid());
    }};
  });
}});
var as = Cn({neg_: function(t2) {
  var e2 = ln(t2, "x", "neg");
  return Nt.runKernelFunc(function(t3) {
    return t3.neg(e2);
  }, {$x: e2}, function(t3) {
    return {$x: function() {
      return t3.neg();
    }};
  });
}});
var is = Cn({reciprocal_: function(t2) {
  var e2 = ln(t2, "x", "reciprocal");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.reciprocal(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.div(n2.square().neg());
    }};
  });
}});
var us = Cn({round_: function(t2) {
  var e2 = ln(t2, "x", "round");
  return Nt.runKernelFunc(function(t3) {
    return t3.round(e2);
  }, {$x: e2}, function(t3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var ss = Cn({rsqrt_: function(t2) {
  var e2 = ln(t2, "x", "rsqrt");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.rsqrt(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.div(n2.pow(1.5).mul(2)).neg();
    }};
  });
}});
var cs = Cn({sigmoid_: function(t2) {
  var e2 = ln(t2, "x", "sigmoid");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.sigmoid(e2);
    return n2([r2]), r2;
  }, {x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {x: function() {
      return t3.mul(n2.mul(An(1).sub(n2)));
    }};
  }, "Sigmoid");
}});
var ls = Cn({sign_: function(t2) {
  var e2 = ln(t2, "x", "sign");
  return Nt.runKernelFunc(function(t3) {
    return t3.sign(e2);
  }, {$x: e2}, function(t3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var hs = Cn({isNaN_: function(t2) {
  var e2 = ln(t2, "x", "isNaN");
  return Nt.runKernelFunc(function(t3) {
    return t3.isNaN(e2);
  }, {$x: e2}, function(t3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var fs = Cn({isInf_: function(t2) {
  var e2 = ln(t2, "x", "isInf");
  return Nt.runKernelFunc(function(t3) {
    return t3.isInf(e2);
  }, {$x: e2}, function(t3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var ps = Cn({isFinite_: function(t2) {
  var e2 = ln(t2, "x", "isFinite");
  return Nt.runKernelFunc(function(t3) {
    return t3.isFinite(e2);
  }, {$x: e2}, function(t3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var ds = Cn({sin_: function(t2) {
  var e2 = ln(t2, "x", "sin");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.sin(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return n2.toFloat().cos().mul(t3);
    }};
  });
}});
var vs = Cn({sinh_: function(t2) {
  var e2 = ln(t2, "x", "sinh");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.sinh(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return n2.toFloat().cosh().mulStrict(t3);
    }};
  });
}});
var ms = Cn({softplus_: function(t2) {
  var e2 = ln(t2, "x", "softplus");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.softplus(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.mul(n2.sigmoid());
    }};
  });
}});
var gs = Cn({sqrt_: function(t2) {
  var e2 = ln(t2, "x", "sqrt");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.sqrt(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.div(n2.toFloat().sqrt().mul(2));
    }};
  });
}});
var ys = Cn({step_: function(t2, e2) {
  void 0 === e2 && (e2 = 0);
  var n2 = ln(t2, "x", "step");
  return Nt.runKernelFunc(function(t3) {
    return t3.step(n2, e2);
  }, {$x: n2}, function(t3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var xs = Cn({tan_: function(t2) {
  var e2 = ln(t2, "x", "tan");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.tan(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.div(n2.cos().square());
    }};
  });
}});
var bs = Cn({tanh_: function(t2) {
  var e2 = ln(t2, "x", "tanh");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.tanh(e2);
    return n2([r2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return An(1).sub(n2.square()).mulStrict(t3);
    }};
  });
}});
function ws(t2, e2, n2, r2, o2, a2) {
  var i2, u2, s2 = ln(t2, "x", "batchNorm"), c2 = ln(e2, "mean", "batchNorm"), l2 = ln(n2, "variance", "batchNorm");
  return null != o2 && (i2 = ln(o2, "scale", "batchNorm")), null != r2 && (u2 = ln(r2, "offset", "batchNorm")), g(2 === s2.rank, function() {
    return "Error in batchNorm3D: x must be rank 3 but got rank " + s2.rank + ".";
  }), g(2 === c2.rank || 1 === c2.rank, function() {
    return "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank " + c2.rank + ".";
  }), g(2 === l2.rank || 1 === l2.rank, function() {
    return "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank " + l2.rank + ".";
  }), null != i2 && g(2 === i2.rank || 1 === i2.rank, function() {
    return "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank " + i2.rank + ".";
  }), null != u2 && g(2 === u2.rank || 1 === u2.rank, function() {
    return "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank " + u2.rank + ".";
  }), Rs(s2, c2, l2, u2, i2, a2);
}
function Cs(t2, e2, n2, r2, o2, a2) {
  var i2, u2, s2 = ln(t2, "x", "batchNorm"), c2 = ln(e2, "mean", "batchNorm"), l2 = ln(n2, "variance", "batchNorm");
  return null != o2 && (i2 = ln(o2, "scale", "batchNorm")), null != r2 && (u2 = ln(r2, "offset", "batchNorm")), g(3 === s2.rank, function() {
    return "Error in batchNorm3D: x must be rank 3 but got rank " + s2.rank + ".";
  }), g(3 === c2.rank || 1 === c2.rank, function() {
    return "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank " + c2.rank + ".";
  }), g(3 === l2.rank || 1 === l2.rank, function() {
    return "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank " + l2.rank + ".";
  }), null != i2 && g(3 === i2.rank || 1 === i2.rank, function() {
    return "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank " + i2.rank + ".";
  }), null != u2 && g(3 === u2.rank || 1 === u2.rank, function() {
    return "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank " + u2.rank + ".";
  }), Rs(s2, c2, l2, u2, i2, a2);
}
function Es(t2, e2, n2, r2, o2, a2) {
  var i2, u2, s2 = ln(t2, "x", "batchNorm"), c2 = ln(e2, "mean", "batchNorm"), l2 = ln(n2, "variance", "batchNorm");
  return null != o2 && (i2 = ln(o2, "scale", "batchNorm")), null != r2 && (u2 = ln(r2, "offset", "batchNorm")), g(4 === s2.rank, function() {
    return "Error in batchNorm4D: x must be rank 4 but got rank " + s2.rank + ".";
  }), g(4 === c2.rank || 1 === c2.rank, function() {
    return "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank " + c2.rank + ".";
  }), g(4 === l2.rank || 1 === l2.rank, function() {
    return "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank " + l2.rank + ".";
  }), null != i2 && g(4 === i2.rank || 1 === i2.rank, function() {
    return "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank " + i2.rank + ".";
  }), null != u2 && g(4 === u2.rank || 1 === u2.rank, function() {
    return "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank " + u2.rank + ".";
  }), Rs(s2, c2, l2, u2, i2, a2);
}
function Rs(t2, e2, n2, r2, o2, a2) {
  null == a2 && (a2 = 1e-3);
  var i2, u2, s2, c2 = ln(t2, "x", "batchNorm"), l2 = ln(e2, "mean", "batchNorm"), h2 = ln(n2, "variance", "batchNorm");
  null != o2 && (i2 = ln(o2, "scale", "batchNorm")), null != r2 && (u2 = ln(r2, "offset", "batchNorm")), g(l2.rank === h2.rank, function() {
    return "Batch normalization gradient requires mean and variance to have equal ranks.";
  }), g(null == u2 || l2.rank === u2.rank, function() {
    return "Batch normalization gradient requires mean and offset to have equal ranks.";
  }), g(null == i2 || l2.rank === i2.rank, function() {
    return "Batch normalization gradient requires mean and scale to have equal ranks.";
  }), s2 = 0 === c2.rank || 1 === c2.rank ? c2.as4D(1, 1, 1, c2.size) : 2 === c2.rank ? c2.as4D(1, 1, c2.shape[0], c2.shape[1]) : 3 === c2.rank ? c2.as4D(1, c2.shape[0], c2.shape[1], c2.shape[2]) : c2;
  var f2 = [c2, l2, h2, i2];
  return Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.batchNormalization(s2, Is(l2), Is(h2), a2, Is(i2), Is(u2));
    return e3([c2, l2, h2, i2]), n3;
  }, {x: c2, mean: l2, variance: h2, scale: i2, offset: u2}, function(t3, e3) {
    var n3 = e3, r3 = n3[0], o3 = n3[1], i3 = n3[2], u3 = n3[3], c3 = null == u3 ? An(1) : u3, l3 = fo(o3.shape, s2.shape), h3 = [];
    if (1 === o3.rank) {
      for (var f3 = 0; f3 < s2.shape.length - 1; ++f3)
        h3.push(s2.shape[f3]);
      h3.push(1);
    }
    var p2 = r3.sub(o3), d2 = t3.mul(c3), v2 = ss(i3.add(An(a2))), m2 = v2.mul(v2).mul(v2).mul(An(-0.5));
    return {x: function() {
      return 1 === o3.rank ? t3.mul(Nr(v2.as4D(1, 1, 1, o3.shape[0]), h3)).mul(c3).reshape(r3.shape) : t3.mul(v2).mul(c3).reshape(r3.shape);
    }, mean: function() {
      var t4 = v2.mul(An(-1)).mul(d2);
      return 1 === o3.rank && (t4 = t4.sum(l3)), t4.reshape(o3.shape);
    }, variance: function() {
      var t4 = m2.mul(p2).mul(d2);
      return 1 === o3.rank && (t4 = t4.sum(l3)), t4.reshape(o3.shape);
    }, scale: function() {
      var e4 = p2.mul(v2), n4 = t3.mul(e4);
      return 1 === o3.rank && (n4 = n4.sum(l3)), n4.reshape(o3.shape);
    }, offset: function() {
      var e4 = t3;
      return 1 === o3.rank && (e4 = e4.sum(l3)), e4.reshape(o3.shape);
    }};
  }, "BatchNormalization", {varianceEpsilon: a2}, f2).reshape(c2.shape);
}
function Is(t2) {
  return null == t2 ? null : 0 === t2.rank ? t2.as1D() : 1 === t2.rank ? t2 : 2 === t2.rank ? t2.as4D(1, 1, t2.shape[0], t2.shape[1]) : 3 === t2.rank ? t2.as4D(1, t2.shape[0], t2.shape[1], t2.shape[2]) : t2;
}
function ks() {
  ze("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon");
}
var Ss = Cn({batchNormalization2d_: function(t2, e2, n2, r2, o2, a2) {
  return void 0 === r2 && (r2 = 1e-3), ks(), ws(t2, e2, n2, a2, o2, r2);
}});
var As = Cn({batchNormalization3d_: function(t2, e2, n2, r2, o2, a2) {
  return void 0 === r2 && (r2 = 1e-3), ks(), Cs(t2, e2, n2, a2, o2, r2);
}});
var Ds = Cn({batchNormalization4d_: function(t2, e2, n2, r2, o2, a2) {
  return void 0 === r2 && (r2 = 1e-3), ks(), Es(t2, e2, n2, a2, o2, r2);
}});
var Ts = Cn({batchNormalization_: function(t2, e2, n2, r2, o2, a2) {
  return void 0 === r2 && (r2 = 1e-3), ks(), Rs(t2, e2, n2, a2, o2, r2);
}});
var Ns = Cn({batchNorm_: Rs});
var Fs = Cn({batchNorm2d_: ws});
var Os = Cn({batchNorm3d_: Cs});
var _s = Cn({batchNorm4d_: Es});
var Ms = Cn({logicalAnd_: function(t2, e2) {
  var n2 = ln(t2, "a", "logicalAnd", "bool"), r2 = ln(e2, "b", "logicalAnd", "bool");
  return po(n2.shape, r2.shape), Nt.runKernelFunc(function(t3) {
    return t3.logicalAnd(n2, r2);
  }, {$a: n2, $b: r2});
}});
var Bs = Cn({logicalNot_: function(t2) {
  var e2 = ln(t2, "x", "logicalNot", "bool");
  return Nt.runKernelFunc(function(t3) {
    return t3.logicalNot(e2);
  }, {$x: e2});
}});
var Ps = Cn({logicalOr_: function(t2, e2) {
  var n2 = ln(t2, "a", "logicalOr", "bool"), r2 = ln(e2, "b", "logicalOr", "bool");
  return po(n2.shape, r2.shape), Nt.runKernelFunc(function(t3) {
    return t3.logicalOr(n2, r2);
  }, {$a: n2, $b: r2});
}});
var Ls = Cn({logicalXor_: function(t2, e2) {
  var n2 = ln(t2, "a", "logicalXor", "bool"), r2 = ln(e2, "b", "logicalXor", "bool");
  return po(n2.shape, r2.shape), Ps(t2, e2).logicalAnd(Ms(t2, e2).logicalNot());
}});
var Ws = Cn({where_: function(t2, e2, n2) {
  var r2 = ln(e2, "a", "where"), o2 = ln(n2, "b", "where"), a2 = ln(t2, "condition", "where", "bool");
  return y(r2.shape, o2.shape, "Error in where: "), 1 === a2.rank ? g(a2.shape[0] === r2.shape[0], function() {
    return "The first dimension of `a` must match the size of `condition`.";
  }) : y(a2.shape, o2.shape, "Error in where: "), Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.select(a2, r2, o2);
    return e3([a2]), n3;
  }, {$condition: a2, $a: r2, $b: o2}, function(t3, e3) {
    var n3 = e3[0];
    return {$condition: function() {
      return zn(n3).toFloat();
    }, $a: function() {
      return t3.mul(n3.cast(t3.dtype));
    }, $b: function() {
      return t3.mul(n3.logicalNot().cast(t3.dtype));
    }};
  });
}});
var Us = function(t2) {
  return n(this, void 0, void 0, function() {
    var e2, n2, o2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          return [4, (e2 = ln(t2, "condition", "whereAsync", "bool")).data()];
        case 1:
          return n2 = r2.sent(), o2 = Uo(e2.shape, n2), t2 !== e2 && e2.dispose(), [2, o2];
      }
    });
  });
};
var Vs = Cn({add_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "add"), o2 = ln(e2, "b", "add");
  n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1];
  var a2 = po(r2.shape, o2.shape);
  return Nt.runKernelFunc(function(t3) {
    return t3.add(r2, o2);
  }, {a: r2, b: o2}, function(t3) {
    return {a: function() {
      var e3 = t3, n3 = fo(r2.shape, a2);
      return n3.length > 0 && (e3 = e3.sum(n3)), e3.reshape(r2.shape);
    }, b: function() {
      var e3 = t3, n3 = fo(o2.shape, a2);
      return n3.length > 0 && (e3 = e3.sum(n3)), e3.reshape(o2.shape);
    }};
  }, "Add");
}});
var zs = Cn({addN_: function(t2) {
  g(Array.isArray(t2), function() {
    return "The argument passed to tf.addN() must be a list of tensors";
  }), g(t2.length >= 1, function() {
    return "Must pass at least one tensor to tf.addN(), but got " + t2.length;
  });
  var e2 = t2.map(function(t3, e3) {
    return ln(t3, "tensors" + e3, "addN");
  }), n2 = e2[0];
  e2.forEach(function(t3) {
    if (t3.dtype !== n2.dtype)
      throw new Error("All tensors passed to tf.addN() must have the same dtype");
  }), e2.forEach(function(t3) {
    if (!C(t3.shape, n2.shape))
      throw new Error("All tensors passed to tf.addN() must have the same shape");
  });
  var r2 = e2;
  return Nt.runKernelFunc(function(t3) {
    return t3.addN(e2);
  }, r2, function(t3) {
    var n3 = {};
    return e2.forEach(function(e3, r3) {
      n3[r3] = function() {
        return t3.clone();
      };
    }), n3;
  });
}});
var Gs = Cn({addStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "addStrict"), r2 = ln(e2, "b", "addStrict");
  return y(n2.shape, r2.shape, "Error in addStrict: "), n2.add(r2);
}});
var Hs = Cn({atan2_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "atan2"), o2 = ln(e2, "b", "atan2");
  n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1];
  var a2 = po(r2.shape, o2.shape);
  return Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.atan2(r2, o2);
    return e3([r2, o2]), n3;
  }, {$a: r2, $b: o2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1];
    return {$a: function() {
      var e4 = Vs(n3.square(), r3.square()), o3 = t3.mul(r3.div(e4)), i2 = fo(n3.shape, a2);
      return i2.length > 0 && (o3 = o3.sum(i2)), o3.reshape(n3.shape);
    }, $b: function() {
      var e4 = Vs(n3.square(), r3.square()), o3 = as(t3.mul(n3.div(e4))), i2 = fo(r3.shape, a2);
      return i2.length > 0 && (o3 = o3.sum(i2)), o3.reshape(r3.shape);
    }};
  });
}});
var qs = Cn({div_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "div"), o2 = ln(e2, "b", "div");
  if (n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], "int32" === r2.dtype && "int32" === o2.dtype)
    return Xs(r2, o2);
  var a2 = po(r2.shape, o2.shape);
  return Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.realDivide(r2, o2);
    return e3([r2, o2]), n3;
  }, {a: r2, b: o2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1];
    return {a: function() {
      var e4 = t3.div(r3.toFloat()), o3 = fo(n3.shape, a2);
      return o3.length > 0 ? e4.sum(o3).reshape(n3.shape) : e4;
    }, b: function() {
      var e4 = t3.mul(n3.toFloat()), o3 = fo(r3.shape, a2);
      o3.length > 0 && (e4 = e4.sum(o3).reshape(r3.shape));
      var i2 = r3.square();
      return e4.div(i2.toFloat()).neg();
    }};
  }, "Div");
}});
var Ks = Cn({divNoNan_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "div"), o2 = ln(e2, "b", "div");
  r2 = (n2 = Rt(r2, o2))[0], o2 = n2[1];
  var a2 = qs(r2, o2), i2 = zn(a2), u2 = o2.equal(i2);
  return Ws(u2, i2, a2);
}});
var js = Cn({divStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "div"), r2 = ln(e2, "b", "div");
  return y(n2.shape, r2.shape, "Error in divideStrict: "), n2.div(r2);
}});
var Xs = Cn({floorDiv_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "floorDiv"), o2 = ln(e2, "b", "floorDiv");
  n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1];
  var a2 = po(r2.shape, o2.shape);
  return Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.floorDiv(r2, o2);
    return e3([r2, o2]), n3;
  }, {$a: r2, $b: o2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1];
    return {$a: function() {
      var e4 = t3.div(r3.toFloat()), o3 = fo(n3.shape, a2);
      return o3.length > 0 ? e4.sum(o3).reshape(n3.shape) : e4;
    }, $b: function() {
      var e4 = t3.mul(n3.toFloat()), o3 = fo(r3.shape, a2);
      o3.length > 0 && (e4 = e4.sum(o3).reshape(r3.shape));
      var i2 = r3.square();
      return e4.div(i2.toFloat()).neg();
    }};
  });
}});
var $s = Cn({maximum_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "maximum"), o2 = ln(e2, "b", "maximum");
  return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], "bool" === r2.dtype && (r2 = r2.toInt(), o2 = o2.toInt()), po(r2.shape, o2.shape), Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.maximum(r2, o2);
    return e3([r2, o2]), n3;
  }, {$a: r2, $b: o2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1];
    return {$a: function() {
      return t3.mul(n3.greaterEqual(r3).toFloat());
    }, $b: function() {
      return t3.mul(n3.less(r3).toFloat());
    }};
  });
}});
var Ys = Cn({maximumStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "maximumStrict"), r2 = ln(e2, "b", "maximumStrict");
  return y(n2.shape, r2.shape, "Error in maximumStrict: "), n2.maximum(r2);
}});
var Qs = Cn({minimum_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "minimum"), o2 = ln(e2, "b", "minimum");
  return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], "bool" === r2.dtype && (r2 = r2.toInt(), o2 = o2.toInt()), po(r2.shape, o2.shape), Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.minimum(r2, o2);
    return e3([r2, o2]), n3;
  }, {$a: r2, $b: o2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1];
    return {$a: function() {
      return t3.mul(n3.lessEqual(r3).toFloat());
    }, $b: function() {
      return t3.mul(n3.greater(r3).toFloat());
    }};
  });
}});
var Js = Cn({minimumStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "minimumStrict"), r2 = ln(e2, "b", "minimumStrict");
  return y(n2.shape, r2.shape, "Error in minimumStrict: "), n2.minimum(r2);
}});
var Zs = Cn({mod_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "mod"), o2 = ln(e2, "b", "mod");
  n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1];
  var a2 = po(r2.shape, o2.shape);
  return Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.mod(r2, o2);
    return e3([r2, o2]), n3;
  }, {$a: r2, $b: o2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1];
    return {$a: function() {
      var e4 = fo(n3.shape, a2);
      return e4.length > 0 ? t3.sum(e4).reshape(n3.shape) : t3;
    }, $b: function() {
      var e4 = t3.mul(n3.div(r3).floor().neg()), o3 = fo(r3.shape, a2);
      return o3.length > 0 ? e4.sum(o3).reshape(r3.shape) : e4;
    }};
  });
}});
var tc = Cn({modStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "modStrict"), r2 = ln(e2, "b", "modStrict");
  return y(n2.shape, r2.shape, "Error in modStrict: "), n2.mod(r2);
}});
var ec = Cn({mul_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "mul"), o2 = ln(e2, "b", "mul");
  n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1];
  var a2 = po(r2.shape, o2.shape);
  return Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.multiply(r2, o2);
    return e3([r2, o2]), n3;
  }, {a: r2, b: o2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1];
    return {a: function() {
      var e4 = t3.mul(r3.toFloat()), o3 = fo(n3.shape, a2);
      return o3.length > 0 ? e4.sum(o3).reshape(n3.shape) : e4;
    }, b: function() {
      var e4 = t3.mul(n3.toFloat()), o3 = fo(r3.shape, a2);
      return o3.length > 0 ? e4.sum(o3).reshape(r3.shape) : e4;
    }};
  }, "Mul");
}});
var nc = Cn({mulStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "mul"), r2 = ln(e2, "b", "mul");
  return y(n2.shape, r2.shape, "Error in multiplyStrict: "), n2.mul(r2);
}});
var rc = Cn({pow_: function(t2, e2) {
  var n2 = ln(t2, "base", "pow"), r2 = ln(e2, "exp", "pow"), o2 = po(n2.shape, r2.shape);
  return t2 = n2.cast(Ct(n2.dtype, r2.dtype)), e2 = r2.cast(Ct(n2.dtype, r2.dtype)), Nt.runKernelFunc(function(t3, e3) {
    var o3 = t3.pow(n2, r2);
    return e3([n2, r2, o3]), o3;
  }, {$base: n2, $exp: r2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1], a2 = e3[2];
    return {$base: function() {
      var e4 = r3.toFloat(), a3 = t3.mul(e4.mul(n3.pow(e4.sub(An(1))))), i2 = fo(n3.shape, o2);
      return i2.length > 0 && (a3 = a3.sum(i2)), a3.reshape(n3.shape);
    }, $exp: function() {
      var e4 = n3.greater(0), i2 = n3.log().where(e4, zn(n3)), u2 = t3.mul(a2.mul(i2)), s2 = fo(r3.shape, o2);
      return s2.length > 0 && (u2 = u2.sum(s2)), u2.reshape(r3.shape);
    }};
  });
}});
var oc = Cn({powStrict_: function(t2, e2) {
  return y(t2.shape, e2.shape, "Error in powStrict: "), t2.pow(e2);
}});
var ac = Cn({squaredDifference_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "squaredDifference"), o2 = ln(e2, "b", "squaredDifference");
  return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.squaredDifference(r2, o2);
    return e3([r2, o2]), n3;
  }, {$a: r2, $b: o2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1], o3 = An(2);
    return {$a: function() {
      return t3.mul(n3.sub(r3).mul(o3));
    }, $b: function() {
      return t3.mul(r3.sub(n3).mul(o3));
    }};
  });
}});
var ic = Cn({squaredDifferenceStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "squaredDifferenceStrict"), r2 = ln(e2, "b", "squaredDifferenceStrict");
  return y(n2.shape, r2.shape, "Error in squaredDifferenceStrict: "), n2.squaredDifference(r2);
}});
var uc = Cn({sub_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "sub"), o2 = ln(e2, "b", "sub");
  n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1];
  var a2 = po(r2.shape, o2.shape);
  return Nt.runKernelFunc(function(t3) {
    return t3.subtract(r2, o2);
  }, {a: r2, b: o2}, function(t3) {
    return {a: function() {
      var e3 = t3, n3 = fo(r2.shape, a2);
      return n3.length > 0 && (e3 = e3.sum(n3)), e3.reshape(r2.shape);
    }, b: function() {
      var e3 = t3, n3 = fo(o2.shape, a2);
      return n3.length > 0 && (e3 = e3.sum(n3)), e3.neg().reshape(o2.shape);
    }};
  }, "Sub");
}});
var sc = Cn({subStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "subStrict"), r2 = ln(e2, "b", "subStrict");
  return y(n2.shape, r2.shape, "Error in subStrict: "), n2.sub(r2);
}});
var cc = Cn({equal_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "equal"), o2 = ln(e2, "b", "equal");
  return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t3) {
    return t3.equal(r2, o2);
  }, {$a: r2, $b: o2});
}});
var lc = Cn({equalStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "equalStrict"), r2 = ln(e2, "b", "equalStrict");
  return y(n2.shape, r2.shape, "Error in equalStrict: "), n2.equal(r2);
}});
var hc = Cn({greater_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "greater"), o2 = ln(e2, "b", "greater");
  return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t3) {
    return t3.greater(r2, o2);
  }, {$a: r2, $b: o2});
}});
var fc = Cn({greaterEqual_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "greaterEqual"), o2 = ln(e2, "b", "greaterEqual");
  return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.greaterEqual(r2, o2);
    return e3([r2, o2]), n3;
  }, {$a: r2, $b: o2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1];
    return {$a: function() {
      return zn(n3);
    }, $b: function() {
      return zn(r3);
    }};
  });
}});
var pc = Cn({greaterEqualStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "greaterEqualStrict"), r2 = ln(e2, "b", "greaterEqualStrict");
  return y(n2.shape, r2.shape, "Error in greaterEqualStrict: "), n2.greaterEqual(r2);
}});
var dc = Cn({greaterStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "greaterStrict"), r2 = ln(e2, "b", "greaterStrict");
  return y(n2.shape, r2.shape, "Error in greaterStrict: "), n2.greater(r2);
}});
var vc = Cn({less_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "less"), o2 = ln(e2, "b", "less");
  return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t3) {
    return t3.less(r2, o2);
  }, {$a: r2, $b: o2});
}});
var mc = Cn({lessEqual_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "lessEqual"), o2 = ln(e2, "b", "lessEqual");
  return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t3) {
    return t3.lessEqual(r2, o2);
  }, {$a: r2, $b: o2});
}});
var gc = Cn({lessEqualStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "lessEqualStrict"), r2 = ln(e2, "b", "lessEqualStrict");
  return y(n2.shape, r2.shape, "Error in lessEqualStrict: "), n2.lessEqual(r2);
}});
var yc = Cn({lessStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "lessStrict"), r2 = ln(e2, "b", "lessStrict");
  return y(n2.shape, r2.shape, "Error in lessStrict: "), n2.less(r2);
}});
var xc = Cn({notEqual_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "notEqual"), o2 = ln(e2, "b", "notEqual");
  return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t3) {
    return t3.notEqual(r2, o2);
  }, {$a: r2, $b: o2});
}});
var bc = Cn({notEqualStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "notEqualStrict"), r2 = ln(e2, "b", "notEqualStrict");
  return y(n2.shape, r2.shape, "Error in notEqualStrict: "), n2.notEqual(r2);
}});
function wc(t2, e2) {
  for (var n2 = [], r2 = t2; r2 < e2; ++r2)
    n2.push(r2);
  return n2;
}
function Cc(t2) {
  for (var e2 = [], n2 = 0; n2 < t2.length; ++n2)
    for (var r2 = 0; r2 < t2[n2].length; ++r2)
      e2.push(t2[n2][r2]);
  return e2;
}
var Ec = Cn({gather_: function(t2, e2, n2) {
  void 0 === n2 && (n2 = 0);
  var r2 = ln(t2, "x", "gather"), o2 = ln(e2, "indices", "gather", "int32");
  n2 = D(n2, r2.shape)[0];
  var a2 = function(t3, e3, n3) {
    for (var r3 = t3.shape[n3], o3 = [], a3 = 1, i2 = 1, u2 = 0; u2 < n3; u2++)
      o3.push(t3.shape[u2]), a3 *= t3.shape[u2];
    for (u2 = 0; u2 < e3.rank; u2++)
      o3.push(e3.shape[u2]);
    for (u2 = n3 + 1; u2 < t3.rank; u2++)
      o3.push(t3.shape[u2]), i2 *= t3.shape[u2];
    return {batchSize: a3, sliceSize: i2, dimSize: r3, outputShape: o3};
  }(r2, o2, n2);
  return Nt.runKernelFunc(function(t3, e3) {
    var a3 = t3.gather(r2, o2.flatten(), n2);
    return e3([o2]), a3;
  }, {$x: r2}, function(t3, e3) {
    var o3 = e3[0];
    return {$x: function() {
      var e4 = r2.shape, a3 = o3.size, i2 = e4.slice(0, n2), u2 = i2.length, s2 = e4.slice(n2, e4.length).slice(1), c2 = s2.length, l2 = wc(0, u2), h2 = wc(u2 + 1, u2 + 1 + c2), f2 = Cc([i2, [a3], s2]), p2 = t3.reshape(f2), d2 = o3.reshape([a3]), v2 = Cc([[u2], l2, h2]), m2 = p2.transpose(v2), g2 = Rc(m2, d2, r2.shape[n2]), y2 = yn(v2);
      return g2 = g2.transpose(y2);
    }};
  }).reshape(a2.outputShape);
}});
var Rc = Cn({unsortedSegmentSum_: function(t2, e2, n2) {
  var r2 = ln(t2, "x", "unsortedSegmentSum"), o2 = ln(e2, "segmentIds", "unsortedSegmentSum", "int32");
  return g(E(n2), function() {
    return "numSegments must be of dtype int";
  }), Nt.runKernelFunc(function(t3, e3) {
    var a2 = t3.unsortedSegmentSum(r2, o2, n2);
    return e3([o2]), a2;
  }, {$x: r2}, function(t3, e3) {
    var n3 = e3[0];
    return {$x: function() {
      return function(t4, e4) {
        for (var n4 = $s(e4, zn(e4)), r3 = Ec(t4, n4), o3 = fc(e4, An(0, "int32")), a2 = r3.rank - o3.rank, i2 = 0; i2 < a2; ++i2)
          o3 = dr(o3, i2 + 1);
        o3 = Ms(o3, Bn(r3.shape, "bool"));
        var u2 = zn(r3);
        return Ws(o3, r3, u2);
      }(t3, n3);
    }};
  });
}});
var Ic = function(t2, e2, o2) {
  return n(this, void 0, void 0, function() {
    var n2, a2, i2, u2, s2, c2, l2, h2, f2, p2, d2, v2, m2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          for (n2 = ln(t2, "tensor", "boolMask"), a2 = ln(e2, "mask", "boolMask", "bool"), i2 = null == o2 ? 0 : o2, u2 = a2.rank, s2 = n2.shape, g(u2 > 0, function() {
            return "mask cannot be scalar";
          }), y(s2.slice(i2, i2 + u2), a2.shape, "mask's shape must match the first K dimensions of tensor's shape,"), c2 = 1, l2 = i2; l2 < i2 + u2; l2++)
            c2 *= s2[l2];
          return h2 = s2.slice(0, i2).concat([c2], s2.slice(i2 + u2)), f2 = n2.reshape(h2), p2 = a2.reshape([-1]), [4, Us(p2)];
        case 1:
          return d2 = r2.sent(), v2 = d2.squeeze([1]), m2 = Ec(f2, v2, i2), t2 !== n2 && n2.dispose(), e2 !== a2 && a2.dispose(), v2.dispose(), f2.dispose(), p2.dispose(), d2.dispose(), [2, m2];
      }
    });
  });
};
function kc(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === a2 && (a2 = "NHWC"), g(t2.length === e2.rank, function() {
    return "Length of inShape (" + t2.length + ") and rank of dy (" + e2.rank + ") must match";
  });
  var u2 = t2, s2 = e2, c2 = false;
  3 === e2.rank && (c2 = true, s2 = e2.as4D(1, e2.shape[0], e2.shape[1], e2.shape[2]), u2 = [1, t2[0], t2[1], t2[2]]), g(4 === u2.length, function() {
    return "Error in conv2dDerInput: inShape must be length 4, but got length " + u2.length + ".";
  }), g(4 === s2.rank, function() {
    return "Error in conv2dDerInput: dy must be rank 4, but got rank " + s2.rank;
  }), g(4 === n2.rank, function() {
    return "Error in conv2dDerInput: filter must be rank 4, but got rank " + n2.rank;
  });
  var l2 = "NHWC" === a2 ? u2[3] : u2[1], h2 = "NHWC" === a2 ? s2.shape[3] : s2.shape[1];
  g(l2 === n2.shape[2], function() {
    return "Error in conv2dDerInput: depth of input (" + l2 + ") must match input depth for filter " + n2.shape[2] + ".";
  }), g(h2 === n2.shape[3], function() {
    return "Error in conv2dDerInput: depth of output (" + h2 + ") must match output depth for filter " + n2.shape[3] + ".";
  }), null != i2 && g(E(o2), function() {
    return "Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + o2 + ".";
  });
  var f2 = ko(a2), p2 = go(u2, n2.shape, r2, 1, o2, i2, false, f2), d2 = Nt.runKernelFunc(function(t3, e3) {
    var r3 = t3.conv2dDerInput(s2, n2, p2);
    return e3([n2, s2]), r3;
  }, {dy4D: s2, filter: n2}, function(t3, e3) {
    var n3 = e3[0], u3 = e3[1];
    return {dy4D: function() {
      return Tc(t3, n3, r2, o2, a2, 1, i2);
    }, filter: function() {
      return Fc(t3, u3, n3.shape, r2, o2, a2, i2);
    }};
  });
  return c2 ? d2.as3D(d2.shape[1], d2.shape[2], d2.shape[3]) : d2;
}
function Sc(t2) {
  var e2 = function(t3) {
    return "number" == typeof t3 ? [t3, t3, t3] : 2 === t3.length ? [t3[0], t3[1], 1] : t3;
  }(t2), n2 = e2[0], r2 = e2[1], o2 = e2[2];
  return 1 === n2 && 1 === r2 && 1 === o2;
}
function Ac(t2, e2, n2, r2, o2) {
  g(t2.length === e2.rank, function() {
    return "Length of inShape (" + t2.length + ") and rank of dy (" + e2.rank + ") must match";
  });
  var a2 = t2, i2 = e2, u2 = false;
  4 === e2.rank && (u2 = true, i2 = e2.as5D(1, e2.shape[0], e2.shape[1], e2.shape[2], e2.shape[3]), a2 = [1, t2[0], t2[1], t2[2], t2[3]]);
  var s2 = a2[4], c2 = i2.shape[4];
  g(5 === a2.length, function() {
    return "Error in conv3dDerInput: inShape must be length 5, but got length " + a2.length + ".";
  }), g(5 === i2.rank, function() {
    return "Error in conv3dDerInput: dy must be rank 5, but got rank " + i2.rank;
  }), g(5 === n2.rank, function() {
    return "Error in conv3dDerInput: filter must be rank 5, but got rank " + n2.rank;
  }), g(s2 === n2.shape[3], function() {
    return "Error in conv3dDerInput: depth of input (" + s2 + ") must match input depth for filter " + n2.shape[3] + ".";
  }), g(c2 === n2.shape[4], function() {
    return "Error in conv3dDerInput: depth of output (" + c2 + ") must match output depth for filter " + n2.shape[4] + ".";
  });
  var l2 = yo(a2, n2.shape, r2, 1, o2), h2 = Nt.runKernelFunc(function(t3) {
    return t3.conv3dDerInput(i2, n2, l2);
  }, {dy5D: i2});
  return u2 ? h2.as4D(h2.shape[1], h2.shape[2], h2.shape[3], h2.shape[4]) : h2;
}
var Dc = Cn({conv1d_: function(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === o2 && (o2 = "NWC"), void 0 === a2 && (a2 = 1);
  var u2 = ln(t2, "x", "conv1d"), s2 = ln(e2, "filter", "conv1d"), c2 = u2, l2 = false;
  2 === u2.rank && (l2 = true, c2 = u2.as3D(1, u2.shape[0], u2.shape[1])), g(3 === c2.rank, function() {
    return "Error in conv1d: input must be rank 3, but got rank " + c2.rank + ".";
  }), g(3 === s2.rank, function() {
    return "Error in conv1d: filter must be rank 3, but got rank " + s2.rank + ".";
  }), null != i2 && g(E(r2), function() {
    return "Error in conv1d: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + r2 + ".";
  }), g(c2.shape[2] === s2.shape[1], function() {
    return "Error in conv1d: depth of input (" + c2.shape[2] + ") must match input depth for filter " + s2.shape[1] + ".";
  }), g(Io(n2, a2), function() {
    return "Error in conv1D: Either stride or dilation must be 1. Got stride " + n2 + " and dilation '" + a2 + "'";
  }), g("NWC" === o2, function() {
    return "Error in conv1d: got dataFormat of " + o2 + " but only NWC is currently supported.";
  });
  var h2 = s2.as4D(1, s2.shape[0], s2.shape[1], s2.shape[2]), f2 = c2.as4D(c2.shape[0], 1, c2.shape[1], c2.shape[2]), p2 = Tc(f2, h2, [1, n2], r2, "NHWC", [1, a2], i2);
  return l2 ? p2.as2D(p2.shape[2], p2.shape[3]) : p2.as3D(p2.shape[0], p2.shape[2], p2.shape[3]);
}});
var Tc = Cn({conv2d_: function(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === o2 && (o2 = "NHWC"), void 0 === a2 && (a2 = [1, 1]);
  var u2 = ln(t2, "x", "conv2d"), s2 = ln(e2, "filter", "conv2d"), c2 = u2, l2 = false;
  3 === u2.rank && (l2 = true, c2 = u2.as4D(1, u2.shape[0], u2.shape[1], u2.shape[2])), g(4 === c2.rank, function() {
    return "Error in conv2d: input must be rank 4, but got rank " + c2.rank + ".";
  }), g(4 === s2.rank, function() {
    return "Error in conv2d: filter must be rank 4, but got rank " + s2.rank + ".";
  }), null != i2 && g(E(r2), function() {
    return "Error in conv2d: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + r2 + ".";
  });
  var h2 = "NHWC" === o2 ? c2.shape[3] : c2.shape[1];
  g(h2 === s2.shape[2], function() {
    return "Error in conv2d: depth of input (" + h2 + ") must match input depth for filter " + s2.shape[2] + ".";
  }), g(Io(n2, a2), function() {
    return "Error in conv2D: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + a2 + "'";
  });
  var f2 = ko(o2), p2 = go(c2.shape, s2.shape, n2, a2, r2, i2, false, f2), d2 = [s2, c2], v2 = Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.conv2d(c2, s2, p2);
    return e3([s2, c2]), n3;
  }, {x: c2, filter: s2}, function(t3, e3) {
    var i3 = e3, u3 = i3[0], s3 = i3[1];
    return g(Ro(a2), function() {
      return "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + a2 + "'";
    }), {x: function() {
      return Oc(s3.shape, t3, u3, n2, r2, o2);
    }, filter: function() {
      return Fc(s3, t3, u3.shape, n2, r2, o2);
    }};
  }, "Conv2D", p2, d2);
  return l2 ? v2.as3D(v2.shape[1], v2.shape[2], v2.shape[3]) : v2;
}});
var Nc = Cn({conv3d_: function(t2, e2, n2, r2, o2, a2) {
  void 0 === o2 && (o2 = "NDHWC"), void 0 === a2 && (a2 = [1, 1, 1]);
  var i2 = ln(t2, "x", "conv3d"), u2 = ln(e2, "filter", "conv3d"), s2 = i2, c2 = false;
  4 === i2.rank && (c2 = true, s2 = i2.as5D(1, i2.shape[0], i2.shape[1], i2.shape[2], i2.shape[3])), g(5 === s2.rank, function() {
    return "Error in conv3d: input must be rank 5, but got rank " + s2.rank + ".";
  }), g(5 === u2.rank, function() {
    return "Error in conv3d: filter must be rank 5, but got rank " + u2.rank + ".";
  }), g(s2.shape[4] === u2.shape[3], function() {
    return "Error in conv3d: depth of input (" + s2.shape[4] + ") must match input depth for filter " + u2.shape[3] + ".";
  }), g(function(t3, e3) {
    return Sc(t3) || Sc(e3);
  }(n2, a2), function() {
    return "Error in conv3D: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + a2 + "'";
  }), g("NDHWC" === o2, function() {
    return "Error in conv3d: got dataFormat of " + o2 + " but only NDHWC is currently supported.";
  });
  var l2 = yo(s2.shape, u2.shape, n2, a2, r2), h2 = Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.conv3d(s2, u2, l2);
    return e3([s2, u2]), n3;
  }, {x: s2, $filter: u2}, function(t3, e3) {
    g(Sc(a2), function() {
      return "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + a2 + "'";
    });
    var o3 = e3[0], i3 = e3[1];
    return {x: function() {
      return Ac(o3.shape, t3, i3, n2, r2);
    }, $filter: function() {
      return function(t4, e4, n3, r3, o4) {
        var a3 = t4;
        4 === t4.rank && (a3 = t4.as5D(1, t4.shape[0], t4.shape[1], t4.shape[2], t4.shape[3]));
        var i4 = e4;
        4 === i4.rank && (i4 = e4.as5D(1, e4.shape[0], e4.shape[1], e4.shape[2], e4.shape[3])), g(5 === a3.rank, function() {
          return "Error in conv3dDerFilter: input must be rank 5, but got shape " + a3.shape + ".";
        }), g(5 === i4.rank, function() {
          return "Error in conv3dDerFilter: dy must be rank 5, but got shape " + i4.shape + ".";
        }), g(5 === n3.length, function() {
          return "Error in conv3dDerFilter: filterShape must be length 5, but got " + n3 + ".";
        }), g(a3.shape[4] === n3[3], function() {
          return "Error in conv3dDerFilter: depth of input " + a3.shape[4] + ") must match input depth in filter (" + n3[3] + ".";
        }), g(i4.shape[4] === n3[4], function() {
          return "Error in conv3dDerFilter: depth of dy (" + i4.shape[4] + ") must match output depth for filter (" + n3[4] + ").";
        });
        var u3 = yo(a3.shape, n3, r3, 1, o4);
        return Nt.runKernelFunc(function(t5) {
          return t5.conv3dDerFilter(a3, i4, u3);
        }, {x5D: a3, dy5D: i4});
      }(o3, t3, i3.shape, n2, r2);
    }};
  });
  return c2 ? h2.as4D(h2.shape[1], h2.shape[2], h2.shape[3], h2.shape[4]) : h2;
}});
var Fc = Cn({conv2dDerFilter_: function(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === a2 && (a2 = "NHWC");
  var u2 = t2;
  3 === t2.rank && (u2 = t2.as4D(1, t2.shape[0], t2.shape[1], t2.shape[2]));
  var s2 = e2;
  3 === s2.rank && (s2 = e2.as4D(1, e2.shape[0], e2.shape[1], e2.shape[2])), g(4 === u2.rank, function() {
    return "Error in conv2dDerFilter: input must be rank 4, but got shape " + u2.shape + ".";
  }), g(4 === s2.rank, function() {
    return "Error in conv2dDerFilter: dy must be rank 4, but got shape " + s2.shape + ".";
  }), g(4 === n2.length, function() {
    return "Error in conv2dDerFilter: filterShape must be length 4, but got " + n2 + ".";
  });
  var c2 = "NHWC" === a2 ? u2.shape[3] : u2.shape[1], l2 = "NHWC" === a2 ? s2.shape[3] : s2.shape[1];
  g(c2 === n2[2], function() {
    return "Error in conv2dDerFilter: depth of input " + c2 + ") must match input depth in filter (" + n2[2] + ".";
  }), g(l2 === n2[3], function() {
    return "Error in conv2dDerFilter: depth of dy (" + l2 + ") must match output depth for filter (" + n2[3] + ").";
  }), null != i2 && g(E(o2), function() {
    return "Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + o2 + ".";
  });
  var h2 = ko(a2), f2 = go(u2.shape, n2, r2, 1, o2, i2, false, h2);
  return Nt.runKernelFunc(function(t3) {
    return t3.conv2dDerFilter(u2, s2, f2);
  }, {x4D: u2, dy4D: s2});
}});
var Oc = Cn({conv2dDerInput_: kc});
var _c = Cn({depthwiseConv2d_: function(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === o2 && (o2 = "NHWC"), void 0 === a2 && (a2 = [1, 1]);
  var u2 = ln(t2, "x", "depthwiseConv2d"), s2 = ln(e2, "filter", "depthwiseConv2d"), c2 = u2, l2 = false;
  3 === u2.rank && (l2 = true, c2 = u2.as4D(1, u2.shape[0], u2.shape[1], u2.shape[2])), g(4 === c2.rank, function() {
    return "Error in depthwiseConv2d: input must be rank 4, but got rank " + c2.rank + ".";
  }), g(4 === s2.rank, function() {
    return "Error in depthwiseConv2d: filter must be rank 4, but got rank " + s2.rank + ".";
  }), g(c2.shape[3] === s2.shape[2], function() {
    return "Error in depthwiseConv2d: number of input channels (" + c2.shape[3] + ") must match the inChannels dimension in filter " + s2.shape[2] + ".";
  }), null == a2 && (a2 = [1, 1]), g(Io(n2, a2), function() {
    return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + a2 + "'";
  }), null != i2 && g(E(r2), function() {
    return "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + r2 + ".";
  });
  var h2 = go(c2.shape, s2.shape, n2, a2, r2, i2, true), f2 = Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.depthwiseConv2D(c2, s2, h2);
    return e3([c2, s2]), n3;
  }, {x: c2, $filter: s2}, function(t3, e3) {
    g(Ro(a2), function() {
      return "Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + a2 + "'";
    });
    var n3 = e3[0], r3 = e3[1];
    return {x: function() {
      return Mc(n3.shape, t3, r3, h2);
    }, $filter: function() {
      return Bc(n3, t3, r3.shape, h2);
    }};
  });
  return l2 ? f2.as3D(f2.shape[1], f2.shape[2], f2.shape[3]) : f2;
}});
var Mc = Cn({depthwiseConv2dDerInput_: function(t2, e2, n2, r2) {
  var o2 = e2, a2 = false;
  3 === e2.rank && (a2 = true, o2 = e2.as4D(1, e2.shape[0], e2.shape[1], e2.shape[2]));
  var i2 = Nt.runKernelFunc(function(t3) {
    return t3.depthwiseConv2DDerInput(o2, n2, r2);
  }, {dy4D: o2});
  return a2 ? i2.as3D(i2.shape[1], i2.shape[2], i2.shape[3]) : i2;
}});
var Bc = Cn({depthwiseConv2dDerFilter_: function(t2, e2, n2, r2) {
  var o2 = t2;
  3 === t2.rank && (o2 = t2.as4D(1, t2.shape[0], t2.shape[1], t2.shape[2]));
  var a2 = e2;
  return 3 === a2.rank && (a2 = e2.as4D(1, e2.shape[0], e2.shape[1], e2.shape[2])), Nt.runKernelFunc(function(t3) {
    return t3.depthwiseConv2DDerFilter(o2, a2, r2);
  }, {x4D: o2, dy4D: a2});
}});
var Pc = Cn({separableConv2d_: function(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === a2 && (a2 = [1, 1]), void 0 === i2 && (i2 = "NHWC");
  var u2 = ln(t2, "x", "separableConv2d"), s2 = ln(e2, "depthwiseFilter", "separableConv2d"), c2 = ln(n2, "pointwiseFilter", "separableConv2d"), l2 = u2, h2 = false;
  if (3 === u2.rank && (h2 = true, l2 = u2.as4D(1, u2.shape[0], u2.shape[1], u2.shape[2])), "NCHW" === i2)
    throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
  g(4 === l2.rank, function() {
    return "Error in separableConv2d: input must be rank 4, but got rank " + l2.rank + ".";
  }), g(4 === s2.rank, function() {
    return "Error in separableConv2d: depthwise filter must be rank 4, but got rank " + s2.rank + ".";
  }), g(4 === c2.rank, function() {
    return "Error in separableConv2d: pointwise filter must be rank 4, but got rank " + s2.rank + ".";
  }), g(1 === c2.shape[0], function() {
    return "Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got " + c2.shape[0] + ".";
  }), g(1 === c2.shape[1], function() {
    return "Error in separableConv2d: the second dimension of pointwise filter must be 1, but got " + c2.shape[1] + ".";
  });
  var f2 = s2.shape[2], p2 = s2.shape[3];
  g(c2.shape[2] === f2 * p2, function() {
    return "Error in separableConv2d: the third dimension of pointwise filter must be " + f2 * p2 + ", but got " + c2.shape[2] + ".";
  });
  var d2 = _c(l2, s2, r2, o2, i2, a2), v2 = Tc(d2, c2, 1, "valid", i2);
  return h2 ? v2.as3D(v2.shape[1], v2.shape[2], v2.shape[3]) : v2;
}});
var Lc = Cn({conv2dTranspose_: function(t2, e2, n2, r2, o2, a2) {
  return kc(n2, ln(t2, "x", "conv2dTranspose"), ln(e2, "filter", "conv2dTranspose"), r2, o2, "NHWC", a2);
}});
var Wc = Cn({conv3dTranspose_: function(t2, e2, n2, r2, o2) {
  return Ac(n2, ln(t2, "x", "conv3dTranspose"), ln(e2, "filter", "conv3dTranspose"), r2, o2);
}});
var Uc = Cn({matMul_: function(t2, e2, n2, r2) {
  var o2;
  void 0 === n2 && (n2 = false), void 0 === r2 && (r2 = false);
  var a2 = ln(t2, "a", "matMul"), i2 = ln(e2, "b", "matMul");
  o2 = Rt(a2, i2), a2 = o2[0], i2 = o2[1];
  var u2 = n2 ? a2.shape[a2.rank - 2] : a2.shape[a2.rank - 1], s2 = r2 ? i2.shape[i2.rank - 1] : i2.shape[i2.rank - 2], c2 = n2 ? a2.shape[a2.rank - 1] : a2.shape[a2.rank - 2], l2 = r2 ? i2.shape[i2.rank - 2] : i2.shape[i2.rank - 1], h2 = a2.shape.slice(0, -2), f2 = i2.shape.slice(0, -2), p2 = w(h2), d2 = w(f2);
  g(a2.rank >= 2 && i2.rank >= 2 && a2.rank === i2.rank, function() {
    return "Error in matMul: inputs must have the same rank of at least 2, got ranks " + a2.rank + " and " + i2.rank + ".";
  }), g(C(h2, f2), function() {
    return "Error in matMul: outer dimensions (" + h2 + ") and (" + f2 + ") of Tensors with shapes " + a2.shape + " and " + i2.shape + " must match.";
  }), g(u2 === s2, function() {
    return "Error in matMul: inner shapes (" + u2 + ") and (" + s2 + ") of Tensors with shapes " + a2.shape + " and " + i2.shape + " and transposeA=" + n2 + " and transposeB=" + r2 + " must match.";
  });
  var v2 = a2.shape.slice(0, -2).concat([c2, l2]), m2 = n2 ? a2.as3D(p2, u2, c2) : a2.as3D(p2, c2, u2), y2 = r2 ? i2.as3D(d2, l2, s2) : i2.as3D(d2, s2, l2), x2 = {transposeA: n2, transposeB: r2};
  return Nt.runKernelFunc(function(t3, e3) {
    var o3 = t3.batchMatMul(m2, y2, n2, r2);
    return e3([m2, y2]), o3;
  }, {a: m2, b: y2}, function(t3, e3) {
    var o3 = e3, a3 = o3[0], i3 = o3[1];
    return n2 || r2 ? !n2 && r2 ? {a: function() {
      return t3.matMul(i3, false, false);
    }, b: function() {
      return t3.matMul(a3, true, false);
    }} : n2 && !r2 ? {a: function() {
      return i3.matMul(t3, false, true);
    }, b: function() {
      return a3.matMul(t3, false, false);
    }} : {a: function() {
      return i3.matMul(t3, true, true);
    }, b: function() {
      return t3.matMul(a3, true, true);
    }} : {a: function() {
      return t3.matMul(i3, false, true);
    }, b: function() {
      return a3.matMul(t3, true, false);
    }};
  }, "BatchMatMul", x2).reshape(v2);
}});
var Vc = Cn({dot_: function(t2, e2) {
  var n2 = ln(t2, "t1", "dot"), r2 = ln(e2, "t2", "dot");
  g(!(1 !== n2.rank && 2 !== n2.rank || 1 !== r2.rank && 2 !== r2.rank), function() {
    return "Error in dot: inputs must all be rank 1 or 2, but got ranks " + n2.rank + " and " + r2.rank + ".";
  });
  var o2 = 1 === n2.rank ? n2.size : n2.shape[1], a2 = 1 === r2.rank ? r2.size : r2.shape[0];
  return g(o2 === a2, function() {
    return "Error in dot: inner dimensions of inputs must match, but got " + o2 + " and " + a2 + ".";
  }), 1 === n2.rank && 1 === r2.rank ? n2.as2D(1, -1).matMul(r2.as2D(-1, 1)).asScalar() : 1 === n2.rank && 2 === r2.rank ? n2.as2D(1, -1).matMul(r2.as2D(r2.shape[0], r2.shape[1])).as1D() : 2 === n2.rank && 1 === r2.rank ? n2.matMul(r2.as2D(-1, 1)).as1D() : n2.matMul(r2.as2D(r2.shape[0], r2.shape[1]));
}});
var zc = Cn({outerProduct_: function(t2, e2) {
  var n2 = ln(t2, "v1", "outerProduct"), r2 = ln(e2, "v2", "outerProduct");
  return g(1 === n2.rank && 1 === r2.rank, function() {
    return "Error in outerProduct: inputs must be rank 1, but got ranks " + n2.rank + " and " + r2.rank + ".";
  }), n2.as2D(-1, 1).matMul(r2.as2D(1, -1));
}});
var Gc = Cn({reverse_: function(t2, e2) {
  var n2 = ln(t2, "x", "reverse");
  if (0 === n2.rank)
    return n2.clone();
  var r2 = D(e2, n2.shape);
  return Nt.runKernelFunc(function(t3) {
    return t3.reverse(n2, r2);
  }, {$x: n2}, function(t3) {
    return {$x: function() {
      return t3.reverse(r2);
    }};
  }).reshapeAs(n2);
}});
var Hc = Cn({reverse1d_: function(t2) {
  var e2 = ln(t2, "x", "reverse");
  return g(1 === e2.rank, function() {
    return "Error in reverse1D: x must be rank 1 but got rank " + e2.rank + ".";
  }), Gc(e2, 0);
}});
var qc = Cn({reverse2d_: function(t2, e2) {
  var n2 = ln(t2, "x", "reverse");
  return g(2 === n2.rank, function() {
    return "Error in reverse2D: x must be rank 2 but got rank " + n2.rank + ".";
  }), Gc(n2, e2);
}});
var Kc = Cn({reverse3d_: function(t2, e2) {
  var n2 = ln(t2, "x", "reverse");
  return g(3 === n2.rank, function() {
    return "Error in reverse3D: x must be rank 3 but got rank " + n2.rank + ".";
  }), Gc(n2, e2);
}});
var jc = Cn({reverse4d_: function(t2, e2) {
  var n2 = ln(t2, "x", "reverse");
  return g(4 === n2.rank, function() {
    return "Error in reverse4D: x must be rank 4 but got rank " + n2.rank + ".";
  }), Gc(n2, e2);
}});
function Xc(t2, e2, n2, r2, o2, a2) {
  var i2 = ln(t2, "x", "maxPool"), u2 = i2, s2 = false;
  3 === i2.rank && (s2 = true, u2 = i2.as4D(1, i2.shape[0], i2.shape[1], i2.shape[2])), null == r2 && (r2 = [1, 1]), g(4 === u2.rank, function() {
    return "Error in maxPool: input must be rank 4 but got rank " + u2.rank + ".";
  }), g(Io(n2, r2), function() {
    return "Error in maxPool: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + r2 + "'";
  }), null != a2 && g(E(o2), function() {
    return "Error in maxPool: pad must be an integer when using, dimRoundingMode " + a2 + " but got pad " + o2 + ".";
  });
  var c2 = vo(u2.shape, e2, n2, r2, o2, a2), l2 = Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.maxPool(u2, c2);
    return e3([u2, n3]), n3;
  }, {x: u2}, function(t3, a3) {
    var i3 = a3[0], u3 = a3[1];
    return {x: function() {
      return function(t4, e3, n3, r3, o3, a4, i4, u4) {
        var s3 = ln(t4, "dy", "maxPoolBackprop"), c3 = ln(e3, "input", "maxPoolBackprop"), l3 = ln(n3, "output", "maxPoolBackprop");
        g(c3.rank === s3.rank, function() {
          return "Rank of input (" + c3.rank + ") does not match rank of dy (" + s3.rank + ")";
        }), null == a4 && (a4 = [1, 1]), g(Io(o3, a4), function() {
          return "Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides " + o3 + " and dilations '" + a4 + "'";
        }), g(4 === s3.rank, function() {
          return "Error in maxPoolBackprop: dy must be rank 4 but got rank " + s3.rank + ".";
        }), g(4 === c3.rank, function() {
          return "Error in maxPoolBackprop: input must be rank 4 but got rank " + c3.rank + ".";
        }), null != u4 && g(E(i4), function() {
          return "Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode " + u4 + " but got pad " + i4 + ".";
        });
        var h2 = vo(c3.shape, r3, o3, a4, i4, u4);
        return Nt.runKernelFunc(function(t5) {
          return t5.maxPoolBackprop(s3, c3, l3, h2);
        }, {$dy: s3, $input: c3});
      }(t3, i3, u3, e2, n2, r2, o2);
    }};
  });
  return s2 ? l2.as3D(l2.shape[1], l2.shape[2], l2.shape[3]) : l2;
}
function $c(t2, e2, n2, r2, o2, a2) {
  var i2 = ln(t2, "x", "avgPool", "float32");
  null == r2 && (r2 = [1, 1]), g(Io(n2, r2), function() {
    return "Error in avgPool: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + r2 + "'";
  });
  var u2 = i2, s2 = false;
  3 === i2.rank && (s2 = true, u2 = i2.as4D(1, i2.shape[0], i2.shape[1], i2.shape[2])), g(4 === u2.rank, function() {
    return "Error in avgPool: x must be rank 4 but got rank " + u2.rank + ".";
  }), null != a2 && g(E(o2), function() {
    return "Error in avgPool: pad must be an integer when using, dimRoundingMode " + a2 + " but got pad " + o2 + ".";
  });
  var c2 = vo(u2.shape, e2, n2, r2, o2, a2), l2 = Nt.runKernelFunc(function(t3) {
    return t3.avgPool(u2, c2);
  }, {x: u2}, function(t3) {
    return {x: function() {
      return function(t4, e3, n3, r3, o3, a3) {
        var i3 = ln(t4, "dy", "avgPoolBackprop"), u3 = ln(e3, "input", "avgPoolBackprop");
        g(u3.rank === i3.rank, function() {
          return "Rank of input (" + u3.rank + ") does not match rank of dy (" + i3.rank + ")";
        }), null == o3 && (o3 = [1, 1]), g(Io(r3, o3), function() {
          return "Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides " + r3 + " and dilations '" + o3 + "'";
        });
        var s3 = u3, c3 = i3, l3 = false;
        3 === u3.rank && (l3 = true, s3 = u3.as4D(1, u3.shape[0], u3.shape[1], u3.shape[2]), c3 = i3.as4D(1, i3.shape[0], i3.shape[1], i3.shape[2])), g(4 === c3.rank, function() {
          return "Error in avgPoolBackprop: dy must be rank 4 but got rank " + c3.rank + ".";
        }), g(4 === s3.rank, function() {
          return "Error in avgPoolBackprop: input must be rank 4 but got rank " + s3.rank + ".";
        });
        var h2 = vo(s3.shape, n3, r3, o3, a3), f2 = Nt.runKernelFunc(function(t5) {
          return t5.avgPoolBackprop(c3, s3, h2);
        }, {dy4D: c3, input4D: s3});
        return l3 ? f2.as3D(f2.shape[1], f2.shape[2], f2.shape[3]) : f2;
      }(t3, u2, e2, n2, r2, o2);
    }};
  });
  return l2 = l2.cast(i2.dtype), s2 ? l2.as3D(l2.shape[1], l2.shape[2], l2.shape[3]) : l2;
}
var Yc = Cn({maxPool_: function(t2, e2, n2, r2, o2) {
  return Xc(t2, e2, n2, 1, r2, o2);
}});
var Qc = Cn({avgPool_: function(t2, e2, n2, r2, o2) {
  return $c(t2, e2, n2, 1, r2, o2);
}});
var Jc = Cn({pool_: function(t2, e2, n2, r2, o2, a2) {
  null == o2 && (o2 = [1, 1]), null == a2 && (a2 = 1), 0 === r2 && (r2 = "valid");
  var i2 = ln(t2, "x", "maxPool"), u2 = i2, s2 = false;
  3 === i2.rank && (s2 = true, u2 = i2.as4D(1, i2.shape[0], i2.shape[1], i2.shape[2])), g(Io(a2, o2), function() {
    return "Error in pool: Either strides or dilations must be 1. Got strides " + a2 + " and dilations '" + o2 + "'";
  });
  var c2, l2 = vo(u2.shape, e2, a2, o2, r2), h2 = [l2.dilationHeight, l2.dilationWidth];
  c2 = "same" === r2 ? function(t3, e3) {
    var n3 = t3.map(function(t4, n4) {
      return t4 + (t4 - 1) * (e3[n4] - 1);
    }).map(function(t4) {
      return t4 - 1;
    }), r3 = n3.map(function(t4) {
      return Math.floor(t4 / 2);
    }), o3 = n3.map(function(t4, e4) {
      return t4 - r3[e4];
    });
    return n3.map(function(t4, e4) {
      return [r3[e4], o3[e4]];
    });
  }([l2.filterHeight, l2.filterWidth], h2) : [[0, 0], [0, 0]];
  var f2 = 1 === h2[0] && 1 === h2[1], p2 = function(t3, e3, n3) {
    var r3 = n3.map(function(t4) {
      return t4[0];
    }), o3 = n3.map(function(t4) {
      return t4[1];
    }), a3 = t3.concat(r3, o3), i3 = e3.map(function(t4, e4) {
      return (t4 - a3[e4] % t4) % t4;
    }), u3 = o3.map(function(t4, e4) {
      return t4 + i3[e4];
    }), s3 = e3.map(function(t4, e4) {
      return [r3[e4], u3[e4]];
    }), c3 = e3.map(function(t4, e4) {
      return [0, i3[e4]];
    });
    return [s3, c3];
  }([l2.inHeight, l2.inWidth], h2, c2), d2 = p2[0], v2 = p2[1], m2 = f2 ? r2 : "valid", y2 = f2 ? u2 : Ar(u2, h2, d2), x2 = ("avg" === n2 ? function() {
    return $c(y2, e2, a2, 1, m2);
  } : function() {
    return Xc(y2, e2, a2, 1, m2);
  })(), b2 = f2 ? x2 : cr(x2, h2, v2);
  return s2 ? b2.as3D(b2.shape[1], b2.shape[2], b2.shape[3]) : b2;
}});
var Zc = Cn({maxPool3d_: function(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === a2 && (a2 = "NDHWC");
  var u2 = ln(t2, "x", "maxPool3d"), s2 = u2, c2 = false;
  4 === u2.rank && (c2 = true, s2 = u2.as5D(1, u2.shape[0], u2.shape[1], u2.shape[2], u2.shape[3])), null == i2 && (i2 = [1, 1, 1]), g(5 === s2.rank, function() {
    return "Error in maxPool3d: x must be rank 5 but got rank " + s2.rank + ".";
  }), g("NDHWC" === a2, function() {
    return "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of " + a2;
  }), g(Io(n2, i2), function() {
    return "Error in maxPool3d: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + i2 + "'";
  }), null != o2 && g(E(r2), function() {
    return "Error in maxPool3d: pad must be an integer when using, dimRoundingMode " + o2 + " but got pad " + r2 + ".";
  });
  var l2 = mo(s2.shape, e2, n2, i2, r2, o2, a2), h2 = Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.maxPool3d(s2, l2);
    return e3([s2, n3]), n3;
  }, {x: s2}, function(t3, a3) {
    var u3 = a3[0], s3 = a3[1];
    return {x: function() {
      return function(t4, e3, n3, r3, o3, a4, i3, u4) {
        var s4 = ln(t4, "dy", "maxPool3dBackprop"), c3 = ln(e3, "input", "maxPool3dBackprop"), l3 = ln(n3, "output", "maxPool3dBackprop"), h3 = s4, f2 = c3, p2 = l3, d2 = false;
        4 === c3.rank && (d2 = true, h3 = s4.as5D(1, s4.shape[0], s4.shape[1], s4.shape[2], s4.shape[3]), f2 = c3.as5D(1, c3.shape[0], c3.shape[1], c3.shape[2], c3.shape[3]), p2 = l3.as5D(1, l3.shape[0], l3.shape[1], l3.shape[2], l3.shape[3])), g(5 === h3.rank, function() {
          return "Error in maxPool3dBackprop: dy must be rank 5 but got rank " + h3.rank + ".";
        }), g(5 === f2.rank, function() {
          return "Error in maxPool3dBackprop: input must be rank 5 but got rank " + f2.rank + ".";
        }), g(5 === p2.rank, function() {
          return "Error in maxPool3dBackprop: output must be rank 5 but got rank " + p2.rank + ".";
        }), null == a4 && (a4 = [1, 1, 1]), g(Io(o3, a4), function() {
          return "Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides " + o3 + " and dilations '" + a4 + "'";
        }), null != u4 && g(E(i3), function() {
          return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + u4 + " but got pad " + i3 + ".";
        });
        var v2 = mo(f2.shape, r3, o3, a4, i3, u4), m2 = Nt.runKernelFunc(function(t5) {
          return t5.maxPool3dBackprop(h3, f2, p2, v2);
        }, {dy5D: h3, input5D: f2});
        return d2 ? m2.as4D(m2.shape[1], m2.shape[2], m2.shape[3], m2.shape[4]) : m2;
      }(t3, u3, s3, e2, n2, i2, r2, o2);
    }};
  });
  return c2 ? h2.as4D(h2.shape[1], h2.shape[2], h2.shape[3], h2.shape[4]) : h2;
}});
var tl = Cn({avgPool3d_: function(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === a2 && (a2 = "NDHWC");
  var u2 = ln(t2, "x", "avgPool3d", "float32"), s2 = u2, c2 = false;
  4 === u2.rank && (c2 = true, s2 = u2.as5D(1, u2.shape[0], u2.shape[1], u2.shape[2], u2.shape[3])), null == i2 && (i2 = [1, 1, 1]), g(5 === s2.rank, function() {
    return "Error in avgPool3d: x must be rank 5 but got rank " + s2.rank + ".";
  }), g("NDHWC" === a2, function() {
    return "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of " + a2;
  }), g(Io(n2, i2), function() {
    return "Error in avgPool3d: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + i2 + "'";
  }), null != o2 && g(E(r2), function() {
    return "Error in avgPool3d: pad must be an integer when using, dimRoundingMode " + o2 + " but got pad " + r2 + ".";
  });
  var l2 = mo(s2.shape, e2, n2, i2, r2, o2, a2), h2 = Nt.runKernelFunc(function(t3) {
    return t3.avgPool3d(s2, l2);
  }, {x: s2}, function(t3) {
    return {x: function() {
      return function(t4, e3, n3, r3, o3, a3, i3) {
        var u3 = ln(t4, "dy", "avgPool3dBackprop"), s3 = ln(e3, "input", "avgPool3dBackprop"), c3 = u3, l3 = s3, h3 = false;
        4 === s3.rank && (h3 = true, c3 = u3.as5D(1, u3.shape[0], u3.shape[1], u3.shape[2], u3.shape[3]), l3 = s3.as5D(1, s3.shape[0], s3.shape[1], s3.shape[2], s3.shape[3])), g(5 === c3.rank, function() {
          return "Error in avgPool3dBackprop: dy must be rank 5 but got rank " + c3.rank + ".";
        }), g(5 === l3.rank, function() {
          return "Error in avgPool3dBackprop: input must be rank 5 but got rank " + l3.rank + ".";
        }), null == o3 && (o3 = [1, 1, 1]), g(Io(r3, o3), function() {
          return "Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides " + r3 + " and dilations '" + o3 + "'";
        }), null != i3 && g(E(a3), function() {
          return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + i3 + " but got pad " + a3 + ".";
        });
        var f2 = mo(l3.shape, n3, r3, o3, a3, i3), p2 = Nt.runKernelFunc(function(t5) {
          return t5.avgPool3dBackprop(c3, l3, f2);
        }, {dy5D: c3, input5D: l3});
        return h3 ? p2.as4D(p2.shape[1], p2.shape[2], p2.shape[3], p2.shape[4]) : p2;
      }(t3, s2, e2, n2, i2, r2, o2);
    }};
  });
  return h2 = h2.cast(s2.dtype), c2 ? h2.as4D(h2.shape[1], h2.shape[2], h2.shape[3], h2.shape[4]) : h2;
}});
var el = Cn({slice_: function(t2, e2, n2) {
  var r2, o2, a2 = ln(t2, "x", "slice");
  if (0 === a2.rank)
    throw new Error("Slicing scalar is not possible");
  (r2 = "number" == typeof e2 ? [e2].concat(new Array(a2.rank - 1).fill(0)) : e2.length < a2.rank ? e2.concat(new Array(a2.rank - e2.length).fill(0)) : e2.slice()).forEach(function(t3) {
    g(-1 !== t3, function() {
      return "slice() does not support negative begin indexing.";
    });
  }), o2 = (o2 = null == n2 ? new Array(a2.rank).fill(-1) : "number" == typeof n2 ? [n2].concat(new Array(a2.rank - 1).fill(-1)) : n2.length < a2.rank ? n2.concat(new Array(a2.rank - n2.length).fill(-1)) : n2).map(function(t3, e3) {
    return t3 >= 0 ? t3 : (g(-1 === t3, function() {
      return "Negative size values should be exactly -1 but got " + t3 + " for the slice() size at index " + e3 + ".";
    }), a2.shape[e3] - r2[e3]);
  }), qr(a2, r2, o2);
  var i2 = a2.shape, u2 = {begin: r2, size: o2};
  return Nt.runKernelFunc(function(t3) {
    return t3.slice(a2, r2, o2);
  }, {x: a2}, function(t3) {
    for (var e3 = [], n3 = 0; n3 < t3.rank; n3++)
      e3.push([r2[n3], i2[n3] - r2[n3] - o2[n3]]);
    return {x: function() {
      return t3.pad(e3);
    }};
  }, "Slice", u2);
}});
var nl = Cn({slice1d_: function(t2, e2, n2) {
  var r2 = ln(t2, "x", "slice1d");
  return g(1 === r2.rank, function() {
    return "slice1d expects a rank-1 tensor, but got a rank-" + r2.rank + " tensor";
  }), el(r2, [e2], [n2]);
}});
var rl = Cn({slice2d_: function(t2, e2, n2) {
  var r2 = ln(t2, "x", "slice2d");
  return g(2 === r2.rank, function() {
    return "slice2d expects a rank-2 tensor, but got a rank-" + r2.rank + " tensor";
  }), el(r2, e2, n2);
}});
var ol = Cn({slice3d_: function(t2, e2, n2) {
  var r2 = ln(t2, "x", "slice3d");
  return g(3 === r2.rank, function() {
    return "slice3d expects a rank-3 tensor, but got a rank-" + r2.rank + " tensor";
  }), el(r2, e2, n2);
}});
var al = Cn({slice4d_: function(t2, e2, n2) {
  var r2 = ln(t2, "x", "slice4d");
  return g(4 === r2.rank, function() {
    return "slice4d expects a rank-4 tensor, but got a rank-" + r2.rank + " tensor";
  }), el(r2, e2, n2);
}});
function il(t2, e2, n2, r2, o2) {
  return e2.rank < n2.rank && (e2 = e2.reshape(vn(e2.shape, r2))), t2.rank < n2.rank && (t2 = t2.reshape(vn(t2.shape, r2))), {x: function() {
    var r3 = t2.mul(n2.equal(e2).cast(t2.dtype));
    return null == o2 ? r3 : r3.transpose(o2);
  }};
}
var ul = Cn({all_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "x", "all", "bool"), o2 = D(e2, r2.shape), a2 = o2, i2 = gn(a2, r2.rank);
  null != i2 && (r2 = r2.transpose(i2), a2 = xn(a2.length, r2.rank));
  var u2 = Nt.runKernelFunc(function(t3) {
    return t3.all(r2, a2);
  }, {$x: r2});
  if (n2) {
    var s2 = vn(u2.shape, o2);
    return u2.reshape(s2);
  }
  return u2;
}});
var sl = Cn({any_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "x", "any", "bool"), o2 = D(e2, r2.shape), a2 = o2, i2 = gn(a2, r2.rank);
  null != i2 && (r2 = r2.transpose(i2), a2 = xn(a2.length, r2.rank));
  var u2 = Nt.runKernelFunc(function(t3) {
    return t3.any(r2, a2);
  }, {$x: r2});
  if (n2) {
    var s2 = vn(u2.shape, o2);
    return u2.reshape(s2);
  }
  return u2;
}});
var cl = Cn({argMax_: function(t2, e2) {
  void 0 === e2 && (e2 = 0);
  var n2 = ln(t2, "x", "argMax");
  null == e2 && (e2 = 0);
  var r2 = D(e2, n2.shape), o2 = gn(r2, n2.rank);
  return null != o2 && (n2 = n2.transpose(o2), r2 = xn(r2.length, n2.rank)), Nt.runKernelFunc(function(t3, e3) {
    var o3 = t3.argMax(n2, r2[0]);
    return e3([n2]), o3;
  }, {$x: n2}, function(t3, e3) {
    var n3 = e3[0];
    return {$x: function() {
      return zn(n3);
    }};
  });
}});
var ll = Cn({argMin_: function(t2, e2) {
  void 0 === e2 && (e2 = 0);
  var n2 = ln(t2, "x", "argMin");
  null == e2 && (e2 = 0);
  var r2 = D(e2, n2.shape), o2 = gn(r2, n2.rank);
  return null != o2 && (n2 = n2.transpose(o2), r2 = xn(r2.length, n2.rank)), Nt.runKernelFunc(function(t3, e3) {
    var o3 = t3.argMin(n2, r2[0]);
    return e3([n2]), o3;
  }, {$x: n2}, function(t3, e3) {
    var n3 = e3[0];
    return {$x: function() {
      return zn(n3);
    }};
  });
}});
var hl = Cn({logSumExp_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "x", "logSumExp"), o2 = D(e2, r2.shape), a2 = r2.max(o2, true), i2 = r2.sub(a2).exp().sum(o2).log(), u2 = a2.reshape(i2.shape).add(i2);
  if (n2) {
    var s2 = vn(u2.shape, o2);
    return u2.reshape(s2);
  }
  return u2;
}});
var fl = Cn({max_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "x", "max"), o2 = r2, a2 = D(e2, r2.shape), i2 = a2, u2 = gn(i2, r2.rank);
  null != u2 && (r2 = r2.transpose(u2), i2 = xn(i2.length, r2.rank));
  var s2 = [r2], c2 = Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.max(r2, i2);
    return e3([o2, n3]), n3;
  }, {x: r2}, function(t3, e3) {
    return il(t3, e3[1], e3[0], a2, u2);
  }, "Max", {axes: i2}, s2, [true]);
  if (n2) {
    var l2 = vn(c2.shape, a2);
    c2 = c2.reshape(l2);
  }
  return c2;
}});
var pl = Cn({mean_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "x", "mean"), o2 = D(e2, r2.shape), a2 = w(dn(r2.shape, o2)[1]);
  return oo(function(t3) {
    var r3 = An(a2);
    return {value: (r3.dtype === t3.dtype ? t3 : t3.cast(r3.dtype)).div(r3).sum(e2, n2), gradFunc: function(e3) {
      var n3 = t3.shape.slice();
      return o2.forEach(function(t4) {
        n3[t4] = 1;
      }), e3.reshape(n3).mul(Bn(t3.shape, "float32")).div(a2);
    }};
  })(r2);
}});
var dl = Cn({min_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "x", "min"), o2 = r2, a2 = D(e2, r2.shape), i2 = a2, u2 = gn(i2, r2.rank);
  null != u2 && (r2 = r2.transpose(u2), i2 = xn(i2.length, r2.rank));
  var s2 = [r2], c2 = Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.min(r2, i2);
    return e3([o2, n3]), n3;
  }, {x: r2}, function(t3, e3) {
    return il(t3, e3[1], e3[0], a2, u2);
  }, "Min", {axes: i2}, s2, [true]);
  if (n2) {
    var l2 = vn(c2.shape, a2);
    c2 = c2.reshape(l2);
  }
  return c2;
}});
var vl = Cn({moments_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
  var r2 = D(e2, (t2 = ln(t2, "x", "moments")).shape), o2 = t2.mean(r2, n2), a2 = o2.shape;
  n2 || (a2 = vn(o2.shape, r2));
  var i2 = t2.toFloat().sub(o2.reshape(a2)).square();
  return {mean: o2, variance: i2.mean(r2, n2)};
}});
var ml = Cn({sum_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "x", "sum");
  "bool" === r2.dtype && (r2 = r2.toInt());
  var o2 = D(e2, r2.shape);
  return oo(function(t3) {
    var e3 = gn(o2, t3.rank), r3 = o2, a2 = t3;
    null != e3 && (a2 = t3.transpose(e3), r3 = xn(r3.length, t3.rank));
    var i2 = Nt.runKernelFunc(function(t4) {
      return t4.sum(a2, r3);
    }, {permutedX: a2});
    if (n2) {
      var u2 = vn(i2.shape, o2);
      i2 = i2.reshape(u2);
    }
    return {value: i2, gradFunc: function(e4) {
      var n3 = t3.shape.slice();
      return o2.forEach(function(t4) {
        n3[t4] = 1;
      }), e4.reshape(n3).mul(Bn(t3.shape, "float32"));
    }};
  })(r2);
}});
var gl = Cn({prod_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "x", "prod");
  "bool" === r2.dtype && (r2 = r2.toInt());
  var o2 = D(e2, r2.shape), a2 = gn(o2, r2.rank), i2 = o2, u2 = r2;
  null != a2 && (u2 = r2.transpose(a2), i2 = xn(i2.length, r2.rank));
  var s2 = Nt.runKernelFunc(function(t3) {
    return t3.prod(u2, i2);
  }, {permutedX: u2});
  if (n2) {
    var c2 = vn(s2.shape, o2);
    s2 = s2.reshape(c2);
  }
  return s2;
}});
var yl = Cn({elu_: function(t2) {
  var e2 = ln(t2, "x", "elu");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.elu(e2);
    return n2([r2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return Nt.runKernelFunc(function(e4) {
        return e4.eluDer(t3, n2);
      }, {dy: t3, y: n2});
    }};
  });
}});
var xl = Cn({leakyRelu_: function(t2, e2) {
  void 0 === e2 && (e2 = 0.2);
  var n2 = ln(t2, "x", "leakyRelu");
  return $s(An(e2).mul(n2), n2);
}});
var bl = Cn({prelu_: function(t2, e2) {
  var n2 = ln(t2, "x", "prelu"), r2 = ln(e2, "alpha", "prelu");
  return Nt.runKernelFunc(function(t3, e3) {
    var o2 = t3.prelu(n2, r2);
    return e3([n2, r2]), o2;
  }, {x: n2, alpha: r2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1], o2 = n3.greater(0);
    return {x: function() {
      return Ws(o2, t3, t3.mul(r3));
    }, alpha: function() {
      var e4 = Ws(o2, zn(t3), t3.mul(n3)), a2 = fo(r3.shape, t3.shape);
      return a2.length > 0 && (e4 = e4.sum(a2)), e4.reshape(r3.shape);
    }};
  }, "Prelu");
}});
var wl = Cn({relu_: function(t2) {
  var e2 = ln(t2, "x", "relu");
  return "bool" === e2.dtype ? e2.toInt() : Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.relu(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.mulStrict(n2.step().toFloat());
    }};
  });
}});
var Cl = Cn({relu6_: function(t2) {
  var e2 = ln(t2, "x", "relu6");
  return "bool" === e2.dtype ? e2.toInt() : Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.relu6(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0], r2 = n2.lessEqual(6).mul(n2.step());
    return {$x: function() {
      return t3.mulStrict(r2.toFloat());
    }};
  });
}});
var El = Cn({selu_: function(t2) {
  var e2 = ln(t2, "x", "selu");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.selu(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      var e4 = n2.greater(An(0)), r2 = An(iu), o2 = An(uu), a2 = t3.mul(o2), i2 = t3.mul(r2).mul(n2.toFloat().exp());
      return Ws(e4, a2, i2);
    }};
  });
}});
var Rl = Cn({transpose_: function(t2, e2) {
  var n2 = ln(t2, "x", "transpose");
  if (null == e2 && (e2 = n2.shape.map(function(t3, e3) {
    return e3;
  }).reverse()), g(n2.rank === e2.length, function() {
    return "Error in transpose: rank of input " + n2.rank + " must match length of perm " + e2 + ".";
  }), e2.forEach(function(t3) {
    g(t3 >= 0 && t3 < n2.rank, function() {
      return "All entries in 'perm' must be between 0 and " + (n2.rank - 1) + " but got " + e2;
    });
  }), n2.rank <= 1)
    return n2.clone();
  var r2 = {perm: e2};
  return Nt.runKernelFunc(function(t3) {
    return t3.transpose(n2, e2);
  }, {x: n2}, function(t3) {
    var n3 = yn(e2);
    return {x: function() {
      return t3.transpose(n3);
    }};
  }, "Transpose", r2);
}});
var Il = Cn({localResponseNormalization_: function(t2, e2, n2, r2, o2) {
  void 0 === e2 && (e2 = 5), void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = 1), void 0 === o2 && (o2 = 0.5);
  var a2 = ln(t2, "x", "localResponseNormalization");
  g(4 === a2.rank || 3 === a2.rank, function() {
    return "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " + a2.rank + ".";
  }), g(E(e2), function() {
    return "Error in localResponseNormalization: depthRadius must be an integer but got depthRadius " + e2 + ".";
  });
  var i2 = a2, u2 = false;
  3 === a2.rank && (u2 = true, i2 = a2.as4D(1, a2.shape[0], a2.shape[1], a2.shape[2]));
  var s2 = Nt.runKernelFunc(function(t3, a3) {
    var u3 = t3.localResponseNormalization4D(i2, e2, n2, r2, o2);
    return a3([i2, u3]), u3;
  }, {x4D: i2}, function(t3, a3) {
    var i3 = a3[0], u3 = a3[1];
    return {x4D: function() {
      return Nt.runKernelFunc(function(a4) {
        return a4.LRNGrad(t3, i3, u3, e2, n2, r2, o2);
      }, {});
    }};
  });
  return u2 ? s2.as3D(s2.shape[1], s2.shape[2], s2.shape[3]) : s2;
}});
var kl = Cn({norm_: function(t2, e2, n2, r2) {
  void 0 === e2 && (e2 = "euclidean"), void 0 === n2 && (n2 = null), void 0 === r2 && (r2 = false);
  var o2 = function t3(e3, n3, r3) {
    if (void 0 === r3 && (r3 = null), 0 === e3.rank)
      return e3.abs();
    if (1 !== e3.rank && null === r3)
      return t3(e3.reshape([-1]), n3, r3);
    if (1 === e3.rank || "number" == typeof r3 || Array.isArray(r3) && 1 === r3.length) {
      if (1 === n3)
        return e3.abs().sum(r3);
      if (n3 === 1 / 0)
        return e3.abs().max(r3);
      if (n3 === -1 / 0)
        return e3.abs().min(r3);
      if ("euclidean" === n3 || 2 === n3)
        return e3.abs().pow(An(2, "int32")).sum(r3).sqrt();
      throw new Error("Error in norm: invalid ord value: " + n3);
    }
    if (Array.isArray(r3) && 2 === r3.length) {
      if (1 === n3)
        return e3.abs().sum(r3[0]).max(r3[1] - 1);
      if (n3 === 1 / 0)
        return e3.abs().sum(r3[1]).max(r3[0]);
      if (n3 === -1 / 0)
        return e3.abs().sum(r3[1]).min(r3[0]);
      if ("fro" === n3 || "euclidean" === n3)
        return e3.square().sum(r3).sqrt();
      throw new Error("Error in norm: invalid ord value: " + n3);
    }
    throw new Error("Error in norm: invalid axis: " + r3);
  }(t2 = ln(t2, "x", "norm"), e2, n2), a2 = o2.shape;
  if (r2) {
    var i2 = D(n2, t2.shape);
    a2 = vn(o2.shape, i2);
  }
  return o2.reshape(a2);
}});
var Sl = Cn({basicLSTMCell_: function(t2, e2, n2, r2, o2, a2) {
  var i2 = ln(t2, "forgetBias", "basicLSTMCell"), u2 = ln(e2, "lstmKernel", "basicLSTMCell"), s2 = ln(n2, "lstmBias", "basicLSTMCell"), c2 = ln(r2, "data", "basicLSTMCell"), l2 = ln(o2, "c", "basicLSTMCell"), h2 = ln(a2, "h", "basicLSTMCell"), f2 = c2.concat(h2, 1).matMul(u2).add(s2), p2 = f2.shape[0], d2 = f2.shape[1] / 4, v2 = [p2, d2], m2 = f2.slice([0, 0], v2), g2 = f2.slice([0, d2], v2), y2 = f2.slice([0, 2 * d2], v2), x2 = f2.slice([0, 3 * d2], v2), b2 = m2.sigmoid().mulStrict(g2.tanh()).addStrict(l2.mulStrict(i2.add(y2).sigmoid())), w2 = b2.tanh().mulStrict(x2.sigmoid());
  return [b2, w2];
}});
var Al = Cn({multiRNNCell_: function(t2, e2, n2, r2) {
  for (var o2 = ln(e2, "data", "multiRNNCell"), a2 = hn(n2, "c", "multiRNNCell"), i2 = hn(r2, "h", "multiRNNCell"), u2 = o2, s2 = [], c2 = 0; c2 < t2.length; c2++) {
    var l2 = t2[c2](u2, a2[c2], i2[c2]);
    s2.push(l2[0]), s2.push(l2[1]), u2 = l2[1];
  }
  var h2 = [], f2 = [];
  for (c2 = 0; c2 < s2.length; c2 += 2)
    h2.push(s2[c2]), f2.push(s2[c2 + 1]);
  return [h2, f2];
}});
var Dl = Cn({movingAverage_: function(t2, e2, n2, r2, o2) {
  void 0 === o2 && (o2 = true);
  var a2 = ln(t2, "v", "movingAverage"), i2 = ln(e2, "x", "movingAverage"), u2 = ln(n2, "decay", "movingAverage");
  It(a2, i2), g(C(a2.shape, i2.shape), function() {
    return "Shape mismatch in v and x";
  });
  var s2 = An(1), c2 = s2.sub(u2), l2 = i2.sub(a2).mul(c2);
  if (o2) {
    g(null != r2, function() {
      return "When using zeroDebias: true, step is required.";
    });
    var h2 = ln(r2, "step", "movingAverage");
    l2 = l2.div(s2.sub(rc(u2, h2)));
  }
  return a2.add(l2);
}});
var Tl = Cn({stridedSlice_: function(t2, e2, n2, r2, o2, a2, i2, u2, s2) {
  if (void 0 === o2 && (o2 = 0), void 0 === a2 && (a2 = 0), void 0 === i2 && (i2 = 0), void 0 === u2 && (u2 = 0), void 0 === s2 && (s2 = 0), null == r2 && (r2 = new Array(e2.length)), 0 !== i2)
    throw new Error("ellipsis mask is not yet supported");
  var c2 = ln(t2, "x", "stridedSlice"), l2 = Kr(u2), h2 = c2.shape.slice();
  l2.forEach(function(t3) {
    e2[t3] = 0, n2[t3] = 1, h2.splice(t3, 0, 1);
  }), c2 = c2.reshape(h2);
  for (var f2 = 0; f2 < c2.rank; f2++)
    e2[f2] = Xr(o2, e2, r2, c2.shape, f2), n2[f2] = $r(a2, n2, r2, c2.shape, f2), r2[f2] = r2[f2] || 1;
  var p2 = Kr(s2);
  p2.forEach(function(t3) {
    n2[t3] = e2[t3] + 1, r2[t3] = 1;
  });
  var d2 = jr(e2, n2, r2), v2 = d2.filter(function(t3, e3) {
    return -1 === p2.indexOf(e3);
  });
  return r2.every(function(t3) {
    return 1 === t3;
  }) ? el(c2, e2, d2).reshape(v2) : Nt.runKernelFunc(function(t3) {
    return t3.stridedSlice(c2, e2, n2, r2);
  }, {$x: c2}).reshape(v2);
}});
var Nl = Cn({topk_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = 1), void 0 === n2 && (n2 = true);
  var r2 = ln(t2, "x", "topk");
  if (0 === r2.rank)
    throw new Error("topk() expects the input to be of rank 1 or higher");
  var o2 = r2.shape[r2.shape.length - 1];
  if (e2 > o2)
    throw new Error("'k' passed to topk() must be <= the last dimension (" + o2 + ") but got " + e2);
  var a2 = Nt.runKernelFunc(function(t3) {
    return t3.topk(r2, e2, n2);
  }, {$x: r2});
  return {values: a2[0], indices: a2[1]};
}});
var Fl = Cn({scatterND_: function(t2, e2, n2) {
  var r2 = ln(t2, "indices", "scatterND", "int32"), o2 = ln(e2, "updates", "scatterND");
  return Gr(o2, r2, n2), Nt.runKernelFunc(function(t3) {
    return t3.scatterND(r2, o2, n2);
  }, {$indices: r2, $updates: o2});
}});
var Ol = Cn({fft_: function(t2) {
  g("complex64" === t2.dtype, function() {
    return "The dtype for tf.spectral.fft() must be complex64 but got " + t2.dtype + ".";
  });
  var e2 = t2.shape[t2.shape.length - 1], n2 = t2.size / e2, r2 = t2.as2D(n2, e2);
  return Nt.runKernelFunc(function(t3) {
    return t3.fft(r2);
  }, {input: t2}).reshape(t2.shape);
}});
var _l = Cn({ifft_: function(t2) {
  g("complex64" === t2.dtype, function() {
    return "The dtype for tf.spectral.ifft() must be complex64 but got " + t2.dtype + ".";
  });
  var e2 = t2.shape[t2.shape.length - 1], n2 = t2.size / e2, r2 = t2.as2D(n2, e2);
  return Nt.runKernelFunc(function(t3) {
    return t3.ifft(r2);
  }, {input: t2}).reshape(t2.shape);
}});
var Ml = Cn({rfft_: function(t2, e2) {
  g("float32" === t2.dtype, function() {
    return "The dtype for rfft() must be real value but got " + t2.dtype;
  });
  var n2, r2 = t2.shape[t2.shape.length - 1], o2 = t2.size / r2;
  if (null != e2 && e2 < r2) {
    var a2 = t2.shape.map(function(t3) {
      return 0;
    }), i2 = t2.shape.map(function(t3) {
      return t3;
    });
    i2[t2.shape.length - 1] = e2, n2 = t2.slice(a2, i2), r2 = e2;
  } else if (null != e2 && e2 > r2) {
    var u2 = t2.shape.map(function(t3) {
      return t3;
    });
    u2[t2.shape.length - 1] = e2 - r2, n2 = t2.concat(Pn(u2), t2.shape.length - 1), r2 = e2;
  } else
    n2 = t2;
  var s2 = n2.zerosLike(), c2 = En(n2, s2).as2D(o2, r2), l2 = Ol(c2), h2 = Math.floor(r2 / 2) + 1, f2 = Rn(l2), p2 = In(l2), d2 = f2.split([h2, r2 - h2], f2.shape.length - 1), v2 = p2.split([h2, r2 - h2], p2.shape.length - 1), m2 = n2.shape.slice();
  return m2[n2.shape.length - 1] = h2, En(d2[0], v2[0]).reshape(m2);
}});
var Bl = Cn({irfft_: function(t2) {
  var e2 = t2.shape[t2.shape.length - 1], n2 = t2.size / e2;
  if (e2 <= 2) {
    var r2 = t2.as2D(n2, e2), o2 = _l(r2);
    return Rn(o2);
  }
  var a2 = [n2, 2 * (e2 - 1)], i2 = Rn(t2).as2D(n2, e2), u2 = In(t2).as2D(n2, e2), s2 = i2.slice([0, 1], [n2, e2 - 2]).reverse(1), c2 = u2.slice([0, 1], [n2, e2 - 2]).reverse(1).mul(An(-1)), l2 = i2.concat(s2, 1), h2 = u2.concat(c2, 1);
  return r2 = En(l2, h2).as2D(a2[0], a2[1]), o2 = _l(r2), Rn(o2);
}});
var Pl = Object.freeze({fft: Ol, ifft: _l, rfft: Ml, irfft: Bl});
var Ll = Cn({sparseToDense_: function(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = 0);
  var o2 = ln(t2, "sparseIndices", "sparseToDense", "int32"), a2 = ln(e2, "sparseValues", "sparseToDense"), i2 = ln(r2, "defaultValue", "sparseToDense", a2.dtype);
  return function(t3, e3, n3, r3) {
    if ("int32" !== t3.dtype)
      throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was " + t3.dtype + ".");
    if (t3.rank > 2)
      throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape " + t3.shape + ".");
    var o3 = t3.rank > 0 ? t3.shape[0] : 1, a3 = t3.rank > 1 ? t3.shape[1] : 1;
    if (n3.length !== a3)
      throw new Error("outputShape has incorrect number of elements:, " + n3.length + ", should be: " + a3 + ".");
    var i3 = e3.size;
    if (0 !== e3.rank && (1 !== e3.rank || i3 !== o3))
      throw new Error("sparseValues has incorrect shape " + e3.shape + ", should be [] or [" + o3 + "]");
    if (e3.dtype !== r3.dtype)
      throw new Error("sparseValues.dtype must match defaultValues.dtype");
  }(o2, a2, n2, i2), Nt.runKernelFunc(function(t3) {
    return t3.sparseToDense(o2, a2, n2, i2);
  }, {$sparseIndices: o2, $sparseValues: a2, $defaultValue: i2});
}});
var Wl = Cn({gatherND_: function(t2, e2) {
  var n2 = ln(e2, "indices", "gatherND", "int32"), r2 = ln(t2, "x", "gatherND");
  return Nt.runKernelFunc(function(t3) {
    return t3.gatherND(r2, n2);
  }, {$x: r2, $indices: n2});
}});
var Ul = Cn({diag_: function(t2) {
  var e2 = ln(t2, "x", "diag").flatten(), n2 = t2.shape.concat(t2.shape);
  return Nt.runKernelFunc(function(t3) {
    return t3.diag(e2);
  }, {$x: e2}).reshape(n2);
}});
var Vl = Cn({dropout_: function(t2, e2, n2, r2) {
  var o2 = ln(t2, "x", "dropout");
  if (g("float32" === o2.dtype, function() {
    return "x has to be a floating point tensor since it's going to be scaled, but got a " + o2.dtype + " tensor instead.";
  }), g(e2 >= 0 && e2 < 1, function() {
    return "rate must be a float in the range [0, 1), but got " + e2 + ".";
  }), 0 === e2)
    return t2 instanceof dt ? o2.clone() : o2;
  var a2 = function(t3, e3) {
    if (null == e3)
      return t3.shape.slice();
    if (C(t3.shape, e3))
      return e3;
    if (t3.shape.length === e3.length) {
      for (var n3 = [], r3 = 0; r3 < t3.shape.length; r3++)
        null == e3[r3] && null != t3.shape[r3] ? n3.push(t3.shape[r3]) : n3.push(e3[r3]);
      return n3;
    }
    return e3;
  }(o2, n2), i2 = 1 - e2, u2 = kr(a2, 0, 1, "float32", r2).add(i2).floor().div(i2);
  return o2.mul(u2);
}});
function zl(t2, e2, n2) {
  for (var r2 = 1 - t2 % 2, o2 = new Float32Array(t2), a2 = 0; a2 < t2; ++a2) {
    var i2 = 2 * Math.PI * a2 / (t2 + r2 - 1);
    o2[a2] = e2 - n2 * Math.cos(i2);
  }
  return Dn(o2, "float32");
}
var Gl = Cn({hannWindow_: function(t2) {
  return zl(t2, 0.5, 0.5);
}});
var Hl = Cn({hammingWindow_: function(t2) {
  return zl(t2, 0.54, 0.46);
}});
var ql = Cn({frame_: function(t2, e2, n2, r2, o2) {
  void 0 === r2 && (r2 = false), void 0 === o2 && (o2 = 0);
  for (var a2 = 0, i2 = []; a2 + e2 <= t2.size; )
    i2.push(el(t2, a2, e2)), a2 += n2;
  if (r2)
    for (; a2 < t2.size; ) {
      var u2 = a2 + e2 - t2.size, s2 = Gn([el(t2, a2, e2 - u2), Ln([u2], o2)]);
      i2.push(s2), a2 += n2;
    }
  return 0 === i2.length ? Tn([], [0, e2]) : Gn(i2).as2D(i2.length, e2);
}});
var Kl = Cn({stft_: function(t2, e2, n2, r2, o2) {
  var a2;
  void 0 === o2 && (o2 = Gl), null == r2 && (a2 = e2, r2 = Math.floor(Math.pow(2, Math.ceil(Math.log(a2) / Math.log(2)))));
  for (var i2 = ql(t2, e2, n2), u2 = ec(i2, o2(e2)), s2 = [], c2 = 0; c2 < i2.shape[0]; c2++)
    s2.push(Ml(u2.slice([c2, 0], [1, e2]), r2));
  return Gn(s2);
}});
var jl = Object.freeze({hannWindow: Gl, hammingWindow: Hl, frame: ql, stft: Kl});
var Xl;
var $l = function(t2, e2, o2) {
  return void 0 === o2 && (o2 = 1), n(this, void 0, void 0, function() {
    var n2, a2, i2, u2, s2, c2, l2, h2, f2, p2, d2, v2, m2, x2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          return n2 = ln(t2, "predictions", "inTopK"), a2 = ln(e2, "targets", "inTopK"), g(n2.rank > 1, function() {
            return "inTopK() expects the predictions to be of rank 2 or higher, but got " + n2.rank;
          }), g(n2.rank - 1 === a2.rank, function() {
            return "predictions rank should be 1 larger than targets rank, but got predictions rank " + n2.rank + " and targets rank " + a2.rank;
          }), y(n2.shape.slice(0, n2.shape.length - 1), a2.shape, "predictions's shape should be align with the targets' shape, except the last dimension."), i2 = n2.shape[n2.shape.length - 1], g(o2 > 0 && o2 <= i2, function() {
            return "'k' passed to inTopK() must be > 0 && <= the predictions last dimension (" + i2 + "), but got " + o2;
          }), [4, n2.data()];
        case 1:
          return u2 = r2.sent(), [4, a2.data()];
        case 2:
          for (s2 = r2.sent(), c2 = [u2.length / i2, i2], h2 = c2[1], f2 = N("bool", l2 = c2[0]), p2 = 0; p2 < l2; p2++) {
            for (d2 = p2 * h2, v2 = u2.subarray(d2, d2 + h2), m2 = [], x2 = 0; x2 < v2.length; x2++)
              m2.push({value: v2[x2], index: x2});
            for (m2.sort(function(t3, e3) {
              return e3.value - t3.value;
            }), f2[p2] = 0, x2 = 0; x2 < o2; x2++)
              if (m2[x2].index === s2[p2]) {
                f2[p2] = 1;
                break;
              }
          }
          return t2 !== n2 && n2.dispose(), e2 !== a2 && a2.dispose(), [2, kn(f2, a2.shape, "bool")];
      }
    });
  });
};
!function(t2) {
  t2[t2.NONE = 0] = "NONE", t2[t2.MEAN = 1] = "MEAN", t2[t2.SUM = 2] = "SUM", t2[t2.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
}(Xl || (Xl = {}));
var Yl = Cn({absoluteDifference_: function(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = Xl.SUM_BY_NONZERO_WEIGHTS);
  var o2 = ln(t2, "labels", "absoluteDifference"), a2 = ln(e2, "predictions", "absoluteDifference"), i2 = null;
  null != n2 && (i2 = ln(n2, "weights", "absoluteDifference")), y(o2.shape, a2.shape, "Error in absoluteDifference: ");
  var u2 = o2.sub(a2).abs();
  return Ql(u2, i2, r2);
}});
var Ql = Cn({computeWeightedLoss_: function(t2, e2, n2) {
  void 0 === n2 && (n2 = Xl.SUM_BY_NONZERO_WEIGHTS);
  var r2 = ln(t2, "losses", "computeWeightedLoss"), o2 = null;
  null != e2 && (o2 = ln(e2, "weights", "computeWeightedLoss"));
  var a2 = null == o2 ? r2 : r2.mul(o2);
  if (n2 === Xl.NONE)
    return a2;
  if (n2 === Xl.SUM)
    return a2.sum();
  if (n2 === Xl.MEAN) {
    if (null == o2)
      return a2.mean();
    var i2 = r2.size / o2.size, u2 = a2.sum().div(o2.sum());
    return i2 > 1 ? u2.div(An(i2)) : u2;
  }
  if (n2 === Xl.SUM_BY_NONZERO_WEIGHTS) {
    if (null == o2)
      return a2.sum().div(An(r2.size));
    var s2 = o2.mul(Bn(r2.shape)).notEqual(An(0)).sum().toFloat();
    return a2.sum().div(s2);
  }
  throw Error("Unknown reduction: " + n2);
}});
var Jl = Cn({cosineDistance_: function(t2, e2, n2, r2, o2) {
  void 0 === o2 && (o2 = Xl.SUM_BY_NONZERO_WEIGHTS);
  var a2 = ln(t2, "labels", "cosineDistance"), i2 = ln(e2, "predictions", "cosineDistance"), u2 = null;
  null != r2 && (u2 = ln(r2, "weights", "cosineDistance")), y(a2.shape, i2.shape, "Error in cosineDistance: ");
  var s2 = An(1).sub(a2.mul(i2).sum(n2, true));
  return Ql(s2, u2, o2);
}});
var Zl = Cn({hingeLoss_: function(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = Xl.SUM_BY_NONZERO_WEIGHTS);
  var o2 = ln(t2, "labels", "hingeLoss"), a2 = ln(e2, "predictions", "hingeLoss"), i2 = null;
  null != n2 && (i2 = ln(n2, "weights", "hingeLoss")), y(o2.shape, a2.shape, "Error in hingeLoss: ");
  var u2 = An(1);
  o2 = An(2).mul(o2).sub(u2);
  var s2 = u2.sub(o2.mul(a2)).relu();
  return Ql(s2, i2, r2);
}});
var th = Cn({huberLoss_: function(t2, e2, n2, r2, o2) {
  void 0 === r2 && (r2 = 1), void 0 === o2 && (o2 = Xl.SUM_BY_NONZERO_WEIGHTS);
  var a2 = ln(t2, "labels", "huberLoss"), i2 = ln(e2, "predictions", "huberLoss"), u2 = null;
  null != n2 && (u2 = ln(n2, "weights", "huberLoss")), y(a2.shape, i2.shape, "Error in huberLoss: ");
  var s2 = An(r2), c2 = i2.sub(a2).abs(), l2 = Qs(c2, s2), h2 = c2.sub(l2), f2 = An(0.5).mul(l2.square()).add(s2.mul(h2));
  return Ql(f2, u2, o2);
}});
var eh = Cn({logLoss_: function(t2, e2, n2, r2, o2) {
  void 0 === r2 && (r2 = 1e-7), void 0 === o2 && (o2 = Xl.SUM_BY_NONZERO_WEIGHTS);
  var a2 = ln(t2, "labels", "logLoss"), i2 = ln(e2, "predictions", "logLoss"), u2 = null;
  null != n2 && (u2 = ln(n2, "weights", "logLoss")), y(a2.shape, i2.shape, "Error in logLoss: ");
  var s2 = An(1), c2 = An(r2), l2 = a2.mul(i2.add(c2).log()).neg().sub(s2.sub(a2).mul(s2.sub(i2).add(c2).log()));
  return Ql(l2, u2, o2);
}});
var nh = Cn({meanSquaredError_: function(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = Xl.SUM_BY_NONZERO_WEIGHTS);
  var o2 = ln(t2, "labels", "meanSquaredError"), a2 = ln(e2, "predictions", "meanSquaredError"), i2 = null;
  null != n2 && (i2 = ln(n2, "weights", "meanSquaredError")), y(o2.shape, a2.shape, "Error in meanSquaredError: ");
  var u2 = o2.squaredDifference(a2);
  return Ql(u2, i2, r2);
}});
var rh = Cn({sigmoidCrossEntropy_: function(t2, e2, n2, r2, o2) {
  void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = Xl.SUM_BY_NONZERO_WEIGHTS);
  var a2 = ln(t2, "multiClassLabels", "sigmoidCrossEntropy"), i2 = ln(e2, "logits", "sigmoidCrossEntropy"), u2 = null;
  if (null != n2 && (u2 = ln(n2, "weights", "sigmoidCrossEntropy")), y(a2.shape, i2.shape, "Error in sigmoidCrossEntropy: "), r2 > 0) {
    var s2 = An(r2), c2 = An(1), l2 = An(0.5);
    a2 = a2.mul(c2.sub(s2)).add(l2.mul(s2));
  }
  var h2 = function(t3, e3) {
    var n3 = ln(t3, "labels", "sigmoidCrossEntropyWithLogits"), r3 = ln(e3, "logits", "sigmoidCrossEntropyWithLogits");
    y(n3.shape, r3.shape, "Error in sigmoidCrossEntropyWithLogits: ");
    var o3 = r3.relu(), a3 = r3.mul(n3), i3 = r3.abs().neg().exp().log1p();
    return o3.sub(a3).add(i3);
  }(a2, i2);
  return Ql(h2, u2, o2);
}});
var oh = Cn({softmaxCrossEntropy_: function(t2, e2, n2, r2, o2) {
  void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = Xl.SUM_BY_NONZERO_WEIGHTS);
  var a2 = ln(t2, "onehotLabels", "softmaxCrossEntropy"), i2 = ln(e2, "logits", "softmaxCrossEntropy"), u2 = null;
  if (null != n2 && (u2 = ln(n2, "weights", "softmaxCrossEntropy")), y(a2.shape, i2.shape, "Error in softmaxCrossEntropy: "), r2 > 0) {
    var s2 = An(r2), c2 = An(1), l2 = An(a2.shape[1]);
    a2 = a2.mul(c2.sub(s2)).add(s2.div(l2));
  }
  var h2 = function(t3, e3, n3) {
    if (void 0 === n3 && (n3 = -1), -1 === n3 && (n3 = e3.rank - 1), n3 !== e3.rank - 1)
      throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank " + e3.rank + " and dim was " + n3);
    return oo(function(t4, e4, r3) {
      var o3 = e4.logSumExp([n3], true), a3 = e4.toFloat().sub(o3);
      return r3([t4, a3]), {value: a3.mul(t4).neg().sum([n3]), gradFunc: function(t5, e5) {
        var r4 = e5[0], o4 = e5[1], a4 = vn(t5.shape, [n3]);
        return [t5.reshape(a4).mul(r4.toFloat().sub(o4.exp())), t5.reshape(a4).mul(o4.exp().sub(r4.toFloat()))];
      }};
    })(t3, e3);
  }(a2, i2);
  return Ql(h2, u2, o2);
}});
var ah = Object.freeze({get Reduction() {
  return Xl;
}, absoluteDifference: Yl, computeWeightedLoss: Ql, cosineDistance: Jl, hingeLoss: Zl, huberLoss: th, logLoss: eh, meanSquaredError: nh, sigmoidCrossEntropy: rh, softmaxCrossEntropy: oh});
function ih(t2, e2) {
  return void 0 === e2 && (e2 = false), Nt.tidy(function() {
    if (2 !== t2.shape.length)
      throw new Error("qr2d() requires a 2D Tensor, but got a " + t2.shape.length + "D Tensor.");
    for (var n2 = t2.shape[0], r2 = t2.shape[1], o2 = vr(n2), a2 = t2.clone(), i2 = Tn([[1]], [1, 1]), u2 = i2.clone(), s2 = n2 >= r2 ? r2 : n2, c2 = function(t3) {
      var e3, s3 = a2, c3 = u2, l3 = o2;
      e3 = Nt.tidy(function() {
        var e4 = a2.slice([t3, t3], [n2 - t3, 1]), s4 = e4.norm(), c4 = a2.slice([t3, t3], [1, 1]), l4 = Tn([[-1]]).where(c4.greater(0), Tn([[1]])), h2 = c4.sub(l4.mul(s4)), f2 = e4.div(h2);
        u2 = 1 === f2.shape[0] ? i2.clone() : i2.concat(f2.slice([1, 0], [f2.shape[0] - 1, f2.shape[1]]), 0);
        var p2 = l4.matMul(h2).div(s4).neg(), d2 = a2.slice([t3, 0], [n2 - t3, r2]), v2 = p2.mul(u2);
        if (0 === t3)
          a2 = d2.sub(v2.matMul(u2.transpose().matMul(d2)));
        else {
          var m2 = d2.sub(v2.matMul(u2.transpose().matMul(d2)));
          a2 = a2.slice([0, 0], [t3, r2]).concat(m2, 0);
        }
        var g2 = o2.slice([0, t3], [n2, o2.shape[1] - t3]);
        if (0 === t3)
          o2 = g2.sub(g2.matMul(u2).matMul(v2.transpose()));
        else {
          var y2 = g2.sub(g2.matMul(u2).matMul(v2.transpose()));
          o2 = o2.slice([0, 0], [n2, t3]).concat(y2, 1);
        }
        return [u2, a2, o2];
      }), u2 = e3[0], a2 = e3[1], o2 = e3[2], Xe([s3, c3, l3]);
    }, l2 = 0; l2 < s2; ++l2)
      c2(l2);
    return !e2 && n2 > r2 && (o2 = o2.slice([0, 0], [n2, r2]), a2 = a2.slice([0, 0], [r2, r2])), [o2, a2];
  });
}
var uh = Cn({gramSchmidt_: function(t2) {
  var e2;
  if (Array.isArray(t2)) {
    e2 = false, g(null != t2 && t2.length > 0, function() {
      return "Gram-Schmidt process: input must not be null, undefined, or empty";
    });
    for (var n2 = t2[0].shape[0], r2 = function(e3) {
      g(t2[e3].shape[0] === n2, function() {
        return "Gram-Schmidt: Non-unique lengths found in the input vectors: (" + t2[e3].shape[0] + " vs. " + n2 + ")";
      });
    }, o2 = 1; o2 < t2.length; ++o2)
      r2(o2);
  } else
    e2 = true, t2 = Xn(t2, t2.shape[0], 0).map(function(t3) {
      return Dr(t3, [0]);
    });
  g(t2.length <= t2[0].shape[0], function() {
    return "Gram-Schmidt: Number of vectors (" + t2.length + ") exceeds number of dimensions (" + t2[0].shape[0] + ").";
  });
  var a2 = [], i2 = t2, u2 = function(t3) {
    a2.push(Nt.tidy(function() {
      var e3 = i2[t3];
      if (t3 > 0)
        for (var n3 = 0; n3 < t3; ++n3) {
          var r3 = ml(a2[n3].mulStrict(e3)).mul(a2[n3]);
          e3 = e3.sub(r3);
        }
      return e3.div(kl(e3, "euclidean"));
    }));
  };
  for (o2 = 0; o2 < t2.length; ++o2)
    u2(o2);
  return e2 ? Tr(a2, 0) : a2;
}});
var sh = Cn({qr_: function(t2, e2) {
  if (void 0 === e2 && (e2 = false), t2.rank < 2)
    throw new Error("qr() requires input tensor to have a rank >= 2, but got rank " + t2.rank);
  if (2 === t2.rank)
    return ih(t2, e2);
  var n2 = t2.shape.slice(0, t2.shape.length - 2).reduce(function(t3, e3) {
    return t3 * e3;
  }), r2 = Or(t2.reshape([n2, t2.shape[t2.shape.length - 2], t2.shape[t2.shape.length - 1]]), 0), o2 = [], a2 = [];
  return r2.forEach(function(t3) {
    var n3 = ih(t3, e2), r3 = n3[0], i2 = n3[1];
    o2.push(r3), a2.push(i2);
  }), [Tr(o2, 0).reshape(t2.shape), Tr(a2, 0).reshape(t2.shape)];
}});
var ch = Object.freeze({gramSchmidt: uh, qr: sh});
function lh(t2, e2, n2, r2, o2) {
  null == r2 && (r2 = 0.5), null == o2 && (o2 = Number.NEGATIVE_INFINITY);
  var a2 = t2.shape[0];
  return n2 = Math.min(n2, a2), g(0 <= r2 && r2 <= 1, function() {
    return "iouThreshold must be in [0, 1], but was '" + r2 + "'";
  }), g(2 === t2.rank, function() {
    return "boxes must be a 2D tensor, but was of rank '" + t2.rank + "'";
  }), g(4 === t2.shape[1], function() {
    return "boxes must have 4 columns, but 2nd dimension was " + t2.shape[1];
  }), g(1 === e2.rank, function() {
    return "scores must be a 1D tensor";
  }), g(e2.shape[0] === a2, function() {
    return "scores has incompatible shape with boxes. Expected " + a2 + ", but was " + e2.shape[0];
  }), {maxOutputSize: n2, iouThreshold: r2, scoreThreshold: o2};
}
var hh = Cn({resizeBilinear_: function(t2, e2, n2) {
  void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "images", "resizeBilinear");
  g(3 === r2.rank || 4 === r2.rank, function() {
    return "Error in resizeBilinear: x must be rank 3 or 4, but got rank " + r2.rank + ".";
  }), g(2 === e2.length, function() {
    return "Error in resizeBilinear: new shape must 2D, but got shape " + e2 + ".";
  });
  var o2 = r2, a2 = false;
  3 === r2.rank && (a2 = true, o2 = r2.as4D(1, r2.shape[0], r2.shape[1], r2.shape[2]));
  var i2 = e2[0], u2 = e2[1], s2 = Nt.runKernelFunc(function(t3, e3) {
    return e3([o2]), t3.resizeBilinear(o2, i2, u2, n2);
  }, {batchImages: o2}, function(t3, e3) {
    return {batchImages: function() {
      return Nt.runKernelFunc(function(r3) {
        return r3.resizeBilinearBackprop(t3, e3[0], n2);
      }, {});
    }};
  });
  return a2 ? s2.as3D(s2.shape[1], s2.shape[2], s2.shape[3]) : s2;
}});
var fh = Cn({resizeNearestNeighbor_: function(t2, e2, n2) {
  void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "images", "resizeNearestNeighbor");
  g(3 === r2.rank || 4 === r2.rank, function() {
    return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank " + r2.rank + ".";
  }), g(2 === e2.length, function() {
    return "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + e2 + ".";
  }), g("float32" === r2.dtype || "int32" === r2.dtype, function() {
    return "`images` must have `int32` or `float32` as dtype";
  });
  var o2 = r2, a2 = false;
  3 === r2.rank && (a2 = true, o2 = r2.as4D(1, r2.shape[0], r2.shape[1], r2.shape[2]));
  var i2 = e2[0], u2 = e2[1], s2 = Nt.runKernelFunc(function(t3, e3) {
    return e3([o2]), t3.resizeNearestNeighbor(o2, i2, u2, n2);
  }, {batchImages: o2}, function(t3, e3) {
    return {batchImages: function() {
      return Nt.runKernelFunc(function(r3) {
        return r3.resizeNearestNeighborBackprop(t3, e3[0], n2);
      }, {});
    }};
  });
  return a2 ? s2.as3D(s2.shape[1], s2.shape[2], s2.shape[3]) : s2;
}});
var ph = Cn({nonMaxSuppression_: function(t2, e2, n2, r2, o2) {
  void 0 === r2 && (r2 = 0.5), void 0 === o2 && (o2 = Number.NEGATIVE_INFINITY);
  var a2 = ln(t2, "boxes", "nonMaxSuppression"), i2 = ln(e2, "scores", "nonMaxSuppression"), u2 = lh(a2, i2, n2, r2, o2);
  return n2 = u2.maxOutputSize, r2 = u2.iouThreshold, o2 = u2.scoreThreshold, Nt.runKernelFunc(function(t3) {
    return t3.nonMaxSuppression(a2, i2, n2, r2, o2);
  }, {$boxes: a2});
}});
var dh = function(t2, e2, o2, a2, i2) {
  return void 0 === a2 && (a2 = 0.5), void 0 === i2 && (i2 = Number.NEGATIVE_INFINITY), n(this, void 0, void 0, function() {
    var n2, u2, s2, c2, l2, h2, f2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          return n2 = ln(t2, "boxes", "nonMaxSuppressionAsync"), u2 = ln(e2, "scores", "nonMaxSuppressionAsync"), s2 = lh(n2, u2, o2, a2, i2), o2 = s2.maxOutputSize, a2 = s2.iouThreshold, i2 = s2.scoreThreshold, [4, Promise.all([n2.data(), u2.data()])];
        case 1:
          return c2 = r2.sent(), l2 = c2[0], h2 = c2[1], f2 = Mo(l2, h2, o2, a2, i2), n2 !== t2 && n2.dispose(), u2 !== e2 && u2.dispose(), [2, f2];
      }
    });
  });
};
var vh = Cn({cropAndResize_: function(t2, e2, n2, r2, o2, a2) {
  var i2 = ln(t2, "image", "cropAndResize", "float32"), u2 = ln(e2, "boxes", "cropAndResize", "float32"), s2 = ln(n2, "boxInd", "cropAndResize", "int32");
  o2 = o2 || "bilinear", a2 = a2 || 0;
  var c2 = u2.shape[0];
  return g(4 === i2.rank, function() {
    return "Error in cropAndResize: image must be rank 4,but got rank " + i2.rank + ".";
  }), g(2 === u2.rank && 4 === u2.shape[1], function() {
    return "Error in cropAndResize: boxes must be have size [" + c2 + ",4] but had shape " + u2.shape + ".";
  }), g(1 === s2.rank && s2.shape[0] === c2, function() {
    return "Error in cropAndResize: boxInd must be have size [" + c2 + "] but had shape " + u2.shape + ".";
  }), g(2 === r2.length, function() {
    return "Error in cropAndResize: cropSize must be of length 2, but got length " + r2.length + ".";
  }), g(r2[0] >= 1 && r2[1] >= 1, function() {
    return "cropSize must be atleast [1,1], but was " + r2;
  }), g("bilinear" === o2 || "nearest" === o2, function() {
    return "method must be bilinear or nearest, but was " + o2;
  }), Nt.runKernelFunc(function(t3, e3) {
    return t3.cropAndResize(i2, u2, s2, r2, o2, a2);
  }, {images: i2, boxes: u2, boxInd: s2}, null, "CropAndResize", {method: o2, extrapolationValue: a2, cropSize: r2});
}});
var mh = Object.freeze({resizeBilinear: hh, resizeNearestNeighbor: fh, nonMaxSuppression: ph, nonMaxSuppressionAsync: dh, cropAndResize: vh});
var gh = function(t2, e2) {
  return !(t2 > 0) && ("linear" === e2 || "relu" === e2);
};
var yh = function(t2, e2, n2) {
  if (null == n2 || "linear" === n2)
    return t2;
  if ("relu" === n2)
    return t2.mul(e2.step());
  throw new Error("Gradient for activation " + n2 + " has not been implemented yet.");
};
var xh = function(t2, e2) {
  var n2 = e2, r2 = fo(t2.shape, e2.shape);
  return r2.length > 0 && (n2 = n2.sum(r2)), n2.reshape(t2.shape);
};
var bh = function(t2, e2, n2) {
  if ("linear" === e2)
    return t2;
  if ("relu" === e2)
    return wl(t2);
  if ("elu" === e2)
    return yl(t2);
  if ("relu6" === e2)
    return Cl(t2);
  if ("prelu" === e2)
    return bl(t2, n2);
  throw new Error("Unknown fused activation " + e2 + ".");
};
var wh = Cn({matMul_: function(t2) {
  var e2, n2 = t2.a, r2 = t2.b, o2 = t2.transposeA, a2 = void 0 !== o2 && o2, i2 = t2.transposeB, u2 = void 0 !== i2 && i2, s2 = t2.bias, c2 = t2.activation, l2 = void 0 === c2 ? "linear" : c2, h2 = t2.preluActivationWeights;
  if (false === gh(Nt.state.gradientDepth, l2)) {
    var f2 = Uc(n2, r2, a2, u2);
    return null != s2 && (f2 = Vs(f2, s2)), bh(f2, l2, h2);
  }
  var p2 = ln(n2, "a", "fused matMul"), d2 = ln(r2, "b", "fused matMul");
  e2 = Rt(p2, d2), p2 = e2[0], d2 = e2[1];
  var v2 = a2 ? p2.shape[p2.rank - 2] : p2.shape[p2.rank - 1], m2 = u2 ? d2.shape[d2.rank - 1] : d2.shape[d2.rank - 2], y2 = a2 ? p2.shape[p2.rank - 1] : p2.shape[p2.rank - 2], x2 = u2 ? d2.shape[d2.rank - 2] : d2.shape[d2.rank - 1], b2 = p2.shape.slice(0, -2), E2 = d2.shape.slice(0, -2), R2 = w(b2), I2 = w(E2);
  g(p2.rank >= 2 && d2.rank >= 2 && p2.rank === d2.rank, function() {
    return "Error in fused matMul: inputs must have the same rank of at least 2, got ranks " + p2.rank + " and " + d2.rank + ".";
  }), g(C(b2, E2), function() {
    return "Error in fused matMul: outer dimensions (" + b2 + ") and (" + E2 + ") of Tensors with shapes " + p2.shape + " and " + d2.shape + " must match.";
  }), g(v2 === m2, function() {
    return "Error in fused matMul: inner shapes (" + v2 + ") and (" + m2 + ") of Tensors with shapes " + p2.shape + " and " + d2.shape + " and transposeA=" + a2 + " and transposeB=" + u2 + " must match.";
  });
  var k2, S2, A2 = p2.shape.slice(0, -2).concat([y2, x2]), D2 = a2 ? p2.as3D(R2, v2, y2) : p2.as3D(R2, y2, v2), T2 = u2 ? d2.as3D(I2, x2, m2) : d2.as3D(I2, m2, x2);
  null != s2 && po(A2, (k2 = Rt(k2 = ln(s2, "bias", "fused matMul"), p2)[0]).shape), null != h2 && (S2 = ln(h2, "prelu weights", "fused matMul"));
  var N2 = {$a: D2, $b: T2};
  return null != s2 && (N2.$bias = k2), null != h2 && (N2.$preluActivationWeights = S2), Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.fusedBatchMatMul({a: D2, b: T2, transposeA: a2, transposeB: u2, bias: k2, activation: l2, preluActivationWeights: S2});
    return e3([D2, T2, n3]), n3;
  }, N2, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1], o3 = e3[2], i3 = yh(t3, o3, l2), c3 = {};
    return null != s2 && (c3 = {$bias: function() {
      return xh(k2, i3);
    }}), a2 || u2 ? !a2 && u2 ? Object.assign({$a: function() {
      return i3.matMul(r3, false, false);
    }, $b: function() {
      return i3.matMul(n3, true, false);
    }}, c3) : a2 && !u2 ? Object.assign({$a: function() {
      return r3.matMul(i3, false, true);
    }, $b: function() {
      return n3.matMul(i3, false, false);
    }}, c3) : Object.assign({$a: function() {
      return r3.matMul(i3, true, true);
    }, $b: function() {
      return i3.matMul(n3, true, true);
    }}, c3) : Object.assign({$a: function() {
      return i3.matMul(r3, false, true);
    }, $b: function() {
      return n3.matMul(i3, true, false);
    }}, c3);
  }).reshape(A2);
}});
var Ch = Cn({conv2d_: function(t2) {
  var e2 = t2.x, n2 = t2.filter, r2 = t2.strides, o2 = t2.pad, a2 = t2.dataFormat, i2 = void 0 === a2 ? "NHWC" : a2, u2 = t2.dilations, s2 = void 0 === u2 ? [1, 1] : u2, c2 = t2.dimRoundingMode, l2 = t2.bias, h2 = t2.activation, f2 = void 0 === h2 ? "linear" : h2, p2 = t2.preluActivationWeights;
  if (f2 = f2 || "linear", false === gh(Nt.state.gradientDepth, f2)) {
    var d2 = Tc(e2, n2, r2, o2, i2, s2, c2);
    return null != l2 && (d2 = Vs(d2, l2)), bh(d2, f2, p2);
  }
  var v2 = ln(e2, "x", "conv2d"), m2 = ln(n2, "filter", "conv2d"), y2 = v2, x2 = false;
  3 === v2.rank && (x2 = true, y2 = v2.as4D(1, v2.shape[0], v2.shape[1], v2.shape[2])), g(4 === y2.rank, function() {
    return "Error in fused conv2d: input must be rank 4, but got rank " + y2.rank + ".";
  }), g(4 === m2.rank, function() {
    return "Error in fused conv2d: filter must be rank 4, but got rank " + m2.rank + ".";
  }), null != c2 && g(E(o2), function() {
    return "Error in fused conv2d: pad must be an integer when using, dimRoundingMode " + c2 + " but got pad " + o2 + ".";
  }), g(y2.shape[3] === m2.shape[2], function() {
    return "Error in conv2d: depth of input (" + y2.shape[3] + ") must match input depth for filter " + m2.shape[2] + ".";
  }), g(Io(r2, s2), function() {
    return "Error in conv2D: Either strides or dilations must be 1. Got strides " + r2 + " and dilations '" + s2 + "'";
  }), g("NHWC" === i2, function() {
    return "Error in conv2d: got dataFormat of " + i2 + " but only NHWC is currently supported.";
  });
  var b2, w2, C2 = go(y2.shape, m2.shape, r2, s2, o2, c2);
  null != l2 && (b2 = Rt(b2 = ln(l2, "bias", "fused conv2d"), v2)[0], po(C2.outShape, b2.shape)), null != p2 && (w2 = ln(p2, "prelu weights", "fused conv2d"));
  var R2 = {x: y2, filter: m2};
  null != l2 && (R2.bias = b2), null != p2 && (R2.preluActivationWeights = w2);
  var I2 = [m2, y2], k2 = Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.fusedConv2d({input: y2, filter: m2, convInfo: C2, bias: b2, activation: f2, preluActivationWeights: w2});
    return e3([m2, y2, n3]), n3;
  }, R2, function(t3, e3) {
    var n3 = e3, a3 = n3[0], i3 = n3[1], u3 = n3[2], c3 = yh(t3, u3, f2);
    g(Ro(s2), function() {
      return "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + s2 + "'";
    });
    var h3 = {};
    return null != l2 && (h3 = {$bias: function() {
      return xh(b2, c3);
    }}), Object.assign({x: function() {
      return Oc(i3.shape, c3, a3, r2, o2);
    }, filter: function() {
      return Fc(i3, c3, a3.shape, r2, o2);
    }}, h3);
  }, "FusedConv2D", {convInfo: C2, activation: f2}, I2, [true]);
  return x2 ? k2.as3D(k2.shape[1], k2.shape[2], k2.shape[3]) : k2;
}});
var Eh = Cn({depthwiseConv2d_: function(t2) {
  var e2 = t2.x, n2 = t2.filter, r2 = t2.strides, o2 = t2.pad, a2 = t2.dataFormat, i2 = void 0 === a2 ? "NHWC" : a2, u2 = t2.dilations, s2 = void 0 === u2 ? [1, 1] : u2, c2 = t2.dimRoundingMode, l2 = t2.bias, h2 = t2.activation, f2 = void 0 === h2 ? "linear" : h2, p2 = t2.preluActivationWeights;
  if (false === gh(Nt.state.gradientDepth, f2)) {
    var d2 = _c(e2, n2, r2, o2, i2, s2, c2);
    return null != l2 && (d2 = Vs(d2, l2)), bh(d2, f2, p2);
  }
  var v2 = ln(e2, "x", "depthwiseConv2d"), m2 = ln(n2, "filter", "depthwiseConv2d"), y2 = v2, x2 = false;
  3 === v2.rank && (x2 = true, y2 = v2.as4D(1, v2.shape[0], v2.shape[1], v2.shape[2])), g(4 === y2.rank, function() {
    return "Error in fused depthwiseConv2d: input must be rank 4, but got rank " + y2.rank + ".";
  }), g(4 === m2.rank, function() {
    return "Error in fused depthwiseConv2d: filter must be rank 4, but got rank " + m2.rank + ".";
  }), g(y2.shape[3] === m2.shape[2], function() {
    return "Error in fused depthwiseConv2d: number of input channels (" + y2.shape[3] + ") must match the inChannels dimension in filter " + m2.shape[2] + ".";
  }), null == s2 && (s2 = [1, 1]), g(Io(r2, s2), function() {
    return "Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides " + r2 + " and dilations '" + s2 + "'";
  }), null != c2 && g(E(o2), function() {
    return "Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode " + c2 + " but got pad " + o2 + ".";
  });
  var b2, w2, C2 = go(y2.shape, m2.shape, r2, s2, o2, c2, true);
  null != l2 && (b2 = Rt(b2 = ln(l2, "bias", "fused conv2d"), v2)[0], po(C2.outShape, b2.shape)), null != p2 && (w2 = ln(p2, "prelu weights", "fused depthwiseConv2d"));
  var R2 = {x: y2, $filter: m2};
  null != l2 && (R2.$bias = b2), null != p2 && (R2.$preluActivationWeights = w2);
  var I2 = Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.fusedDepthwiseConv2D({input: y2, filter: m2, convInfo: C2, bias: b2, activation: f2, preluActivationWeights: w2});
    return e3([y2, m2, n3]), n3;
  }, R2, function(t3, e3) {
    g(Ro(s2), function() {
      return "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + s2 + "'";
    });
    var n3 = e3[0], r3 = e3[1], o3 = e3[2], a3 = yh(t3, o3, f2), i3 = {};
    return null != l2 && (i3 = {$bias: function() {
      return xh(b2, a3);
    }}), Object.assign({x: function() {
      return Mc(n3.shape, a3, r3, C2);
    }, $filter: function() {
      return Bc(n3, a3, r3.shape, C2);
    }}, i3);
  });
  return x2 ? I2.as3D(I2.shape[1], I2.shape[2], I2.shape[3]) : I2;
}});
var Rh = Object.freeze({matMul: wh, conv2d: Ch, depthwiseConv2d: Eh});
var Ih = Object.freeze({image: mh, linalg: ch, losses: ah, spectral: Pl, fused: Rh, signal: jl, square: Uu, conv1d: Dc, conv2d: Tc, conv3d: Nc, depthwiseConv2d: _c, separableConv2d: Pc, conv2dTranspose: Lc, conv3dTranspose: Wc, op: Cn, batchNormalization2d: Ss, batchNormalization3d: As, batchNormalization4d: Ds, batchNormalization: Ts, batchNorm: Ns, batchNorm2d: Fs, batchNorm3d: Os, batchNorm4d: _s, booleanMaskAsync: Ic, complex: En, real: Rn, imag: In, concat: Gn, concat1d: Hn, concat2d: qn, concat3d: Kn, concat4d: jn, split: Xn, matMul: Uc, dot: Vc, outerProduct: zc, reverse: Gc, reverse1d: Hc, reverse2d: qc, reverse3d: Kc, reverse4d: jc, maxPool: Yc, avgPool: Qc, pool: Jc, maxPool3d: Zc, avgPool3d: tl, slice: el, slice1d: nl, slice2d: rl, slice3d: ol, slice4d: al, abs: Vu, acos: zu, acosh: Gu, asin: Hu, asinh: qu, atan: Ku, atanh: ju, ceil: Xu, clipByValue: $u, cos: Yu, cosh: Qu, erf: Ju, exp: Zu, expm1: ts, floor: es, log: ns, log1p: rs, logSigmoid: os, neg: as, reciprocal: is, round: us, rsqrt: ss, sigmoid: cs, sign: ls, isNaN: hs, isInf: fs, isFinite: ps, sin: ds, sinh: vs, softplus: ms, sqrt: gs, step: ys, tan: xs, tanh: bs, all: ul, any: sl, argMax: cl, argMin: ll, logSumExp: hl, max: fl, mean: pl, min: dl, moments: vl, sum: ml, prod: gl, equal: cc, equalStrict: lc, greater: hc, greaterEqual: fc, greaterEqualStrict: pc, greaterStrict: dc, less: vc, lessEqual: mc, lessEqualStrict: gc, lessStrict: yc, notEqual: xc, notEqualStrict: bc, add: Vs, addN: zs, addStrict: Gs, atan2: Hs, div: qs, divNoNan: Ks, divStrict: js, floorDiv: Xs, maximum: $s, maximumStrict: Ys, minimum: Qs, minimumStrict: Js, mod: Zs, modStrict: tc, mul: ec, mulStrict: nc, pow: rc, powStrict: oc, squaredDifference: ac, squaredDifferenceStrict: ic, sub: uc, subStrict: sc, elu: yl, leakyRelu: xl, prelu: bl, relu: wl, relu6: Cl, selu: El, logicalAnd: Ms, logicalNot: Bs, logicalOr: Ps, logicalXor: Ls, where: Ws, whereAsync: Us, buffer: ur, print: sr, batchToSpaceND: cr, cast: lr, clone: hr, cumsum: fr, depthToSpace: pr, expandDims: dr, eye: vr, multinomial: mr, oneHot: gr, pad: yr, pad1d: xr, pad2d: br, pad3d: wr, pad4d: Cr, rand: Er, randomNormal: Rr, randomGamma: Ir, randomUniform: kr, reshape: Sr, spaceToBatchND: Ar, squeeze: Dr, stack: Tr, tile: Nr, truncatedNormal: Fr, unstack: Or, setdiff1dAsync: _r, fill: Ln, linspace: Wn, ones: Bn, range: Un, scalar: An, tensor: kn, tensor1d: Dn, tensor2d: Tn, tensor3d: Nn, tensor4d: Fn, tensor5d: On, tensor6d: _n, variable: Mn, zeros: Pn, onesLike: Vn, zerosLike: zn, transpose: Rl, softmax: io, logSoftmax: uo, localResponseNormalization: Il, norm: kl, gather: Ec, unsortedSegmentSum: Rc, basicLSTMCell: Sl, multiRNNCell: Al, movingAverage: Dl, stridedSlice: Tl, topk: Nl, scatterND: Fl, fft: Ol, ifft: _l, rfft: Ml, irfft: Bl, sparseToDense: Ll, gatherND: Wl, diag: Ul, dropout: Vl, hannWindow: Gl, hammingWindow: Hl, frame: ql, stft: Kl, inTopKAsync: $l});
function kh(t2, e2) {
  Array.isArray(t2) || (t2 = [t2]), t2.forEach(function(t3) {
    null != t3 && g("complex64" !== t3.dtype, function() {
      return e2 + " does not support complex64 tensors.";
    });
  });
}
function Sh(t2, e2, n2, r2) {
  if ("linear" === n2)
    return t2.linear(e2);
  if ("relu" === n2)
    return t2.relu(e2);
  if ("elu" === n2)
    return t2.elu(e2);
  if ("relu6" === n2)
    return t2.relu6(e2);
  if ("prelu" === n2)
    return t2.prelu(e2, r2);
  throw new Error("Activation " + n2 + " has not been implemented for the CPU backend.");
}
var Ah = function(t2) {
  function o2() {
    var e2 = t2.call(this) || this;
    if (e2.blockSize = 48, e2.firstUse = true, a().get("IS_BROWSER")) {
      var n2 = "undefined" != typeof OffscreenCanvas ? new OffscreenCanvas(300, 150) : "undefined" != typeof document ? document.createElement("canvas") : null;
      null !== n2 && (e2.fromPixels2DContext = n2.getContext("2d"));
    }
    return e2.data = new so(e2, Nt), e2;
  }
  return e(o2, t2), o2.prototype.write = function(t3, e2, n2) {
    this.firstUse && (this.firstUse = false, a().get("IS_NODE") && un("\n============================\nHi there ğŸ‘‹. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================\n"));
    var r2 = {};
    return this.data.set(r2, {values: t3, dtype: n2}), r2;
  }, o2.prototype.move = function(t3, e2, n2, r2) {
    this.data.set(t3, {values: e2, dtype: r2});
  }, o2.prototype.numDataIds = function() {
    return this.data.numDataIds();
  }, o2.prototype.fromPixels = function(t3, e2) {
    if (null == t3)
      throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
    var n2, r2, o3 = t3.data instanceof Uint8Array, i2 = "undefined" != typeof ImageData && t3 instanceof ImageData, u2 = "undefined" != typeof HTMLVideoElement && t3 instanceof HTMLVideoElement, s2 = "undefined" != typeof HTMLImageElement && t3 instanceof HTMLImageElement, c2 = u2 ? [t3.videoWidth, t3.videoHeight] : [t3.width, t3.height], l2 = c2[0], h2 = c2[1];
    if (a().get("IS_NODE") && null == t3.getContext)
      throw new Error("When running in node, pixels must be an HTMLCanvasElement like the one returned by the `canvas` npm package");
    if (null != t3.getContext)
      n2 = t3.getContext("2d").getImageData(0, 0, l2, h2).data;
    else if (i2 || o3)
      n2 = t3.data;
    else {
      if (!s2 && !u2)
        throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData or {data: Uint32Array, width: number, height: number}, but was " + t3.constructor.name);
      if (null == this.fromPixels2DContext)
        throw new Error("Can't read pixels from HTMLImageElement outside the browser.");
      this.fromPixels2DContext.canvas.width = l2, this.fromPixels2DContext.canvas.height = h2, this.fromPixels2DContext.drawImage(t3, 0, 0, l2, h2), n2 = this.fromPixels2DContext.getImageData(0, 0, l2, h2).data;
    }
    if (4 === e2)
      r2 = new Int32Array(n2);
    else {
      var f2 = l2 * h2;
      r2 = new Int32Array(f2 * e2);
      for (var p2 = 0; p2 < f2; p2++)
        for (var d2 = 0; d2 < e2; ++d2)
          r2[p2 * e2 + d2] = n2[4 * p2 + d2];
    }
    return Nn(r2, [h2, l2, e2], "int32");
  }, o2.prototype.read = function(t3) {
    return n(this, void 0, void 0, function() {
      return r(this, function(e2) {
        return [2, this.readSync(t3)];
      });
    });
  }, o2.prototype.readSync = function(t3) {
    var e2 = this.data.get(t3), n2 = e2.dtype, r2 = e2.complexTensors;
    return "complex64" === n2 ? No(this.readSync(r2.real.dataId), this.readSync(r2.imag.dataId)) : this.data.get(t3).values;
  }, o2.prototype.bufferSync = function(t3) {
    var e2 = this.readSync(t3.dataId), n2 = e2;
    if ("string" === t3.dtype)
      try {
        n2 = e2.map(function(t4) {
          return Z(t4);
        });
      } catch (t4) {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
    return ur(t3.shape, t3.dtype, n2);
  }, o2.prototype.makeOutput = function(t3, e2, n2) {
    var r2 = this.write(t3, e2, n2);
    return Nt.makeTensorFromDataId(r2, e2, n2, this);
  }, o2.prototype.disposeData = function(t3) {
    if (this.data.has(t3)) {
      var e2 = this.data.get(t3).complexTensors;
      null != e2 && (e2.real.dispose(), e2.imag.dispose()), this.data.delete(t3);
    }
  }, o2.prototype.time = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2;
      return r(this, function(n2) {
        return e2 = Y(), t3(), [2, {kernelMs: Y() - e2}];
      });
    });
  }, o2.prototype.memory = function() {
    return {unreliable: true, reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]};
  }, o2.prototype.complex = function(t3, e2) {
    var n2 = this.makeOutput(null, t3.shape, "complex64");
    return this.data.get(n2.dataId).complexTensors = {real: Nt.keep(t3.clone()), imag: Nt.keep(e2.clone())}, n2;
  }, o2.prototype.real = function(t3) {
    return this.data.get(t3.dataId).complexTensors.real.clone();
  }, o2.prototype.imag = function(t3) {
    return this.data.get(t3.dataId).complexTensors.imag.clone();
  }, o2.prototype.slice = function(t3, e2, n2) {
    if (kh(t3, "slice"), Yr(t3.shape, e2, n2)) {
      var r2 = Qr(e2, t3.strides), o3 = w(n2);
      return kn(this.readSync(t3.dataId).subarray(r2, r2 + o3), n2, t3.dtype);
    }
    for (var a2 = ur(n2, t3.dtype), i2 = this.bufferSync(t3), u2 = 0; u2 < a2.size; ++u2) {
      var s2 = a2.indexToLoc(u2).map(function(t4, n3) {
        return t4 + e2[n3];
      });
      a2.values[u2] = i2.get.apply(i2, s2);
    }
    return a2.toTensor();
  }, o2.prototype.stridedSlice = function(t3, e2, n2, r2) {
    kh(t3, "stridedSlice");
    var o3 = jr(e2, n2, r2);
    if (o3.some(function(t4) {
      return 0 === t4;
    }))
      return kn([], o3);
    for (var a2 = ur(o3, t3.dtype), i2 = this.bufferSync(t3), u2 = 0; u2 < a2.size; u2++) {
      for (var s2 = a2.indexToLoc(u2), c2 = new Array(s2.length), l2 = 0; l2 < c2.length; l2++)
        c2[l2] = s2[l2] * r2[l2] + e2[l2];
      a2.set.apply(a2, [i2.get.apply(i2, c2)].concat(s2));
    }
    return a2.toTensor();
  }, o2.prototype.diag = function(t3) {
    for (var e2 = this.readSync(t3.dataId), n2 = ur([t3.size, t3.size], t3.dtype), r2 = n2.values, o3 = 0; o3 < e2.length; o3++)
      r2[o3 * t3.size + o3] = e2[o3];
    return n2.toTensor();
  }, o2.prototype.unstack = function(t3, e2) {
    for (var n2 = t3.shape[e2], r2 = new Array(t3.rank - 1), o3 = 0, a2 = 0; a2 < t3.rank; a2++)
      a2 !== e2 && (r2[o3++] = t3.shape[a2]);
    var i2 = new Array(t3.rank).fill(0), u2 = t3.shape.slice();
    u2[e2] = 1;
    var s2 = new Array(n2);
    for (a2 = 0; a2 < s2.length; a2++)
      i2[e2] = a2, s2[a2] = this.slice(t3, i2, u2).reshape(r2);
    return s2;
  }, o2.prototype.reverse = function(t3, e2) {
    kh(t3, "reverse");
    for (var n2 = ur(t3.shape, t3.dtype), r2 = this.bufferSync(t3), o3 = function(o4) {
      var a3 = n2.indexToLoc(o4), i2 = a3.slice();
      e2.forEach(function(e3) {
        return i2[e3] = t3.shape[e3] - 1 - i2[e3];
      }), n2.set.apply(n2, [r2.get.apply(r2, i2)].concat(a3));
    }, a2 = 0; a2 < n2.size; a2++)
      o3(a2);
    return n2.toTensor();
  }, o2.prototype.concat = function(t3, e2) {
    var n2 = this;
    if ("complex64" === t3[0].dtype) {
      var r2 = t3.map(function(t4) {
        return Rn(t4);
      }), o3 = t3.map(function(t4) {
        return In(t4);
      });
      return En(this.concat(r2, e2), this.concat(o3, e2));
    }
    var a2 = t3.map(function(t4) {
      var n3 = w(t4.shape.slice(e2));
      return t4.as2D(-1, n3);
    }), i2 = wn(a2.map(function(t4) {
      return t4.shape;
    }), 1), u2 = ur(i2, t3[0].dtype).values;
    if (1 === a2[0].shape[0]) {
      var s2 = 0;
      a2.forEach(function(t4) {
        u2.set(n2.readSync(t4.dataId), s2), s2 += t4.size;
      });
    } else {
      var c2 = 0;
      a2.forEach(function(t4) {
        for (var e3 = n2.readSync(t4.dataId), r3 = 0, o4 = 0; o4 < t4.shape[0]; ++o4)
          for (var a3 = o4 * i2[1] + c2, s3 = 0; s3 < t4.shape[1]; ++s3)
            u2[a3 + s3] = e3[r3++];
        c2 += t4.shape[1];
      });
    }
    var l2 = wn(t3.map(function(t4) {
      return t4.shape;
    }), e2);
    return kn(u2, l2, t3[0].dtype);
  }, o2.prototype.neg = function(t3) {
    return kh(t3, "neg"), this.multiply(An(-1), t3);
  }, o2.prototype.add = function(t3, e2) {
    return "complex64" === t3.dtype || "complex64" === e2.dtype ? this.broadcastedBinaryComplexOp(t3.cast("complex64"), e2.cast("complex64"), function(t4, e3, n2, r2) {
      return {real: t4 + n2, imag: e3 + r2};
    }) : this.broadcastedBinaryOp(t3, e2, Ct(t3.dtype, e2.dtype), function(t4, e3) {
      return t4 + e3;
    });
  }, o2.prototype.addN = function(t3) {
    var e2 = this;
    kh(t3, "addN");
    for (var n2 = t3.map(function(t4) {
      return e2.readSync(t4.dataId);
    }), r2 = ur(t3[0].shape, t3[0].dtype), o3 = r2.values, a2 = 0; a2 < t3.length; a2++)
      for (var i2 = n2[a2], u2 = 0; u2 < o3.length; u2++)
        o3[u2] += i2[u2];
    return r2.toTensor();
  }, o2.prototype.subtract = function(t3, e2) {
    return "complex64" === t3.dtype || "complex64" === e2.dtype ? this.broadcastedBinaryComplexOp(t3.cast("complex64"), e2.cast("complex64"), function(t4, e3, n2, r2) {
      return {real: t4 - n2, imag: e3 - r2};
    }) : this.broadcastedBinaryOp(t3, e2, Ct(t3.dtype, e2.dtype), function(t4, e3) {
      return t4 - e3;
    });
  }, o2.prototype.pow = function(t3, e2) {
    return kh([t3, e2], "pow"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
      return Math.pow(t4, e3);
    });
  }, o2.prototype.batchMatMul = function(t3, e2, n2, r2) {
    kh([t3, e2], "matMul");
    for (var o3 = n2 ? t3.shape[1] : t3.shape[2], a2 = n2 ? t3.shape[2] : t3.shape[1], i2 = r2 ? e2.shape[1] : e2.shape[2], u2 = t3.shape[0], s2 = this.readSync(t3.dataId), c2 = this.readSync(e2.dataId), l2 = n2 ? [t3.strides[0], 1, t3.strides[1]] : [t3.strides[0], t3.strides[1], 1], h2 = l2[0], f2 = l2[1], p2 = l2[2], d2 = r2 ? [1, e2.strides[1], e2.strides[0]] : [e2.strides[1], 1, e2.strides[0]], v2 = d2[0], m2 = d2[1], g2 = d2[2], y2 = a2 * i2, x2 = ur([u2, a2, i2], t3.dtype), b2 = x2.values, w2 = this.blockSize, C2 = 0; C2 < u2; C2++)
      for (var E2 = 0; E2 < a2; E2 += w2)
        for (var R2 = 0; R2 < i2; R2 += w2)
          for (var I2 = 0; I2 < o3; I2 += w2)
            for (var k2 = Math.min(E2 + w2, a2), S2 = Math.min(R2 + w2, i2), A2 = Math.min(I2 + w2, o3), D2 = E2; D2 < k2; D2++)
              for (var T2 = R2; T2 < S2; T2++) {
                for (var N2 = 0, F2 = I2; F2 < A2; F2++)
                  N2 += s2[C2 * h2 + D2 * f2 + F2 * p2] * c2[F2 * v2 + T2 * m2 + C2 * g2];
                b2[C2 * y2 + (D2 * i2 + T2)] += N2;
              }
    return x2.toTensor();
  }, o2.prototype.fusedBatchMatMul = function(t3) {
    var e2 = t3.a, n2 = t3.b, r2 = t3.transposeA, o3 = t3.transposeB, a2 = t3.bias, i2 = t3.activation, u2 = t3.preluActivationWeights, s2 = this.batchMatMul(e2, n2, r2, o3);
    return a2 && (s2 = this.add(s2, a2)), i2 && (s2 = Sh(this, s2, i2, u2)), s2;
  }, o2.prototype.multiply = function(t3, e2) {
    return "complex64" === t3.dtype || "complex64" === e2.dtype ? this.broadcastedBinaryComplexOp(t3.cast("complex64"), e2.cast("complex64"), function(t4, e3, n2, r2) {
      return {real: t4 * n2 - e3 * r2, imag: t4 * r2 + e3 * n2};
    }) : this.broadcastedBinaryOp(t3, e2, Ct(t3.dtype, e2.dtype), function(t4, e3) {
      return t4 * e3;
    });
  }, o2.prototype.realDivide = function(t3, e2) {
    kh([t3, e2], "realDivide");
    return this.broadcastedBinaryOp(t3, e2, "float32", function(t4, e3) {
      return t4 / e3;
    });
  }, o2.prototype.floorDiv = function(t3, e2) {
    kh([t3, e2], "floorDiv");
    return this.broadcastedBinaryOp(t3, e2, "int32", function(t4, e3) {
      return Math.floor(t4 / e3);
    });
  }, o2.prototype.sum = function(t3, e2) {
    kh(t3, "sum"), mn("sum", e2, t3.rank);
    for (var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Pn(r2, Ct(t3.dtype, "int32")), i2 = w(o3), u2 = this.readSync(a2.dataId), s2 = this.readSync(t3.dataId), c2 = 0; c2 < u2.length; ++c2) {
      for (var l2 = c2 * i2, h2 = 0, f2 = 0; f2 < i2; ++f2)
        h2 += s2[l2 + f2];
      u2[c2] = h2;
    }
    return a2;
  }, o2.prototype.prod = function(t3, e2) {
    kh(t3, "sum");
    for (var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Pn(r2, Ct(t3.dtype, "int32")), i2 = w(o3), u2 = this.readSync(a2.dataId), s2 = this.readSync(t3.dataId), c2 = 0; c2 < u2.length; ++c2) {
      for (var l2 = c2 * i2, h2 = 1, f2 = 0; f2 < i2; ++f2)
        h2 *= s2[l2 + f2];
      u2[c2] = h2;
    }
    return a2;
  }, o2.prototype.unsortedSegmentSum = function(t3, e2, n2) {
    kh(t3, "unsortedSegmentSum");
    for (var r2 = [], o3 = t3.rank - e2.rank, a2 = 0; a2 < o3; ++a2)
      e2 = e2.expandDims(a2 + 1);
    for (a2 = 0; a2 < n2; ++a2) {
      var i2 = An(a2, "int32"), u2 = cc(i2, e2).asType("float32").mul(t3).sum(0);
      r2.push(u2);
    }
    return Tr(r2);
  }, o2.prototype.argMin = function(t3, e2) {
    kh(t3, "argMin");
    var n2 = [e2];
    mn("argMin", n2, t3.rank);
    for (var r2 = dn(t3.shape, n2), o3 = r2[0], a2 = r2[1], i2 = Pn(o3, "int32"), u2 = w(a2), s2 = this.readSync(i2.dataId), c2 = this.readSync(t3.dataId), l2 = 0; l2 < s2.length; ++l2) {
      for (var h2 = l2 * u2, f2 = c2[h2], p2 = 0, d2 = 0; d2 < u2; ++d2) {
        var v2 = c2[h2 + d2];
        v2 < f2 && (f2 = v2, p2 = d2);
      }
      s2[l2] = p2;
    }
    return i2;
  }, o2.prototype.argMax = function(t3, e2) {
    kh(t3, "argMax");
    var n2 = [e2];
    mn("argMax", n2, t3.rank);
    for (var r2 = dn(t3.shape, n2), o3 = r2[0], a2 = r2[1], i2 = Pn(o3, "int32"), u2 = w(a2), s2 = this.readSync(i2.dataId), c2 = this.readSync(t3.dataId), l2 = 0; l2 < s2.length; ++l2) {
      for (var h2 = l2 * u2, f2 = c2[h2], p2 = 0, d2 = 0; d2 < u2; ++d2) {
        var v2 = c2[h2 + d2];
        v2 > f2 && (f2 = v2, p2 = d2);
      }
      s2[l2] = p2;
    }
    return i2;
  }, o2.prototype.cumsum = function(t3, e2, n2, r2) {
    if (kh(t3, "cumsum"), e2 !== t3.rank - 1)
      throw new Error("backend.cumsum in CPU expects an inner-most axis=" + (t3.rank - 1) + " but got axis=" + e2);
    for (var o3 = Ct(t3.dtype, "int32"), a2 = Pn(t3.shape, o3), i2 = this.readSync(a2.dataId), u2 = this.readSync(t3.dataId), s2 = t3.shape[t3.rank - 1], c2 = r2 ? function(t4, e3) {
      return t4 + s2 - e3 - 1;
    } : function(t4, e3) {
      return t4 + e3;
    }, l2 = 0; l2 < u2.length; l2 += s2)
      for (var h2 = 0; h2 < s2; h2++) {
        var f2 = c2(l2, h2);
        if (0 === h2)
          i2[f2] = n2 ? 0 : u2[f2];
        else {
          var p2 = c2(l2, h2 - 1);
          i2[f2] = n2 ? u2[p2] + i2[p2] : u2[f2] + i2[p2];
        }
      }
    return a2;
  }, o2.prototype.equal = function(t3, e2) {
    return kh([t3, e2], "equal"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
      return t4 === e3 ? 1 : 0;
    });
  }, o2.prototype.notEqual = function(t3, e2) {
    return kh([t3, e2], "notEqual"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
      return t4 !== e3 ? 1 : 0;
    });
  }, o2.prototype.less = function(t3, e2) {
    return kh([t3, e2], "less"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
      return t4 < e3 ? 1 : 0;
    });
  }, o2.prototype.lessEqual = function(t3, e2) {
    return kh([t3, e2], "lessEqual"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
      return t4 <= e3 ? 1 : 0;
    });
  }, o2.prototype.greater = function(t3, e2) {
    return kh([t3, e2], "greater"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
      return t4 > e3 ? 1 : 0;
    });
  }, o2.prototype.greaterEqual = function(t3, e2) {
    return kh([t3, e2], "greaterEqual"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
      return t4 >= e3 ? 1 : 0;
    });
  }, o2.prototype.logicalNot = function(t3) {
    kh(t3, "logicalNot");
    for (var e2 = this.readSync(t3.dataId), n2 = new Uint8Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      n2[r2] = e2[r2] ? 0 : 1;
    return this.makeOutput(n2, t3.shape, "bool");
  }, o2.prototype.logicalAnd = function(t3, e2) {
    return kh([t3, e2], "logicalAnd"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
      return t4 && e3;
    });
  }, o2.prototype.logicalOr = function(t3, e2) {
    return kh([t3, e2], "logicalOr"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
      return t4 || e3;
    });
  }, o2.prototype.select = function(t3, e2, n2) {
    kh([t3, e2, n2], "select");
    for (var r2 = this.readSync(t3.dataId), o3 = this.readSync(e2.dataId), a2 = this.readSync(n2.dataId), i2 = Pn(e2.shape, Ct(e2.dtype, n2.dtype)), u2 = this.readSync(i2.dataId), s2 = 0, c2 = 0 === t3.rank || t3.rank > 1 || 1 === e2.rank ? 1 : w(e2.shape.slice(1)), l2 = 0; l2 < r2.length; l2++)
      for (var h2 = 0; h2 < c2; h2++)
        1 === r2[l2] ? u2[s2++] = o3[l2] : u2[s2++] = a2[l2];
    return i2;
  }, o2.prototype.where = function(t3) {
    kh([t3], "where");
    var e2 = this.readSync(t3.dataId);
    return Uo(t3.shape, e2);
  }, o2.prototype.topk = function(t3, e2, n2) {
    return kh(t3, "topk"), Wo(this.readSync(t3.dataId), t3.shape, t3.dtype, e2);
  }, o2.prototype.min = function(t3, e2) {
    kh(t3, "min"), mn("min", e2, t3.rank);
    for (var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Pn(r2, t3.dtype), i2 = w(o3), u2 = this.readSync(a2.dataId), s2 = this.readSync(t3.dataId), c2 = 0; c2 < u2.length; ++c2) {
      for (var l2 = c2 * i2, h2 = s2[l2], f2 = 0; f2 < i2; ++f2) {
        var p2 = s2[l2 + f2];
        p2 < h2 && (h2 = p2);
      }
      u2[c2] = h2;
    }
    return a2;
  }, o2.prototype.minimum = function(t3, e2) {
    return kh([t3, e2], "minimum"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
      return Math.min(t4, e3);
    });
  }, o2.prototype.mod = function(t3, e2) {
    return kh([t3, e2], "mod"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
      var n2 = t4 % e3;
      return t4 < 0 && e3 < 0 || t4 >= 0 && e3 >= 0 ? n2 : (n2 + e3) % e3;
    });
  }, o2.prototype.max = function(t3, e2) {
    kh(t3, "max"), mn("max", e2, t3.rank);
    for (var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Pn(r2, t3.dtype), i2 = w(o3), u2 = this.readSync(a2.dataId), s2 = this.readSync(t3.dataId), c2 = 0; c2 < u2.length; ++c2) {
      for (var l2 = c2 * i2, h2 = s2[l2], f2 = 0; f2 < i2; ++f2) {
        var p2 = s2[l2 + f2];
        p2 > h2 && (h2 = p2);
      }
      u2[c2] = h2;
    }
    return a2;
  }, o2.prototype.maximum = function(t3, e2) {
    return kh([t3, e2], "maximum"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
      return Math.max(t4, e3);
    });
  }, o2.prototype.all = function(t3, e2) {
    kh(t3, "all"), mn("all", e2, t3.rank);
    for (var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Pn(r2, t3.dtype), i2 = w(o3), u2 = this.readSync(a2.dataId), s2 = this.readSync(t3.dataId), c2 = 0; c2 < u2.length; ++c2) {
      for (var l2 = c2 * i2, h2 = s2[l2], f2 = 0; f2 < i2; ++f2) {
        var p2 = s2[l2 + f2];
        h2 = h2 && p2;
      }
      u2[c2] = h2;
    }
    return a2;
  }, o2.prototype.any = function(t3, e2) {
    kh(t3, "any"), mn("any", e2, t3.rank);
    for (var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Pn(r2, t3.dtype), i2 = w(o3), u2 = this.readSync(a2.dataId), s2 = this.readSync(t3.dataId), c2 = 0; c2 < u2.length; ++c2) {
      for (var l2 = c2 * i2, h2 = s2[l2], f2 = 0; f2 < i2; ++f2) {
        var p2 = s2[l2 + f2];
        h2 = h2 || p2;
      }
      u2[c2] = h2;
    }
    return a2;
  }, o2.prototype.squaredDifference = function(t3, e2) {
    return kh([t3, e2], "squaredDifference"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
      var n2 = t4 - e3;
      return n2 * n2;
    });
  }, o2.prototype.ceil = function(t3) {
    kh(t3, "ceil");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      n2[r2] = Math.ceil(e2[r2]);
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.floor = function(t3) {
    kh(t3, "floor");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      n2[r2] = Math.floor(e2[r2]);
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.sign = function(t3) {
    kh(t3, "x");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      e2[r2] < 0 ? n2[r2] = -1 : e2[r2] > 0 ? n2[r2] = 1 : n2[r2] = 0;
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.isNaN = function(t3) {
    kh(t3, "x");
    for (var e2 = this.readSync(t3.dataId), n2 = new Uint8Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      Number.isNaN(e2[r2]) && (n2[r2] = 1);
    return this.makeOutput(n2, t3.shape, "bool");
  }, o2.prototype.isInf = function(t3) {
    kh(t3, "x");
    for (var e2 = this.readSync(t3.dataId), n2 = new Uint8Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      Math.abs(e2[r2]) === 1 / 0 && (n2[r2] = 1);
    return this.makeOutput(n2, t3.shape, "bool");
  }, o2.prototype.isFinite = function(t3) {
    kh(t3, "x");
    for (var e2 = this.readSync(t3.dataId), n2 = new Uint8Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      Number.isFinite(e2[r2]) && (n2[r2] = 1);
    return this.makeOutput(n2, t3.shape, "bool");
  }, o2.prototype.round = function(t3) {
    kh(t3, "round");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
      var o3 = Math.floor(e2[r2]);
      e2[r2] - o3 < 0.5 ? n2[r2] = Math.floor(e2[r2]) : e2[r2] - o3 > 0.5 ? n2[r2] = Math.ceil(e2[r2]) : n2[r2] = o3 % 2 == 0 ? o3 : o3 + 1;
    }
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.exp = function(t3) {
    kh(t3, "exp");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      n2[r2] = Math.exp(e2[r2]);
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.expm1 = function(t3) {
    kh(t3, "expm1");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      n2[r2] = Math.expm1(e2[r2]);
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.log = function(t3) {
    kh(t3, "log");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
      var o3 = e2[r2];
      n2[r2] = Math.log(o3);
    }
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.log1p = function(t3) {
    kh(t3, "log1p");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
      var o3 = e2[r2];
      n2[r2] = Math.log1p(o3);
    }
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.sqrt = function(t3) {
    kh(t3, "sqrt");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
      var o3 = e2[r2];
      n2[r2] = Math.sqrt(o3);
    }
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.rsqrt = function(t3) {
    kh(t3, "rsqrt");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
      var o3 = e2[r2];
      n2[r2] = 1 / Math.sqrt(o3);
    }
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.reciprocal = function(t3) {
    kh(t3, "reciprocal");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      n2[r2] = 1 / e2[r2];
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.linear = function(t3) {
    return t3;
  }, o2.prototype.relu = function(t3) {
    kh(t3, "relu");
    for (var e2 = Pn(t3.shape, t3.dtype), n2 = this.readSync(e2.dataId), r2 = this.readSync(t3.dataId), o3 = 0; o3 < r2.length; ++o3)
      n2[o3] = Math.max(0, r2[o3]);
    return e2;
  }, o2.prototype.relu6 = function(t3) {
    kh(t3, "relu");
    for (var e2 = Pn(t3.shape, t3.dtype), n2 = this.readSync(e2.dataId), r2 = this.readSync(t3.dataId), o3 = 0; o3 < r2.length; ++o3)
      n2[o3] = Math.min(Math.max(0, r2[o3]), 6);
    return e2;
  }, o2.prototype.prelu = function(t3, e2) {
    return kh([t3, e2], "prelu"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
      return t4 < 0 ? e3 * t4 : t4;
    });
  }, o2.prototype.elu = function(t3) {
    kh(t3, "elu");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) {
      var o3 = n2[r2];
      e2[r2] = o3 >= 0 ? o3 : Math.exp(o3) - 1;
    }
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.eluDer = function(t3, e2) {
    kh([t3, e2], "eluDer");
    for (var n2 = new Float32Array(e2.size), r2 = this.readSync(e2.dataId), o3 = this.readSync(t3.dataId), a2 = 0; a2 < r2.length; ++a2) {
      var i2 = r2[a2];
      n2[a2] = i2 >= 1 ? o3[a2] : o3[a2] * (i2 + 1);
    }
    return this.makeOutput(n2, e2.shape, "float32");
  }, o2.prototype.selu = function(t3) {
    kh(t3, "selu");
    for (var e2 = iu, n2 = uu, r2 = new Float32Array(t3.size), o3 = this.readSync(t3.dataId), a2 = 0; a2 < o3.length; ++a2) {
      var i2 = o3[a2];
      r2[a2] = i2 >= 0 ? n2 * i2 : e2 * (Math.exp(i2) - 1);
    }
    return this.makeOutput(r2, t3.shape, "float32");
  }, o2.prototype.clip = function(t3, e2, n2) {
    kh(t3, "clip");
    for (var r2 = new Float32Array(t3.size), o3 = this.readSync(t3.dataId), a2 = 0; a2 < o3.length; ++a2) {
      var i2 = o3[a2];
      r2[a2] = i2 > n2 ? n2 : i2 < e2 ? e2 : i2;
    }
    return this.makeOutput(r2, t3.shape, "float32");
  }, o2.prototype.abs = function(t3) {
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.abs(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.complexAbs = function(t3) {
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < t3.size; ++r2) {
      var o3 = n2[2 * r2], a2 = n2[2 * r2 + 1];
      e2[r2] = Math.hypot(o3, a2);
    }
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.int = function(t3) {
    kh(t3, "int");
    for (var e2 = new Int32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = n2[r2];
    return this.makeOutput(e2, t3.shape, "int32");
  }, o2.prototype.sigmoid = function(t3) {
    kh(t3, "sigmoid");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = 1 / (1 + Math.exp(-n2[r2]));
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.softplus = function(t3) {
    kh(t3, "softplus");
    for (var e2 = Math.log(11920928955078125e-23) + 2, n2 = new Float32Array(t3.size), r2 = this.readSync(t3.dataId), o3 = 0; o3 < r2.length; ++o3) {
      var a2 = r2[o3] > -e2, i2 = r2[o3] < e2, u2 = Math.exp(r2[o3]), s2 = void 0;
      s2 = i2 ? u2 : a2 ? r2[o3] : Math.log(1 + u2), n2[o3] = s2;
    }
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.sin = function(t3) {
    kh(t3, "sin");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.sin(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.cos = function(t3) {
    kh(t3, "cos");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.cos(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.tan = function(t3) {
    kh(t3, "tan");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.tan(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.asin = function(t3) {
    kh(t3, "asin");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.asin(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.acos = function(t3) {
    kh(t3, "acos");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.acos(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.atan = function(t3) {
    kh(t3, "atan");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.atan(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.atan2 = function(t3, e2) {
    return kh([t3, e2], "atan2"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
      return Math.atan2(t4, e3);
    });
  }, o2.prototype.sinh = function(t3) {
    kh(t3, "sinh");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.sinh(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.cosh = function(t3) {
    kh(t3, "cosh");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.cosh(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.tanh = function(t3) {
    kh(t3, "tanh");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = R(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.asinh = function(t3) {
    kh(t3, "asinh");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.asinh(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.acosh = function(t3) {
    kh(t3, "acosh");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.acosh(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.atanh = function(t3) {
    kh(t3, "atanh");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.atanh(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.erf = function(t3) {
    kh(t3, "erf");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) {
      var o3 = Math.sign(n2[r2]), a2 = Math.abs(n2[r2]), i2 = 1 / (1 + 0.3275911 * a2);
      e2[r2] = o3 * (1 - ((((1.061405429 * i2 - 1.453152027) * i2 + 1.421413741) * i2 - 0.284496736) * i2 + 0.254829592) * i2 * Math.exp(-a2 * a2));
    }
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.step = function(t3, e2) {
    void 0 === e2 && (e2 = 0), kh(t3, "step");
    for (var n2 = new Float32Array(t3.size), r2 = this.readSync(t3.dataId), o3 = 0; o3 < r2.length; ++o3) {
      var a2 = r2[o3];
      isNaN(a2) ? n2[o3] = NaN : n2[o3] = a2 > 0 ? 1 : e2;
    }
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.fusedConv2d = function(t3) {
    var e2 = t3.input, n2 = t3.filter, r2 = t3.convInfo, o3 = t3.bias, a2 = t3.activation, i2 = t3.preluActivationWeights, u2 = this.conv2d(e2, n2, r2);
    return o3 && (u2 = this.add(u2, o3)), a2 && (u2 = Sh(this, u2, a2, i2)), u2;
  }, o2.prototype.conv2d = function(t3, e2, n2) {
    kh([t3, e2], "conv2d");
    for (var r2 = n2.filterHeight, o3 = n2.filterWidth, a2 = n2.dilationHeight, i2 = n2.dilationWidth, u2 = n2.padInfo.left, s2 = n2.padInfo.top, c2 = "channelsLast" === n2.dataFormat, l2 = ur(n2.outShape, t3.dtype), h2 = t3.strides[0], f2 = c2 ? t3.strides[1] : t3.strides[2], p2 = c2 ? t3.strides[2] : 1, d2 = c2 ? 1 : t3.strides[1], v2 = l2.strides[0], m2 = c2 ? l2.strides[1] : l2.strides[2], g2 = c2 ? l2.strides[2] : 1, y2 = c2 ? 1 : l2.strides[1], x2 = this.readSync(t3.dataId), b2 = this.readSync(e2.dataId), w2 = l2.values, C2 = 0; C2 < n2.batchSize; ++C2)
      for (var E2 = C2 * h2, R2 = C2 * v2, I2 = 0; I2 < n2.outHeight; ++I2)
        for (var k2 = R2 + I2 * m2, S2 = I2 * n2.strideHeight - s2, A2 = 0; A2 < r2; A2++) {
          var D2 = S2 + A2 * a2;
          if (!(D2 < 0 || D2 >= n2.inHeight))
            for (var T2 = A2 * e2.strides[0], N2 = E2 + D2 * f2, F2 = 0; F2 < n2.outWidth; ++F2)
              for (var O2 = k2 + F2 * g2, _2 = F2 * n2.strideWidth - u2, M2 = 0; M2 < o3; M2++) {
                var B2 = _2 + M2 * i2;
                if (!(B2 < 0 || B2 >= n2.inWidth))
                  for (var P2 = N2 + B2 * p2, L2 = T2 + M2 * e2.strides[1], W2 = 0; W2 < n2.inChannels; ++W2) {
                    for (var U2 = x2[P2 + W2 * d2], V2 = 0; V2 < n2.outChannels; ++V2)
                      w2[O2 + V2 * y2] += U2 * b2[L2 + V2];
                    L2 += n2.outChannels;
                  }
              }
        }
    return l2.toTensor();
  }, o2.prototype.conv3d = function(t3, e2, n2) {
    for (var r2 = n2.filterDepth, o3 = n2.filterHeight, a2 = n2.filterWidth, i2 = n2.dilationDepth, u2 = n2.dilationHeight, s2 = n2.dilationWidth, c2 = n2.padInfo.front, l2 = n2.padInfo.left, h2 = n2.padInfo.top, f2 = ur(n2.outShape, t3.dtype), p2 = this.readSync(t3.dataId), d2 = this.readSync(e2.dataId), v2 = f2.values, m2 = 0; m2 < n2.batchSize; ++m2)
      for (var g2 = m2 * t3.strides[0], y2 = m2 * f2.strides[0], x2 = 0; x2 < n2.outDepth; ++x2)
        for (var b2 = y2 + x2 * f2.strides[1], w2 = x2 * n2.strideDepth - c2, C2 = 0; C2 < r2; C2++) {
          var E2 = w2 + C2 * i2;
          if (!(E2 < 0 || E2 >= n2.inDepth))
            for (var R2 = C2 * e2.strides[0], I2 = g2 + E2 * t3.strides[1], k2 = 0; k2 < n2.outHeight; ++k2)
              for (var S2 = b2 + k2 * f2.strides[2], A2 = k2 * n2.strideHeight - h2, D2 = 0; D2 < o3; D2++) {
                var T2 = A2 + D2 * u2;
                if (!(T2 < 0 || T2 >= n2.inHeight))
                  for (var N2 = R2 + D2 * e2.strides[1], F2 = I2 + T2 * t3.strides[2], O2 = 0; O2 < n2.outWidth; ++O2)
                    for (var _2 = S2 + O2 * n2.outChannels, M2 = O2 * n2.strideWidth - l2, B2 = 0; B2 < a2; B2++) {
                      var P2 = M2 + B2 * s2;
                      if (!(P2 < 0 || P2 >= n2.inWidth))
                        for (var L2 = N2 + B2 * e2.strides[2], W2 = F2 + P2 * n2.inChannels, U2 = L2, V2 = 0; V2 < n2.inChannels; ++V2) {
                          for (var z2 = p2[W2 + V2], G2 = 0; G2 < n2.outChannels; ++G2)
                            v2[_2 + G2] += z2 * d2[U2 + G2];
                          U2 += n2.outChannels;
                        }
                    }
              }
        }
    return f2.toTensor();
  }, o2.prototype.conv2dDerInput = function(t3, e2, n2) {
    kh([t3, e2], "conv2dDerInput");
    for (var r2 = ur(n2.inShape, "float32"), o3 = r2.values, a2 = this.readSync(t3.dataId), i2 = this.readSync(e2.dataId), u2 = e2.strides, s2 = u2[0], c2 = u2[1], l2 = u2[2], h2 = n2.batchSize, f2 = n2.filterHeight, p2 = n2.filterWidth, d2 = n2.inChannels, v2 = n2.inHeight, m2 = n2.inWidth, g2 = n2.outChannels, y2 = n2.outHeight, x2 = n2.outWidth, b2 = n2.strideHeight, w2 = n2.strideWidth, C2 = n2.dataFormat, E2 = f2 - 1 - n2.padInfo.top, R2 = p2 - 1 - n2.padInfo.left, I2 = "channelsLast" === C2, k2 = r2.strides[0], S2 = I2 ? r2.strides[1] : r2.strides[2], A2 = I2 ? r2.strides[2] : 1, D2 = I2 ? 1 : r2.strides[1], T2 = t3.strides[0], N2 = I2 ? t3.strides[1] : t3.strides[2], F2 = I2 ? t3.strides[2] : 1, O2 = I2 ? 1 : t3.strides[1], _2 = 0; _2 < h2; ++_2)
      for (var M2 = 0; M2 < d2; ++M2)
        for (var B2 = 0; B2 < v2; ++B2)
          for (var P2 = B2 - E2, L2 = Math.max(0, Math.ceil(P2 / b2)), W2 = Math.min(y2, (f2 + P2) / b2), U2 = 0; U2 < m2; ++U2) {
            for (var V2 = U2 - R2, z2 = Math.max(0, Math.ceil(V2 / w2)), G2 = Math.min(x2, (p2 + V2) / w2), H2 = 0, q2 = L2; q2 < W2; ++q2)
              for (var K2 = q2 * b2 - P2, j2 = z2; j2 < G2; ++j2)
                for (var X2 = T2 * _2 + N2 * q2 + F2 * j2, $2 = s2 * (f2 - 1 - K2) + c2 * (p2 - 1 - (j2 * w2 - V2)) + l2 * M2, Y2 = 0; Y2 < g2; ++Y2) {
                  H2 += a2[X2 + O2 * Y2] * i2[$2 + Y2];
                }
            o3[k2 * _2 + S2 * B2 + A2 * U2 + D2 * M2] = H2;
          }
    return r2.toTensor();
  }, o2.prototype.conv3dDerInput = function(t3, e2, n2) {
    for (var r2 = ur(n2.inShape, "float32"), o3 = r2.values, a2 = r2.strides, i2 = a2[0], u2 = a2[1], s2 = a2[2], c2 = a2[3], l2 = this.readSync(t3.dataId), h2 = t3.strides, f2 = h2[0], p2 = h2[1], d2 = h2[2], v2 = h2[3], m2 = this.readSync(e2.dataId), g2 = e2.strides, y2 = g2[0], x2 = g2[1], b2 = g2[2], w2 = g2[3], C2 = n2.batchSize, E2 = n2.filterDepth, R2 = n2.filterHeight, I2 = n2.filterWidth, k2 = n2.inChannels, S2 = n2.inDepth, A2 = n2.inHeight, D2 = n2.inWidth, T2 = n2.outChannels, N2 = n2.outDepth, F2 = n2.outHeight, O2 = n2.outWidth, _2 = n2.strideDepth, M2 = n2.strideHeight, B2 = n2.strideWidth, P2 = E2 - 1 - n2.padInfo.front, L2 = R2 - 1 - n2.padInfo.top, W2 = I2 - 1 - n2.padInfo.left, U2 = 0; U2 < C2; ++U2)
      for (var V2 = 0; V2 < k2; ++V2)
        for (var z2 = 0; z2 < S2; ++z2)
          for (var G2 = z2 - P2, H2 = Math.max(0, Math.ceil(G2 / _2)), q2 = Math.min(N2, (E2 + G2) / _2), K2 = 0; K2 < A2; ++K2)
            for (var j2 = K2 - L2, X2 = Math.max(0, Math.ceil(j2 / M2)), $2 = Math.min(F2, (R2 + j2) / M2), Y2 = 0; Y2 < D2; ++Y2) {
              for (var Q2 = Y2 - W2, J2 = Math.max(0, Math.ceil(Q2 / B2)), Z2 = Math.min(O2, (I2 + Q2) / B2), tt2 = 0, et2 = H2; et2 < q2; ++et2)
                for (var nt2 = et2 * _2 - G2, rt2 = X2; rt2 < $2; ++rt2)
                  for (var ot2 = rt2 * M2 - j2, at2 = J2; at2 < Z2; ++at2)
                    for (var it2 = f2 * U2 + p2 * et2 + d2 * rt2 + v2 * at2, ut2 = y2 * (E2 - 1 - nt2) + x2 * (R2 - 1 - ot2) + b2 * (I2 - 1 - (at2 * B2 - Q2)) + w2 * V2, st2 = 0; st2 < T2; ++st2) {
                      tt2 += l2[it2 + st2] * m2[ut2 + st2];
                    }
              o3[i2 * U2 + u2 * z2 + s2 * K2 + c2 * Y2 + V2] = tt2;
            }
    return r2.toTensor();
  }, o2.prototype.conv2dDerFilter = function(t3, e2, n2) {
    kh([t3, e2], "conv2dDerFilter");
    for (var r2 = n2.strideHeight, o3 = n2.strideWidth, a2 = n2.filterHeight, i2 = n2.filterWidth, u2 = "channelsLast" === n2.dataFormat, s2 = ur(n2.filterShape, "float32"), c2 = n2.padInfo.left, l2 = n2.padInfo.top, h2 = this.bufferSync(t3), f2 = this.bufferSync(e2), p2 = 0; p2 < a2; ++p2)
      for (var d2 = Math.max(0, Math.ceil((l2 - p2) / r2)), v2 = Math.min(n2.outHeight, (n2.inHeight + l2 - p2) / r2), m2 = 0; m2 < i2; ++m2)
        for (var g2 = Math.max(0, Math.ceil((c2 - m2) / o3)), y2 = Math.min(n2.outWidth, (n2.inWidth + c2 - m2) / o3), x2 = 0; x2 < n2.inChannels; ++x2)
          for (var b2 = 0; b2 < n2.outChannels; ++b2) {
            for (var w2 = 0, C2 = 0; C2 < n2.batchSize; ++C2)
              for (var E2 = d2; E2 < v2; ++E2)
                for (var R2 = p2 + E2 * r2 - l2, I2 = g2; I2 < y2; ++I2) {
                  var k2 = m2 + I2 * o3 - c2;
                  w2 += u2 ? h2.get(C2, R2, k2, x2) * f2.get(C2, E2, I2, b2) : h2.get(C2, x2, R2, k2) * f2.get(C2, b2, E2, I2);
                }
            s2.set(w2, p2, m2, x2, b2);
          }
    return s2.toTensor();
  }, o2.prototype.conv3dDerFilter = function(t3, e2, n2) {
    for (var r2 = n2.strideDepth, o3 = n2.strideHeight, a2 = n2.strideWidth, i2 = n2.filterDepth, u2 = n2.filterHeight, s2 = n2.filterWidth, c2 = ur(n2.filterShape, "float32"), l2 = c2.values, h2 = c2.strides, f2 = h2[0], p2 = h2[1], d2 = h2[2], v2 = h2[3], m2 = this.readSync(e2.dataId), g2 = e2.strides, y2 = g2[0], x2 = g2[1], b2 = g2[2], w2 = g2[3], C2 = this.readSync(t3.dataId), E2 = t3.strides, R2 = E2[0], I2 = E2[1], k2 = E2[2], S2 = E2[3], A2 = n2.padInfo.front, D2 = n2.padInfo.left, T2 = n2.padInfo.top, N2 = 0; N2 < i2; ++N2)
      for (var F2 = Math.max(0, Math.ceil((A2 - N2) / r2)), O2 = Math.min(n2.outDepth, (n2.inDepth + A2 - N2) / r2), _2 = N2 * f2, M2 = 0; M2 < u2; ++M2)
        for (var B2 = Math.max(0, Math.ceil((T2 - M2) / o3)), P2 = Math.min(n2.outHeight, (n2.inHeight + T2 - M2) / o3), L2 = M2 * p2 + _2, W2 = 0; W2 < s2; ++W2)
          for (var U2 = Math.max(0, Math.ceil((D2 - W2) / a2)), V2 = Math.min(n2.outWidth, (n2.inWidth + D2 - W2) / a2), z2 = W2 * d2 + L2, G2 = 0; G2 < n2.inChannels; ++G2)
            for (var H2 = G2 * v2 + z2, q2 = 0; q2 < n2.outChannels; ++q2) {
              for (var K2 = 0, j2 = 0; j2 < n2.batchSize; ++j2)
                for (var X2 = j2 * R2, $2 = j2 * y2, Y2 = F2; Y2 < O2; ++Y2)
                  for (var Q2 = (N2 + Y2 * r2 - A2) * I2 + X2, J2 = Y2 * x2 + $2, Z2 = B2; Z2 < P2; ++Z2)
                    for (var tt2 = (M2 + Z2 * o3 - T2) * k2 + Q2, et2 = Z2 * b2 + J2, nt2 = U2; nt2 < V2; ++nt2) {
                      var rt2 = nt2 * w2 + et2;
                      K2 += C2[(W2 + nt2 * a2 - D2) * S2 + tt2 + G2] * m2[rt2 + q2];
                    }
              l2[H2 + q2] = K2;
            }
    return c2.toTensor();
  }, o2.prototype.fusedDepthwiseConv2D = function(t3) {
    var e2 = t3.input, n2 = t3.filter, r2 = t3.convInfo, o3 = t3.bias, a2 = t3.activation, i2 = t3.preluActivationWeights, u2 = this.depthwiseConv2D(e2, n2, r2);
    return o3 && (u2 = this.add(u2, o3)), a2 && (u2 = Sh(this, u2, a2, i2)), u2;
  }, o2.prototype.depthwiseConv2D = function(t3, e2, n2) {
    kh([t3, e2], "depthwiseConv2D");
    for (var r2 = n2.filterHeight, o3 = n2.filterWidth, a2 = n2.dilationHeight, i2 = n2.dilationWidth, u2 = n2.padInfo.left, s2 = n2.padInfo.top, c2 = n2.outChannels / n2.inChannels, l2 = ur(n2.outShape, t3.dtype), h2 = this.readSync(t3.dataId), f2 = this.readSync(e2.dataId), p2 = l2.values, d2 = 0; d2 < n2.batchSize; ++d2)
      for (var v2 = d2 * t3.strides[0], m2 = d2 * l2.strides[0], g2 = 0; g2 < n2.outHeight; ++g2)
        for (var y2 = m2 + g2 * l2.strides[1], x2 = g2 * n2.strideHeight - u2, b2 = 0; b2 < r2; ++b2) {
          var w2 = x2 + b2 * a2;
          if (!(w2 < 0 || w2 >= n2.inHeight))
            for (var C2 = b2 * e2.strides[0], E2 = v2 + w2 * t3.strides[1], R2 = 0; R2 < n2.outWidth; ++R2)
              for (var I2 = y2 + R2 * l2.strides[2], k2 = R2 * n2.strideWidth - s2, S2 = 0; S2 < o3; ++S2) {
                var A2 = k2 + S2 * i2;
                if (!(A2 < 0 || A2 >= n2.inWidth))
                  for (var D2 = C2 + S2 * e2.strides[1], T2 = E2 + A2 * n2.inChannels, N2 = I2, F2 = D2, O2 = 0; O2 < n2.inChannels; ++O2) {
                    for (var _2 = h2[T2 + O2], M2 = 0; M2 < c2; ++M2)
                      p2[N2 + M2] += _2 * f2[F2 + M2];
                    N2 += c2, F2 += c2;
                  }
              }
        }
    return l2.toTensor();
  }, o2.prototype.depthwiseConv2DDerInput = function(t3, e2, n2) {
    kh([t3, e2], "depthwiseConv2DDerInput");
    for (var r2 = ur(n2.inShape, "float32"), o3 = r2.values, a2 = r2.strides, i2 = a2[0], u2 = a2[1], s2 = a2[2], c2 = this.readSync(t3.dataId), l2 = t3.strides, h2 = l2[0], f2 = l2[1], p2 = l2[2], d2 = this.readSync(e2.dataId), v2 = e2.strides, m2 = v2[0], g2 = v2[1], y2 = v2[2], x2 = n2.batchSize, b2 = n2.filterHeight, w2 = n2.filterWidth, C2 = n2.inChannels, E2 = n2.inHeight, R2 = n2.inWidth, I2 = n2.outChannels, k2 = n2.outHeight, S2 = n2.outWidth, A2 = n2.strideHeight, D2 = n2.strideWidth, T2 = b2 - 1 - n2.padInfo.top, N2 = w2 - 1 - n2.padInfo.left, F2 = I2 / C2, O2 = 0; O2 < x2; ++O2)
      for (var _2 = 0; _2 < C2; ++_2)
        for (var M2 = 0; M2 < E2; ++M2)
          for (var B2 = M2 - T2, P2 = Math.max(0, Math.ceil(B2 / A2)), L2 = Math.min(k2, (b2 + B2) / A2), W2 = 0; W2 < R2; ++W2) {
            for (var U2 = W2 - N2, V2 = Math.max(0, Math.ceil(U2 / D2)), z2 = Math.min(S2, (w2 + U2) / D2), G2 = 0, H2 = P2; H2 < L2; ++H2)
              for (var q2 = H2 * A2 - B2, K2 = V2; K2 < z2; ++K2)
                for (var j2 = h2 * O2 + f2 * H2 + p2 * K2, X2 = m2 * (b2 - 1 - q2) + g2 * (w2 - 1 - (K2 * D2 - U2)) + y2 * _2, $2 = 0; $2 < F2; ++$2) {
                  G2 += c2[j2 + (_2 * F2 + $2)] * d2[X2 + $2];
                }
            o3[i2 * O2 + u2 * M2 + s2 * W2 + _2] = G2;
          }
    return r2.toTensor();
  }, o2.prototype.depthwiseConv2DDerFilter = function(t3, e2, n2) {
    kh([t3, e2], "depthwiseConv2DDerFilter");
    for (var r2 = n2.strideHeight, o3 = n2.strideWidth, a2 = n2.filterHeight, i2 = n2.filterWidth, u2 = ur(n2.filterShape, "float32"), s2 = n2.padInfo.left, c2 = n2.padInfo.top, l2 = n2.outChannels / n2.inChannels, h2 = this.bufferSync(t3), f2 = this.bufferSync(e2), p2 = 0; p2 < a2; ++p2)
      for (var d2 = Math.max(0, Math.ceil((c2 - p2) / r2)), v2 = Math.min(n2.outHeight, (n2.inHeight + c2 - p2) / r2), m2 = 0; m2 < i2; ++m2)
        for (var g2 = Math.max(0, Math.ceil((s2 - m2) / o3)), y2 = Math.min(n2.outWidth, (n2.inWidth + s2 - m2) / o3), x2 = 0; x2 < n2.outChannels; ++x2) {
          for (var b2 = Math.trunc(x2 / l2), w2 = x2 % l2, C2 = 0, E2 = 0; E2 < n2.batchSize; ++E2)
            for (var R2 = d2; R2 < v2; ++R2)
              for (var I2 = p2 + R2 * r2 - c2, k2 = g2; k2 < y2; ++k2) {
                var S2 = m2 + k2 * o3 - s2;
                C2 += h2.get(E2, I2, S2, b2) * f2.get(E2, R2, k2, x2);
              }
          u2.set(C2, p2, m2, b2, w2);
        }
    return u2.toTensor();
  }, o2.prototype.tile = function(t3, e2) {
    return kh(t3, "tile"), Lo(this.bufferSync(t3), e2);
  }, o2.prototype.pad = function(t3, e2, n2) {
    kh(t3, "pad");
    var r2 = e2.map(function(e3, n3) {
      return e3[0] + t3.shape[n3] + e3[1];
    }), o3 = e2.map(function(t4) {
      return t4[0];
    }), a2 = this.bufferSync(t3), i2 = ur(r2, t3.dtype);
    0 !== n2 && i2.values.fill(n2);
    for (var u2 = 0; u2 < t3.size; u2++) {
      var s2 = a2.indexToLoc(u2), c2 = s2.map(function(t4, e3) {
        return t4 + o3[e3];
      });
      i2.set.apply(i2, [a2.get.apply(a2, s2)].concat(c2));
    }
    return i2.toTensor();
  }, o2.prototype.transpose = function(t3, e2) {
    kh(t3, "transpose");
    for (var n2 = new Array(t3.rank), r2 = 0; r2 < n2.length; r2++)
      n2[r2] = t3.shape[e2[r2]];
    var o3 = this.readSync(t3.dataId), a2 = ur(n2, t3.dtype), i2 = this.bufferSync(t3);
    for (r2 = 0; r2 < t3.size; ++r2) {
      for (var u2 = i2.indexToLoc(r2), s2 = new Array(u2.length), c2 = 0; c2 < s2.length; c2++)
        s2[c2] = u2[e2[c2]];
      var l2 = a2.locToIndex(s2);
      a2.values[l2] = o3[r2];
    }
    return a2.toTensor();
  }, o2.prototype.gather = function(t3, e2, n2) {
    kh([t3, e2], "gather");
    var r2 = t3.shape.slice(), o3 = this.readSync(e2.dataId);
    r2[n2] = o3.length;
    for (var a2 = ur(r2, t3.dtype), i2 = this.bufferSync(t3), u2 = 0; u2 < a2.size; ++u2) {
      var s2 = a2.indexToLoc(u2), c2 = s2.slice();
      c2[n2] = o3[s2[n2]];
      var l2 = i2.locToIndex(c2);
      a2.values[u2] = i2.values[l2];
    }
    return a2.toTensor();
  }, o2.prototype.batchToSpaceND = function(t3, e2, n2) {
    kh([t3], "batchToSpaceND");
    var r2 = e2.reduce(function(t4, e3) {
      return t4 * e3;
    }), o3 = Mr(t3.shape, e2, r2), a2 = Br(o3.length, e2.length), i2 = Pr(t3.shape, e2, r2), u2 = Lr(n2, e2.length), s2 = Wr(i2, n2, e2.length);
    return t3.reshape(o3).transpose(a2).reshape(i2).slice(u2, s2);
  }, o2.prototype.spaceToBatchND = function(t3, e2, n2) {
    kh([t3], "spaceToBatchND");
    var r2 = e2.reduce(function(t4, e3) {
      return t4 * e3;
    }), o3 = [[0, 0]];
    o3.push.apply(o3, n2);
    for (var a2 = 1 + e2.length; a2 < t3.shape.length; ++a2)
      o3.push([0, 0]);
    var i2 = t3.pad(o3), u2 = Mr(i2.shape, e2, r2, false), s2 = Br(u2.length, e2.length, false), c2 = Pr(i2.shape, e2, r2, false);
    return i2.reshape(u2).transpose(s2).reshape(c2);
  }, o2.prototype.pool = function(t3, e2, n2) {
    kh(t3, "pool");
    for (var r2 = e2.strideHeight, o3 = e2.strideWidth, a2 = e2.dilationHeight, i2 = e2.dilationWidth, u2 = e2.effectiveFilterHeight, s2 = e2.effectiveFilterWidth, c2 = e2.padInfo.top, l2 = e2.padInfo.left, h2 = "max" === n2 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, f2 = this.readSync(t3.dataId), p2 = ur(e2.outShape, t3.dtype), d2 = p2.values, v2 = e2.outShape[1] * e2.outShape[2] * e2.outShape[3], m2 = e2.outShape[2] * e2.outShape[3], g2 = e2.outShape[3], y2 = 0; y2 < e2.batchSize; ++y2)
      for (var x2 = y2 * v2, b2 = y2 * t3.strides[0], w2 = 0; w2 < e2.inChannels; ++w2)
        for (var C2 = 0; C2 < e2.outHeight; ++C2)
          for (var E2 = C2 * r2 - c2, R2 = Math.max(0, E2), I2 = Math.min(e2.inHeight, u2 + E2), k2 = x2 + C2 * m2, S2 = 0; S2 < e2.outWidth; ++S2) {
            for (var A2 = S2 * o3 - l2, D2 = Math.max(0, A2), T2 = Math.min(e2.inWidth, s2 + A2), N2 = h2, F2 = 0, O2 = 0, _2 = R2; _2 < I2; _2 += a2) {
              for (var M2 = b2 + _2 * t3.strides[1], B2 = D2; B2 < T2; B2 += i2) {
                var P2 = f2[M2 + B2 * t3.strides[2] + w2];
                "max" === n2 && P2 > N2 ? N2 = P2 : "avg" === n2 && (F2 += P2, O2++);
              }
              if (isNaN(N2))
                break;
            }
            d2[k2 + S2 * g2 + w2] = "avg" === n2 ? F2 / O2 : N2;
          }
    return p2.toTensor();
  }, o2.prototype.maxPool = function(t3, e2) {
    return this.pool(t3, e2, "max");
  }, o2.prototype.maxPoolPositions = function(t3, e2) {
    for (var n2 = ur(e2.outShape, "int32"), r2 = e2.strideHeight, o3 = e2.strideWidth, a2 = e2.dilationHeight, i2 = e2.dilationWidth, u2 = e2.effectiveFilterHeight, s2 = e2.effectiveFilterWidth, c2 = e2.padInfo.top, l2 = e2.padInfo.left, h2 = this.bufferSync(t3), f2 = 0; f2 < e2.batchSize; ++f2)
      for (var p2 = 0; p2 < e2.inChannels; ++p2)
        for (var d2 = 0; d2 < e2.outHeight; ++d2) {
          for (var v2 = d2 * r2 - c2, m2 = v2; m2 < 0; )
            m2 += a2;
          for (var g2 = Math.min(e2.inHeight, u2 + v2), y2 = 0; y2 < e2.outWidth; ++y2) {
            for (var x2 = y2 * o3 - l2, b2 = x2; b2 < 0; )
              b2 += i2;
            for (var w2 = Math.min(e2.inWidth, s2 + x2), C2 = Number.NEGATIVE_INFINITY, E2 = -1, R2 = m2; R2 < g2; R2 += a2)
              for (var I2 = R2 - v2, k2 = b2; k2 < w2; k2 += i2) {
                var S2 = k2 - x2, A2 = h2.get(f2, R2, k2, p2);
                A2 > C2 && (C2 = A2, E2 = I2 * s2 + S2);
              }
            n2.set(E2, f2, d2, y2, p2);
          }
        }
    return n2.toTensor();
  }, o2.prototype.maxPoolBackprop = function(t3, e2, n2, r2) {
    kh([e2, n2], "maxPoolBackprop");
    for (var o3 = this.maxPoolPositions(e2, r2), a2 = r2.strideHeight, i2 = r2.strideWidth, u2 = r2.dilationHeight, s2 = r2.dilationWidth, c2 = r2.effectiveFilterHeight, l2 = r2.effectiveFilterWidth, h2 = l2 - 1 - r2.padInfo.left, f2 = c2 - 1 - r2.padInfo.top, p2 = ur(e2.shape, "float32"), d2 = this.bufferSync(o3), v2 = this.bufferSync(t3), m2 = 0; m2 < r2.batchSize; ++m2)
      for (var g2 = 0; g2 < r2.inChannels; ++g2)
        for (var y2 = 0; y2 < r2.inHeight; ++y2)
          for (var x2 = 0; x2 < r2.inWidth; ++x2) {
            for (var b2 = y2 - f2, w2 = x2 - h2, C2 = 0, E2 = 0; E2 < c2; E2 += u2) {
              var R2 = (b2 + E2) / a2;
              if (!(R2 < 0 || R2 >= r2.outHeight || Math.floor(R2) !== R2))
                for (var I2 = 0; I2 < l2; I2 += s2) {
                  var k2 = (w2 + I2) / i2;
                  if (!(k2 < 0 || k2 >= r2.outWidth || Math.floor(k2) !== k2)) {
                    var S2 = c2 * l2 - 1 - d2.get(m2, R2, k2, g2) === E2 * l2 + I2 ? 1 : 0;
                    if (0 !== S2)
                      C2 += v2.get(m2, R2, k2, g2) * S2;
                  }
                }
            }
            p2.set(C2, m2, y2, x2, g2);
          }
    return p2.toTensor();
  }, o2.prototype.avgPoolBackprop = function(t3, e2, n2) {
    kh([t3, e2], "avgPoolBackprop");
    for (var r2 = n2.strideHeight, o3 = n2.strideWidth, a2 = n2.filterHeight, i2 = n2.filterWidth, u2 = n2.dilationHeight, s2 = n2.dilationWidth, c2 = n2.effectiveFilterHeight, l2 = n2.effectiveFilterWidth, h2 = l2 - 1 - n2.padInfo.left, f2 = c2 - 1 - n2.padInfo.top, p2 = ur(e2.shape, "float32"), d2 = 1 / (a2 * i2), v2 = this.bufferSync(t3), m2 = 0; m2 < n2.batchSize; ++m2)
      for (var g2 = 0; g2 < n2.inChannels; ++g2)
        for (var y2 = 0; y2 < n2.inHeight; ++y2)
          for (var x2 = 0; x2 < n2.inWidth; ++x2) {
            for (var b2 = y2 - f2, w2 = x2 - h2, C2 = 0, E2 = 0; E2 < c2; E2 += u2) {
              var R2 = (b2 + E2) / r2;
              if (!(R2 < 0 || R2 >= n2.outHeight || Math.floor(R2) !== R2))
                for (var I2 = 0; I2 < l2; I2 += s2) {
                  var k2 = (w2 + I2) / o3;
                  if (!(k2 < 0 || k2 >= n2.outWidth || Math.floor(k2) !== k2))
                    C2 += v2.get(m2, R2, k2, g2);
                }
            }
            p2.set(C2 * d2, m2, y2, x2, g2);
          }
    return p2.toTensor();
  }, o2.prototype.pool3d = function(t3, e2, n2) {
    kh(t3, "pool3d");
    for (var r2 = e2.strideDepth, o3 = e2.strideHeight, a2 = e2.strideWidth, i2 = e2.dilationDepth, u2 = e2.dilationHeight, s2 = e2.dilationWidth, c2 = e2.effectiveFilterDepth, l2 = e2.effectiveFilterHeight, h2 = e2.effectiveFilterWidth, f2 = e2.padInfo.front, p2 = e2.padInfo.top, d2 = e2.padInfo.left, v2 = "max" === n2 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, m2 = this.readSync(t3.dataId), g2 = ur(e2.outShape, t3.dtype), y2 = g2.values, x2 = e2.outShape[1] * e2.outShape[2] * e2.outShape[3] * e2.outShape[4], b2 = e2.outShape[2] * e2.outShape[3] * e2.outShape[4], w2 = e2.outShape[3] * e2.outShape[4], C2 = e2.outShape[4], E2 = 0; E2 < e2.batchSize; ++E2)
      for (var R2 = E2 * x2, I2 = E2 * t3.strides[0], k2 = 0; k2 < e2.inChannels; ++k2)
        for (var S2 = 0; S2 < e2.outDepth; ++S2) {
          for (var A2 = S2 * r2 - f2, D2 = A2; D2 < 0; )
            D2 += i2;
          for (var T2 = Math.min(e2.inDepth, c2 + A2), N2 = R2 + S2 * b2, F2 = 0; F2 < e2.outHeight; ++F2) {
            for (var O2 = F2 * o3 - p2, _2 = O2; _2 < 0; )
              _2 += u2;
            for (var M2 = Math.min(e2.inHeight, l2 + O2), B2 = N2 + F2 * w2, P2 = 0; P2 < e2.outWidth; ++P2) {
              for (var L2 = P2 * a2 - d2, W2 = L2; W2 < 0; )
                W2 += s2;
              for (var U2 = Math.min(e2.inWidth, h2 + L2), V2 = B2 + P2 * C2, z2 = v2, G2 = 0, H2 = 0, q2 = D2; q2 < T2; q2 += i2) {
                for (var K2 = I2 + q2 * t3.strides[1], j2 = _2; j2 < M2; j2 += u2) {
                  for (var X2 = K2 + j2 * t3.strides[2], $2 = W2; $2 < U2; $2 += s2) {
                    var Y2 = m2[X2 + $2 * t3.strides[3] + k2];
                    if ("max" === n2 && Y2 > z2 ? z2 = Y2 : "avg" === n2 && (G2 += Y2, H2++), isNaN(z2))
                      break;
                  }
                  if (isNaN(z2))
                    break;
                }
                if (isNaN(z2))
                  break;
              }
              y2[V2 + k2] = "avg" === n2 ? G2 / H2 : z2;
            }
          }
        }
    return g2.toTensor();
  }, o2.prototype.avgPool3d = function(t3, e2) {
    return kh(t3, "avgPool3d"), this.pool3d(t3, e2, "avg").toFloat();
  }, o2.prototype.avgPool3dBackprop = function(t3, e2, n2) {
    kh([t3, e2], "avgPool3dBackprop");
    for (var r2 = n2.strideDepth, o3 = n2.strideHeight, a2 = n2.strideWidth, i2 = n2.filterDepth, u2 = n2.filterHeight, s2 = n2.filterWidth, c2 = n2.dilationDepth, l2 = n2.dilationHeight, h2 = n2.dilationWidth, f2 = n2.effectiveFilterDepth, p2 = n2.effectiveFilterHeight, d2 = n2.effectiveFilterWidth, v2 = f2 - 1 - n2.padInfo.front, m2 = d2 - 1 - n2.padInfo.left, g2 = p2 - 1 - n2.padInfo.top, y2 = ur(e2.shape, "float32"), x2 = 1 / (i2 * u2 * s2), b2 = this.bufferSync(t3), w2 = 0; w2 < n2.batchSize; ++w2)
      for (var C2 = 0; C2 < n2.inChannels; ++C2)
        for (var E2 = 0; E2 < n2.inDepth; ++E2)
          for (var R2 = 0; R2 < n2.inHeight; ++R2)
            for (var I2 = 0; I2 < n2.inWidth; ++I2) {
              for (var k2 = E2 - v2, S2 = R2 - g2, A2 = I2 - m2, D2 = 0, T2 = 0; T2 < f2; T2 += c2) {
                var N2 = (k2 + T2) / r2;
                if (!(N2 < 0 || N2 >= n2.outDepth || Math.floor(N2) !== N2))
                  for (var F2 = 0; F2 < p2; F2 += l2) {
                    var O2 = (S2 + F2) / o3;
                    if (!(O2 < 0 || O2 >= n2.outHeight || Math.floor(O2) !== O2))
                      for (var _2 = 0; _2 < d2; _2 += h2) {
                        var M2 = (A2 + _2) / a2;
                        if (!(M2 < 0 || M2 >= n2.outWidth || Math.floor(M2) !== M2))
                          D2 += b2.get(w2, N2, O2, M2, C2);
                      }
                  }
              }
              y2.set(D2 * x2, w2, E2, R2, I2, C2);
            }
    return y2.toTensor();
  }, o2.prototype.maxPool3d = function(t3, e2) {
    return kh(t3, "maxPool3d"), this.pool3d(t3, e2, "max").toFloat();
  }, o2.prototype.maxPool3dPositions = function(t3, e2) {
    for (var n2 = ur(e2.outShape, "int32"), r2 = e2.strideDepth, o3 = e2.strideHeight, a2 = e2.strideWidth, i2 = e2.dilationDepth, u2 = e2.dilationHeight, s2 = e2.dilationWidth, c2 = e2.effectiveFilterDepth, l2 = e2.effectiveFilterHeight, h2 = e2.effectiveFilterWidth, f2 = e2.padInfo.front, p2 = e2.padInfo.top, d2 = e2.padInfo.left, v2 = this.bufferSync(t3), m2 = 0; m2 < e2.batchSize; ++m2)
      for (var g2 = 0; g2 < e2.inChannels; ++g2)
        for (var y2 = 0; y2 < e2.outDepth; ++y2) {
          for (var x2 = y2 * r2 - f2, b2 = x2; b2 < 0; )
            b2 += i2;
          for (var w2 = Math.min(e2.inDepth, c2 + x2), C2 = 0; C2 < e2.outHeight; ++C2) {
            for (var E2 = C2 * o3 - p2, R2 = E2; R2 < 0; )
              R2 += u2;
            for (var I2 = Math.min(e2.inHeight, l2 + E2), k2 = 0; k2 < e2.outWidth; ++k2) {
              for (var S2 = k2 * a2 - d2, A2 = S2; A2 < 0; )
                A2 += s2;
              for (var D2 = Math.min(e2.inWidth, h2 + S2), T2 = Number.NEGATIVE_INFINITY, N2 = -1, F2 = b2; F2 < w2; F2 += i2)
                for (var O2 = F2 - x2, _2 = R2; _2 < I2; _2 += u2)
                  for (var M2 = _2 - E2, B2 = A2; B2 < D2; B2 += s2) {
                    var P2 = B2 - S2, L2 = v2.get(m2, F2, _2, B2, g2);
                    L2 >= T2 && (T2 = L2, N2 = O2 * l2 * h2 + M2 * l2 + P2);
                  }
              n2.set(N2, m2, y2, C2, k2, g2);
            }
          }
        }
    return n2.toTensor();
  }, o2.prototype.maxPool3dBackprop = function(t3, e2, n2, r2) {
    kh([e2, n2], "maxPool3dBackprop");
    for (var o3 = this.maxPool3dPositions(e2, r2), a2 = r2.strideDepth, i2 = r2.strideHeight, u2 = r2.strideWidth, s2 = r2.dilationDepth, c2 = r2.dilationHeight, l2 = r2.dilationWidth, h2 = r2.effectiveFilterDepth, f2 = r2.effectiveFilterHeight, p2 = r2.effectiveFilterWidth, d2 = h2 - 1 - r2.padInfo.front, v2 = p2 - 1 - r2.padInfo.left, m2 = f2 - 1 - r2.padInfo.top, g2 = ur(e2.shape, "float32"), y2 = this.bufferSync(o3), x2 = this.bufferSync(t3), b2 = 0; b2 < r2.batchSize; ++b2)
      for (var w2 = 0; w2 < r2.inChannels; ++w2)
        for (var C2 = 0; C2 < r2.inDepth; ++C2)
          for (var E2 = 0; E2 < r2.inHeight; ++E2)
            for (var R2 = 0; R2 < r2.inWidth; ++R2) {
              for (var I2 = C2 - d2, k2 = E2 - m2, S2 = R2 - v2, A2 = 0, D2 = 0; D2 < h2; D2 += s2) {
                var T2 = (I2 + D2) / a2;
                if (!(T2 < 0 || T2 >= r2.outDepth || Math.floor(T2) !== T2))
                  for (var N2 = 0; N2 < f2; N2 += c2) {
                    var F2 = (k2 + N2) / i2;
                    if (!(F2 < 0 || F2 >= r2.outHeight || Math.floor(F2) !== F2))
                      for (var O2 = 0; O2 < p2; O2 += l2) {
                        var _2 = (S2 + O2) / u2;
                        if (!(_2 < 0 || _2 >= r2.outWidth || Math.floor(_2) !== _2)) {
                          var M2 = h2 * f2 * p2 - 1 - y2.get(b2, T2, F2, _2, w2) === D2 * f2 * p2 + N2 * p2 + O2 ? 1 : 0;
                          if (0 !== M2)
                            A2 += x2.get(b2, T2, F2, _2, w2) * M2;
                        }
                      }
                  }
              }
              g2.set(A2, b2, C2, E2, R2, w2);
            }
    return g2.toTensor();
  }, o2.prototype.cast = function(t3, e2) {
    return So(t3, e2, this);
  }, o2.prototype.reshape = function(t3, e2) {
    return Ao(t3, e2);
  }, o2.prototype.avgPool = function(t3, e2) {
    return kh(t3, "avgPool"), this.pool(t3, e2, "avg").toFloat();
  }, o2.prototype.resizeBilinear = function(t3, e2, n2, r2) {
    kh(t3, "resizeBilinear");
    for (var o3 = t3.shape, a2 = o3[0], i2 = o3[1], u2 = o3[2], s2 = o3[3], c2 = this.readSync(t3.dataId), l2 = new Float32Array(w([a2, e2, n2, s2])), h2 = [r2 && e2 > 1 ? i2 - 1 : i2, r2 && n2 > 1 ? u2 - 1 : u2], f2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2], p2 = 0, d2 = h2[0] / f2[0], v2 = h2[1] / f2[1], m2 = 0; m2 < a2; m2++)
      for (var g2 = 0; g2 < e2; g2++)
        for (var y2 = d2 * g2, x2 = Math.floor(y2), b2 = y2 - x2, C2 = Math.min(i2 - 1, Math.ceil(y2)), E2 = m2 * t3.strides[0] + x2 * t3.strides[1], R2 = m2 * t3.strides[0] + C2 * t3.strides[1], I2 = 0; I2 < n2; I2++)
          for (var k2 = v2 * I2, S2 = Math.floor(k2), A2 = k2 - S2, D2 = Math.min(u2 - 1, Math.ceil(k2)), T2 = E2 + S2 * t3.strides[2], N2 = R2 + S2 * t3.strides[2], F2 = E2 + +D2 * t3.strides[2], O2 = R2 + D2 * t3.strides[2], _2 = 0; _2 < s2; _2++) {
            var M2 = c2[T2 + _2], B2 = c2[N2 + _2], P2 = M2 + (c2[F2 + _2] - M2) * A2, L2 = P2 + (B2 + (c2[O2 + _2] - B2) * A2 - P2) * b2;
            l2[p2++] = L2;
          }
    return kn(l2, [a2, e2, n2, s2]);
  }, o2.prototype.resizeBilinearBackprop = function(t3, e2, n2) {
    kh([t3, e2], "resizeBilinearBackprop");
    for (var r2 = e2.shape, o3 = r2[0], a2 = r2[1], i2 = r2[2], u2 = r2[3], s2 = t3.shape, c2 = s2[1], l2 = s2[2], h2 = new Float32Array(o3 * a2 * i2 * u2), f2 = [n2 && c2 > 1 ? a2 - 1 : a2, n2 && l2 > 1 ? i2 - 1 : i2], p2 = [n2 && c2 > 1 ? c2 - 1 : c2, n2 && l2 > 1 ? l2 - 1 : l2], d2 = f2[0] / p2[0], v2 = f2[1] / p2[1], m2 = this.readSync(t3.dataId), g2 = 0, y2 = 0; y2 < o3; y2++)
      for (var x2 = y2 * e2.strides[0], b2 = 0; b2 < c2; b2++)
        for (var w2 = b2 * d2, C2 = Math.floor(w2), E2 = Math.min(Math.ceil(w2), a2 - 1), R2 = x2 + C2 * e2.strides[1], I2 = x2 + E2 * e2.strides[1], k2 = w2 - C2, S2 = 1 - k2, A2 = 0; A2 < l2; A2++)
          for (var D2 = A2 * v2, T2 = Math.floor(D2), N2 = Math.min(Math.ceil(D2), i2 - 1), F2 = D2 - T2, O2 = 1 - F2, _2 = R2 + T2 * e2.strides[2], M2 = R2 + N2 * e2.strides[2], B2 = I2 + T2 * e2.strides[2], P2 = I2 + N2 * e2.strides[2], L2 = S2 * O2, W2 = S2 * F2, U2 = k2 * O2, V2 = k2 * F2, z2 = 0; z2 < u2; z2++) {
            var G2 = m2[g2++];
            h2[_2 + z2] += G2 * L2, h2[M2 + z2] += G2 * W2, h2[B2 + z2] += G2 * U2, h2[P2 + z2] += G2 * V2;
          }
    return Fn(h2, [o3, i2, a2, u2], e2.dtype);
  }, o2.prototype.resizeNearestNeighbor = function(t3, e2, n2, r2) {
    kh(t3, "resizeNearestNeighbor");
    for (var o3 = t3.shape, a2 = o3[0], i2 = o3[1], u2 = o3[2], s2 = o3[3], c2 = this.readSync(t3.dataId), l2 = new Float32Array(a2 * e2 * n2 * s2), h2 = [r2 && e2 > 1 ? i2 - 1 : i2, r2 && n2 > 1 ? u2 - 1 : u2], f2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2], p2 = h2[0] / f2[0], d2 = h2[1] / f2[1], v2 = 0, m2 = 0; m2 < a2; m2++)
      for (var g2 = m2 * t3.strides[0], y2 = 0; y2 < e2; y2++)
        for (var x2 = p2 * y2, b2 = g2 + Math.min(i2 - 1, r2 ? Math.round(x2) : Math.floor(x2)) * t3.strides[1], w2 = 0; w2 < n2; w2++)
          for (var C2 = d2 * w2, E2 = b2 + Math.min(u2 - 1, r2 ? Math.round(C2) : Math.floor(C2)) * t3.strides[2], R2 = 0; R2 < s2; R2++) {
            var I2 = c2[E2 + R2];
            l2[v2++] = I2;
          }
    return kn(l2, [a2, e2, n2, s2], t3.dtype);
  }, o2.prototype.resizeNearestNeighborBackprop = function(t3, e2, n2) {
    kh([t3, e2], "resizeNearestNeighborBackprop");
    for (var r2 = e2.shape, o3 = r2[0], a2 = r2[1], i2 = r2[2], u2 = r2[3], s2 = t3.shape, c2 = s2[1], l2 = s2[2], h2 = new Float32Array(o3 * a2 * i2 * u2), f2 = this.readSync(t3.dataId), p2 = [n2 && c2 > 1 ? a2 - 1 : a2, n2 && l2 > 1 ? i2 - 1 : i2], d2 = [n2 && c2 > 1 ? c2 - 1 : c2, n2 && l2 > 1 ? l2 - 1 : l2], v2 = p2[0] / d2[0], m2 = p2[1] / d2[1], g2 = 1 / v2, y2 = 1 / m2, x2 = 2 * Math.ceil(g2) + 2, b2 = 2 * Math.ceil(y2) + 2, w2 = 0; w2 < o3; w2++)
      for (var C2 = w2 * e2.strides[0], E2 = 0; E2 < a2; E2++)
        for (var R2 = C2 + E2 * e2.strides[1], I2 = Math.floor(E2 * g2), k2 = Math.floor(I2 - x2 / 2), S2 = 0; S2 < i2; S2++)
          for (var A2 = R2 + S2 * e2.strides[2], D2 = Math.floor(S2 * y2), T2 = Math.floor(D2 - b2 / 2), N2 = 0; N2 < u2; N2++) {
            for (var F2 = 0, O2 = 0; O2 < x2; O2++) {
              var _2 = O2 + k2;
              if (!(_2 < 0 || _2 >= c2)) {
                var M2 = C2 + _2 * t3.strides[1], B2 = _2 * v2;
                if (E2 === Math.min(a2 - 1, n2 ? Math.round(B2) : Math.floor(B2)))
                  for (var P2 = 0; P2 < b2; P2++) {
                    var L2 = P2 + T2;
                    if (!(L2 < 0 || L2 >= l2)) {
                      var W2 = M2 + L2 * t3.strides[2], U2 = L2 * m2;
                      S2 === Math.min(i2 - 1, n2 ? Math.round(U2) : Math.floor(U2)) && (F2 += f2[W2 + N2]);
                    }
                  }
              }
            }
            h2[A2 + N2] = F2;
          }
    return Fn(h2, e2.shape, e2.dtype);
  }, o2.prototype.batchNormalization = function(t3, e2, n2, r2, o3, a2) {
    kh([t3, e2, n2, o3, a2], "batchNorm");
    for (var i2 = this.readSync(t3.dataId), u2 = this.readSync(e2.dataId), s2 = this.readSync(n2.dataId), c2 = o3 ? this.readSync(o3.dataId) : new Float32Array([1]), l2 = a2 ? this.readSync(a2.dataId) : new Float32Array([0]), h2 = new Float32Array(i2.length), f2 = l2.length, p2 = c2.length, d2 = s2.length, v2 = u2.length, m2 = 0, g2 = 0, y2 = 0, x2 = 0, b2 = 0; b2 < i2.length; ++b2)
      h2[b2] = l2[m2++] + (i2[b2] - u2[g2++]) * c2[y2++] / Math.sqrt(s2[x2++] + r2), m2 >= f2 && (m2 = 0), g2 >= v2 && (g2 = 0), y2 >= p2 && (y2 = 0), x2 >= d2 && (x2 = 0);
    return Fn(h2, t3.shape);
  }, o2.prototype.localResponseNormalization4D = function(t3, e2, n2, r2, o3) {
    kh(t3, "localResponseNormalization4D");
    var a2 = t3.shape[3], i2 = a2 - 1, u2 = this.readSync(t3.dataId), s2 = t3.size, c2 = new Float32Array(s2);
    function l2(t4) {
      for (var n3 = t4 % a2, r3 = t4 - n3 + Math.max(0, n3 - e2), o4 = t4 - n3 + Math.min(n3 + e2, i2), s3 = 0; r3 <= o4; r3++) {
        var c3 = u2[r3];
        s3 += c3 * c3;
      }
      return s3;
    }
    for (var h2 = 0; h2 < s2; h2++) {
      var f2 = l2(h2), p2 = u2[h2] * Math.pow(n2 + r2 * f2, -o3);
      c2[h2] = p2;
    }
    return Fn(c2, t3.shape);
  }, o2.prototype.LRNGrad = function(t3, e2, n2, r2, o3, a2, i2) {
    kh(t3, "LRNGrad");
    for (var u2 = t3.shape[3], s2 = this.readSync(t3.dataId), c2 = this.readSync(e2.dataId), l2 = this.readSync(n2.dataId), h2 = new Float32Array(t3.size), f2 = t3.size, p2 = 0; p2 < f2; p2++) {
      for (var d2 = p2 % u2, v2 = p2 - d2 + Math.max(0, d2 - r2), m2 = p2 - d2 + Math.min(u2, d2 + r2 + 1), g2 = 0, y2 = v2; y2 < m2; y2++)
        g2 += Math.pow(c2[y2], 2);
      g2 = a2 * g2 + o3;
      for (y2 = v2; y2 < m2; y2++) {
        var x2 = -2 * a2 * i2 * c2[y2] * l2[p2] / g2;
        p2 === y2 && (x2 += Math.pow(g2, -i2)), x2 *= s2[p2], h2[y2] += x2;
      }
    }
    return Fn(h2, t3.shape);
  }, o2.prototype.multinomial = function(t3, e2, n2, r2) {
    kh(t3, "multinomial");
    for (var o3 = e2 ? t3 : io(t3), a2 = o3.shape[0], i2 = o3.shape[1], u2 = Pn([a2, n2], "int32"), s2 = this.readSync(u2.dataId), c2 = this.readSync(o3.dataId), l2 = 0; l2 < a2; ++l2) {
      var h2 = l2 * i2, f2 = new Float32Array(i2 - 1);
      f2[0] = c2[h2];
      for (var p2 = 1; p2 < f2.length; ++p2)
        f2[p2] = f2[p2 - 1] + c2[h2 + p2];
      for (var d2 = rr(r2.toString()), v2 = l2 * n2, m2 = 0; m2 < n2; ++m2) {
        var g2 = d2();
        s2[v2 + m2] = f2.length;
        for (var y2 = 0; y2 < f2.length; y2++)
          if (g2 < f2[y2]) {
            s2[v2 + m2] = y2;
            break;
          }
      }
    }
    return u2;
  }, o2.prototype.oneHot = function(t3, e2, n2, r2) {
    kh(t3, "oneHot");
    var o3 = new Float32Array(t3.size * e2);
    o3.fill(r2);
    for (var a2 = this.readSync(t3.dataId), i2 = 0; i2 < t3.size; ++i2)
      a2[i2] >= 0 && a2[i2] < e2 && (o3[i2 * e2 + a2[i2]] = n2);
    return Tn(o3, [t3.size, e2], "int32");
  }, o2.prototype.nonMaxSuppression = function(t3, e2, n2, r2, o3) {
    return kh(t3, "nonMaxSuppression"), Mo(this.readSync(t3.dataId), this.readSync(e2.dataId), n2, r2, o3);
  }, o2.prototype.fft = function(t3) {
    return this.fftBatch(t3, false);
  }, o2.prototype.ifft = function(t3) {
    return this.fftBatch(t3, true);
  }, o2.prototype.fftBatch = function(t3, e2) {
    for (var n2 = t3.shape[0], r2 = t3.shape[1], o3 = ur(t3.shape, "float32"), a2 = ur(t3.shape, "float32"), i2 = Rn(t3).as2D(n2, r2), u2 = In(t3).as2D(n2, r2), s2 = 0; s2 < n2; s2++)
      for (var c2 = i2.slice([s2, 0], [1, r2]), l2 = u2.slice([s2, 0], [1, r2]), h2 = En(c2, l2), f2 = this.readSync(this.fftImpl(h2, e2).dataId), p2 = 0; p2 < r2; p2++) {
        var d2 = Fo(f2, p2);
        o3.values[s2 * r2 + p2] = d2.real, a2.values[s2 * r2 + p2] = d2.imag;
      }
    return En(o3.toTensor(), a2.toTensor()).as2D(n2, r2);
  }, o2.prototype.fftImpl = function(t3, e2) {
    var n2 = t3.as1D(), r2 = n2.size;
    if (this.isExponentOf2(r2)) {
      var o3 = this.fftRadix2(n2, r2, e2).as2D(t3.shape[0], t3.shape[1]);
      return e2 && (o3 = En(Rn(o3).div(An(r2)), In(o3).div(An(r2)))), o3;
    }
    var a2 = this.readSync(t3.dataId), i2 = function(t4) {
      for (var e3 = new Float32Array(t4.length / 2), n3 = new Float32Array(t4.length / 2), r3 = 0; r3 < t4.length; r3 += 2)
        e3[r3 / 2] = t4[r3], n3[r3 / 2] = t4[r3 + 1];
      return {real: e3, imag: n3};
    }(this.fourierTransformByMatmul(a2, r2, e2));
    return En(i2.real, i2.imag).as2D(t3.shape[0], t3.shape[1]);
  }, o2.prototype.isExponentOf2 = function(t3) {
    return 0 == (t3 & t3 - 1);
  }, o2.prototype.fftRadix2 = function(t3, e2, n2) {
    if (1 === e2)
      return t3;
    var r2 = this.readSync(t3.dataId), o3 = e2 / 2, a2 = function(t4) {
      for (var e3 = Math.ceil(t4.length / 4), n3 = new Float32Array(e3), r3 = new Float32Array(e3), o4 = 0; o4 < t4.length; o4 += 4)
        n3[Math.floor(o4 / 4)] = t4[o4], r3[Math.floor(o4 / 4)] = t4[o4 + 1];
      return {real: n3, imag: r3};
    }(r2), i2 = En(a2.real, a2.imag).as1D(), u2 = function(t4) {
      for (var e3 = Math.floor(t4.length / 4), n3 = new Float32Array(e3), r3 = new Float32Array(e3), o4 = 2; o4 < t4.length; o4 += 4)
        n3[Math.floor(o4 / 4)] = t4[o4], r3[Math.floor(o4 / 4)] = t4[o4 + 1];
      return {real: n3, imag: r3};
    }(r2), s2 = En(u2.real, u2.imag).as1D();
    i2 = this.fftRadix2(i2, o3, n2), s2 = this.fftRadix2(s2, o3, n2);
    var c2 = function(t4, e3) {
      for (var n3 = new Float32Array(t4 / 2), r3 = new Float32Array(t4 / 2), o4 = 0; o4 < Math.ceil(t4 / 2); o4++) {
        var a3 = (e3 ? 2 : -2) * Math.PI * (o4 / t4);
        n3[o4] = Math.cos(a3), r3[o4] = Math.sin(a3);
      }
      return {real: n3, imag: r3};
    }(e2, n2), l2 = En(c2.real, c2.imag).mul(s2), h2 = i2.add(l2), f2 = i2.sub(l2), p2 = Rn(h2).concat(Rn(f2)), d2 = In(h2).concat(In(f2));
    return En(p2, d2).as1D();
  }, o2.prototype.fourierTransformByMatmul = function(t3, e2, n2) {
    for (var r2 = new Float32Array(2 * e2), o3 = 0; o3 < e2; o3++) {
      for (var a2 = 0, i2 = 0, u2 = 0; u2 < e2; u2++) {
        var s2 = _o(o3 * u2, e2, n2), c2 = Fo(t3, u2);
        a2 += c2.real * s2.real - c2.imag * s2.imag, i2 += c2.real * s2.imag + c2.imag * s2.real;
      }
      n2 && (a2 /= e2, i2 /= e2), Oo(r2, a2, i2, o3);
    }
    return r2;
  }, o2.prototype.depthToSpace = function(t3, e2, n2) {
    g("NHWC" === n2, function() {
      return "Only NHWC dataFormat supported on CPU for depthToSpace. Got " + n2;
    }), g(e2 > 1, function() {
      return "blockSize should be > 1 for depthToSpace, but was: " + e2;
    });
    for (var r2 = t3.shape[0], o3 = t3.shape[1], a2 = t3.shape[2], i2 = t3.shape[3], u2 = o3 * e2, s2 = a2 * e2, c2 = i2 / (e2 * e2), l2 = this.readSync(t3.dataId), h2 = new Float32Array(r2 * u2 * s2 * c2), f2 = 0, p2 = 0; p2 < r2; ++p2)
      for (var d2 = 0; d2 < u2; ++d2)
        for (var v2 = Math.floor(d2 / e2), m2 = d2 % e2, y2 = 0; y2 < s2; ++y2)
          for (var x2 = Math.floor(y2 / e2), b2 = (m2 * e2 + y2 % e2) * c2, w2 = 0; w2 < c2; ++w2) {
            var C2 = w2 + b2 + i2 * (x2 + a2 * (v2 + o3 * p2));
            h2[f2++] = l2[C2];
          }
    return Fn(h2, [r2, u2, s2, c2]);
  }, o2.prototype.broadcastedBinaryOp = function(t3, e2, n2, r2) {
    var o3 = po(t3.shape, e2.shape), a2 = ur(o3, n2), i2 = this.readSync(t3.dataId), u2 = this.readSync(e2.dataId), s2 = ho(t3.shape, o3), c2 = ho(e2.shape, o3), l2 = a2.values;
    if (s2.length + c2.length === 0)
      for (var h2 = 0; h2 < l2.length; ++h2)
        l2[h2] = r2(i2[h2 % i2.length], u2[h2 % u2.length]);
    else {
      var f2 = this.bufferSync(t3), p2 = this.bufferSync(e2), d2 = function(n3) {
        var o4 = a2.indexToLoc(n3), h3 = o4.slice(-t3.rank);
        s2.forEach(function(t4) {
          return h3[t4] = 0;
        });
        var d3 = f2.locToIndex(h3), v2 = o4.slice(-e2.rank);
        c2.forEach(function(t4) {
          return v2[t4] = 0;
        });
        var m2 = p2.locToIndex(v2);
        l2[n3] = r2(i2[d3], u2[m2]);
      };
      for (h2 = 0; h2 < l2.length; ++h2)
        d2(h2);
    }
    return a2.toTensor();
  }, o2.prototype.broadcastedBinaryComplexOp = function(t3, e2, n2) {
    var r2 = po(t3.shape, e2.shape), o3 = ur(r2, "float32"), a2 = ur(r2, "float32"), i2 = this.readSync(t3.dataId), u2 = this.readSync(e2.dataId), s2 = ho(t3.shape, r2), c2 = ho(e2.shape, r2), l2 = o3.values, h2 = a2.values;
    if (s2.length + c2.length === 0)
      for (var f2 = 0; f2 < l2.length; f2++) {
        var p2 = f2 % i2.length, d2 = f2 % u2.length, v2 = n2(i2[2 * p2], i2[2 * p2 + 1], u2[2 * d2], u2[2 * d2 + 1]);
        l2[f2] = v2.real, h2[f2] = v2.imag;
      }
    else {
      var m2 = this.bufferSync(this.data.get(t3.dataId).complexTensors.real), g2 = this.bufferSync(this.data.get(e2.dataId).complexTensors.real), y2 = function(r3) {
        var a3 = o3.indexToLoc(r3), f3 = a3.slice(-t3.rank);
        s2.forEach(function(t4) {
          return f3[t4] = 0;
        });
        var p3 = m2.locToIndex(f3), d3 = a3.slice(-e2.rank);
        c2.forEach(function(t4) {
          return d3[t4] = 0;
        });
        var v3 = g2.locToIndex(d3), y3 = n2(i2[2 * p3], i2[2 * p3 + 1], u2[2 * v3], u2[2 * v3 + 1]);
        l2[r3] = y3.real, h2[r3] = y3.imag;
      };
      for (f2 = 0; f2 < l2.length; f2++)
        y2(f2);
    }
    return this.complex(o3.toTensor(), a2.toTensor());
  }, o2.prototype.split = function(t3, e2, n2) {
    return Po(t3, e2, n2);
  }, o2.prototype.dispose = function() {
  }, o2.prototype.floatPrecision = function() {
    return 32;
  }, o2.prototype.epsilon = function() {
    return 1e-7;
  }, o2.prototype.cropAndResize = function(t3, e2, n2, r2, o3, a2) {
    for (var i2 = t3.shape, u2 = i2[0], s2 = i2[1], c2 = i2[2], l2 = i2[3], h2 = e2.shape[0], f2 = r2[0], p2 = r2[1], d2 = ur([h2, f2, p2, l2], t3.dtype), v2 = this.readSync(e2.dataId), m2 = this.readSync(n2.dataId), g2 = this.readSync(t3.dataId), y2 = t3.strides, x2 = d2.strides, b2 = 0; b2 < h2; b2++) {
      var w2 = 4 * b2, C2 = v2[w2], E2 = v2[w2 + 1], R2 = v2[w2 + 2], I2 = v2[w2 + 3], k2 = m2[b2];
      if (!(k2 >= u2))
        for (var S2 = f2 > 1 ? (R2 - C2) * (s2 - 1) / (f2 - 1) : 0, A2 = p2 > 1 ? (I2 - E2) * (c2 - 1) / (p2 - 1) : 0, D2 = 0; D2 < f2; D2++) {
          var T2 = f2 > 1 ? C2 * (s2 - 1) + D2 * S2 : 0.5 * (C2 + R2) * (s2 - 1);
          if (T2 < 0 || T2 > s2 - 1)
            for (var N2 = 0; N2 < p2; N2++)
              for (var F2 = 0; F2 < l2; F2++) {
                var O2 = F2 + N2 * x2[2] + D2 * x2[1] + b2 * x2[0];
                d2.values[O2] = a2;
              }
          else if ("bilinear" === o3) {
            var _2 = Math.floor(T2), M2 = Math.ceil(T2), B2 = T2 - _2;
            for (N2 = 0; N2 < p2; N2++) {
              if ((q2 = p2 > 1 ? E2 * (c2 - 1) + N2 * A2 : 0.5 * (E2 + I2) * (c2 - 1)) < 0 || q2 > c2 - 1)
                for (F2 = 0; F2 < l2; F2++) {
                  O2 = F2 + N2 * x2[2] + D2 * x2[1] + b2 * x2[0];
                  d2.values[O2] = a2;
                }
              else {
                var P2 = Math.floor(q2), L2 = Math.ceil(q2), W2 = q2 - P2;
                for (F2 = 0; F2 < l2; F2++) {
                  var U2 = g2[O2 = F2 + P2 * y2[2] + _2 * y2[1] + k2 * y2[0]], V2 = g2[O2 = F2 + L2 * y2[2] + _2 * y2[1] + k2 * y2[0]], z2 = g2[O2 = F2 + P2 * y2[2] + M2 * y2[1] + k2 * y2[0]], G2 = U2 + (V2 - U2) * W2, H2 = z2 + (g2[O2 = F2 + L2 * y2[2] + M2 * y2[1] + k2 * y2[0]] - z2) * W2;
                  O2 = F2 + N2 * x2[2] + D2 * x2[1] + b2 * x2[0], d2.values[O2] = G2 + (H2 - G2) * B2;
                }
              }
            }
          } else
            for (N2 = 0; N2 < p2; ++N2) {
              var q2;
              if ((q2 = p2 > 1 ? E2 * (c2 - 1) + N2 * A2 : 0.5 * (E2 + I2) * (c2 - 1)) < 0 || q2 > c2 - 1)
                for (F2 = 0; F2 < l2; F2++) {
                  O2 = F2 + N2 * x2[2] + D2 * x2[1] + b2 * x2[0];
                  d2.values[O2] = a2;
                }
              else {
                var K2 = Math.round(q2), j2 = Math.round(T2);
                for (F2 = 0; F2 < l2; F2++) {
                  var X2 = F2 + K2 * y2[2] + j2 * y2[1] + k2 * y2[0], $2 = F2 + N2 * x2[2] + D2 * x2[1] + b2 * x2[0];
                  d2.values[$2] = g2[X2];
                }
              }
            }
        }
    }
    return d2.toTensor();
  }, o2.prototype.sparseToDense = function(t3, e2, n2, r2) {
    var o3 = Hr(0, t3, n2), a2 = o3.sliceRank, i2 = o3.numUpdates, u2 = o3.sliceSize, s2 = o3.strides, c2 = o3.outputSize;
    return this.scatter(t3, e2, n2, c2, u2, i2, a2, s2, r2, false);
  }, o2.prototype.gatherND = function(t3, e2) {
    var n2 = e2.shape, r2 = n2[n2.length - 1], o3 = Ur(t3, e2), a2 = o3[0], i2 = o3[1], u2 = o3[2], s2 = o3[3];
    if (0 === i2)
      return kn([], a2, t3.dtype);
    for (var c2 = new lt([i2, u2], t3.dtype), l2 = this.readSync(e2.dataId), h2 = this.readSync(t3.dataId), f2 = 0; f2 < i2; f2++) {
      for (var p2 = [], d2 = 0, v2 = 0; v2 < r2; v2++) {
        var m2 = l2[f2 * r2 + v2];
        d2 += m2 * s2[v2], p2.push(m2);
      }
      if (d2 < 0 || d2 >= t3.size / u2)
        throw new Error("Invalid indices: " + p2 + " does not index into " + t3.shape);
      for (var g2 = 0; g2 < u2; g2++)
        c2.values[f2 * u2 + g2] = h2[d2 * u2 + g2];
    }
    return c2.toTensor().reshape(a2);
  }, o2.prototype.scatterND = function(t3, e2, n2) {
    var r2 = Hr(0, t3, n2), o3 = r2.sliceRank, a2 = r2.numUpdates, i2 = r2.sliceSize, u2 = r2.strides, s2 = r2.outputSize, c2 = An(0);
    return this.scatter(t3, e2, n2, s2, i2, a2, o3, u2, c2, true);
  }, o2.prototype.fill = function(t3, e2, n2) {
    var r2 = F(n2 = n2 || z(e2), w(t3));
    return r2.fill(e2), Nt.makeTensor(r2, t3, n2, this);
  }, o2.prototype.onesLike = function(t3) {
    if ("string" === t3.dtype)
      throw new Error("onesLike is not supported for string tensors");
    return this.fill(t3.shape, 1, t3.dtype);
  }, o2.prototype.zerosLike = function(t3) {
    var e2 = F(t3.dtype, w(t3.shape));
    return this.makeOutput(e2, t3.shape, t3.dtype);
  }, o2.prototype.linspace = function(t3, e2, n2) {
    return Do(t3, e2, n2);
  }, o2.prototype.scatter = function(t3, e2, n2, r2, o3, a2, i2, u2, s2, c2) {
    var l2 = [r2 / o3, o3], h2 = this.readSync(t3.dataId), f2 = this.readSync(e2.dataId);
    if (0 === r2)
      return kn([], n2, e2.dtype);
    var p2 = new lt(l2, e2.dtype);
    p2.values.fill(this.readSync(s2.dataId)[0]);
    for (var d2 = 0; d2 < a2; d2++) {
      for (var v2 = [], m2 = 0, g2 = 0; g2 < i2; g2++) {
        var y2 = h2[d2 * i2 + g2];
        v2.push(y2), m2 += y2 * u2[g2];
      }
      if (m2 < 0 || m2 >= r2 / o3)
        throw new Error("Invalid indices: " + v2 + " does not index into " + n2);
      for (var x2 = 0; x2 < o3; x2++)
        c2 ? p2.values[m2 * o3 + x2] += f2[d2 * o3 + x2] : p2.values[m2 * o3 + x2] = 0 === e2.rank ? f2[0] : f2[d2 * o3 + x2];
    }
    return p2.toTensor().reshape(n2);
  }, o2;
}(co);
Nt.registerBackend("cpu", function() {
  return new Ah();
}, 1), l({kernelName: "Square", backendName: "cpu", kernelFunc: function(t2) {
  var e2 = t2.inputs, n2 = t2.backend, r2 = e2.x, o2 = n2;
  kh(r2, "square");
  for (var a2 = o2.data.get(r2.dataId).values, i2 = new Float32Array(a2.length), u2 = 0; u2 < a2.length; ++u2) {
    var s2 = a2[u2];
    i2[u2] = s2 * s2;
  }
  return {dataId: o2.write(i2, r2.shape, r2.dtype), shape: r2.shape, dtype: r2.dtype};
}}), l({kernelName: "Square", backendName: "webgl", kernelFunc: function(t2) {
  var e2 = t2.inputs, n2 = t2.backend, r2 = e2.x, o2 = n2, a2 = new su(r2.shape, "return x * x;");
  return o2.runWebGLProgram(a2, [r2], r2.dtype);
}});
var Dh = function() {
  function t2() {
  }
  return t2.prototype.fetch = function(t3, e2) {
    return fetch(t3, e2);
  }, t2.prototype.now = function() {
    return performance.now();
  }, t2.prototype.encode = function(t3, e2) {
    if ("utf-8" !== e2 && "utf8" !== e2)
      throw new Error("Browser's encoder only supports utf-8, but got " + e2);
    return null == this.textEncoder && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(t3);
  }, t2.prototype.decode = function(t3, e2) {
    return new TextDecoder(e2).decode(t3);
  }, t2;
}();
a().get("IS_BROWSER") && a().setPlatform("browser", new Dh());
var Th;
var Nh = function() {
  return require_index_es();
};
var Fh = function() {
  function t2() {
    this.util = require("util"), this.textEncoder = new this.util.TextEncoder();
  }
  return t2.prototype.fetch = function(t3, e2) {
    return null != a().global.fetch ? a().global.fetch(t3, e2) : (null == Th && (Th = Nh()), Th(t3, e2));
  }, t2.prototype.now = function() {
    var t3 = process.hrtime();
    return 1e3 * t3[0] + t3[1] / 1e6;
  }, t2.prototype.encode = function(t3, e2) {
    if ("utf-8" !== e2 && "utf8" !== e2)
      throw new Error("Node built-in encoder only supports utf-8, but got " + e2);
    return this.textEncoder.encode(t3);
  }, t2.prototype.decode = function(t3, e2) {
    return 0 === t3.length ? "" : new this.util.TextDecoder(e2).decode(t3);
  }, t2;
}();
a().get("IS_NODE") && a().setPlatform("node", new Fh());
var Oh = {float32: 4, int32: 4, uint16: 2, uint8: 1, bool: 1};
var _h = 4;
function Mh(t2, e2) {
  for (var n2 = {}, r2 = 0, o2 = function(e3) {
    var o3 = e3.name, a3 = e3.dtype, i3 = e3.shape, u2 = w(i3), s2 = void 0;
    if ("quantization" in e3) {
      var c2 = e3.quantization;
      if ("uint8" !== c2.dtype && "uint16" !== c2.dtype)
        throw new Error("Weight " + e3.name + " has unknown quantization dtype " + c2.dtype + ". Supported quantization dtypes are: 'uint8' and 'uint16'.");
      var l2 = Oh[c2.dtype], h2 = t2.slice(r2, r2 + u2 * l2), f2 = "uint8" === c2.dtype ? new Uint8Array(h2) : new Uint16Array(h2);
      if ("float32" === a3)
        s2 = Float32Array.from(f2, function(t3) {
          return t3 * c2.scale + c2.min;
        });
      else {
        if ("int32" !== a3)
          throw new Error("Unsupported dtype in weight '" + o3 + "': " + a3);
        s2 = Int32Array.from(f2, function(t3) {
          return Math.round(t3 * c2.scale + c2.min);
        });
      }
      r2 += u2 * l2;
    } else if ("string" === a3) {
      var p2 = w(e3.shape);
      s2 = [];
      for (var d2 = 0; d2 < p2; d2++) {
        var v2 = new Uint32Array(t2.slice(r2, r2 + _h))[0];
        r2 += _h;
        var m2 = new Uint8Array(t2.slice(r2, r2 + v2));
        s2.push(m2), r2 += v2;
      }
    } else {
      var g2 = Oh[a3];
      h2 = t2.slice(r2, r2 + u2 * g2);
      if ("float32" === a3)
        s2 = new Float32Array(h2);
      else if ("int32" === a3)
        s2 = new Int32Array(h2);
      else {
        if ("bool" !== a3)
          throw new Error("Unsupported dtype in weight '" + o3 + "': " + a3);
        s2 = new Uint8Array(h2);
      }
      r2 += u2 * g2;
    }
    n2[o3] = kn(s2, i3, a3);
  }, a2 = 0, i2 = e2; a2 < i2.length; a2++) {
    o2(i2[a2]);
  }
  return n2;
}
function Bh(t2) {
  if (null === t2)
    throw new Error("Invalid input value: " + JSON.stringify(t2));
  var e2 = 0, n2 = [];
  t2.forEach(function(t3) {
    if (e2 += t3.byteLength, n2.push(t3.byteLength === t3.buffer.byteLength ? t3 : new t3.constructor(t3)), !(t3 instanceof Float32Array || t3 instanceof Int32Array || t3 instanceof Uint8Array))
      throw new Error("Unsupported TypedArray subtype: " + t3.constructor.name);
  });
  var r2 = new Uint8Array(e2), o2 = 0;
  return n2.forEach(function(t3) {
    r2.set(new Uint8Array(t3.buffer), o2), o2 += t3.byteLength;
  }), r2.buffer;
}
var Ph = "undefined" != typeof Buffer && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);
function Lh(t2) {
  return Ph ? Buffer.byteLength(t2) : new Blob([t2]).size;
}
function Wh(t2) {
  var e2 = 0;
  t2.forEach(function(t3) {
    e2 += t3.byteLength;
  });
  var n2 = new Uint8Array(e2), r2 = 0;
  return t2.forEach(function(t3) {
    n2.set(new Uint8Array(t3), r2), r2 += t3.byteLength;
  }), n2.buffer;
}
function Uh(t2) {
  for (t2 = t2.trim(); t2.endsWith("/"); )
    t2 = t2.slice(0, t2.length - 1);
  var e2 = t2.split("/");
  return e2[e2.length - 1];
}
function Vh(t2) {
  if (t2.modelTopology instanceof ArrayBuffer)
    throw new Error("Expected JSON model topology, received ArrayBuffer.");
  return {dateSaved: new Date(), modelTopologyType: "JSON", modelTopologyBytes: null == t2.modelTopology ? 0 : Lh(JSON.stringify(t2.modelTopology)), weightSpecsBytes: null == t2.weightSpecs ? 0 : Lh(JSON.stringify(t2.weightSpecs)), weightDataBytes: null == t2.weightData ? 0 : t2.weightData.byteLength};
}
var zh = function() {
  function t2() {
    this.saveRouters = [], this.loadRouters = [];
  }
  return t2.getInstance = function() {
    return null == t2.instance && (t2.instance = new t2()), t2.instance;
  }, t2.registerSaveRouter = function(e2) {
    t2.getInstance().saveRouters.push(e2);
  }, t2.registerLoadRouter = function(e2) {
    t2.getInstance().loadRouters.push(e2);
  }, t2.getSaveHandlers = function(e2) {
    return t2.getHandlers(e2, "save");
  }, t2.getLoadHandlers = function(e2, n2) {
    return t2.getHandlers(e2, "load", n2);
  }, t2.getHandlers = function(e2, n2, r2) {
    var o2 = [];
    return ("load" === n2 ? t2.getInstance().loadRouters : t2.getInstance().saveRouters).forEach(function(t3) {
      var n3 = t3(e2, r2);
      null !== n3 && o2.push(n3);
    }), o2;
  }, t2;
}();
var Gh = "://";
var Hh = function() {
  function t2() {
    this.managers = {};
  }
  return t2.getInstance = function() {
    return null == t2.instance && (t2.instance = new t2()), t2.instance;
  }, t2.registerManager = function(e2, n2) {
    g(null != e2, function() {
      return "scheme must not be undefined or null.";
    }), e2.endsWith(Gh) && (e2 = e2.slice(0, e2.indexOf(Gh))), g(e2.length > 0, function() {
      return "scheme must not be an empty string.";
    });
    var r2 = t2.getInstance();
    g(null == r2.managers[e2], function() {
      return "A model store manager is already registered for scheme '" + e2 + "'.";
    }), r2.managers[e2] = n2;
  }, t2.getManager = function(t3) {
    var e2 = this.getInstance().managers[t3];
    if (null == e2)
      throw new Error("Cannot find model manager for scheme '" + t3 + "'");
    return e2;
  }, t2.getSchemes = function() {
    return Object.keys(this.getInstance().managers);
  }, t2;
}();
function qh(t2) {
  if (-1 === t2.indexOf(Gh))
    throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + Hh.getSchemes().join(","));
  return {scheme: t2.split(Gh)[0], path: t2.split(Gh)[1]};
}
function Kh(t2, e2, o2) {
  return void 0 === o2 && (o2 = false), n(this, void 0, void 0, function() {
    var n2, a2, i2, u2, s2, c2, l2, h2, f2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          return g(t2 !== e2, function() {
            return "Old path and new path are the same: '" + t2 + "'";
          }), g((n2 = zh.getLoadHandlers(t2)).length > 0, function() {
            return "Copying failed because no load handler is found for source URL " + t2 + ".";
          }), g(n2.length < 2, function() {
            return "Copying failed because more than one (" + n2.length + ") load handlers for source URL " + t2 + ".";
          }), a2 = n2[0], g((i2 = zh.getSaveHandlers(e2)).length > 0, function() {
            return "Copying failed because no save handler is found for destination URL " + e2 + ".";
          }), g(i2.length < 2, function() {
            return "Copying failed because more than one (" + n2.length + ") save handlers for destination URL " + e2 + ".";
          }), u2 = i2[0], s2 = qh(t2).scheme, c2 = qh(t2).path, l2 = s2 === qh(t2).scheme, [4, a2.load()];
        case 1:
          return h2 = r2.sent(), o2 && l2 ? [4, Hh.getManager(s2).removeModel(c2)] : [3, 3];
        case 2:
          r2.sent(), r2.label = 3;
        case 3:
          return [4, u2.save(h2)];
        case 4:
          return f2 = r2.sent(), !o2 || l2 ? [3, 6] : [4, Hh.getManager(s2).removeModel(c2)];
        case 5:
          r2.sent(), r2.label = 6;
        case 6:
          return [2, f2.modelArtifactsInfo];
      }
    });
  });
}
var jh = "models_store";
var Xh = "model_info_store";
function $h() {
  if (!a().getBool("IS_BROWSER"))
    throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
  var t2 = window, e2 = t2.indexedDB || t2.mozIndexedDB || t2.webkitIndexedDB || t2.msIndexedDB || t2.shimIndexedDB;
  if (null == e2)
    throw new Error("The current browser does not appear to support IndexedDB.");
  return e2;
}
function Yh(t2) {
  var e2 = t2.result;
  e2.createObjectStore(jh, {keyPath: "modelPath"}), e2.createObjectStore(Xh, {keyPath: "modelPath"});
}
var Qh = function() {
  function t2(t3) {
    if (this.indexedDB = $h(), null == t3 || !t3)
      throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
    this.modelPath = t3;
  }
  return t2.prototype.save = function(t3) {
    return n(this, void 0, void 0, function() {
      return r(this, function(e2) {
        if (t3.modelTopology instanceof ArrayBuffer)
          throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        return [2, this.databaseAction(this.modelPath, t3)];
      });
    });
  }, t2.prototype.load = function() {
    return n(this, void 0, void 0, function() {
      return r(this, function(t3) {
        return [2, this.databaseAction(this.modelPath)];
      });
    });
  }, t2.prototype.databaseAction = function(t3, e2) {
    var n2 = this;
    return new Promise(function(t4, r2) {
      var o2 = n2.indexedDB.open("tensorflowjs", 1);
      o2.onupgradeneeded = function() {
        return Yh(o2);
      }, o2.onsuccess = function() {
        var a2 = o2.result;
        if (null == e2) {
          var i2 = a2.transaction(jh, "readonly"), u2 = i2.objectStore(jh).get(n2.modelPath);
          u2.onsuccess = function() {
            if (null == u2.result)
              return a2.close(), r2(new Error("Cannot find model with path '" + n2.modelPath + "' in IndexedDB."));
            t4(u2.result.modelArtifacts);
          }, u2.onerror = function(t5) {
            return a2.close(), r2(u2.error);
          }, i2.oncomplete = function() {
            return a2.close();
          };
        } else {
          var s2, c2 = Vh(e2), l2 = a2.transaction(Xh, "readwrite"), h2 = l2.objectStore(Xh), f2 = h2.put({modelPath: n2.modelPath, modelArtifactsInfo: c2});
          f2.onsuccess = function() {
            var o3 = (s2 = a2.transaction(jh, "readwrite")).objectStore(jh).put({modelPath: n2.modelPath, modelArtifacts: e2, modelArtifactsInfo: c2});
            o3.onsuccess = function() {
              return t4({modelArtifactsInfo: c2});
            }, o3.onerror = function(t5) {
              var e3 = (h2 = l2.objectStore(Xh)).delete(n2.modelPath);
              e3.onsuccess = function() {
                return a2.close(), r2(o3.error);
              }, e3.onerror = function(t6) {
                return a2.close(), r2(o3.error);
              };
            };
          }, f2.onerror = function(t5) {
            return a2.close(), r2(f2.error);
          }, l2.oncomplete = function() {
            null == s2 ? a2.close() : s2.oncomplete = function() {
              return a2.close();
            };
          };
        }
      }, o2.onerror = function(t5) {
        return r2(o2.error);
      };
    });
  }, t2.URL_SCHEME = "indexeddb://", t2;
}();
var Jh = function(t2) {
  return a().getBool("IS_BROWSER") && !Array.isArray(t2) && t2.startsWith(Qh.URL_SCHEME) ? (e2 = t2.slice(Qh.URL_SCHEME.length), new Qh(e2)) : null;
  var e2;
};
zh.registerSaveRouter(Jh), zh.registerLoadRouter(Jh);
var Zh = function() {
  function t2() {
    this.indexedDB = $h();
  }
  return t2.prototype.listModels = function() {
    return n(this, void 0, void 0, function() {
      var t3 = this;
      return r(this, function(e2) {
        return [2, new Promise(function(e3, n2) {
          var r2 = t3.indexedDB.open("tensorflowjs", 1);
          r2.onupgradeneeded = function() {
            return Yh(r2);
          }, r2.onsuccess = function() {
            var t4 = r2.result, o2 = t4.transaction(Xh, "readonly"), a2 = o2.objectStore(Xh).getAll();
            a2.onsuccess = function() {
              for (var t5 = {}, n3 = 0, r3 = a2.result; n3 < r3.length; n3++) {
                var o3 = r3[n3];
                t5[o3.modelPath] = o3.modelArtifactsInfo;
              }
              e3(t5);
            }, a2.onerror = function(e4) {
              return t4.close(), n2(a2.error);
            }, o2.oncomplete = function() {
              return t4.close();
            };
          }, r2.onerror = function(t4) {
            return n2(r2.error);
          };
        })];
      });
    });
  }, t2.prototype.removeModel = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2 = this;
      return r(this, function(n2) {
        var r2;
        return t3 = (r2 = t3).startsWith(Qh.URL_SCHEME) ? r2.slice(Qh.URL_SCHEME.length) : r2, [2, new Promise(function(n3, r3) {
          var o2 = e2.indexedDB.open("tensorflowjs", 1);
          o2.onupgradeneeded = function() {
            return Yh(o2);
          }, o2.onsuccess = function() {
            var e3, a2 = o2.result, i2 = a2.transaction(Xh, "readwrite"), u2 = i2.objectStore(Xh), s2 = u2.get(t3);
            s2.onsuccess = function() {
              if (null == s2.result)
                return a2.close(), r3(new Error("Cannot find model with path '" + t3 + "' in IndexedDB."));
              var o3 = u2.delete(t3), i3 = function() {
                var o4 = (e3 = a2.transaction(jh, "readwrite")).objectStore(jh).delete(t3);
                o4.onsuccess = function() {
                  return n3(s2.result.modelArtifactsInfo);
                }, o4.onerror = function(t4) {
                  return r3(s2.error);
                };
              };
              o3.onsuccess = i3, o3.onerror = function(t4) {
                return i3(), a2.close(), r3(s2.error);
              };
            }, s2.onerror = function(t4) {
              return a2.close(), r3(s2.error);
            }, i2.oncomplete = function() {
              null == e3 ? a2.close() : e3.oncomplete = function() {
                return a2.close();
              };
            };
          }, o2.onerror = function(t4) {
            return r3(o2.error);
          };
        })];
      });
    });
  }, t2;
}();
if (a().getBool("IS_BROWSER"))
  try {
    Hh.registerManager(Qh.URL_SCHEME, new Zh());
  } catch (t2) {
  }
var tf = "/";
var ef = "tensorflowjs_models";
var nf = "info";
var rf = "model_topology";
var of = "weight_specs";
var af = "weight_data";
var uf = "model_metadata";
function sf(t2) {
  return {info: [ef, t2, nf].join(tf), topology: [ef, t2, rf].join(tf), weightSpecs: [ef, t2, of].join(tf), weightData: [ef, t2, af].join(tf), modelMetadata: [ef, t2, uf].join(tf)};
}
function cf(t2) {
  var e2 = t2.split(tf);
  if (e2.length < 3)
    throw new Error("Invalid key format: " + t2);
  return e2.slice(1, e2.length - 1).join(tf);
}
var lf = function() {
  function t2(t3) {
    if (!a().getBool("IS_BROWSER") || void 0 === window.localStorage)
      throw new Error("The current environment does not support local storage.");
    if (this.LS = window.localStorage, null == t3 || !t3)
      throw new Error("For local storage, modelPath must not be null, undefined or empty.");
    this.modelPath = t3, this.keys = sf(this.modelPath);
  }
  return t2.prototype.save = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2, o2;
      return r(this, function(r2) {
        if (t3.modelTopology instanceof ArrayBuffer)
          throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        e2 = JSON.stringify(t3.modelTopology), n2 = JSON.stringify(t3.weightSpecs), o2 = Vh(t3);
        try {
          return this.LS.setItem(this.keys.info, JSON.stringify(o2)), this.LS.setItem(this.keys.topology, e2), this.LS.setItem(this.keys.weightSpecs, n2), this.LS.setItem(this.keys.weightData, (a2 = t3.weightData, Ph ? Buffer.from(a2).toString("base64") : btoa(String.fromCharCode.apply(null, new Uint8Array(a2))))), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({format: t3.format, generatedBy: t3.generatedBy, convertedBy: t3.convertedBy})), [2, {modelArtifactsInfo: o2}];
        } catch (t4) {
          throw this.LS.removeItem(this.keys.info), this.LS.removeItem(this.keys.topology), this.LS.removeItem(this.keys.weightSpecs), this.LS.removeItem(this.keys.weightData), this.LS.removeItem(this.keys.modelMetadata), new Error("Failed to save model '" + this.modelPath + "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=" + o2.modelTopologyBytes + ", weightSpecsBytes=" + o2.weightSpecsBytes + ", weightDataBytes=" + o2.weightDataBytes + ".");
        }
        var a2;
        return [2];
      });
    });
  }, t2.prototype.load = function() {
    return n(this, void 0, void 0, function() {
      var t3, e2, n2, o2, a2, i2, u2;
      return r(this, function(r2) {
        if (null == (t3 = JSON.parse(this.LS.getItem(this.keys.info))))
          throw new Error("In local storage, there is no model with name '" + this.modelPath + "'");
        if ("JSON" !== t3.modelTopologyType)
          throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
        if (e2 = {}, null == (n2 = JSON.parse(this.LS.getItem(this.keys.topology))))
          throw new Error("In local storage, the topology of model '" + this.modelPath + "' is missing.");
        if (e2.modelTopology = n2, null == (o2 = JSON.parse(this.LS.getItem(this.keys.weightSpecs))))
          throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' are missing.");
        if (e2.weightSpecs = o2, null != (a2 = this.LS.getItem(this.keys.modelMetadata)) && (i2 = JSON.parse(a2), e2.format = i2.format, e2.generatedBy = i2.generatedBy, e2.convertedBy = i2.convertedBy), null == (u2 = this.LS.getItem(this.keys.weightData)))
          throw new Error("In local storage, the binary weight values of model '" + this.modelPath + "' are missing.");
        return e2.weightData = function(t4) {
          if (Ph) {
            var e3 = Buffer.from(t4, "base64");
            return e3.buffer.slice(e3.byteOffset, e3.byteOffset + e3.byteLength);
          }
          for (var n3 = atob(t4), r3 = new Uint8Array(n3.length), o3 = 0; o3 < n3.length; ++o3)
            r3.set([n3.charCodeAt(o3)], o3);
          return r3.buffer;
        }(u2), [2, e2];
      });
    });
  }, t2.URL_SCHEME = "localstorage://", t2;
}();
var hf = function(t2) {
  return a().getBool("IS_BROWSER") && !Array.isArray(t2) && t2.startsWith(lf.URL_SCHEME) ? (e2 = t2.slice(lf.URL_SCHEME.length), new lf(e2)) : null;
  var e2;
};
zh.registerSaveRouter(hf), zh.registerLoadRouter(hf);
var ff = function() {
  function t2() {
    g(a().getBool("IS_BROWSER"), function() {
      return "Current environment is not a web browser";
    }), g(void 0 !== window.localStorage, function() {
      return "Current browser does not appear to support localStorage";
    }), this.LS = window.localStorage;
  }
  return t2.prototype.listModels = function() {
    return n(this, void 0, void 0, function() {
      var t3, e2, n2, o2, a2, i2;
      return r(this, function(r2) {
        for (t3 = {}, e2 = ef + tf, n2 = tf + nf, o2 = 0; o2 < this.LS.length; ++o2)
          (a2 = this.LS.key(o2)).startsWith(e2) && a2.endsWith(n2) && (i2 = cf(a2), t3[i2] = JSON.parse(this.LS.getItem(a2)));
        return [2, t3];
      });
    });
  }, t2.prototype.removeModel = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2;
      return r(this, function(r2) {
        var o2;
        if (t3 = (o2 = t3).startsWith(lf.URL_SCHEME) ? o2.slice(lf.URL_SCHEME.length) : o2, e2 = sf(t3), null == this.LS.getItem(e2.info))
          throw new Error("Cannot find model at path '" + t3 + "'");
        return n2 = JSON.parse(this.LS.getItem(e2.info)), this.LS.removeItem(e2.info), this.LS.removeItem(e2.topology), this.LS.removeItem(e2.weightSpecs), this.LS.removeItem(e2.weightData), [2, n2];
      });
    });
  }, t2;
}();
if (a().getBool("IS_BROWSER"))
  try {
    Hh.registerManager(lf.URL_SCHEME, new ff());
  } catch (t2) {
  }
var pf = "model";
var df = ".json";
var vf = ".weights.bin";
function mf(t2) {
  return new Promise(function(t3) {
    return setTimeout(t3);
  }).then(t2);
}
var gf = function() {
  function t2(e2) {
    if (!a().getBool("IS_BROWSER"))
      throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
    e2.startsWith(t2.URL_SCHEME) && (e2 = e2.slice(t2.URL_SCHEME.length)), null != e2 && 0 !== e2.length || (e2 = pf), this.modelTopologyFileName = e2 + df, this.weightDataFileName = e2 + vf;
  }
  return t2.prototype.save = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2, o2, a2, i2, u2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            if ("undefined" == typeof document)
              throw new Error("Browser downloads are not supported in this environment since `document` is not present");
            if (e2 = window.URL.createObjectURL(new Blob([t3.weightData], {type: "application/octet-stream"})), !(t3.modelTopology instanceof ArrayBuffer))
              return [3, 1];
            throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
          case 1:
            return n2 = [{paths: ["./" + this.weightDataFileName], weights: t3.weightSpecs}], o2 = {modelTopology: t3.modelTopology, format: t3.format, generatedBy: t3.generatedBy, convertedBy: t3.convertedBy, weightsManifest: n2}, a2 = window.URL.createObjectURL(new Blob([JSON.stringify(o2)], {type: "application/json"})), (i2 = null == this.jsonAnchor ? document.createElement("a") : this.jsonAnchor).download = this.modelTopologyFileName, i2.href = a2, [4, mf(function() {
              return i2.dispatchEvent(new MouseEvent("click"));
            })];
          case 2:
            return r2.sent(), null == t3.weightData ? [3, 4] : ((u2 = null == this.weightDataAnchor ? document.createElement("a") : this.weightDataAnchor).download = this.weightDataFileName, u2.href = e2, [4, mf(function() {
              return u2.dispatchEvent(new MouseEvent("click"));
            })]);
          case 3:
            r2.sent(), r2.label = 4;
          case 4:
            return [2, {modelArtifactsInfo: Vh(t3)}];
        }
      });
    });
  }, t2.URL_SCHEME = "downloads://", t2;
}();
var yf = function() {
  function t2(t3) {
    if (null == t3 || t3.length < 1)
      throw new Error("When calling browserFiles, at least 1 file is required, but received " + t3);
    this.files = t3;
  }
  return t2.prototype.load = function() {
    return n(this, void 0, void 0, function() {
      var t3, e2, n2 = this;
      return r(this, function(r2) {
        return t3 = this.files[0], e2 = this.files.slice(1), [2, new Promise(function(r3, o2) {
          var a2 = new FileReader();
          a2.onload = function(a3) {
            var i2 = JSON.parse(a3.target.result), u2 = i2.modelTopology;
            if (null != u2) {
              0 === e2.length && r3({modelTopology: u2});
              var s2 = i2.weightsManifest;
              if (null != s2) {
                var c2;
                try {
                  c2 = n2.checkManifestAndWeightFiles(s2, e2);
                } catch (t4) {
                  return void o2(t4);
                }
                var l2 = [], h2 = [], f2 = [];
                s2.forEach(function(t4) {
                  t4.paths.forEach(function(t5) {
                    h2.push(t5), f2.push(null);
                  }), l2.push.apply(l2, t4.weights);
                }), s2.forEach(function(t4) {
                  t4.paths.forEach(function(t5) {
                    var e3 = new FileReader();
                    e3.onload = function(e4) {
                      var n3 = e4.target.result, o3 = h2.indexOf(t5);
                      f2[o3] = n3, -1 === f2.indexOf(null) && r3({modelTopology: u2, weightSpecs: l2, weightData: Wh(f2)});
                    }, e3.onerror = function(e4) {
                      return o2("Failed to weights data from file of path '" + t5 + "'.");
                    }, e3.readAsArrayBuffer(c2[t5]);
                  });
                });
              } else
                o2(new Error("weightManifest field is missing from file " + t3.name));
            } else
              o2(new Error("modelTopology field is missing from file " + t3.name));
          }, a2.onerror = function(e3) {
            return o2("Failed to read model topology and weights manifest JSON from file '" + t3.name + "'. BrowserFiles supports loading Keras-style tf.Model artifacts only.");
          }, a2.readAsText(t3);
        })];
      });
    });
  }, t2.prototype.checkManifestAndWeightFiles = function(t3, e2) {
    for (var n2 = [], r2 = e2.map(function(t4) {
      return Uh(t4.name);
    }), o2 = {}, a2 = 0, i2 = t3; a2 < i2.length; a2++) {
      i2[a2].paths.forEach(function(t4) {
        var a3 = Uh(t4);
        if (-1 !== n2.indexOf(a3))
          throw new Error("Duplicate file basename found in weights manifest: '" + a3 + "'");
        if (n2.push(a3), -1 === r2.indexOf(a3))
          throw new Error("Weight file with basename '" + a3 + "' is not provided.");
        o2[t4] = e2[r2.indexOf(a3)];
      });
    }
    if (n2.length !== e2.length)
      throw new Error("Mismatch in the number of files in weights manifest (" + n2.length + ") and the number of weight files provided (" + e2.length + ").");
    return o2;
  }, t2;
}();
function xf(t2, e2, n2, r2) {
  !function(t3) {
    g(null != t3 && Array.isArray(t3) && t3.length > 0, function() {
      return "promises must be a none empty array";
    });
  }(t2), function(t3, e3) {
    g(t3 >= 0 && t3 <= 1, function() {
      return "Progress fraction must be in range [0, 1], but got startFraction " + t3;
    }), g(e3 >= 0 && e3 <= 1, function() {
      return "Progress fraction must be in range [0, 1], but got endFraction " + e3;
    }), g(e3 >= t3, function() {
      return "startFraction must be no more than endFraction, but got startFraction " + t3 + " and endFraction " + e3;
    });
  }(n2 = null == n2 ? 0 : n2, r2 = null == r2 ? 1 : r2);
  var o2 = 0;
  return Promise.all(t2.map(function(a2) {
    return a2.then(function(a3) {
      var i2 = n2 + ++o2 / t2.length * (r2 - n2);
      return e2(i2), a3;
    }), a2;
  }));
}
function bf(t2, e2) {
  return n(this, void 0, void 0, function() {
    var n2, o2, i2, u2, s2, c2, l2, h2, f2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          return null == e2 && (e2 = {}), n2 = null == e2.fetchFunc ? a().platform.fetch : e2.fetchFunc, o2 = t2.map(function(t3) {
            return n2(t3, e2.requestInit, {isBinary: true});
          }), i2 = 0, u2 = 0.5, null != e2.onProgress ? [3, 2] : [4, Promise.all(o2)];
        case 1:
          return s2 = r2.sent(), [3, 4];
        case 2:
          return [4, xf(o2, e2.onProgress, i2, u2)];
        case 3:
          s2 = r2.sent(), r2.label = 4;
        case 4:
          return c2 = s2.map(function(t3) {
            return t3.arrayBuffer();
          }), l2 = 0.5, h2 = 1, null != e2.onProgress ? [3, 6] : [4, Promise.all(c2)];
        case 5:
          return f2 = r2.sent(), [3, 8];
        case 6:
          return [4, xf(c2, e2.onProgress, l2, h2)];
        case 7:
          f2 = r2.sent(), r2.label = 8;
        case 8:
          return [2, f2];
      }
    });
  });
}
function wf(t2) {
  var e2 = this;
  return function(o2, a2, i2) {
    return void 0 === a2 && (a2 = ""), n(e2, void 0, void 0, function() {
      var e3, n2, u2, s2, c2, l2, h2, f2, p2, d2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (e3 = o2.map(function() {
              return false;
            }), n2 = {}, u2 = null != i2 ? i2.map(function() {
              return false;
            }) : [], s2 = [], o2.forEach(function(t3, r3) {
              var o3 = 0;
              t3.weights.forEach(function(t4) {
                var a3 = "quantization" in t4 ? t4.quantization.dtype : t4.dtype, c3 = Oh[a3] * w(t4.shape), l3 = function() {
                  e3[r3] = true, null == n2[r3] && (n2[r3] = []), n2[r3].push({manifestEntry: t4, groupOffset: o3, sizeBytes: c3});
                };
                null != i2 ? i2.forEach(function(e4, n3) {
                  e4 === t4.name && (l3(), u2[n3] = true);
                }) : l3(), s2.push(t4.name), o3 += c3;
              });
            }), !u2.every(function(t3) {
              return t3;
            }))
              throw c2 = i2.filter(function(t3, e4) {
                return !u2[e4];
              }), new Error("Could not find weights in manifest with names: " + c2.join(", ") + ". \nManifest JSON has weights with names: " + s2.join(", ") + ".");
            return l2 = e3.reduce(function(t3, e4, n3) {
              return e4 && t3.push(n3), t3;
            }, []), h2 = [], l2.forEach(function(t3) {
              o2[t3].paths.forEach(function(t4) {
                var e4 = a2 + (a2.endsWith("/") ? "" : "/") + t4;
                h2.push(e4);
              });
            }), [4, t2(h2)];
          case 1:
            return f2 = r2.sent(), p2 = {}, d2 = 0, l2.forEach(function(t3) {
              for (var e4 = o2[t3].paths.length, r3 = 0, a3 = 0; a3 < e4; a3++)
                r3 += f2[d2 + a3].byteLength;
              for (var i3 = new ArrayBuffer(r3), u3 = new Uint8Array(i3), s3 = 0, c3 = 0; c3 < e4; c3++) {
                var l3 = new Uint8Array(f2[d2 + c3]);
                u3.set(l3, s3), s3 += l3.byteLength;
              }
              n2[t3].forEach(function(t4) {
                var e5 = Mh(i3.slice(t4.groupOffset, t4.groupOffset + t4.sizeBytes), [t4.manifestEntry]);
                for (var n3 in e5)
                  p2[n3] = e5[n3];
              }), d2 += e4;
            }), [2, p2];
        }
      });
    });
  };
}
zh.registerSaveRouter(function(t2) {
  return a().getBool("IS_BROWSER") && !Array.isArray(t2) && t2.startsWith(gf.URL_SCHEME) ? (e2 = t2.slice(gf.URL_SCHEME.length), void 0 === e2 && (e2 = "model"), new gf(e2)) : null;
  var e2;
});
var Cf = function() {
  function t2(t3, e2) {
    if (this.DEFAULT_METHOD = "POST", null == e2 && (e2 = {}), this.weightPathPrefix = e2.weightPathPrefix, this.onProgress = e2.onProgress, null != e2.fetchFunc ? (g("function" == typeof e2.fetchFunc, function() {
      return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)";
    }), this.fetch = e2.fetchFunc) : this.fetch = a().platform.fetch, g(null != t3 && t3.length > 0, function() {
      return "URL path for http must not be null, undefined or empty.";
    }), Array.isArray(t3) && g(2 === t3.length, function() {
      return "URL paths for http must have a length of 2, (actual length is " + t3.length + ").";
    }), this.path = t3, null != e2.requestInit && null != e2.requestInit.body)
      throw new Error("requestInit is expected to have no pre-existing body, but has one.");
    this.requestInit = e2.requestInit || {};
  }
  return t2.prototype.save = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2, o2, a2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (t3.modelTopology instanceof ArrayBuffer)
              throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
            return (e2 = Object.assign({method: this.DEFAULT_METHOD}, this.requestInit)).body = new FormData(), n2 = [{paths: ["./model.weights.bin"], weights: t3.weightSpecs}], o2 = {modelTopology: t3.modelTopology, format: t3.format, generatedBy: t3.generatedBy, convertedBy: t3.convertedBy, userDefinedMetadata: t3.userDefinedMetadata, weightsManifest: n2}, e2.body.append("model.json", new Blob([JSON.stringify(o2)], {type: "application/json"}), "model.json"), null != t3.weightData && e2.body.append("model.weights.bin", new Blob([t3.weightData], {type: "application/octet-stream"}), "model.weights.bin"), [4, this.fetch(this.path, e2)];
          case 1:
            if ((a2 = r2.sent()).ok)
              return [2, {modelArtifactsInfo: Vh(t3), responses: [a2]}];
            throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + a2.status + ".");
        }
      });
    });
  }, t2.prototype.load = function() {
    return n(this, void 0, void 0, function() {
      var t3, e2, n2, o2, a2, i2, u2, s2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            return [4, this.fetch(this.path, this.requestInit)];
          case 1:
            if (!(t3 = r2.sent()).ok)
              throw new Error("Request to " + this.path + " failed with status code " + t3.status + ". Please verify this URL points to the model JSON of the model to load.");
            r2.label = 2;
          case 2:
            return r2.trys.push([2, 4, , 5]), [4, t3.json()];
          case 3:
            return e2 = r2.sent(), [3, 5];
          case 4:
            throw r2.sent(), n2 = "Failed to parse model JSON of response from " + this.path + ".", this.path.endsWith(".pb") ? n2 += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : n2 += " Please make sure the server is serving valid JSON for this request.", new Error(n2);
          case 5:
            if (o2 = e2.modelTopology, a2 = e2.weightsManifest, null == o2 && null == a2)
              throw new Error("The JSON from HTTP path " + this.path + " contains neither model topology or manifest for weights.");
            return null == a2 ? [3, 7] : [4, this.loadWeights(a2)];
          case 6:
            s2 = r2.sent(), i2 = s2[0], u2 = s2[1], r2.label = 7;
          case 7:
            return [2, {modelTopology: o2, weightSpecs: i2, weightData: u2}];
        }
      });
    });
  }, t2.prototype.loadWeights = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2, o2, a2, i2, u2, s2, c2, l2, h2, f2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            for (e2 = Array.isArray(this.path) ? this.path[1] : this.path, n2 = function(t4) {
              var e3 = t4.lastIndexOf("/"), n3 = t4.lastIndexOf("?"), r3 = t4.substring(0, e3), o3 = n3 > e3 ? t4.substring(n3) : "";
              return [r3 + "/", o3];
            }(e2), o2 = n2[0], a2 = n2[1], i2 = this.weightPathPrefix || o2, u2 = [], s2 = 0, c2 = t3; s2 < c2.length; s2++)
              l2 = c2[s2], u2.push.apply(u2, l2.weights);
            return h2 = [], t3.forEach(function(t4) {
              t4.paths.forEach(function(t5) {
                h2.push(i2 + t5 + a2);
              });
            }), [4, bf(h2, {requestInit: this.requestInit, fetchFunc: this.fetch, onProgress: this.onProgress})];
          case 1:
            return f2 = r2.sent(), [2, [u2, Wh(f2)]];
        }
      });
    });
  }, t2.URL_SCHEME_REGEX = /^https?:\/\//, t2;
}();
function Ef(t2) {
  return null != t2.match(Cf.URL_SCHEME_REGEX);
}
var Rf = function(t2, e2) {
  if ("undefined" == typeof fetch)
    return null;
  return (Array.isArray(t2) ? t2.every(function(t3) {
    return Ef(t3);
  }) : Ef(t2)) ? If(t2, {onProgress: e2}) : null;
};
function If(t2, e2) {
  return new Cf(t2, e2);
}
zh.registerSaveRouter(Rf), zh.registerLoadRouter(Rf);
var kf = function() {
  function t2(t3) {
    this.modelArtifacts = t3;
  }
  return t2.prototype.load = function() {
    return n(this, void 0, void 0, function() {
      return r(this, function(t3) {
        return [2, this.modelArtifacts];
      });
    });
  }, t2;
}();
var Sf = function() {
  function t2(t3) {
    this.saveHandler = t3;
  }
  return t2.prototype.save = function(t3) {
    return n(this, void 0, void 0, function() {
      return r(this, function(e2) {
        return [2, this.saveHandler(t3)];
      });
    });
  }, t2;
}();
var Af = Object.freeze({browserFiles: function(t2) {
  return new yf(t2);
}, browserHTTPRequest: function(t2, e2) {
  return If(t2, e2);
}, concatenateArrayBuffers: Wh, decodeWeights: Mh, encodeWeights: function(t2, e2) {
  return n(this, void 0, void 0, function() {
    var o2, a2, i2, u2, s2, c2 = this;
    return r(this, function(l2) {
      switch (l2.label) {
        case 0:
          for (o2 = [], a2 = [], i2 = Array.isArray(t2) ? t2.map(function(t3) {
            return t3.name;
          }) : Object.keys(t2), u2 = function(u3) {
            var s3 = i2[u3], l3 = Array.isArray(t2) ? t2[u3].tensor : t2[s3];
            if ("float32" !== l3.dtype && "int32" !== l3.dtype && "bool" !== l3.dtype && "string" !== l3.dtype)
              throw new Error("Unsupported dtype in weight '" + s3 + "': " + l3.dtype);
            var h2 = {name: s3, shape: l3.shape, dtype: l3.dtype};
            if ("string" === l3.dtype) {
              var f2 = new Promise(function(t3) {
                return n(c2, void 0, void 0, function() {
                  var e3, n2, o3, a3, i3, u4, s4;
                  return r(this, function(r2) {
                    switch (r2.label) {
                      case 0:
                        return [4, l3.bytes()];
                      case 1:
                        for (e3 = r2.sent(), n2 = e3.reduce(function(t4, e4) {
                          return t4 + e4.length;
                        }, 0) + _h * e3.length, o3 = new Uint8Array(n2), a3 = 0, i3 = 0; i3 < e3.length; i3++)
                          u4 = e3[i3], s4 = new Uint8Array(new Uint32Array([u4.length]).buffer), o3.set(s4, a3), a3 += _h, o3.set(u4, a3), a3 += u4.length;
                        return t3(o3), [2];
                    }
                  });
                });
              });
              a2.push(f2);
            } else
              a2.push(l3.data());
            null != e2 && (h2.group = e2), o2.push(h2);
          }, s2 = 0; s2 < i2.length; ++s2)
            u2(s2);
          return [4, Promise.all(a2)];
        case 1:
          return [2, {data: Bh(l2.sent()), specs: o2}];
      }
    });
  });
}, fromMemory: function(t2, e2, n2, r2) {
  return 1 === arguments.length ? null != t2.modelTopology || null != t2.weightSpecs ? new kf(t2) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new kf({modelTopology: t2})) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new kf({modelTopology: t2, weightSpecs: e2, weightData: n2, trainingConfig: r2}));
}, getLoadHandlers: function(t2, e2) {
  return zh.getLoadHandlers(t2, e2);
}, getModelArtifactsInfoForJSON: Vh, getSaveHandlers: function(t2) {
  return zh.getSaveHandlers(t2);
}, http: If, isHTTPScheme: Ef, loadWeights: function(t2, e2, o2, a2) {
  return void 0 === e2 && (e2 = ""), n(this, void 0, void 0, function() {
    return r(this, function(n2) {
      return [2, wf(function(t3) {
        return bf(t3, {requestInit: a2});
      })(t2, e2, o2)];
    });
  });
}, registerLoadRouter: function(t2) {
  return zh.registerLoadRouter(t2);
}, registerSaveRouter: function(t2) {
  return zh.registerSaveRouter(t2);
}, weightsLoaderFactory: wf, withSaveHandler: function(t2) {
  return new Sf(t2);
}, copyModel: function(t2, e2) {
  return n(this, void 0, void 0, function() {
    return r(this, function(n2) {
      return [2, Kh(t2, e2, false)];
    });
  });
}, listModels: function() {
  return n(this, void 0, void 0, function() {
    var t2, e2, n2, o2, a2, i2, u2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          t2 = Hh.getSchemes(), e2 = {}, n2 = 0, o2 = t2, r2.label = 1;
        case 1:
          return n2 < o2.length ? (a2 = o2[n2], [4, Hh.getManager(a2).listModels()]) : [3, 4];
        case 2:
          for (u2 in i2 = r2.sent())
            e2[a2 + Gh + u2] = i2[u2];
          r2.label = 3;
        case 3:
          return n2++, [3, 1];
        case 4:
          return [2, e2];
      }
    });
  });
}, moveModel: function(t2, e2) {
  return n(this, void 0, void 0, function() {
    return r(this, function(n2) {
      return [2, Kh(t2, e2, true)];
    });
  });
}, removeModel: function(t2) {
  return n(this, void 0, void 0, function() {
    var e2;
    return r(this, function(n2) {
      return e2 = qh(t2), [2, Hh.getManager(e2.scheme).removeModel(e2.path)];
    });
  });
}});
var Df = Cn({confusionMatrix_: function(t2, e2, n2) {
  var r2 = ln(t2, "labels", "confusionMatrix"), o2 = ln(e2, "predictions", "confusionMatrix");
  g(null == n2 || n2 > 0 && Number.isInteger(n2), function() {
    return "If provided, numClasses must be a positive integer, but got " + n2;
  }), g(1 === r2.rank, function() {
    return "Expected the rank of labels to be 1, but got " + r2.rank;
  }), g(1 === o2.rank, function() {
    return "Expected the rank of predictions to be 1, but got " + o2.rank;
  }), g(r2.shape[0] === o2.shape[0], function() {
    return "Mismatch in the number of examples: " + r2.shape[0] + " vs. " + o2.shape[0] + ". Labels and predictions should have the same number of elements.";
  }), g(n2 > 0 && Number.isInteger(n2), function() {
    return "numClasses is required to be a positive integer, but got " + n2;
  });
  var a2 = gr(r2.asType("int32"), n2), i2 = gr(o2.asType("int32"), n2);
  return a2.transpose().matMul(i2).asType("int32");
}});
var Tf = Object.freeze({confusionMatrix: Df});
var Nf = Cn({fromPixels_: function(t2, e2) {
  if (void 0 === e2 && (e2 = 3), e2 > 4)
    throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
  var n2 = "undefined" != typeof HTMLVideoElement && t2 instanceof HTMLVideoElement;
  if (n2 && n2 && t2.readyState < 2)
    throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");
  return Nt.fromPixels(t2, e2);
}});
var Ff = Object.freeze({toPixels: function(t2, e2) {
  return n(this, void 0, void 0, function() {
    var n2, o2, a2, i2, u2, s2, c2, l2, h2, f2, p2, d2, v2, m2, g2, y2, x2, b2, w2, C2, E2, R2, I2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          if (n2 = ln(t2, "img", "toPixels"), t2 instanceof dt || (n2 = n2.toInt()), 2 !== n2.rank && 3 !== n2.rank)
            throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + n2.rank + ".");
          if (o2 = n2.shape.slice(0, 2), a2 = o2[0], i2 = o2[1], (u2 = 2 === n2.rank ? 1 : n2.shape[2]) > 4 || 2 === u2)
            throw new Error("toPixels only supports depth of size 1, 3 or 4 but got " + u2);
          return [4, n2.data()];
        case 1:
          return s2 = r2.sent(), c2 = n2.min(), l2 = n2.max(), [4, Promise.all([c2.data(), l2.data()])];
        case 2:
          if (h2 = r2.sent(), f2 = h2[0], p2 = h2[1], d2 = f2[0], v2 = p2[0], c2.dispose(), l2.dispose(), "float32" === n2.dtype) {
            if (d2 < 0 || v2 > 1)
              throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [" + d2 + " - " + v2 + "].");
          } else {
            if ("int32" !== n2.dtype)
              throw new Error("Unsupported type for toPixels: " + n2.dtype + ". Please use float32 or int32 tensors.");
            if (d2 < 0 || v2 > 255)
              throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [" + d2 + " - " + v2 + "].");
          }
          for (m2 = "float32" === n2.dtype ? 255 : 1, g2 = new Uint8ClampedArray(i2 * a2 * 4), y2 = 0; y2 < a2 * i2; ++y2)
            x2 = void 0, b2 = void 0, w2 = void 0, C2 = void 0, 1 === u2 ? (x2 = s2[y2] * m2, b2 = s2[y2] * m2, w2 = s2[y2] * m2, C2 = 255) : 3 === u2 ? (x2 = s2[3 * y2] * m2, b2 = s2[3 * y2 + 1] * m2, w2 = s2[3 * y2 + 2] * m2, C2 = 255) : 4 === u2 && (x2 = s2[4 * y2] * m2, b2 = s2[4 * y2 + 1] * m2, w2 = s2[4 * y2 + 2] * m2, C2 = s2[4 * y2 + 3] * m2), g2[0 + (E2 = 4 * y2)] = Math.round(x2), g2[E2 + 1] = Math.round(b2), g2[E2 + 2] = Math.round(w2), g2[E2 + 3] = Math.round(C2);
          return null != e2 && (e2.width = i2, e2.height = a2, R2 = e2.getContext("2d"), I2 = new ImageData(g2, i2, a2), R2.putImageData(I2, 0, 0)), n2 !== t2 && n2.dispose(), [2, g2];
      }
    });
  });
}, fromPixels: Nf});
var Of = function() {
  function t2() {
  }
  return t2.prototype.getClassName = function() {
    return this.constructor.className;
  }, t2.fromConfig = function(t3, e2) {
    return new t3(e2);
  }, t2;
}();
var _f = function() {
  function t2() {
    this.classNameMap = {};
  }
  return t2.getMap = function() {
    return null == t2.instance && (t2.instance = new t2()), t2.instance;
  }, t2.register = function(e2) {
    t2.getMap().classNameMap[e2.className] = [e2, e2.fromConfig];
  }, t2;
}();
function Mf(t2) {
  g(null != t2.className, function() {
    return "Class being registered does not have the static className property defined.";
  }), g("string" == typeof t2.className, function() {
    return "className is required to be a string, but got type " + typeof t2.className;
  }), g(t2.className.length > 0, function() {
    return "Class being registered has an empty-string as its className, which is disallowed.";
  }), _f.register(t2);
}
var Bf = Object.freeze({Serializable: Of, SerializationMap: _f, registerClass: Mf});
var Pf = 1e-3;
var Lf = 0.1;
function Wf() {
  return 32 === Nt.backend.floatPrecision() ? Pf : Lf;
}
function Uf(t2, e2, n2) {
  var r2 = true;
  if ((B(t2) || B(e2)) && (r2 = false), B(t2) && B(e2) && (r2 = true), r2) {
    var o2 = t2.constructor.name, a2 = e2.constructor.name;
    if (o2 !== a2)
      throw new Error("Arrays are of different type. Actual: " + o2 + ". Expected: " + a2);
  }
  if (Array.isArray(t2) && Array.isArray(e2)) {
    var i2 = sn(t2), u2 = sn(e2);
    if (!C(i2, u2))
      throw new Error("Arrays have different shapes. Actual: [" + i2 + "]. Expected: [" + u2 + "]");
  }
  var s2 = B(t2) ? t2 : b(t2), c2 = B(e2) ? e2 : b(e2);
  if (s2.length !== c2.length)
    throw new Error("Arrays have different lengths actual: " + s2.length + " vs expected: " + c2.length + ".\nActual:   " + s2 + ".\nExpected: " + c2 + ".");
  for (var l2 = 0; l2 < c2.length; ++l2) {
    var h2 = s2[l2], f2 = c2[l2];
    if (!n2(h2, f2))
      throw new Error("Arrays differ: actual[" + l2 + "] = " + h2 + ", expected[" + l2 + "] = " + f2 + ".\nActual:   " + s2 + ".\nExpected: " + c2 + ".");
  }
}
function Vf(t2, e2, n2) {
  return !isFinite(t2) && !isFinite(e2) || !(isNaN(t2) || isNaN(e2) || Math.abs(t2 - e2) > n2);
}
var zf = Object.freeze({TEST_EPSILON_FLOAT16: Lf, expectArraysClose: function(t2, e2, n2) {
  return null == n2 && (n2 = Wf()), Uf(t2, e2, function(t3, e3) {
    return Vf(t3, e3, n2);
  });
}, testEpsilon: Wf, expectPromiseToFail: function(t2, e2) {
  t2().then(function() {
    return e2.fail();
  }, function() {
    return e2();
  });
}, expectArraysEqual: function(t2, e2) {
  var n2 = "string" == typeof e2 || "number" == typeof e2 || "boolean" == typeof e2 ? [e2] : e2;
  return W(t2) || W(t2[0]) || W(e2) || W(e2[0]) ? Uf(t2, n2, function(t3, e3) {
    return t3 == e3;
  }) : Uf(t2, e2, function(t3, e3) {
    return Vf(t3, e3, 0);
  });
}, expectNumbersClose: function(t2, e2, n2) {
  if (null == n2 && (n2 = Wf()), !Vf(t2, e2, n2))
    throw new Error("Numbers differ: actual === " + t2 + ", expected === " + e2);
}, expectValuesInRange: function(t2, e2, n2) {
  for (var r2 = 0; r2 < t2.length; r2++)
    if (t2[r2] < e2 || t2[r2] > n2)
      throw new Error("Value out of range:" + t2[r2] + " low: " + e2 + ", high: " + n2);
}, expectArrayBuffersEqual: function(t2, e2) {
  expect(new Float32Array(t2)).toEqual(new Float32Array(e2));
}});
var Gf = "1.3.2";
var Hf = Object.freeze({gpgpu_util: wi, webgl_util: Pe, forceHalfFloat: function() {
  a().set("WEBGL_FORCE_F16_TEXTURES", true);
}, MathBackendWebGL: Wu, setWebGLContext: Wt, GPGPUContext: Ci});
var qf = function(t2) {
  function o2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return e(o2, t2), o2.prototype.minimize = function(t3, e2, n2) {
    void 0 === e2 && (e2 = false);
    var r2 = this.computeGradients(t3, n2), o3 = r2.value, a2 = r2.grads;
    if (null != n2) {
      var i2 = n2.map(function(t4) {
        return {name: t4.name, tensor: a2[t4.name]};
      });
      this.applyGradients(i2);
    } else
      this.applyGradients(a2);
    return Xe(a2), e2 ? o3 : (o3.dispose(), null);
  }, Object.defineProperty(o2.prototype, "iterations", {get: function() {
    return null == this.iterations_ && (this.iterations_ = 0), this.iterations_;
  }, enumerable: true, configurable: true}), o2.prototype.incrementIterations = function() {
    this.iterations_ = this.iterations + 1;
  }, o2.prototype.computeGradients = function(t3, e2) {
    return ro(t3, e2);
  }, o2.prototype.dispose = function() {
    null != this.iterations_ && Xe(this.iterations_);
  }, o2.prototype.saveIterations = function() {
    return n(this, void 0, void 0, function() {
      return r(this, function(t3) {
        return null == this.iterations_ && (this.iterations_ = 0), [2, {name: "iter", tensor: An(this.iterations_, "int32")}];
      });
    });
  }, o2.prototype.getWeights = function() {
    return n(this, void 0, void 0, function() {
      return r(this, function(t3) {
        throw new Error("getWeights() is not implemented for this optimizer yet.");
      });
    });
  }, o2.prototype.setWeights = function(t3) {
    return n(this, void 0, void 0, function() {
      return r(this, function(t4) {
        throw new Error("setWeights() is not implemented for this optimizer class " + this.getClassName());
      });
    });
  }, o2.prototype.extractIterations = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2;
      return r(this, function(n2) {
        switch (n2.label) {
          case 0:
            return e2 = this, [4, t3[0].tensor.data()];
          case 1:
            return e2.iterations_ = n2.sent()[0], [2, t3.slice(1)];
        }
      });
    });
  }, o2;
}(Of);
Object.defineProperty(qf, Symbol.hasInstance, {value: function(t2) {
  return null != t2.minimize && null != t2.computeGradients && null != t2.applyGradients;
}});
var Kf = function(t2) {
  function o2(e2, n2, r2) {
    void 0 === r2 && (r2 = null);
    var o3 = t2.call(this) || this;
    return o3.learningRate = e2, o3.rho = n2, o3.epsilon = r2, o3.accumulatedGrads = [], o3.accumulatedUpdates = [], null == r2 && (o3.epsilon = Nt.backend.epsilon()), o3;
  }
  return e(o2, t2), o2.prototype.applyGradients = function(t3) {
    var e2 = this;
    (Array.isArray(t3) ? t3.map(function(t4) {
      return t4.name;
    }) : Object.keys(t3)).forEach(function(n2, r2) {
      var o3 = Nt.registeredVariables[n2];
      null == e2.accumulatedGrads[r2] && (e2.accumulatedGrads[r2] = {originalName: n2 + "/accum_grad", variable: je(function() {
        return zn(o3).variable(false);
      })}), null == e2.accumulatedUpdates[r2] && (e2.accumulatedUpdates[r2] = {originalName: n2 + "/accum_var", variable: je(function() {
        return zn(o3).variable(false);
      })});
      var a2 = Array.isArray(t3) ? t3[r2].tensor : t3[n2];
      if (null != a2) {
        var i2 = e2.accumulatedGrads[r2].variable, u2 = e2.accumulatedUpdates[r2].variable;
        je(function() {
          var t4 = i2.mul(e2.rho).add(a2.square().mul(1 - e2.rho)), n3 = u2.add(e2.epsilon).sqrt().div(i2.add(e2.epsilon).sqrt()).mul(a2), r3 = u2.mul(e2.rho).add(n3.square().mul(1 - e2.rho));
          i2.assign(t4), u2.assign(r3);
          var s2 = n3.mul(-e2.learningRate).add(o3);
          o3.assign(s2);
        });
      }
    }), this.incrementIterations();
  }, o2.prototype.dispose = function() {
    null != this.accumulatedUpdates && (Xe(this.accumulatedGrads.map(function(t3) {
      return t3.variable;
    })), Xe(this.accumulatedUpdates.map(function(t3) {
      return t3.variable;
    })));
  }, o2.prototype.getWeights = function() {
    return n(this, void 0, void 0, function() {
      var t3;
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return t3 = this.accumulatedGrads.concat(this.accumulatedUpdates), [4, this.saveIterations()];
          case 1:
            return [2, [e2.sent()].concat(t3.map(function(t4) {
              return {name: t4.originalName, tensor: t4.variable};
            }))];
        }
      });
    });
  }, o2.prototype.setWeights = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2;
      return r(this, function(n2) {
        switch (n2.label) {
          case 0:
            return [4, this.extractIterations(t3)];
          case 1:
            return t3 = n2.sent(), e2 = t3.length / 2, false, this.accumulatedGrads = t3.slice(0, e2).map(function(t4) {
              return {originalName: t4.name, variable: t4.tensor.variable(false)};
            }), this.accumulatedUpdates = t3.slice(e2, 2 * e2).map(function(t4) {
              return {originalName: t4.name, variable: t4.tensor.variable(false)};
            }), [2];
        }
      });
    });
  }, o2.prototype.getConfig = function() {
    return {learningRate: this.learningRate, rho: this.rho, epsilon: this.epsilon};
  }, o2.fromConfig = function(t3, e2) {
    return new t3(e2.learningRate, e2.rho, e2.epsilon);
  }, o2.className = "Adadelta", o2;
}(qf);
Mf(Kf);
var jf = function(t2) {
  function o2(e2, n2) {
    void 0 === n2 && (n2 = 0.1);
    var r2 = t2.call(this) || this;
    return r2.learningRate = e2, r2.initialAccumulatorValue = n2, r2.accumulatedGrads = [], r2;
  }
  return e(o2, t2), o2.prototype.applyGradients = function(t3) {
    var e2 = this;
    (Array.isArray(t3) ? t3.map(function(t4) {
      return t4.name;
    }) : Object.keys(t3)).forEach(function(n2, r2) {
      var o3 = Nt.registeredVariables[n2];
      if (null == e2.accumulatedGrads[r2]) {
        e2.accumulatedGrads[r2] = {originalName: n2 + "/accumulator", variable: je(function() {
          return Ln(o3.shape, e2.initialAccumulatorValue).variable(false);
        })};
      }
      var a2 = Array.isArray(t3) ? t3[r2].tensor : t3[n2];
      if (null != a2) {
        var i2 = e2.accumulatedGrads[r2].variable;
        je(function() {
          var t4 = i2.add(a2.square());
          i2.assign(t4);
          var n3 = a2.div(t4.add(Nt.backend.epsilon()).sqrt()).mul(-e2.learningRate).add(o3);
          o3.assign(n3);
        });
      }
    }), this.incrementIterations();
  }, o2.prototype.dispose = function() {
    null != this.accumulatedGrads && Xe(this.accumulatedGrads.map(function(t3) {
      return t3.variable;
    }));
  }, o2.prototype.getWeights = function() {
    return n(this, void 0, void 0, function() {
      return r(this, function(t3) {
        switch (t3.label) {
          case 0:
            return [4, this.saveIterations()];
          case 1:
            return [2, [t3.sent()].concat(this.accumulatedGrads.map(function(t4) {
              return {name: t4.originalName, tensor: t4.variable};
            }))];
        }
      });
    });
  }, o2.prototype.setWeights = function(t3) {
    return n(this, void 0, void 0, function() {
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return [4, this.extractIterations(t3)];
          case 1:
            return t3 = e2.sent(), false, this.accumulatedGrads = t3.map(function(t4) {
              return {originalName: t4.name, variable: t4.tensor.variable(false)};
            }), [2];
        }
      });
    });
  }, o2.prototype.getConfig = function() {
    return {learningRate: this.learningRate, initialAccumulatorValue: this.initialAccumulatorValue};
  }, o2.fromConfig = function(t3, e2) {
    return new t3(e2.learningRate, e2.initialAccumulatorValue);
  }, o2.className = "Adagrad", o2;
}(qf);
Mf(jf);
var Xf = function(t2) {
  function o2(e2, n2, r2, o3) {
    void 0 === o3 && (o3 = null);
    var a2 = t2.call(this) || this;
    return a2.learningRate = e2, a2.beta1 = n2, a2.beta2 = r2, a2.epsilon = o3, a2.accumulatedFirstMoment = [], a2.accumulatedSecondMoment = [], je(function() {
      a2.accBeta1 = An(n2).variable(), a2.accBeta2 = An(r2).variable();
    }), null == o3 && (a2.epsilon = Nt.backend.epsilon()), a2;
  }
  return e(o2, t2), o2.prototype.applyGradients = function(t3) {
    var e2 = this, n2 = Array.isArray(t3) ? t3.map(function(t4) {
      return t4.name;
    }) : Object.keys(t3);
    je(function() {
      var r2 = uc(1, e2.accBeta1), o3 = uc(1, e2.accBeta2);
      n2.forEach(function(n3, a2) {
        var i2 = Nt.registeredVariables[n3];
        null == e2.accumulatedFirstMoment[a2] && (e2.accumulatedFirstMoment[a2] = {originalName: n3 + "/m", variable: je(function() {
          return zn(i2).variable(false);
        })}), null == e2.accumulatedSecondMoment[a2] && (e2.accumulatedSecondMoment[a2] = {originalName: n3 + "/v", variable: je(function() {
          return zn(i2).variable(false);
        })});
        var u2 = Array.isArray(t3) ? t3[a2].tensor : t3[n3];
        if (null != u2) {
          var s2 = e2.accumulatedFirstMoment[a2].variable, c2 = e2.accumulatedSecondMoment[a2].variable, l2 = s2.mul(e2.beta1).add(u2.mul(1 - e2.beta1)), h2 = c2.mul(e2.beta2).add(u2.square().mul(1 - e2.beta2)), f2 = l2.div(r2), p2 = h2.div(o3);
          s2.assign(l2), c2.assign(h2);
          var d2 = f2.div(p2.sqrt().add(e2.epsilon)).mul(-e2.learningRate).add(i2);
          i2.assign(d2);
        }
      }), e2.accBeta1.assign(e2.accBeta1.mul(e2.beta1)), e2.accBeta2.assign(e2.accBeta2.mul(e2.beta2));
    }), this.incrementIterations();
  }, o2.prototype.dispose = function() {
    this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && Xe(this.accumulatedFirstMoment.map(function(t3) {
      return t3.variable;
    })), null != this.accumulatedSecondMoment && Xe(this.accumulatedSecondMoment.map(function(t3) {
      return t3.variable;
    }));
  }, o2.prototype.getWeights = function() {
    return n(this, void 0, void 0, function() {
      var t3;
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return t3 = this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment), [4, this.saveIterations()];
          case 1:
            return [2, [e2.sent()].concat(t3.map(function(t4) {
              return {name: t4.originalName, tensor: t4.variable};
            }))];
        }
      });
    });
  }, o2.prototype.setWeights = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2 = this;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            return [4, this.extractIterations(t3)];
          case 1:
            return t3 = r2.sent(), je(function() {
              n2.accBeta1.assign(rc(n2.beta1, n2.iterations_ + 1)), n2.accBeta2.assign(rc(n2.beta2, n2.iterations_ + 1));
            }), e2 = t3.length / 2, false, this.accumulatedFirstMoment = t3.slice(0, e2).map(function(t4) {
              return {originalName: t4.name, variable: t4.tensor.variable(false)};
            }), this.accumulatedSecondMoment = t3.slice(e2, 2 * e2).map(function(t4) {
              return {originalName: t4.name, variable: t4.tensor.variable(false)};
            }), [2];
        }
      });
    });
  }, o2.prototype.getConfig = function() {
    return {learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon};
  }, o2.fromConfig = function(t3, e2) {
    return new t3(e2.learningRate, e2.beta1, e2.beta2, e2.epsilon);
  }, o2.className = "Adam", o2;
}(qf);
Mf(Xf);
var $f = function(t2) {
  function o2(e2, n2, r2, o3, a2) {
    void 0 === o3 && (o3 = null), void 0 === a2 && (a2 = 0);
    var i2 = t2.call(this) || this;
    return i2.learningRate = e2, i2.beta1 = n2, i2.beta2 = r2, i2.epsilon = o3, i2.decay = a2, i2.accumulatedFirstMoment = [], i2.accumulatedWeightedInfNorm = [], je(function() {
      i2.iteration = An(0).variable(), i2.accBeta1 = An(n2).variable();
    }), null == o3 && (i2.epsilon = Nt.backend.epsilon()), i2;
  }
  return e(o2, t2), o2.prototype.applyGradients = function(t3) {
    var e2 = this, n2 = Array.isArray(t3) ? t3.map(function(t4) {
      return t4.name;
    }) : Object.keys(t3);
    je(function() {
      var r2 = uc(1, e2.accBeta1), o3 = qs(-e2.learningRate, e2.iteration.mul(e2.decay).add(1));
      n2.forEach(function(n3, a2) {
        var i2 = Nt.registeredVariables[n3];
        null == e2.accumulatedFirstMoment[a2] && (e2.accumulatedFirstMoment[a2] = {originalName: n3 + "/m", variable: zn(i2).variable(false)}), null == e2.accumulatedWeightedInfNorm[a2] && (e2.accumulatedWeightedInfNorm[a2] = {originalName: n3 + "/v", variable: zn(i2).variable(false)});
        var u2 = Array.isArray(t3) ? t3[a2].tensor : t3[n3];
        if (null != u2) {
          var s2 = e2.accumulatedFirstMoment[a2].variable, c2 = e2.accumulatedWeightedInfNorm[a2].variable, l2 = s2.mul(e2.beta1).add(u2.mul(1 - e2.beta1)), h2 = c2.mul(e2.beta2), f2 = u2.abs(), p2 = h2.maximum(f2);
          s2.assign(l2), c2.assign(p2);
          var d2 = o3.div(r2).mul(l2.div(p2.add(e2.epsilon))).add(i2);
          i2.assign(d2);
        }
      }), e2.iteration.assign(e2.iteration.add(1)), e2.accBeta1.assign(e2.accBeta1.mul(e2.beta1));
    }), this.incrementIterations();
  }, o2.prototype.dispose = function() {
    this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && Xe(this.accumulatedFirstMoment.map(function(t3) {
      return t3.variable;
    })), null != this.accumulatedWeightedInfNorm && Xe(this.accumulatedWeightedInfNorm.map(function(t3) {
      return t3.variable;
    }));
  }, o2.prototype.getWeights = function() {
    return n(this, void 0, void 0, function() {
      return r(this, function(t3) {
        throw new Error("getWeights() is not implemented for Adamax yet.");
      });
    });
  }, o2.prototype.setWeights = function(t3) {
    return n(this, void 0, void 0, function() {
      return r(this, function(t4) {
        throw new Error("setWeights() is not implemented for Adamax yet.");
      });
    });
  }, o2.prototype.getConfig = function() {
    return {learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon, decay: this.decay};
  }, o2.fromConfig = function(t3, e2) {
    return new t3(e2.learningRate, e2.beta1, e2.beta2, e2.epsilon, e2.decay);
  }, o2.className = "Adamax", o2;
}(qf);
Mf($f);
var Yf = function(t2) {
  function o2(e2) {
    var n2 = t2.call(this) || this;
    return n2.learningRate = e2, n2.setLearningRate(e2), n2;
  }
  return e(o2, t2), o2.prototype.applyGradients = function(t3) {
    var e2 = this;
    (Array.isArray(t3) ? t3.map(function(t4) {
      return t4.name;
    }) : Object.keys(t3)).forEach(function(n2, r2) {
      var o3 = Array.isArray(t3) ? t3[r2].tensor : t3[n2];
      if (null != o3) {
        var a2 = Nt.registeredVariables[n2];
        je(function() {
          var t4 = e2.c.mul(o3).add(a2);
          a2.assign(t4);
        });
      }
    }), this.incrementIterations();
  }, o2.prototype.setLearningRate = function(t3) {
    this.learningRate = t3, null != this.c && this.c.dispose(), this.c = $e(An(-t3));
  }, o2.prototype.dispose = function() {
    this.c.dispose();
  }, o2.prototype.getWeights = function() {
    return n(this, void 0, void 0, function() {
      return r(this, function(t3) {
        switch (t3.label) {
          case 0:
            return [4, this.saveIterations()];
          case 1:
            return [2, [t3.sent()]];
        }
      });
    });
  }, o2.prototype.setWeights = function(t3) {
    return n(this, void 0, void 0, function() {
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return [4, this.extractIterations(t3)];
          case 1:
            if (0 !== (t3 = e2.sent()).length)
              throw new Error("SGD optimizer does not have settable weights.");
            return [2];
        }
      });
    });
  }, o2.prototype.getConfig = function() {
    return {learningRate: this.learningRate};
  }, o2.fromConfig = function(t3, e2) {
    return new t3(e2.learningRate);
  }, o2.className = "SGD", o2;
}(qf);
Mf(Yf);
var Qf = function(t2) {
  function o2(e2, n2, r2) {
    void 0 === r2 && (r2 = false);
    var o3 = t2.call(this, e2) || this;
    return o3.learningRate = e2, o3.momentum = n2, o3.useNesterov = r2, o3.accumulations = [], o3.m = An(o3.momentum), o3;
  }
  return e(o2, t2), o2.prototype.applyGradients = function(t3) {
    var e2 = this;
    (Array.isArray(t3) ? t3.map(function(t4) {
      return t4.name;
    }) : Object.keys(t3)).forEach(function(n2, r2) {
      var o3 = Nt.registeredVariables[n2];
      if (null == e2.accumulations[r2]) {
        e2.accumulations[r2] = {originalName: n2 + "/momentum", variable: je(function() {
          return zn(o3).variable(false);
        })};
      }
      var a2 = e2.accumulations[r2].variable, i2 = Array.isArray(t3) ? t3[r2].tensor : t3[n2];
      null != i2 && je(function() {
        var t4, n3 = e2.m.mul(a2).add(i2);
        t4 = e2.useNesterov ? e2.c.mul(i2.add(n3.mul(e2.m))).add(o3) : e2.c.mul(n3).add(o3), a2.assign(n3), o3.assign(t4);
      });
    }), this.incrementIterations();
  }, o2.prototype.dispose = function() {
    this.m.dispose(), null != this.accumulations && Xe(this.accumulations.map(function(t3) {
      return t3.variable;
    }));
  }, o2.prototype.setMomentum = function(t3) {
    this.momentum = t3;
  }, o2.prototype.getWeights = function() {
    return n(this, void 0, void 0, function() {
      return r(this, function(t3) {
        switch (t3.label) {
          case 0:
            return [4, this.saveIterations()];
          case 1:
            return [2, [t3.sent()].concat(this.accumulations.map(function(t4) {
              return {name: t4.originalName, tensor: t4.variable};
            }))];
        }
      });
    });
  }, o2.prototype.setWeights = function(t3) {
    return n(this, void 0, void 0, function() {
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return [4, this.extractIterations(t3)];
          case 1:
            return t3 = e2.sent(), false, this.accumulations = t3.map(function(t4) {
              return {originalName: t4.name, variable: t4.tensor.variable(false)};
            }), [2];
        }
      });
    });
  }, o2.prototype.getConfig = function() {
    return {learningRate: this.learningRate, momentum: this.momentum, useNesterov: this.useNesterov};
  }, o2.fromConfig = function(t3, e2) {
    return new t3(e2.learningRate, e2.momentum, e2.useNesterov);
  }, o2.className = "Momentum", o2;
}(Yf);
Mf(Qf);
var Jf = function(t2) {
  function o2(e2, n2, r2, o3, a2) {
    void 0 === n2 && (n2 = 0.9), void 0 === r2 && (r2 = 0), void 0 === o3 && (o3 = null), void 0 === a2 && (a2 = false);
    var i2 = t2.call(this) || this;
    return i2.learningRate = e2, i2.decay = n2, i2.momentum = r2, i2.epsilon = o3, i2.accumulatedMeanSquares = [], i2.accumulatedMoments = [], i2.accumulatedMeanGrads = [], i2.centered = a2, null == o3 && (i2.epsilon = Nt.backend.epsilon()), i2;
  }
  return e(o2, t2), o2.prototype.applyGradients = function(t3) {
    var e2 = this;
    (Array.isArray(t3) ? t3.map(function(t4) {
      return t4.name;
    }) : Object.keys(t3)).forEach(function(n2, r2) {
      var o3 = Nt.registeredVariables[n2];
      null == e2.accumulatedMeanSquares[r2] && (e2.accumulatedMeanSquares[r2] = {originalName: n2 + "/rms", variable: je(function() {
        return zn(o3).variable(false);
      })}), null == e2.accumulatedMoments[r2] && (e2.accumulatedMoments[r2] = {originalName: n2 + "/momentum", variable: je(function() {
        return zn(o3).variable(false);
      })}), null == e2.accumulatedMeanGrads[r2] && e2.centered && (e2.accumulatedMeanGrads[r2] = {originalName: n2 + "/mg", variable: je(function() {
        return zn(o3).variable(false);
      })});
      var a2 = Array.isArray(t3) ? t3[r2].tensor : t3[n2];
      if (null != a2) {
        var i2 = e2.accumulatedMeanSquares[r2].variable, u2 = e2.accumulatedMoments[r2].variable;
        je(function() {
          var t4 = i2.mul(e2.decay).add(a2.square().mul(1 - e2.decay));
          if (e2.centered) {
            var n3 = e2.accumulatedMeanGrads[r2].variable, s2 = n3.mul(e2.decay).add(a2.mul(1 - e2.decay)), c2 = u2.mul(e2.momentum).add(a2.mul(e2.learningRate).div(t4.sub(s2.square().add(e2.epsilon)).sqrt()));
            i2.assign(t4), n3.assign(s2), u2.assign(c2);
            var l2 = o3.sub(c2);
            o3.assign(l2);
          } else {
            var h2 = i2.mul(e2.decay).add(a2.square().mul(1 - e2.decay));
            c2 = u2.mul(e2.momentum).add(a2.mul(e2.learningRate).div(h2.add(e2.epsilon).sqrt()));
            i2.assign(h2), u2.assign(c2);
            l2 = o3.sub(c2);
            o3.assign(l2);
          }
        });
      }
    }), this.incrementIterations();
  }, o2.prototype.dispose = function() {
    null != this.accumulatedMeanSquares && Xe(this.accumulatedMeanSquares.map(function(t3) {
      return t3.variable;
    })), null != this.accumulatedMeanGrads && this.centered && Xe(this.accumulatedMeanGrads.map(function(t3) {
      return t3.variable;
    })), null != this.accumulatedMoments && Xe(this.accumulatedMoments.map(function(t3) {
      return t3.variable;
    }));
  }, o2.prototype.getWeights = function() {
    return n(this, void 0, void 0, function() {
      var t3;
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return t3 = this.accumulatedMeanSquares.concat(this.accumulatedMoments), this.centered && t3.push.apply(t3, this.accumulatedMeanGrads), [4, this.saveIterations()];
          case 1:
            return [2, [e2.sent()].concat(t3.map(function(t4) {
              return {name: t4.originalName, tensor: t4.variable};
            }))];
        }
      });
    });
  }, o2.prototype.setWeights = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2;
      return r(this, function(n2) {
        switch (n2.label) {
          case 0:
            return [4, this.extractIterations(t3)];
          case 1:
            return t3 = n2.sent(), e2 = this.centered ? t3.length / 3 : t3.length / 2, false, this.accumulatedMeanSquares = t3.slice(0, e2).map(function(t4) {
              return {originalName: t4.name, variable: t4.tensor.variable(false)};
            }), this.accumulatedMoments = t3.slice(e2, 2 * e2).map(function(t4) {
              return {originalName: t4.name, variable: t4.tensor.variable(false)};
            }), this.centered && (this.accumulatedMeanGrads = t3.slice(2 * e2, 3 * e2).map(function(t4) {
              return {originalName: t4.name, variable: t4.tensor.variable(false)};
            })), [2];
        }
      });
    });
  }, o2.prototype.getConfig = function() {
    return {learningRate: this.learningRate, decay: this.decay, momentum: this.momentum, epsilon: this.epsilon, centered: this.centered};
  }, o2.fromConfig = function(t3, e2) {
    return new t3(e2.learningRate, e2.decay, e2.momentum, e2.epsilon, e2.centered);
  }, o2.className = "RMSProp", o2;
}(qf);
Mf(Jf);
var Zf = function() {
  function t2() {
  }
  return t2.sgd = function(t3) {
    return new Yf(t3);
  }, t2.momentum = function(t3, e2, n2) {
    return void 0 === n2 && (n2 = false), new Qf(t3, e2, n2);
  }, t2.rmsprop = function(t3, e2, n2, r2, o2) {
    return void 0 === e2 && (e2 = 0.9), void 0 === n2 && (n2 = 0), void 0 === r2 && (r2 = null), void 0 === o2 && (o2 = false), new Jf(t3, e2, n2, r2, o2);
  }, t2.adam = function(t3, e2, n2, r2) {
    return void 0 === t3 && (t3 = 1e-3), void 0 === e2 && (e2 = 0.9), void 0 === n2 && (n2 = 0.999), void 0 === r2 && (r2 = null), new Xf(t3, e2, n2, r2);
  }, t2.adadelta = function(t3, e2, n2) {
    return void 0 === t3 && (t3 = 1e-3), void 0 === e2 && (e2 = 0.95), void 0 === n2 && (n2 = null), new Kf(t3, e2, n2);
  }, t2.adamax = function(t3, e2, n2, r2, o2) {
    return void 0 === t3 && (t3 = 2e-3), void 0 === e2 && (e2 = 0.9), void 0 === n2 && (n2 = 0.999), void 0 === r2 && (r2 = null), void 0 === o2 && (o2 = 0), new $f(t3, e2, n2, r2, o2);
  }, t2.adagrad = function(t3, e2) {
    return void 0 === e2 && (e2 = 0.1), new jf(t3, e2);
  }, t2;
}();
var tp = {sgd: Zf.sgd, momentum: Zf.momentum, adadelta: Zf.adadelta, adagrad: Zf.adagrad, rmsprop: Zf.rmsprop, adamax: Zf.adamax, adam: Zf.adam};
var ep = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate ? setImmediate : function(t2) {
  return t2();
};
function np() {
  return new Promise(function(t2) {
    return ep(function() {
      return t2();
    });
  });
}
ft = Ih;

// node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js
var DataType;
var SaverDef;
var __assign2 = function() {
  return (__assign2 = Object.assign || function(e2) {
    for (var t2, a2 = 1, r2 = arguments.length; a2 < r2; a2++)
      for (var n2 in t2 = arguments[a2])
        Object.prototype.hasOwnProperty.call(t2, n2) && (e2[n2] = t2[n2]);
    return e2;
  }).apply(this, arguments);
};
function __awaiter2(e2, t2, a2, r2) {
  return new (a2 || (a2 = Promise))(function(n2, s2) {
    function o2(e3) {
      try {
        u2(r2.next(e3));
      } catch (e4) {
        s2(e4);
      }
    }
    function p2(e3) {
      try {
        u2(r2.throw(e3));
      } catch (e4) {
        s2(e4);
      }
    }
    function u2(e3) {
      e3.done ? n2(e3.value) : new a2(function(t3) {
        t3(e3.value);
      }).then(o2, p2);
    }
    u2((r2 = r2.apply(e2, t2 || [])).next());
  });
}
function __generator2(e2, t2) {
  var a2, r2, n2, s2, o2 = {label: 0, sent: function() {
    if (1 & n2[0])
      throw n2[1];
    return n2[1];
  }, trys: [], ops: []};
  return s2 = {next: p2(0), throw: p2(1), return: p2(2)}, "function" == typeof Symbol && (s2[Symbol.iterator] = function() {
    return this;
  }), s2;
  function p2(s3) {
    return function(p3) {
      return function(s4) {
        if (a2)
          throw new TypeError("Generator is already executing.");
        for (; o2; )
          try {
            if (a2 = 1, r2 && (n2 = 2 & s4[0] ? r2.return : s4[0] ? r2.throw || ((n2 = r2.return) && n2.call(r2), 0) : r2.next) && !(n2 = n2.call(r2, s4[1])).done)
              return n2;
            switch (r2 = 0, n2 && (s4 = [2 & s4[0], n2.value]), s4[0]) {
              case 0:
              case 1:
                n2 = s4;
                break;
              case 4:
                return o2.label++, {value: s4[1], done: false};
              case 5:
                o2.label++, r2 = s4[1], s4 = [0];
                continue;
              case 7:
                s4 = o2.ops.pop(), o2.trys.pop();
                continue;
              default:
                if (!(n2 = (n2 = o2.trys).length > 0 && n2[n2.length - 1]) && (6 === s4[0] || 2 === s4[0])) {
                  o2 = 0;
                  continue;
                }
                if (3 === s4[0] && (!n2 || s4[1] > n2[0] && s4[1] < n2[3])) {
                  o2.label = s4[1];
                  break;
                }
                if (6 === s4[0] && o2.label < n2[1]) {
                  o2.label = n2[1], n2 = s4;
                  break;
                }
                if (n2 && o2.label < n2[2]) {
                  o2.label = n2[2], o2.ops.push(s4);
                  break;
                }
                n2[2] && o2.ops.pop(), o2.trys.pop();
                continue;
            }
            s4 = t2.call(e2, o2);
          } catch (e3) {
            s4 = [6, e3], r2 = 0;
          } finally {
            a2 = n2 = 0;
          }
        if (5 & s4[0])
          throw s4[1];
        return {value: s4[0] ? s4[1] : void 0, done: true};
      }([s3, p3]);
    };
  }
}
!function(e2) {
  e2[e2.DT_INVALID = 0] = "DT_INVALID", e2[e2.DT_FLOAT = 1] = "DT_FLOAT", e2[e2.DT_DOUBLE = 2] = "DT_DOUBLE", e2[e2.DT_INT32 = 3] = "DT_INT32", e2[e2.DT_UINT8 = 4] = "DT_UINT8", e2[e2.DT_INT16 = 5] = "DT_INT16", e2[e2.DT_INT8 = 6] = "DT_INT8", e2[e2.DT_STRING = 7] = "DT_STRING", e2[e2.DT_COMPLEX64 = 8] = "DT_COMPLEX64", e2[e2.DT_INT64 = 9] = "DT_INT64", e2[e2.DT_BOOL = 10] = "DT_BOOL", e2[e2.DT_QINT8 = 11] = "DT_QINT8", e2[e2.DT_QUINT8 = 12] = "DT_QUINT8", e2[e2.DT_QINT32 = 13] = "DT_QINT32", e2[e2.DT_BFLOAT16 = 14] = "DT_BFLOAT16", e2[e2.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", e2[e2.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", e2[e2.DT_INT32_REF = 103] = "DT_INT32_REF", e2[e2.DT_UINT8_REF = 104] = "DT_UINT8_REF", e2[e2.DT_INT16_REF = 105] = "DT_INT16_REF", e2[e2.DT_INT8_REF = 106] = "DT_INT8_REF", e2[e2.DT_STRING_REF = 107] = "DT_STRING_REF", e2[e2.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", e2[e2.DT_INT64_REF = 109] = "DT_INT64_REF", e2[e2.DT_BOOL_REF = 110] = "DT_BOOL_REF", e2[e2.DT_QINT8_REF = 111] = "DT_QINT8_REF", e2[e2.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", e2[e2.DT_QINT32_REF = 113] = "DT_QINT32_REF", e2[e2.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF";
}(DataType || (DataType = {})), function(e2) {
  !function(e3) {
    e3[e3.LEGACY = 0] = "LEGACY", e3[e3.V1 = 1] = "V1", e3[e3.V2 = 2] = "V2";
  }(e2.CheckpointFormatVersion || (e2.CheckpointFormatVersion = {}));
}(SaverDef || (SaverDef = {}));
var CUSTOM_OPS = {};
function getRegisteredOp(e2) {
  return CUSTOM_OPS[e2];
}
function getParamValue(e2, t2, a2, r2) {
  var n2 = t2.inputParams[e2];
  if (n2 && void 0 !== n2.inputIndexStart) {
    var s2 = n2.inputIndexStart, o2 = 0 === n2.inputIndexEnd ? void 0 : void 0 === n2.inputIndexEnd ? s2 + 1 : n2.inputIndexEnd;
    if ("tensor" === n2.type)
      return getTensor(t2.inputNames[n2.inputIndexStart], a2, r2);
    if ("tensors" === n2.type)
      return t2.inputNames.slice(s2, o2).map(function(e3) {
        return getTensor(e3, a2, r2);
      });
    var p2 = Array.prototype.slice.call(getTensor(t2.inputNames.slice(s2)[0], a2, r2).dataSync());
    return "number" === n2.type ? p2[0] : p2;
  }
  var u2 = t2.attrParams[e2];
  return u2 && u2.value;
}
function getTensor(e2, t2, a2) {
  var r2 = parseNodeName(e2), n2 = r2[0], s2 = r2[1], o2 = a2.currentContextIds.find(function(e3) {
    return !!t2[getNodeNameWithContextId(n2, e3)];
  });
  return void 0 !== o2 ? t2[getNodeNameWithContextId(n2, o2)][s2] : void 0;
}
function getTensorsForCurrentContenxt(e2, t2, a2) {
  return t2[getNodeNameWithContextId(e2, a2.currentContextId)];
}
function getNodeNameAndIndex(e2, t2) {
  var a2 = parseNodeName(e2), r2 = a2[0], n2 = a2[1];
  return [getNodeNameWithContextId(r2, t2 && t2.currentContextId), n2];
}
function getNodeNameWithContextId(e2, t2) {
  return t2 ? e2 + "-" + t2 : e2;
}
function parseNodeName(e2) {
  var t2 = e2.lastIndexOf(":");
  return -1 === t2 ? [e2, 0] : [e2.substring(0, t2), Number(e2.substring(t2 + 1))];
}
function split$1(e2, t2) {
  for (var a2 = [], r2 = 0; r2 < e2.length; r2 += t2)
    a2.push(e2.slice(r2, r2 + t2));
  return a2;
}
var json = [{tfOpName: "Add", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "AddV2", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "AddN", category: "arithmetic", inputs: [{start: 0, end: 0, name: "tensors", type: "tensors"}]}, {tfOpName: "BiasAdd", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Sub", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "RealDiv", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Div", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "DivNoNan", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "FloorDiv", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Mul", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Maximum", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}]}, {tfOpName: "Minimum", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}]}, {tfOpName: "Pow", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "SquaredDifference", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Mod", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "FloorMod", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}];
var arithmetic = Object.freeze({json});
var json$1 = [{tfOpName: "Abs", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Acos", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Asin", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Atan", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Atan2", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "y", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Ceil", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "ClipByValue", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "clip_value_min", name: "clipValueMin", type: "number"}, {tfName: "clip_value_max", name: "clipValueMax", type: "number"}]}, {tfOpName: "Complex", category: "basic_math", inputs: [{start: 0, name: "real", type: "tensor"}, {start: 1, name: "imag", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "ComplexAbs", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Cos", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Cosh", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Elu", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Exp", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Floor", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Log", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Imag", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}, {tfName: "Tout", name: "outputType", type: "dtype", notSupported: true}]}, {tfOpName: "Neg", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Real", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}, {tfName: "Tout", name: "outputType", type: "dtype", notSupported: true}]}, {tfOpName: "Prelu", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "alpha", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Relu", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Relu6", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}, {tfName: "clipValueMin", name: "clipValueMin", type: "number", defaultValue: 0}, {tfName: "clipValueMax", name: "clipValueMax", type: "number", defaultValue: 6}]}, {tfOpName: "Selu", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Sigmoid", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Sin", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Sinh", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Sqrt", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Rsqrt", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Square", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Tan", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Tanh", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Sign", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Round", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Expm1", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Log1p", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Reciprocal", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Softplus", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Asinh", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Acosh", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Atanh", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Erf", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Prod", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axes", type: "number[]"}], attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool", notSupported: true}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "LeakyRelu", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "alpha", name: "alpha", type: "number", defaultValue: 0.2}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}];
var basicMath = Object.freeze({json: json$1});
var json$2 = [{tfOpName: "LoopCond", category: "control", inputs: [{start: 0, name: "pred", type: "tensor"}]}, {tfOpName: "Switch", category: "control", inputs: [{start: 0, name: "data", type: "tensor"}, {start: 1, name: "pred", type: "tensor"}]}, {tfOpName: "Merge", category: "control", inputs: [{start: 0, end: 0, name: "tensors", type: "tensors"}]}, {tfOpName: "Enter", category: "control", inputs: [{start: 0, name: "tensor", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}, {tfName: "frame_name", name: "frameName", type: "string"}, {tfName: "is_constant", name: "isConstant", type: "bool"}]}, {tfOpName: "Exit", category: "control", inputs: [{start: 0, name: "tensor", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "NextIteration", category: "control", inputs: [{start: 0, name: "tensor", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "TensorArrayV3", category: "control", inputs: [{start: 0, name: "size", type: "number"}], attrs: [{tfName: "dtype", name: "dtype", type: "dtype"}, {tfName: "element_shape", name: "elementShape", type: "shape"}, {tfName: "dynamic_size", name: "dynamicSize", type: "bool"}, {tfName: "clear_after_read", name: "clearAfterRead", type: "bool"}, {tfName: "identical_element_shapes", name: "identicalElementShapes", type: "bool"}, {tfName: "tensor_array_name", name: "name", type: "string"}]}, {tfOpName: "TensorArrayWriteV3", category: "control", inputs: [{start: 0, name: "tensorArrayId", type: "number"}, {start: 1, name: "index", type: "number"}, {start: 2, name: "tensor", type: "tensor"}, {start: 3, name: "flowIn", type: "number"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "TensorArrayReadV3", category: "control", inputs: [{start: 0, name: "tensorArrayId", type: "number"}, {start: 1, name: "index", type: "number"}, {start: 2, name: "flowIn", type: "number"}], attrs: [{tfName: "dtype", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "TensorArrayGatherV3", category: "control", inputs: [{start: 0, name: "tensorArrayId", type: "number"}, {start: 1, name: "indices", type: "number[]"}, {start: 2, name: "flowIn", type: "number"}], attrs: [{tfName: "dtype", name: "dtype", type: "dtype"}, {tfName: "element_shape", name: "elementShape", type: "shape"}]}, {tfOpName: "TensorArrayScatterV3", category: "control", inputs: [{start: 0, name: "tensorArrayId", type: "number"}, {start: 1, name: "indices", type: "number[]"}, {start: 2, name: "tensor", type: "tensor"}, {start: 3, name: "flowIn", type: "number"}], attrs: [{tfName: "T", name: "dtype", type: "dtype"}]}, {tfOpName: "TensorArrayConcatV3", category: "control", inputs: [{start: 0, name: "tensorArrayId", type: "number"}, {start: 1, name: "flowIn", type: "number"}], attrs: [{tfName: "dtype", name: "dtype", type: "dtype"}, {tfName: "element_shape_except0", name: "elementShapeExcept0", type: "shape", notSupported: true}]}, {tfOpName: "TensorArraySplitV3", category: "control", inputs: [{start: 0, name: "tensorArrayId", type: "number"}, {start: 1, name: "tensor", type: "tensor"}, {start: 2, name: "lengths", type: "number[]"}, {start: 3, name: "flowIn", type: "number"}], attrs: [{tfName: "T", name: "dtype", type: "dtype"}]}, {tfOpName: "TensorArraySizeV3", category: "control", inputs: [{start: 0, name: "tensorArrayId", type: "number"}, {start: 1, name: "flowIn", type: "number"}]}, {tfOpName: "TensorArrayCloseV3", category: "control", inputs: [{start: 0, name: "tensorArrayId", type: "number"}]}];
var control = Object.freeze({json: json$2});
var json$3 = [{tfOpName: "AvgPool", category: "convolution", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "data_format", name: "dataFormat", type: "string", notSupported: true}, {tfName: "ksize", name: "kernelSize", type: "number[]"}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "MaxPool", category: "convolution", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "data_format", name: "dataFormat", type: "string", notSupported: true}, {tfName: "ksize", name: "kernelSize", type: "number[]"}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "AvgPool3D", category: "convolution", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "data_format", name: "dataFormat", type: "string", notSupported: true}, {tfName: "ksize", name: "kernelSize", type: "number[]"}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "MaxPool3D", category: "convolution", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "data_format", name: "dataFormat", type: "string", notSupported: true}, {tfName: "ksize", name: "kernelSize", type: "number[]"}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Conv1D", category: "convolution", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "filter", type: "tensor"}], attrs: [{tfName: "stride", name: "stride", type: "number"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NWC"}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}, {tfName: "dilation", name: "dilation", type: "number", defaultValue: 1}]}, {tfOpName: "Conv2D", category: "convolution", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "filter", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}, {tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "useCudnnOnGpu", name: "useCudnnOnGpu", type: "bool"}, {tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC"}, {tfName: "dilations", name: "dilations", type: "number[]"}]}, {tfOpName: "_FusedConv2D", category: "convolution", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "filter", type: "tensor"}, {start: 2, end: 0, name: "args", type: "tensors"}], attrs: [{tfName: "num_args", name: "numArgs", type: "number"}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}, {tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: []}, {tfName: "use_cudnn_on_gpu", name: "useCudnnOnGpu", type: "bool", defaultValue: true}, {tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC"}, {tfName: "dilations", name: "dilations", type: "number[]", defaultValue: [1, 1, 1, 1]}, {tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: []}, {tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-4}]}, {tfOpName: "Conv2DBackpropInput", category: "convolution", inputs: [{start: 2, name: "x", type: "tensor"}, {start: 1, name: "filter", type: "tensor"}, {start: 0, name: "outputShape", type: "number[]"}], attrs: [{tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "data_format", name: "dataFormat", type: "string", notSupported: true}]}, {tfOpName: "DepthwiseConv2d", category: "convolution", inputs: [{start: 0, name: "input", type: "tensor"}, {start: 1, name: "filter", type: "tensor"}], attrs: [{tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC"}, {tfName: "dilations", name: "dilations", type: "number[]"}]}, {tfOpName: "DepthwiseConv2dNative", category: "convolution", inputs: [{start: 0, name: "input", type: "tensor"}, {start: 1, name: "filter", type: "tensor"}], attrs: [{tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC"}, {tfName: "dilations", name: "dilations", type: "number[]"}]}, {tfOpName: "Conv3D", category: "convolution", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "filter", type: "tensor"}], attrs: [{tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC"}, {tfName: "dilations", name: "dilations", type: "number[]"}]}];
var convolution = Object.freeze({json: json$3});
var json$4 = [{tfOpName: "Fill", category: "creation", inputs: [{start: 0, name: "shape", type: "number[]"}, {start: 1, name: "value", type: "number"}], attrs: [{tfName: "T", name: "dtype", type: "dtype"}]}, {tfOpName: "LinSpace", category: "creation", inputs: [{start: 0, name: "start", type: "number"}, {start: 1, name: "stop", type: "number"}, {start: 2, name: "num", type: "number"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "OneHot", category: "creation", inputs: [{start: 0, name: "indices", type: "tensor"}, {start: 1, name: "depth", type: "number"}, {start: 2, name: "onValue", type: "number", defaultValue: 1}, {start: 3, name: "offValue", type: "number", defaultValue: 0}], attrs: [{tfName: "axis", name: "axis", type: "number", notSupported: true}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Ones", category: "creation", inputs: [{start: 0, name: "shape", type: "number[]"}], attrs: [{tfName: "T", name: "dtype", type: "dtype"}]}, {tfOpName: "OnesLike", category: "creation", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "dtype", name: "dtype", type: "dtype"}]}, {tfOpName: "RandomUniform", category: "creation", inputs: [{start: 0, name: "shape", type: "number[]"}], attrs: [{tfName: "minval", name: "minval", type: "number", defaultValue: 0}, {tfName: "maxval", name: "maxval", type: "number", defaultValue: 1}, {tfName: "dtype", name: "dtype", type: "dtype"}, {tfName: "seed", name: "seed", type: "number", defaultValue: 0}, {tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true}, {tfName: "T", name: "T", type: "number", notSupported: true}]}, {tfOpName: "Range", category: "creation", inputs: [{start: 0, name: "start", type: "number"}, {start: 1, name: "stop", type: "number"}, {start: 2, name: "step", type: "number", defaultValue: 0}], attrs: [{tfName: "Tidx", name: "dtype", type: "dtype"}]}, {tfOpName: "TruncatedNormal", category: "creation", inputs: [{start: 0, name: "shape", type: "number[]"}], attrs: [{tfName: "means", name: "mean", type: "number", defaultValue: 0}, {tfName: "stddev", name: "stdDev", type: "number", defaultValue: 1}, {tfName: "seed", name: "seed", type: "number"}, {tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true}, {tfName: "dtype", name: "dtype", type: "dtype"}, {tfName: "T", name: "T", type: "number", notSupported: true}]}, {tfOpName: "Zeros", category: "creation", inputs: [{start: 0, name: "shape", type: "number[]"}], attrs: [{tfName: "T", name: "dtype", type: "dtype"}]}, {tfOpName: "ZerosLike", category: "creation", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype"}]}, {tfOpName: "Multinomial", category: "creation", inputs: [{start: 0, name: "logits", type: "tensor"}, {start: 1, name: "numSamples", type: "number"}], attrs: [{tfName: "seed", name: "seed", type: "number"}, {tfName: "seed2", name: "seed2", type: "number"}, {tfName: "T", name: "dtype", type: "dtype"}, {tfName: "output_dtype", name: "output_dtype", type: "dtype"}]}];
var creation = Object.freeze({json: json$4});
var json$5 = [{tfOpName: "NonMaxSuppressionV2", category: "dynamic", inputs: [{start: 0, name: "boxes", type: "tensor"}, {start: 1, name: "scores", type: "tensor"}, {start: 2, name: "maxOutputSize", type: "number"}, {start: 3, name: "iouThreshold", type: "number"}]}, {tfOpName: "NonMaxSuppressionV3", category: "dynamic", inputs: [{start: 0, name: "boxes", type: "tensor"}, {start: 1, name: "scores", type: "tensor"}, {start: 2, name: "maxOutputSize", type: "number"}, {start: 3, name: "iouThreshold", type: "number"}, {start: 4, name: "scoreThreshold", type: "number"}]}, {tfOpName: "Where", category: "dynamic", inputs: [{start: 0, name: "condition", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "ListDiff", category: "dynamic", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "y", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}];
var dynamic = Object.freeze({json: json$5});
var json$6 = [{tfOpName: "TopKV2", category: "evaluation", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "k", type: "number"}], attrs: [{tfName: "sorted", name: "sorted", type: "bool"}]}];
var evaluation = Object.freeze({json: json$6});
var json$7 = [{tfOpName: "PlaceholderWithDefault", category: "graph", inputs: [{start: 0, name: "default", type: "tensor"}], attrs: [{tfName: "shape", name: "shape", type: "shape"}, {tfName: "dtype", name: "dtype", type: "dtype"}]}, {tfOpName: "Placeholder", category: "graph", attrs: [{tfName: "shape", name: "shape", type: "shape"}, {tfName: "dtype", name: "dtype", type: "dtype"}]}, {tfOpName: "Const", category: "graph"}, {tfOpName: "Identity", category: "graph", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "IdentityN", category: "graph", inputs: [{start: 0, end: 0, name: "x", type: "tensors"}]}, {tfOpName: "Snapshot", category: "graph", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "Rank", category: "graph", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "Size", category: "graph", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "Shape", category: "graph", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "ShapeN", category: "graph", inputs: [{start: 0, end: 0, name: "x", type: "tensors"}]}, {tfOpName: "Print", category: "graph", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "data", type: "tensors"}], attrs: [{tfName: "message", name: "message", type: "string"}, {tfName: "first_n", name: "firstN", type: "number", notSupported: true}, {tfName: "summarize", name: "summarize", type: "number", defaultValue: 3}]}, {tfOpName: "NoOp", category: "graph", inputs: []}, {tfOpName: "StopGradient", category: "graph", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "FakeQuantWithMinMaxVars", category: "graph", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "min", name: "min", type: "number"}, {tfName: "max", name: "max", type: "number"}]}];
var graph = Object.freeze({json: json$7});
var json$8 = [{tfOpName: "ResizeBilinear", category: "image", inputs: [{start: 0, name: "images", type: "tensor"}, {start: 1, name: "size", type: "number[]"}], attrs: [{tfName: "align_corners", name: "alignCorners", type: "bool"}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "ResizeNearestNeighbor", category: "image", inputs: [{start: 0, name: "images", type: "tensor"}, {start: 1, name: "size", type: "number[]"}], attrs: [{tfName: "align_corners", name: "alignCorners", type: "bool"}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "CropAndResize", category: "image", inputs: [{start: 0, name: "image", type: "tensor"}, {start: 1, name: "boxes", type: "tensor"}, {start: 2, name: "boxInd", type: "tensor"}, {start: 3, name: "cropSize", type: "number[]"}], attrs: [{tfName: "method", name: "method", type: "string"}, {tfName: "extrapolation_value", name: "extrapolationValue", type: "number"}]}];
var image$1 = Object.freeze({json: json$8});
var json$9 = [{tfOpName: "Equal", category: "logical", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "NotEqual", category: "logical", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Greater", category: "logical", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "GreaterEqual", category: "logical", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Less", category: "logical", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "LessEqual", category: "logical", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "LogicalAnd", category: "logical", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "LogicalNot", category: "logical", inputs: [{start: 0, name: "a", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "LogicalOr", category: "logical", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Select", category: "logical", inputs: [{start: 0, name: "condition", type: "tensor"}, {start: 1, name: "a", type: "tensor"}, {start: 2, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}];
var logical = Object.freeze({json: json$9});
var json$10 = [{tfOpName: "MatMul", category: "matrices", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "transpose_a", name: "transposeA", type: "bool", defaultValue: false}, {tfName: "transpose_b", name: "transposeB", type: "bool", defaultValue: false}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "BatchMatMul", category: "matrices", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "adj_x", name: "transposeA", type: "bool", defaultValue: false}, {tfName: "adj_y", name: "transposeB", type: "bool", defaultValue: false}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "BatchMatMulV2", category: "matrices", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "adj_x", name: "transposeA", type: "bool", defaultValue: false}, {tfName: "adj_y", name: "transposeB", type: "bool", defaultValue: false}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Transpose", category: "matrices", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "perm", type: "number[]"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}];
var matrices = Object.freeze({json: json$10});
var json$11 = [{tfOpName: "FusedBatchNorm", category: "normalization", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "scale", type: "tensor"}, {start: 2, name: "offset", type: "tensor"}, {start: 3, name: "mean", type: "tensor"}, {start: 4, name: "variance", type: "tensor"}], attrs: [{tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3}, {tfName: "data_format", name: "dataFormat", type: "string", notSupported: true}]}, {tfOpName: "FusedBatchNormV2", category: "normalization", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "scale", type: "tensor"}, {start: 2, name: "offset", type: "tensor"}, {start: 3, name: "mean", type: "tensor"}, {start: 4, name: "variance", type: "tensor"}], attrs: [{tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3}, {tfName: "data_format", name: "dataFormat", type: "string", notSupported: true}]}, {tfOpName: "FusedBatchNormV3", category: "normalization", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "scale", type: "tensor"}, {start: 2, name: "offset", type: "tensor"}, {start: 3, name: "mean", type: "tensor"}, {start: 4, name: "variance", type: "tensor"}], attrs: [{tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3}, {tfName: "data_format", name: "dataFormat", type: "string", notSupported: true}]}, {tfOpName: "LRN", category: "normalization", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "depth_radius", name: "radius", type: "number", defaultValue: 5}, {tfName: "bias", name: "bias", type: "number", defaultValue: 1}, {tfName: "alpha", name: "alpha", type: "number", defaultValue: 1}, {tfName: "beta", name: "beta", type: "number", defaultValue: 0.5}]}, {tfOpName: "Softmax", category: "normalization", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "LogSoftmax", category: "normalization", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "SparseToDense", category: "normalization", inputs: [{start: 0, name: "sparseIndices", type: "tensor"}, {start: 1, name: "outputShape", type: "number[]"}, {start: 2, name: "sparseValues", type: "tensor"}, {start: 3, name: "defaultValue", type: "tensor"}], attrs: [{tfName: "validate_indices", name: "validateIndices", type: "bool", defaultValue: true, notSupported: true}]}];
var normalization = Object.freeze({json: json$11});
var json$12 = [{tfOpName: "Max", category: "reduction", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number[]"}], attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]}, {tfOpName: "Mean", category: "reduction", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number[]"}], attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]}, {tfOpName: "Min", category: "reduction", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number[]"}], attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]}, {tfOpName: "Sum", category: "reduction", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number[]"}], attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]}, {tfOpName: "All", category: "reduction", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number[]"}], attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]}, {tfOpName: "Any", category: "reduction", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number[]"}], attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]}, {tfOpName: "ArgMax", category: "reduction", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number"}]}, {tfOpName: "ArgMin", category: "reduction", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number"}]}, {tfOpName: "Prod", category: "reduction", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number[]"}], attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]}];
var reduction = Object.freeze({json: json$12});
var json$13 = [{tfOpName: "ConcatV2", category: "slice_join", inputs: [{start: 0, end: -1, name: "tensors", type: "tensors"}, {start: -1, name: "axis", type: "number"}], attrs: [{tfName: "N", name: "n", type: "number", defaultValue: 2}]}, {tfOpName: "Concat", category: "slice_join", inputs: [{start: 1, end: 0, name: "tensors", type: "tensors"}, {start: 0, name: "axis", type: "number"}], attrs: [{tfName: "N", name: "n", type: "number", defaultValue: 2}]}, {tfOpName: "GatherV2", category: "slice_join", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "indices", type: "tensor"}, {start: 2, name: "axis", type: "number", defaultValue: 0}]}, {tfOpName: "Gather", category: "slice_join", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "indices", type: "tensor"}], attrs: [{tfName: "axis", name: "axis", type: "number", defaultValue: 0}, {tfName: "validate_indices", name: "validateIndices", type: "bool", notSupported: true}]}, {tfOpName: "Reverse", category: "slice_join", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "dims", type: "bool", notSupported: true}]}, {tfOpName: "ReverseV2", category: "slice_join", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number[]"}]}, {tfOpName: "Slice", category: "slice_join", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "begin", type: "number[]"}, {start: 2, name: "size", type: "number[]"}]}, {tfOpName: "StridedSlice", category: "slice_join", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "begin", type: "number[]"}, {start: 2, name: "end", type: "number[]"}, {start: 3, name: "strides", type: "number[]"}], attrs: [{tfName: "begin_mask", name: "beginMask", type: "number", defaultValue: 0}, {tfName: "end_mask", name: "endMask", type: "number", defaultValue: 0}, {tfName: "new_axis_mask", name: "newAxisMask", type: "number", defaultValue: 0}, {tfName: "ellipsis_mask", name: "ellipsisMask", type: "number", defaultValue: 0}, {tfName: "shrink_axis_mask", name: "shrinkAxisMask", type: "number", defaultValue: 0}]}, {tfOpName: "Pack", category: "slice_join", inputs: [{start: 0, end: 0, name: "tensors", type: "tensors"}], attrs: [{tfName: "axis", name: "axis", type: "number", defaultValue: 0}]}, {tfOpName: "Unpack", category: "slice_join", inputs: [{start: 0, name: "tensor", type: "tensor"}], attrs: [{tfName: "axis", name: "axis", type: "number", defaultValue: 0}, {tfName: "num", name: "num", type: "number", defaultValue: 0, notSupported: true}]}, {tfOpName: "Tile", category: "slice_join", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "reps", type: "number[]"}]}, {tfOpName: "Split", category: "slice_join", inputs: [{start: 0, name: "axis", type: "number", defaultValue: 0}, {start: 1, name: "x", type: "tensor"}], attrs: [{tfName: "num_split", name: "numOrSizeSplits", type: "number", defaultValue: 1}]}, {tfOpName: "SplitV", category: "slice_join", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "numOrSizeSplits", type: "number[]"}, {start: 2, name: "axis", type: "number", defaultValue: 0}]}, {tfOpName: "ScatterNd", category: "slice_join", inputs: [{start: 0, name: "indices", type: "tensor"}, {start: 1, name: "values", type: "tensor"}, {start: 2, name: "shape", type: "number[]"}]}, {tfOpName: "GatherNd", category: "slice_join", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "indices", type: "tensor"}]}, {tfOpName: "SparseToDense", category: "slice_join", inputs: [{start: 0, name: "sparseIndices", type: "tensor"}, {start: 1, name: "outputShape", type: "number[]"}, {start: 2, name: "sparseValues", type: "tensor"}, {start: 3, name: "defaultValue", type: "tensor"}], attrs: [{tfName: "validate_indices", name: "validateIndices", type: "bool", defaultValue: false, notSupported: true}]}];
var sliceJoin = Object.freeze({json: json$13});
var json$14 = [{tfOpName: "FFT", category: "spectral", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "IFFT", category: "spectral", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "RFFT", category: "spectral", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "fft_length", type: "number", notSupported: true}]}, {tfOpName: "IRFFT", category: "spectral", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "fft_length", type: "number", notSupported: true}]}];
var spectral = Object.freeze({json: json$14});
var json$15 = [{tfOpName: "Cast", category: "transformation", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "SrcT", name: "sdtype", type: "dtype", notSupported: true}, {tfName: "DstT", name: "dtype", type: "dtype"}]}, {tfOpName: "ExpandDims", category: "transformation", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number"}]}, {tfOpName: "Pad", category: "transformation", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "padding", type: "number[]"}], attrs: [{tfName: "constant_value", name: "constantValue", type: "number", defaultValue: 0}]}, {tfOpName: "PadV2", category: "transformation", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "padding", type: "number[]"}, {start: 2, name: "constantValue", type: "number", defaultValue: 0}]}, {tfOpName: "Reshape", category: "transformation", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "shape", type: "number[]"}]}, {tfOpName: "Squeeze", category: "transformation", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "axis", tfDeprecatedName: "squeeze_dims", name: "axis", type: "number[]"}]}, {tfOpName: "SpaceToBatchND", category: "transformation", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "blockShape", type: "number[]"}, {start: 2, name: "paddings", type: "number[]"}]}, {tfOpName: "BatchToSpaceND", category: "transformation", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "blockShape", type: "number[]"}, {start: 2, name: "crops", type: "number[]"}]}, {tfOpName: "DepthToSpace", category: "transformation", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "block_size", name: "blockSize", type: "number"}, {tfName: "data_format", name: "dataFormat", type: "string"}]}];
var transformation = Object.freeze({json: json$15});
var OperationMapper = function() {
  function e2() {
    var e3 = [arithmetic, basicMath, control, convolution, creation, dynamic, evaluation, logical, image$1, graph, matrices, normalization, reduction, sliceJoin, spectral, transformation], t2 = [].concat.apply([], e3.map(function(e4) {
      return e4.json;
    }));
    this.opMappers = t2.reduce(function(e4, t3) {
      return e4[t3.tfOpName] = t3, e4;
    }, {});
  }
  return Object.defineProperty(e2, "Instance", {get: function() {
    return this._instance || (this._instance = new this());
  }, enumerable: true, configurable: true}), e2.prototype.transformGraph = function(e3) {
    var t2 = this, a2 = [], r2 = [], n2 = e3.node.reduce(function(e4, n3) {
      return e4[n3.name] = t2.mapNode(n3), "Placeholder" === n3.op && a2.push(e4[n3.name]), "Const" === n3.op && r2.push(e4[n3.name]), e4;
    }, {}), s2 = [], o2 = [], p2 = Object.keys(n2);
    return p2.forEach(function(e4) {
      var t3 = n2[e4];
      t3.inputNames.forEach(function(e5) {
        var a3 = getNodeNameAndIndex(e5)[0];
        t3.inputs.push(n2[a3]), n2[a3].children.push(t3);
      }), 0 === t3.inputs.length && s2.push(t3);
    }), p2.forEach(function(e4) {
      var t3 = n2[e4];
      0 === t3.children.length && o2.push(t3);
    }), {nodes: n2, inputs: s2, outputs: o2, weights: r2, placeholders: a2};
  }, e2.prototype.mapNode = function(e3) {
    var t2 = getRegisteredOp(e3.op) || this.opMappers[e3.op] || {};
    null == e3.attr && (e3.attr = {});
    var a2 = {name: e3.name, op: e3.op, category: t2.category, inputNames: (e3.input || []).map(function(e4) {
      return e4.startsWith("^") ? e4.substr(1) : e4;
    }), inputs: [], children: [], inputParams: {}, attrParams: {}, rawAttrs: e3.attr};
    return null != t2.inputs && (a2.inputParams = t2.inputs.reduce(function(e4, t3) {
      return e4[t3.name] = {type: t3.type, inputIndexStart: t3.start, inputIndexEnd: t3.end}, e4;
    }, {})), null != t2.attrs && (a2.attrParams = t2.attrs.reduce(function(t3, a3) {
      var r2 = a3.type, n2 = void 0;
      switch (a3.type) {
        case "string":
          void 0 === (n2 = getStringParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getStringParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "string[]":
          void 0 === (n2 = getStringArrayParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getStringArrayParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "number":
          void 0 === (n2 = getNumberParam(e3.attr, a3.tfName, a3.defaultValue || 0)) && a3.tfDeprecatedName && (n2 = getNumberParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "number[]":
          void 0 === (n2 = getNumericArrayParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getNumericArrayParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "bool":
          void 0 === (n2 = getBoolParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getBoolParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "bool[]":
          void 0 === (n2 = getBoolArrayParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getBoolArrayParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "shape":
          void 0 === (n2 = getTensorShapeParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getTensorShapeParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "shape[]":
          void 0 === (n2 = getTensorShapeArrayParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getTensorShapeArrayParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "dtype":
          void 0 === (n2 = getDtypeParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getDtypeParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "dtype[]":
          void 0 === (n2 = getDtypeArrayParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getDtypeArrayParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "tensor":
        case "tensors":
          break;
        default:
          throw new Error("Unsupported param type: " + a3.type + " for op: " + e3.op);
      }
      return t3[a3.name] = {value: n2, type: r2}, t3;
    }, {})), a2;
  }, e2;
}();
function decodeBase64(e2) {
  var t2 = a().global;
  if (void 0 !== t2.atob)
    return t2.atob(e2);
  if ("undefined" != typeof Buffer)
    return new Buffer(e2, "base64").toString();
  throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
}
function parseStringParam(e2, t2) {
  var a2 = Array.isArray(e2) ? String.fromCharCode.apply(null, e2) : decodeBase64(e2);
  return t2 ? a2 : a2.toLowerCase();
}
function getStringParam(e2, t2, a2, r2) {
  void 0 === r2 && (r2 = false);
  var n2 = e2[t2];
  return null != n2 ? parseStringParam(n2.s, r2) : a2;
}
function getBoolParam(e2, t2, a2) {
  var r2 = e2[t2];
  return r2 ? r2.b : a2;
}
function getNumberParam(e2, t2, a2) {
  var r2 = e2[t2] || {}, n2 = null != r2.i ? r2.i : null != r2.f ? r2.f : a2;
  return "number" == typeof n2 ? n2 : parseInt(n2, 10);
}
function parseDtypeParam(e2) {
  switch ("string" == typeof e2 && (e2 = DataType[e2]), e2) {
    case DataType.DT_FLOAT:
      return "float32";
    case DataType.DT_INT32:
    case DataType.DT_INT64:
      return "int32";
    case DataType.DT_BOOL:
      return "bool";
    case DataType.DT_DOUBLE:
      return "float32";
    case DataType.DT_STRING:
      return "string";
    default:
      return null;
  }
}
function getDtypeParam(e2, t2, a2) {
  var r2 = e2[t2];
  return r2 && r2.type ? parseDtypeParam(r2.type) : a2;
}
function getDtypeArrayParam(e2, t2, a2) {
  var r2 = e2[t2];
  return r2 && r2.list && r2.list.type ? r2.list.type.map(function(e3) {
    return parseDtypeParam(e3);
  }) : a2;
}
function parseTensorShapeParam(e2) {
  if (!e2.unknownRank)
    return null != e2.dim ? e2.dim.map(function(e3) {
      return "number" == typeof e3.size ? e3.size : parseInt(e3.size, 10);
    }) : [];
}
function getTensorShapeParam(e2, t2, a2) {
  var r2 = e2[t2];
  return r2 && r2.shape ? parseTensorShapeParam(r2.shape) : a2;
}
function getNumericArrayParam(e2, t2, a2) {
  var r2 = e2[t2];
  return r2 ? ((r2.list.f && r2.list.f.length ? r2.list.f : r2.list.i) || []).map(function(e3) {
    return "number" == typeof e3 ? e3 : parseInt(e3, 10);
  }) : a2;
}
function getStringArrayParam(e2, t2, a2, r2) {
  void 0 === r2 && (r2 = false);
  var n2 = e2[t2];
  return n2 && n2.list && n2.list.s ? n2.list.s.map(function(e3) {
    return parseStringParam(e3, r2);
  }) : a2;
}
function getTensorShapeArrayParam(e2, t2, a2) {
  var r2 = e2[t2];
  return r2 && r2.list && r2.list.shape ? r2.list.shape.map(function(e3) {
    return parseTensorShapeParam(e3);
  }) : a2;
}
function getBoolArrayParam(e2, t2, a2) {
  var r2 = e2[t2];
  return r2 && r2.list && r2.list.b ? r2.list.b : a2;
}
var NodeValueImpl = function() {
  function e2(e3, t2, a2) {
    var r2 = this;
    this.node = e3, this.tensorMap = t2, this.context = a2, this.inputs = [], this.attrs = {}, this.inputs = e3.inputNames.map(function(e4) {
      return r2.getInput(e4);
    }), null != e3.rawAttrs && (this.attrs = Object.keys(e3.rawAttrs).reduce(function(e4, t3) {
      return e4[t3] = r2.getAttr(t3), e4;
    }, {}));
  }
  return e2.prototype.getInput = function(e3) {
    return getTensor(e3, this.tensorMap, this.context);
  }, e2.prototype.getAttr = function(e3, t2) {
    var a2 = this.node.rawAttrs[e3];
    if (null != a2.tensor)
      return getTensor(e3, this.tensorMap, this.context);
    if (null != a2.i || null != a2.f)
      return getNumberParam(this.node.rawAttrs, e3, t2);
    if (null != a2.s)
      return getStringParam(this.node.rawAttrs, e3, t2);
    if (null != a2.b)
      return getBoolParam(this.node.rawAttrs, e3, t2);
    if (null != a2.shape)
      return getTensorShapeParam(this.node.rawAttrs, e3, t2);
    if (null != a2.type)
      return getDtypeParam(this.node.rawAttrs, e3, t2);
    if (null != a2.list) {
      if (null != a2.list.i || null != a2.list.f)
        return getNumericArrayParam(this.node.rawAttrs, e3, t2);
      if (null != a2.list.s)
        return getStringArrayParam(this.node.rawAttrs, e3, t2);
      if (null != a2.list.shape)
        return getTensorShapeArrayParam(this.node.rawAttrs, e3, t2);
      if (null != a2.list.b)
        return getBoolArrayParam(this.node.rawAttrs, e3, t2);
      if (null != a2.list.type)
        return getDtypeArrayParam(this.node.rawAttrs, e3, t2);
    }
    return t2;
  }, e2;
}();
var executeOp = function(e2, t2, a2) {
  switch (e2.op) {
    case "BiasAdd":
    case "AddV2":
    case "Add":
      return [Vs(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "AddN":
      return [zs(getParamValue("tensors", e2, t2, a2))];
    case "FloorMod":
    case "Mod":
      return [Zs(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "Mul":
      return [ec(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "RealDiv":
    case "Div":
      return [qs(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "DivNoNan":
      return [Ks(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "FloorDiv":
      return [Xs(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "Sub":
      return [uc(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "Minimum":
      return [Qs(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "Maximum":
      return [$s(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "Pow":
      return [rc(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "SquaredDifference":
      return [ac(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$1 = function(e2, t2, a2) {
  switch (e2.op) {
    case "Abs":
    case "ComplexAbs":
      return [Vu(getParamValue("x", e2, t2, a2))];
    case "Acos":
      return [zu(getParamValue("x", e2, t2, a2))];
    case "Acosh":
      return [Gu(getParamValue("x", e2, t2, a2))];
    case "Asin":
      return [Hu(getParamValue("x", e2, t2, a2))];
    case "Asinh":
      return [qu(getParamValue("x", e2, t2, a2))];
    case "Atan":
      return [Ku(getParamValue("x", e2, t2, a2))];
    case "Atan2":
      return [Hs(getParamValue("x", e2, t2, a2), getParamValue("y", e2, t2, a2))];
    case "Atanh":
      return [ju(getParamValue("x", e2, t2, a2))];
    case "Ceil":
      return [Xu(getParamValue("x", e2, t2, a2))];
    case "Complex":
      return [En(getParamValue("real", e2, t2, a2), getParamValue("imag", e2, t2, a2))];
    case "Cos":
      return [Yu(getParamValue("x", e2, t2, a2))];
    case "Cosh":
      return [Qu(getParamValue("x", e2, t2, a2))];
    case "Elu":
      return [yl(getParamValue("x", e2, t2, a2))];
    case "Erf":
      return [Ju(getParamValue("x", e2, t2, a2))];
    case "Exp":
      return [Zu(getParamValue("x", e2, t2, a2))];
    case "Expm1":
      return [ts(getParamValue("x", e2, t2, a2))];
    case "Floor":
      return [es(getParamValue("x", e2, t2, a2))];
    case "Log":
      return [ns(getParamValue("x", e2, t2, a2))];
    case "Log1p":
      return [rs(getParamValue("x", e2, t2, a2))];
    case "Imag":
      return [In(getParamValue("x", e2, t2, a2))];
    case "Neg":
      return [as(getParamValue("x", e2, t2, a2))];
    case "Reciprocal":
      return [is(getParamValue("x", e2, t2, a2))];
    case "Real":
      return [Rn(getParamValue("x", e2, t2, a2))];
    case "Relu":
      return [wl(getParamValue("x", e2, t2, a2))];
    case "Round":
      return [us(getParamValue("x", e2, t2, a2))];
    case "Selu":
      return [El(getParamValue("x", e2, t2, a2))];
    case "Sigmoid":
      return [cs(getParamValue("x", e2, t2, a2))];
    case "Sin":
      return [ds(getParamValue("x", e2, t2, a2))];
    case "Sign":
      return [ls(getParamValue("x", e2, t2, a2))];
    case "Sinh":
      return [vs(getParamValue("x", e2, t2, a2))];
    case "Softplus":
      return [ms(getParamValue("x", e2, t2, a2))];
    case "Sqrt":
      return [gs(getParamValue("x", e2, t2, a2))];
    case "Square":
      return [Uu(getParamValue("x", e2, t2, a2))];
    case "Tanh":
      return [bs(getParamValue("x", e2, t2, a2))];
    case "Tan":
      return [xs(getParamValue("x", e2, t2, a2))];
    case "Relu6":
    case "ClipByValue":
      return [$u(getParamValue("x", e2, t2, a2), getParamValue("clipValueMin", e2, t2, a2), getParamValue("clipValueMax", e2, t2, a2))];
    case "Rsqrt":
      return [ss(getTensor(e2.inputNames[0], t2, a2))];
    case "Prod":
      return [gl(getParamValue("x", e2, t2, a2), getParamValue("axes", e2, t2, a2))];
    case "LeakyRelu":
      return [xl(getParamValue("x", e2, t2, a2), getParamValue("alpha", e2, t2, a2))];
    case "Prelu":
      return [bl(getParamValue("x", e2, t2, a2), getParamValue("alpha", e2, t2, a2))];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var TensorArray = function() {
  function e2(t2, a2, r2, n2, s2, o2, p2) {
    this.name = t2, this.dtype = a2, this.maxSize = r2, this.elementShape = n2, this.identicalElementShapes = s2, this.dynamicSize = o2, this.clearAfterRead = p2, this.tensors = [], this.closed_ = false, this.id = e2.nextId++;
  }
  return Object.defineProperty(e2.prototype, "closed", {get: function() {
    return this.closed_;
  }, enumerable: true, configurable: true}), e2.prototype.clearAndClose = function() {
    this.tensors.forEach(function(e3) {
      return e3.tensor.dispose();
    }), this.tensors = [], this.closed_ = true;
  }, e2.prototype.size = function() {
    return this.tensors.length;
  }, e2.prototype.read = function(e3) {
    if (this.closed_)
      throw new Error("TensorArray " + this.name + " has already been closed.");
    if (e3 < 0 || e3 >= this.tensors.length)
      throw new Error("Tried to read from index " + e3 + ", but array size is: " + this.tensors.length);
    var t2 = this.tensors[e3];
    if (t2.cleared)
      throw new Error("TensorArray " + this.name + ": Could not read index " + e3 + " twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");
    return this.clearAfterRead && (t2.cleared = true), t2.read = true, t2.tensor;
  }, e2.prototype.readMany = function(e3) {
    var t2 = this;
    return e3.map(function(e4) {
      return t2.read(e4);
    });
  }, e2.prototype.write = function(e3, t2) {
    if (this.closed_)
      throw new Error("TensorArray " + this.name + " has already been closed.");
    if (e3 < 0 || !this.dynamicSize && e3 >= this.maxSize)
      throw new Error("Tried to write to index " + e3 + ", but array is not resizeable and size is: " + this.maxSize);
    var a2 = this.tensors[e3] || {};
    if (t2.dtype !== this.dtype)
      throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e3 + ",\n          because the value dtype is " + t2.dtype + ", but TensorArray dtype is " + this.dtype + ".");
    if (0 !== this.size() || null != this.elementShape && 0 !== this.elementShape.length || (this.elementShape = t2.shape), this.assertShapesMatchAllowUndefinedSize(this.elementShape, t2.shape, "TensorArray " + this.name + ": Could not write to TensorArray index " + e3 + "."), a2 && a2.read)
      throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e3 + ", because it has already been read.");
    if (a2 && a2.written)
      throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e3 + ", because it has already been written.");
    a2.tensor = t2, a2.written = true, this.tensors[e3] = a2;
  }, e2.prototype.writeMany = function(e3, t2) {
    var a2 = this;
    if (e3.length !== t2.length)
      throw new Error("TensorArray " + this.name + ": could not write multiple tensors,because the index size: " + e3.length + " is not the same as tensors size: " + t2.length + ".");
    e3.forEach(function(e4, r2) {
      return a2.write(e4, t2[r2]);
    });
  }, e2.prototype.gather = function(e3, t2) {
    if (t2 && t2 !== this.dtype)
      throw new Error("TensorArray dtype is " + this.dtype + " but gather requested dtype " + t2);
    if (!e3) {
      e3 = [];
      for (var a2 = 0; a2 < this.size(); a2++)
        e3.push(a2);
    }
    if (0 === e3.length)
      return kn([], [0].concat(this.elementShape));
    var r2 = this.readMany(e3);
    return this.assertShapesMatchAllowUndefinedSize(this.elementShape, r2[0].shape, "TensorArray shape mismatch: "), Tr(r2, 0);
  }, e2.prototype.concat = function(e3) {
    if (e3 && e3 !== this.dtype)
      throw new Error("TensorArray dtype is " + this.dtype + " but concat requested dtype " + e3);
    if (0 === this.size())
      return kn([], [0].concat(this.elementShape));
    for (var t2 = [], a2 = 0; a2 < this.size(); a2++)
      t2.push(a2);
    var r2 = this.readMany(t2);
    return this.assertShapesMatchAllowUndefinedSize(this.elementShape, r2[0].shape, "TensorArray shape mismatch: tensor array shape (" + this.elementShape + ") vs first tensor shape (" + r2[0].shape + ")"), Gn(r2, 0);
  }, e2.prototype.scatter = function(e3, t2) {
    if (t2.dtype !== this.dtype)
      throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + t2.dtype);
    if (e3.length !== t2.shape[0])
      throw new Error("Expected len(indices) == tensor.shape[0], but saw: " + e3.length + " vs. " + t2.shape[0]);
    var a2 = Math.max.apply(Math, e3);
    if (!this.dynamicSize && a2 >= this.maxSize)
      throw new Error("Max index must be < array size (" + a2 + "  vs. " + this.maxSize + ")");
    this.writeMany(e3, Or(t2, 0));
  }, e2.prototype.split = function(e3, t2) {
    var a2 = this;
    if (t2.dtype !== this.dtype)
      throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + t2.dtype);
    var r2 = 0, n2 = e3.map(function(e4) {
      return r2 += e4;
    });
    if (r2 !== t2.shape[0])
      throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        " + r2 + ", and tensor's shape is: " + t2.shape);
    if (!this.dynamicSize && e3.length !== this.maxSize)
      throw new Error("TensorArray's size is not equal to the size of lengths (" + this.maxSize + " vs. " + e3.length + "), and the TensorArray is not marked as dynamically resizeable");
    var s2 = 0 === r2 ? 0 : t2.size / r2, o2 = [];
    je(function() {
      t2 = t2.reshape([1, r2, s2]);
      for (var p3 = 0; p3 < e3.length; ++p3) {
        var u3 = [0, 0 === p3 ? 0 : n2[p3 - 1], 0], i2 = [1, e3[p3], s2];
        o2[p3] = el(t2, u3, i2).reshape(a2.elementShape);
      }
      return o2;
    });
    for (var p2 = [], u2 = 0; u2 < e3.length; u2++)
      p2[u2] = u2;
    this.writeMany(p2, o2);
  }, e2.prototype.assertShapesMatchAllowUndefinedSize = function(e3, t2, a2) {
    void 0 === a2 && (a2 = ""), tt.assert(this.shapesEqualAllowUndefinedSize(e3, t2), function() {
      return a2 + " Shapes " + e3 + " and " + t2 + " must match";
    });
  }, e2.prototype.shapesEqualAllowUndefinedSize = function(e3, t2) {
    if (e3.length !== t2.length)
      return false;
    for (var a2 = 0; a2 < e3.length; a2++)
      if (-1 !== e3[a2] && -1 !== t2[a2] && e3[a2] !== t2[a2])
        return false;
    return true;
  }, e2.nextId = 0, e2;
}();
function executeOp$2(e2, t2, a2) {
  return __awaiter2(this, void 0, void 0, function() {
    var r2, n2, s2, o2, p2, u2, i2, m2, l2, c2, d2, y2, f2, g2, h2, N2, x2, V2, P2, b2, T2, O2, v2, S2, _2, w2, A2, D2, E2, I2, C2, M2, k2, z2, j2;
    return __generator2(this, function(F2) {
      switch (F2.label) {
        case 0:
          switch (e2.op) {
            case "LoopCond":
              return [3, 1];
            case "Switch":
              return [3, 2];
            case "Merge":
              return [3, 4];
            case "Enter":
              return [3, 5];
            case "Exit":
              return [3, 6];
            case "NextIteration":
              return [3, 7];
            case "TensorArrayV3":
              return [3, 8];
            case "TensorArrayWriteV3":
              return [3, 9];
            case "TensorArrayReadV3":
              return [3, 10];
            case "TensorArrayGatherV3":
              return [3, 11];
            case "TensorArrayScatterV3":
              return [3, 12];
            case "TensorArrayConcatV3":
              return [3, 13];
            case "TensorArraySplitV3":
              return [3, 14];
            case "TensorArraySizeV3":
              return [3, 15];
            case "TensorArrayCloseV3":
              return [3, 16];
          }
          return [3, 17];
        case 1:
          return [2, [getParamValue("pred", e2, t2, a2).clone()]];
        case 2:
          return r2 = getParamValue("pred", e2, t2, a2), n2 = getParamValue("data", e2, t2, a2), [4, r2.data()];
        case 3:
          return [2, F2.sent()[0] ? [void 0, n2.clone()] : [n2.clone(), void 0]];
        case 4:
          return [2, (s2 = e2.inputNames.find(function(e3) {
            return void 0 !== getTensor(e3, t2, a2);
          })) ? [getTensor(s2, t2, a2).clone()] : void 0];
        case 5:
          return o2 = getParamValue("frameName", e2, t2, a2), p2 = getParamValue("tensor", e2, t2, a2), a2.enterFrame(o2), [2, [p2.clone()]];
        case 6:
          return u2 = getParamValue("tensor", e2, t2, a2), a2.exitFrame(), [2, [u2.clone()]];
        case 7:
          return i2 = getParamValue("tensor", e2, t2, a2), a2.nextIteration(), [2, [i2.clone()]];
        case 8:
          return m2 = getParamValue("size", e2, t2, a2), l2 = getParamValue("dtype", e2, t2, a2), c2 = getParamValue("elementShape", e2, t2, a2), d2 = getParamValue("dynamicSize", e2, t2, a2), y2 = getParamValue("clearAfterRead", e2, t2, a2), f2 = getParamValue("identicalElementShapes", e2, t2, a2), g2 = getParamValue("name", e2, t2, a2), h2 = new TensorArray(g2, l2, m2, c2, f2, d2, y2), a2.addTensorArray(h2), [2, [An(h2.id), An(1)]];
        case 9:
          return N2 = getParamValue("tensorArrayId", e2, t2, a2), x2 = getParamValue("index", e2, t2, a2), V2 = getParamValue("tensor", e2, t2, a2), a2.getTensorArray(N2).write(x2, V2), [2, [An(1)]];
        case 10:
          return P2 = getParamValue("tensorArrayId", e2, t2, a2), b2 = getParamValue("index", e2, t2, a2), [2, [a2.getTensorArray(P2).read(b2)]];
        case 11:
          return T2 = getParamValue("tensorArrayId", e2, t2, a2), O2 = getParamValue("indices", e2, t2, a2), v2 = getParamValue("dtype", e2, t2, a2), [2, [a2.getTensorArray(T2).gather(O2, v2)]];
        case 12:
          return S2 = getParamValue("tensorArrayId", e2, t2, a2), _2 = getParamValue("indices", e2, t2, a2), w2 = getParamValue("tensor", e2, t2, a2), a2.getTensorArray(S2).scatter(_2, w2), [2, [An(1)]];
        case 13:
          return A2 = getParamValue("tensorArrayId", e2, t2, a2), D2 = a2.getTensorArray(A2), E2 = getParamValue("dtype", e2, t2, a2), [2, [D2.concat(E2)]];
        case 14:
          return I2 = getParamValue("tensorArrayId", e2, t2, a2), C2 = getParamValue("tensor", e2, t2, a2), M2 = getParamValue("lengths", e2, t2, a2), a2.getTensorArray(I2).split(M2, C2), [2, [An(1)]];
        case 15:
          return k2 = getParamValue("tensorArrayId", e2, t2, a2), z2 = a2.getTensorArray(k2), [2, [An(z2.size(), "int32")]];
        case 16:
          return j2 = getParamValue("tensorArrayId", e2, t2, a2), a2.getTensorArray(j2).clearAndClose(), [2, [An(0)]];
        case 17:
          throw TypeError("Node type " + e2.op + " is not implemented");
      }
    });
  });
}
var executeOp$3 = function(e2, t2, a2) {
  var r2, n2;
  switch (e2.op) {
    case "Conv1D":
      var s2 = getParamValue("stride", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2), p2 = getParamValue("dataFormat", e2, t2, a2).toUpperCase(), u2 = getParamValue("dilation", e2, t2, a2);
      return [Dc(getParamValue("x", e2, t2, a2), getParamValue("filter", e2, t2, a2), s2, o2, p2, u2)];
    case "Conv2D":
      s2 = getParamValue("strides", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2), p2 = getParamValue("dataFormat", e2, t2, a2).toUpperCase();
      var i2 = getParamValue("dilations", e2, t2, a2);
      return [Tc(getParamValue("x", e2, t2, a2), getParamValue("filter", e2, t2, a2), [s2[1], s2[2]], o2, p2, [i2[1], i2[2]])];
    case "_FusedConv2D":
      var m2 = (r2 = getParamValue("fusedOps", e2, t2, a2))[0], l2 = r2[1], c2 = "biasadd" === m2, d2 = "prelu" === l2, y2 = "fusedbatchnorm" === m2, f2 = getParamValue("numArgs", e2, t2, a2);
      if (c2) {
        if (d2 && 2 !== f2)
          throw new Error("Fused Conv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
        if (!d2 && 1 !== f2)
          throw new Error("Fused Conv2d with BiasAdd must have one extra argument: bias.");
      }
      if (y2)
        throw new Error("Fused Conv2d with FusedBatchNorm is not supported.");
      s2 = getParamValue("strides", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2), p2 = getParamValue("dataFormat", e2, t2, a2).toUpperCase(), i2 = getParamValue("dilations", e2, t2, a2);
      var g2 = (n2 = getParamValue("args", e2, t2, a2))[0], h2 = n2[1];
      return [Rh.conv2d({x: getParamValue("x", e2, t2, a2), filter: getParamValue("filter", e2, t2, a2), strides: [s2[1], s2[2]], pad: o2, dataFormat: p2, dilations: [i2[1], i2[2]], bias: g2, activation: l2, preluActivationWeights: h2})];
    case "Conv2DBackpropInput":
    case "Conv2dTranspose":
      var N2 = getParamValue("outputShape", e2, t2, a2);
      s2 = getParamValue("strides", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2);
      return [Lc(getParamValue("x", e2, t2, a2), getParamValue("filter", e2, t2, a2), N2, [s2[1], s2[2]], o2)];
    case "DepthwiseConv2dNative":
    case "DepthwiseConv2d":
      s2 = getParamValue("strides", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2), i2 = getParamValue("dilations", e2, t2, a2), p2 = getParamValue("dataFormat", e2, t2, a2).toUpperCase();
      return [_c(getParamValue("input", e2, t2, a2), getParamValue("filter", e2, t2, a2), [s2[1], s2[2]], o2, p2, [i2[1], i2[2]])];
    case "Conv3D":
      s2 = getParamValue("strides", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2), p2 = getParamValue("dataFormat", e2, t2, a2).toUpperCase(), i2 = getParamValue("dilations", e2, t2, a2);
      return [Nc(getParamValue("x", e2, t2, a2), getParamValue("filter", e2, t2, a2), [s2[1], s2[2], s2[3]], o2, p2, [i2[1], i2[2], i2[3]])];
    case "AvgPool":
      s2 = getParamValue("strides", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2);
      var x2 = getParamValue("kernelSize", e2, t2, a2);
      return [Qc(getParamValue("x", e2, t2, a2), [x2[1], x2[2]], [s2[1], s2[2]], o2)];
    case "MaxPool":
      s2 = getParamValue("strides", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2), x2 = getParamValue("kernelSize", e2, t2, a2);
      return [Yc(getParamValue("x", e2, t2, a2), [x2[1], x2[2]], [s2[1], s2[2]], o2)];
    case "AvgPool3D":
      s2 = getParamValue("strides", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2), x2 = getParamValue("kernelSize", e2, t2, a2);
      return [tl(getParamValue("x", e2, t2, a2), [x2[1], x2[2], x2[3]], [s2[1], s2[2], s2[3]], o2)];
    case "MaxPool3D":
      s2 = getParamValue("strides", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2), x2 = getParamValue("kernelSize", e2, t2, a2);
      return [Zc(getParamValue("x", e2, t2, a2), [x2[1], x2[2], x2[3]], [s2[1], s2[2], s2[3]], o2)];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$4 = function(e2, t2, a2) {
  switch (e2.op) {
    case "Fill":
      var r2 = getParamValue("shape", e2, t2, a2), n2 = getParamValue("dtype", e2, t2, a2), s2 = getParamValue("value", e2, t2, a2);
      return [Ln(r2, s2, n2)];
    case "LinSpace":
      var o2 = getParamValue("start", e2, t2, a2), p2 = getParamValue("stop", e2, t2, a2), u2 = getParamValue("num", e2, t2, a2);
      return [Wn(o2, p2, u2)];
    case "Multinomial":
      var i2 = getParamValue("logits", e2, t2, a2), m2 = getParamValue("numSamples", e2, t2, a2), l2 = getParamValue("seed", e2, t2, a2);
      return [mr(i2, m2, l2)];
    case "OneHot":
      var c2 = getParamValue("indices", e2, t2, a2), d2 = getParamValue("depth", e2, t2, a2), y2 = getParamValue("onValue", e2, t2, a2), f2 = getParamValue("offValue", e2, t2, a2);
      return [gr(c2, d2, y2, f2)];
    case "Ones":
      return [Bn(getParamValue("shape", e2, t2, a2), getParamValue("dtype", e2, t2, a2))];
    case "OnesLike":
      return [Vn(getParamValue("x", e2, t2, a2))];
    case "RandomUniform":
      return [kr(getParamValue("shape", e2, t2, a2), getParamValue("minval", e2, t2, a2), getParamValue("maxval", e2, t2, a2), getParamValue("dtype", e2, t2, a2))];
    case "Range":
      o2 = getParamValue("start", e2, t2, a2);
      var g2 = getParamValue("stop", e2, t2, a2), h2 = getParamValue("step", e2, t2, a2);
      return [Un(o2, g2, h2, getParamValue("dtype", e2, t2, a2))];
    case "TruncatedNormal":
      r2 = getParamValue("shape", e2, t2, a2);
      var N2 = getParamValue("mean", e2, t2, a2), x2 = getParamValue("stdDev", e2, t2, a2);
      l2 = getParamValue("seed", e2, t2, a2);
      return [Fr(r2, N2, x2, getParamValue("dtype", e2, t2, a2), l2)];
    case "Zeros":
      return [Pn(getParamValue("shape", e2, t2, a2), getParamValue("dtype", e2, t2, a2))];
    case "ZerosLike":
      return [zn(getParamValue("x", e2, t2, a2))];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
function executeOp$5(e2, t2, a2) {
  return __awaiter2(this, void 0, void 0, function() {
    var r2, n2, s2, o2, p2;
    return __generator2(this, function(u2) {
      switch (u2.label) {
        case 0:
          switch (e2.op) {
            case "NonMaxSuppressionV3":
            case "NonMaxSuppressionV2":
              return [3, 1];
            case "Where":
              return [3, 3];
            case "ListDiff":
              return [3, 5];
          }
          return [3, 6];
        case 1:
          return r2 = getParamValue("boxes", e2, t2, a2), n2 = getParamValue("scores", e2, t2, a2), s2 = getParamValue("maxOutputSize", e2, t2, a2), o2 = getParamValue("iouThreshold", e2, t2, a2), p2 = getParamValue("scoreThreshold", e2, t2, a2), [4, mh.nonMaxSuppressionAsync(r2, n2, s2, o2, p2)];
        case 2:
          return [2, [u2.sent()]];
        case 3:
          return [4, Us(getParamValue("condition", e2, t2, a2).asType("bool"))];
        case 4:
          return [2, [u2.sent()]];
        case 5:
          return [2, _r(getParamValue("x", e2, t2, a2), getParamValue("y", e2, t2, a2))];
        case 6:
          throw TypeError("Node type " + e2.op + " is not implemented");
      }
    });
  });
}
var executeOp$6 = function(e2, t2, a2) {
  switch (e2.op) {
    case "TopKV2":
      var r2 = getParamValue("x", e2, t2, a2), n2 = getParamValue("k", e2, t2, a2), s2 = getParamValue("sorted", e2, t2, a2), o2 = Nl(r2, n2, s2);
      return [o2.values, o2.indices];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$7 = function(e2, t2, a2) {
  switch (e2.op) {
    case "Const":
      return t2[e2.name];
    case "PlaceholderWithDefault":
      var r2 = getParamValue("default", e2, t2, a2);
      return [getTensor(e2.name, t2, a2) || r2];
    case "Placeholder":
      return [getTensor(e2.name, t2, a2)];
    case "Identity":
    case "StopGradient":
    case "FakeQuantWithMinMaxVars":
      return [getParamValue("x", e2, t2, a2).clone()];
    case "IdentityN":
      return getParamValue("x", e2, t2, a2).map(function(e3) {
        return e3.clone();
      });
    case "Snapshot":
      return [getParamValue("x", e2, t2, a2).clone()];
    case "Shape":
      return [Dn(getParamValue("x", e2, t2, a2).shape, "int32")];
    case "ShapeN":
      return getParamValue("x", e2, t2, a2).map(function(e3) {
        return Dn(e3.shape);
      });
    case "Size":
      return [An(getParamValue("x", e2, t2, a2).size, "int32")];
    case "Rank":
      return [An(getParamValue("x", e2, t2, a2).rank, "int32")];
    case "NoOp":
      return [An(1)];
    case "Print":
      var n2 = getParamValue("x", e2, t2, a2), s2 = getParamValue("data", e2, t2, a2), o2 = getParamValue("message", e2, t2, a2), p2 = getParamValue("summarize", e2, t2, a2);
      console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(o2);
      for (var u2 = 0; u2 < s2.length; u2++)
        console.log(Array.prototype.slice.call(s2[u2].dataSync()).slice(0, p2));
      return [n2];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$8 = function(e2, t2, a2) {
  switch (e2.op) {
    case "ResizeBilinear":
      var r2 = getParamValue("images", e2, t2, a2), n2 = getParamValue("size", e2, t2, a2), s2 = getParamValue("alignCorners", e2, t2, a2);
      return [mh.resizeBilinear(r2, [n2[0], n2[1]], s2)];
    case "ResizeNearestNeighbor":
      r2 = getParamValue("images", e2, t2, a2), n2 = getParamValue("size", e2, t2, a2), s2 = getParamValue("alignCorners", e2, t2, a2);
      return [mh.resizeNearestNeighbor(r2, [n2[0], n2[1]], s2)];
    case "CropAndResize":
      var o2 = getParamValue("image", e2, t2, a2), p2 = getParamValue("boxes", e2, t2, a2), u2 = getParamValue("boxInd", e2, t2, a2), i2 = getParamValue("cropSize", e2, t2, a2), m2 = getParamValue("method", e2, t2, a2), l2 = getParamValue("extrapolationValue", e2, t2, a2);
      return [mh.cropAndResize(o2, p2, u2, i2, m2, l2)];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$9 = function(e2, t2, a2) {
  switch (e2.op) {
    case "Equal":
      return [cc(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "NotEqual":
      return [xc(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "Greater":
      return [hc(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "GreaterEqual":
      return [fc(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "Less":
      return [vc(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "LessEqual":
      return [mc(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "LogicalAnd":
      return [Ms(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "LogicalNot":
      return [Bs(getParamValue("a", e2, t2, a2))];
    case "LogicalOr":
      return [Ps(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "Select":
      return [Ws(getParamValue("condition", e2, t2, a2), getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$10 = function(e2, t2, a2) {
  switch (e2.op) {
    case "BatchMatMul":
    case "BatchMatMulV2":
    case "MatMul":
      return [Uc(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2), getParamValue("transposeA", e2, t2, a2), getParamValue("transposeB", e2, t2, a2))];
    case "Transpose":
      return [Rl(getParamValue("x", e2, t2, a2), getParamValue("perm", e2, t2, a2))];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$11 = function(e2, t2, a2) {
  switch (e2.op) {
    case "FusedBatchNorm":
    case "FusedBatchNormV2":
    case "FusedBatchNormV3":
      return [Ns(getParamValue("x", e2, t2, a2), getParamValue("mean", e2, t2, a2), getParamValue("variance", e2, t2, a2), getParamValue("offset", e2, t2, a2), getParamValue("scale", e2, t2, a2), getParamValue("epsilon", e2, t2, a2))];
    case "LRN":
      return [Il(getParamValue("x", e2, t2, a2), getParamValue("radius", e2, t2, a2), getParamValue("bias", e2, t2, a2), getParamValue("alpha", e2, t2, a2), getParamValue("beta", e2, t2, a2))];
    case "Softmax":
      return [io(getParamValue("x", e2, t2, a2))];
    case "LogSoftmax":
      return [uo(getParamValue("x", e2, t2, a2))];
    case "SparseToDense":
      return [Ll(getParamValue("sparseIndices", e2, t2, a2), getParamValue("outputShape", e2, t2, a2), getParamValue("sparseValues", e2, t2, a2), getParamValue("defaultValue", e2, t2, a2))];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$12 = function(e2, t2, a2) {
  switch (e2.op) {
    case "Max":
      var r2 = getParamValue("axis", e2, t2, a2), n2 = getParamValue("keepDims", e2, t2, a2);
      return [fl(getParamValue("x", e2, t2, a2), r2, n2)];
    case "Mean":
      r2 = getParamValue("axis", e2, t2, a2), n2 = getParamValue("keepDims", e2, t2, a2);
      return [pl(getParamValue("x", e2, t2, a2), r2, n2)];
    case "Min":
      r2 = getParamValue("axis", e2, t2, a2), n2 = getParamValue("keepDims", e2, t2, a2);
      return [dl(getParamValue("x", e2, t2, a2), r2, n2)];
    case "Sum":
      r2 = getParamValue("axis", e2, t2, a2), n2 = getParamValue("keepDims", e2, t2, a2);
      return [ml(getParamValue("x", e2, t2, a2), r2, n2)];
    case "All":
      r2 = getParamValue("axis", e2, t2, a2), n2 = getParamValue("keepDims", e2, t2, a2);
      return [ul(getParamValue("x", e2, t2, a2), r2, n2)];
    case "Any":
      r2 = getParamValue("axis", e2, t2, a2), n2 = getParamValue("keepDims", e2, t2, a2);
      return [sl(getParamValue("x", e2, t2, a2), r2, n2)];
    case "ArgMax":
      r2 = getParamValue("axis", e2, t2, a2);
      return [cl(getParamValue("x", e2, t2, a2), r2)];
    case "ArgMin":
      r2 = getParamValue("axis", e2, t2, a2);
      return [ll(getParamValue("x", e2, t2, a2), r2)];
    case "Prod":
      r2 = getParamValue("axis", e2, t2, a2), n2 = getParamValue("keepDims", e2, t2, a2);
      return [gl(getParamValue("x", e2, t2, a2), r2, n2)];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$13 = function(e2, t2, a2) {
  switch (e2.op) {
    case "ConcatV2":
    case "Concat":
      var r2 = getParamValue("n", e2, t2, a2), n2 = getParamValue("axis", e2, t2, a2), s2 = getParamValue("tensors", e2, t2, a2);
      return s2 = s2.slice(0, r2), [Gn(s2, n2)];
    case "GatherV2":
    case "Gather":
      n2 = getParamValue("axis", e2, t2, a2);
      var o2 = getParamValue("x", e2, t2, a2), p2 = getParamValue("indices", e2, t2, a2);
      return [Ec(o2, p2.asType("int32"), n2)];
    case "ReverseV2":
    case "Reverse":
      n2 = getParamValue("axis", e2, t2, a2), o2 = getParamValue("x", e2, t2, a2);
      return [Gc(o2, n2)];
    case "Slice":
      var u2 = getParamValue("begin", e2, t2, a2), i2 = getParamValue("size", e2, t2, a2);
      return [el(getParamValue("x", e2, t2, a2), u2, i2)];
    case "StridedSlice":
      u2 = getParamValue("begin", e2, t2, a2);
      var m2 = getParamValue("end", e2, t2, a2), l2 = getParamValue("strides", e2, t2, a2), c2 = getParamValue("beginMask", e2, t2, a2), d2 = getParamValue("endMask", e2, t2, a2), y2 = getParamValue("ellipsisMask", e2, t2, a2), f2 = getParamValue("newAxisMask", e2, t2, a2), g2 = getParamValue("shrinkAxisMask", e2, t2, a2), h2 = getParamValue("x", e2, t2, a2);
      if (1 === u2.length && h2.shape.length > 1)
        for (var N2 = 1; N2 < h2.shape.length; N2++)
          u2.push(0), m2.push(h2.shape[N2]), l2.push(l2[0]);
      return [Tl(h2, u2, m2, l2, c2, d2, y2, f2, g2)];
    case "Pack":
      return je(function() {
        var r3 = getParamValue("axis", e2, t2, a2), n3 = getParamValue("tensors", e2, t2, a2), s3 = n3[0].shape, o3 = n3[0].squeeze().shape, p3 = n3.map(function(e3) {
          var t3 = tt.arraysEqual(e3.shape, s3);
          if (!t3 && !tt.arraysEqual(e3.squeeze().shape, o3))
            throw new Error("the input tensors shape does not match");
          return t3 ? e3 : e3.reshape(s3);
        });
        return [Tr(p3, r3)];
      });
    case "Unpack":
      return je(function() {
        var r3 = getParamValue("axis", e2, t2, a2), n3 = getParamValue("tensor", e2, t2, a2);
        return Or(n3, r3);
      });
    case "Tile":
      var x2 = getParamValue("reps", e2, t2, a2);
      return [Nr(getParamValue("x", e2, t2, a2), x2)];
    case "Split":
    case "SplitV":
      n2 = getParamValue("axis", e2, t2, a2);
      var V2 = getParamValue("numOrSizeSplits", e2, t2, a2);
      return Xn(getParamValue("x", e2, t2, a2), V2, n2);
    case "ScatterNd":
      p2 = getParamValue("indices", e2, t2, a2);
      var P2 = getParamValue("values", e2, t2, a2), b2 = getParamValue("shape", e2, t2, a2);
      return [Fl(p2, P2, b2)];
    case "GatherNd":
      var T2 = getParamValue("x", e2, t2, a2);
      p2 = getParamValue("indices", e2, t2, a2);
      return [Wl(T2, p2)];
    case "SparseToDense":
      p2 = getParamValue("sparseIndices", e2, t2, a2), b2 = getParamValue("outputShape", e2, t2, a2);
      var O2 = getParamValue("sparseValues", e2, t2, a2), v2 = getParamValue("defaultValue", e2, t2, a2);
      return [Ll(p2, O2, b2, O2.dtype === v2.dtype ? v2 : v2.asType(O2.dtype))];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$14 = function(e2, t2, a2) {
  switch (e2.op) {
    case "FFT":
      return [Ol(getParamValue("x", e2, t2, a2))];
    case "IFFT":
      return [_l(getParamValue("x", e2, t2, a2))];
    case "RFFT":
      return [Ml(getParamValue("x", e2, t2, a2))];
    case "IRFFT":
      return [Bl(getParamValue("x", e2, t2, a2))];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$15 = function(e2, t2, a2) {
  switch (e2.op) {
    case "Cast":
      return [lr(getParamValue("x", e2, t2, a2), getParamValue("dtype", e2, t2, a2))];
    case "ExpandDims":
      var r2 = getParamValue("axis", e2, t2, a2);
      return [dr(getParamValue("x", e2, t2, a2), r2)];
    case "Squeeze":
      r2 = getParamValue("axis", e2, t2, a2);
      return [Dr(getParamValue("x", e2, t2, a2), r2)];
    case "Reshape":
      return [Sr(getParamValue("x", e2, t2, a2), getParamValue("shape", e2, t2, a2))];
    case "PadV2":
    case "Pad":
      return [yr(getParamValue("x", e2, t2, a2), split$1(getParamValue("padding", e2, t2, a2), 2), getParamValue("constantValue", e2, t2, a2))];
    case "SpaceToBatchND":
      var n2 = getParamValue("blockShape", e2, t2, a2), s2 = split$1(getParamValue("paddings", e2, t2, a2), 2);
      return [Ar(getParamValue("x", e2, t2, a2), n2, s2)];
    case "BatchToSpaceND":
      n2 = getParamValue("blockShape", e2, t2, a2);
      var o2 = split$1(getParamValue("crops", e2, t2, a2), 2);
      return [cr(getParamValue("x", e2, t2, a2), n2, o2)];
    case "DepthToSpace":
      var p2 = getParamValue("blockSize", e2, t2, a2), u2 = getParamValue("dataFormat", e2, t2, a2).toUpperCase();
      return [pr(getParamValue("x", e2, t2, a2), p2, u2)];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
function executeOp$16(e2, t2, a2) {
  var r2 = function(e3, t3, a3) {
    switch (e3.category) {
      case "arithmetic":
        return executeOp(e3, t3, a3);
      case "basic_math":
        return executeOp$1(e3, t3, a3);
      case "control":
        return executeOp$2(e3, t3, a3);
      case "convolution":
        return executeOp$3(e3, t3, a3);
      case "creation":
        return executeOp$4(e3, t3, a3);
      case "dynamic":
        return executeOp$5(e3, t3, a3);
      case "evaluation":
        return executeOp$6(e3, t3, a3);
      case "image":
        return executeOp$8(e3, t3, a3);
      case "graph":
        return executeOp$7(e3, t3, a3);
      case "logical":
        return executeOp$9(e3, t3, a3);
      case "matrices":
        return executeOp$10(e3, t3, a3);
      case "normalization":
        return executeOp$11(e3, t3, a3);
      case "reduction":
        return executeOp$12(e3, t3, a3);
      case "slice_join":
        return executeOp$13(e3, t3, a3);
      case "spectral":
        return executeOp$14(e3, t3, a3);
      case "transformation":
        return executeOp$15(e3, t3, a3);
      case "custom":
        var r3 = getRegisteredOp(e3.op);
        if (r3 && r3.customExecutor)
          return r3.customExecutor(new NodeValueImpl(e3, t3, a3));
        throw TypeError("Custom op " + e3.op + " is not registered.");
      default:
        throw TypeError("Unknown op '" + e3.op + "'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()");
    }
  }(e2, t2, a2);
  return r2 instanceof Promise ? r2.then(function(e3) {
    return [].concat(e3);
  }) : [].concat(r2);
}
var ExecutionContext = function() {
  function e2(e3, t2) {
    this.weightMap = e3, this.tensorArrayMap = t2, this.rootContext = {id: 0, frameName: "", iterationId: 0}, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds();
  }
  return e2.prototype.newFrame = function(e3, t2) {
    return {id: e3, frameName: t2, iterationId: 0};
  }, Object.defineProperty(e2.prototype, "currentContext", {get: function() {
    return this.contexts;
  }, set: function(e3) {
    this.contexts !== e3 && (this.contexts = e3, this.generateCurrentContextIds());
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "currentContextId", {get: function() {
    return this._currentContextIds[0];
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "currentContextIds", {get: function() {
    return this._currentContextIds;
  }, enumerable: true, configurable: true}), e2.prototype.generateCurrentContextIds = function() {
    for (var e3 = [], t2 = 0; t2 < this.contexts.length - 1; t2++) {
      var a2 = this.contexts.slice(0, this.contexts.length - t2);
      e3.push(this.contextIdforContexts(a2));
    }
    e3.push(""), this._currentContextIds = e3;
  }, e2.prototype.contextIdforContexts = function(e3) {
    return e3 ? e3.map(function(e4) {
      return 0 === e4.id && 0 === e4.iterationId ? "" : e4.frameName + "-" + e4.iterationId;
    }).join("/") : "";
  }, e2.prototype.enterFrame = function(e3) {
    this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, e3)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)));
  }, e2.prototype.exitFrame = function() {
    if (!(this.contexts && this.contexts.length > 1))
      throw new Error("Cannot exit frame, the context is empty");
    this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift();
  }, e2.prototype.nextIteration = function() {
    if (!(this.contexts && this.contexts.length > 0))
      throw new Error("Cannot increase frame iteration, the context is empty");
    this.contexts = this.contexts.slice(), this.lastId++;
    var e3 = Object.assign({}, this.contexts[this.contexts.length - 1]);
    e3.iterationId += 1, e3.id = this.lastId, this.contexts.splice(-1, 1, e3), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
  }, e2.prototype.getWeight = function(e3) {
    return this.weightMap[e3];
  }, e2.prototype.addTensorArray = function(e3) {
    this.tensorArrayMap[e3.id] = e3;
  }, e2.prototype.getTensorArray = function(e3) {
    return this.tensorArrayMap[e3];
  }, e2;
}();
function getExecutionSubgraph(e2, t2, a2) {
  for (var r2 = new Set(), n2 = [], s2 = null, o2 = null, p2 = new Set(), u2 = t2.slice(); u2.length > 0; ) {
    var i2 = u2.pop();
    (isControlFlow(i2) || isDynamicShape(i2)) && null == s2 && (o2 = (s2 = i2).children.map(function(e3) {
      return e3.name;
    }).filter(function(e3) {
      return r2.has(e3);
    })), r2.add(i2.name), null == a2[i2.name] && (null == e2[i2.name] && (0 !== i2.inputs.length ? i2.inputs.forEach(function(e3) {
      p2.has(e3.name) || (p2.add(e3.name), u2.push(e3));
    }) : n2.push(i2.name)));
  }
  return {inputs: e2, outputs: t2, usedNodes: r2, missingInputs: n2, dynamicNode: s2, syncInputs: o2};
}
function getNodesInTopologicalOrder(e2, t2, a2) {
  var r2 = a2.usedNodes, n2 = a2.inputs, s2 = [];
  Object.keys(n2).map(function(t3) {
    return e2.nodes[t3];
  }).forEach(function(e3) {
    r2.has(e3.name) && s2.push(e3);
  }), e2.weights.forEach(function(e3) {
    r2.has(e3.name) && s2.push(e3);
  });
  for (var o2 = new Set(), p2 = []; s2.length > 0; ) {
    var u2 = s2.pop();
    o2.add(u2.name), t2[u2.name] || p2.push(u2), u2.children.forEach(function(e3) {
      !o2.has(e3.name) && r2.has(e3.name) && e3.inputs.every(function(e4) {
        return o2.has(e4.name);
      }) && s2.push(e3);
    });
  }
  return p2;
}
var CONTROL_FLOW_OPS = ["Switch", "Merge", "Enter", "Exit", "NextIteration"];
var DYNAMIC_SHAPE_OPS = ["NonMaxSuppressionV2", "NonMaxSuppressionV3", "Where"];
function isControlFlow(e2) {
  return CONTROL_FLOW_OPS.indexOf(e2.op) >= 0;
}
function isDynamicShape(e2) {
  return DYNAMIC_SHAPE_OPS.indexOf(e2.op) >= 0;
}
var GraphExecutor = function() {
  function e2(e3) {
    this.graph = e3, this.compiledMap = new Map(), this._weightMap = {}, this.SEPERATOR = ",", this.placeholders = e3.placeholders, this._outputs = e3.outputs;
  }
  return Object.defineProperty(e2.prototype, "weightMap", {get: function() {
    return this._weightMap;
  }, set: function(e3) {
    var t2 = Object.keys(e3).map(function(t3) {
      return e3[t3].map(function(e4) {
        return e4.id;
      });
    });
    this.weightIds = [].concat.apply([], t2), this._weightMap = e3;
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "inputs", {get: function() {
    return this.placeholders.map(function(e3) {
      return {name: e3.name, shape: e3.attrParams.shape ? e3.attrParams.shape.value : void 0, dtype: e3.attrParams.dtype ? e3.attrParams.dtype.value : void 0};
    });
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "outputs", {get: function() {
    return this._outputs.map(function(e3) {
      return {name: e3.name, shape: e3.attrParams.shape ? e3.attrParams.shape.value : void 0, dtype: e3.attrParams.dtype ? e3.attrParams.dtype.value : void 0};
    });
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "inputNodes", {get: function() {
    return this.placeholders.map(function(e3) {
      return e3.name;
    });
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "outputNodes", {get: function() {
    return this.outputs.map(function(e3) {
      return e3.name;
    });
  }, enumerable: true, configurable: true}), e2.prototype.getCompilationKey = function(e3, t2) {
    var a2 = e3.map(function(e4) {
      return e4.name;
    }).sort(), r2 = t2.map(function(e4) {
      return e4.name;
    }).sort();
    return a2.join(this.SEPERATOR) + "--" + r2.join(this.SEPERATOR);
  }, e2.prototype.compile = function(e3, t2) {
    var a2 = getExecutionSubgraph(e3, t2, this.weightMap), r2 = a2.missingInputs, n2 = a2.dynamicNode, s2 = a2.syncInputs;
    if (null != n2)
      throw new Error("This execution contains the node '" + n2.name + "', which has the dynamic op '" + n2.op + "'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [" + s2 + "]");
    if (r2.length > 0) {
      var o2 = t2.map(function(e4) {
        return e4.name;
      }), p2 = Object.keys(e3);
      throw new Error("Cannot compute the outputs [" + o2 + "] from the provided inputs [" + p2 + "]. Missing the following inputs: [" + r2 + "]");
    }
    return getNodesInTopologicalOrder(this.graph, this.weightMap, a2);
  }, e2.prototype.execute = function(e3, t2) {
    var a2 = this, r2 = Object.keys(e3).sort();
    this.checkInputs(e3), this.checkInputShapeAndType(e3), this.checkOutputs(t2);
    var n2 = r2.map(function(e4) {
      return a2.graph.nodes[e4];
    }), s2 = t2.map(function(e4) {
      return a2.graph.nodes[parseNodeName(e4)[0]];
    }), o2 = this.getCompilationKey(n2, s2), p2 = this.compiledMap.get(o2);
    null == p2 && (p2 = this.compile(e3, s2), this.compiledMap.set(o2, p2));
    var u2 = {};
    return je(function() {
      var r3 = new ExecutionContext(a2._weightMap, u2), n3 = __assign2({}, a2.weightMap);
      Object.keys(e3).forEach(function(t3) {
        n3[t3] = [e3[t3]];
      });
      for (var s3 = a2.getFrozenTensorIds(n3), o3 = {}, i2 = 0; i2 < p2.length; i2++) {
        var m2 = p2[i2];
        if (!n3[m2.name]) {
          var l2 = executeOp$16(m2, n3, r3);
          if (l2 instanceof Promise)
            throw new Error("The execution of the op '" + m2.op + "' returned a promise. Please use model.executeAsync() instead.");
          n3[m2.name] = l2, a2.checkTensorForDisposal(m2.name, m2, n3, r3, s3, t2, o3);
        }
      }
      return t2.map(function(e4) {
        return getTensor(e4, n3, r3);
      });
    });
  }, e2.prototype.getFrozenTensorIds = function(e3) {
    var t2 = [].concat.apply([], Object.keys(e3).map(function(t3) {
      return e3[t3];
    }).map(function(e4) {
      return e4.map(function(e5) {
        return e5.id;
      });
    }));
    return new Set(t2);
  }, e2.prototype.checkTensorForDisposal = function(e3, t2, a2, r2, n2, s2, o2) {
    "control" !== t2.category && -1 === s2.indexOf(e3) && (a2[e3].forEach(function(e4) {
      null != e4 && (o2[e4.id] = (o2[e4.id] || 0) + t2.children.length);
    }), t2.inputs.forEach(function(e4) {
      if ("control" !== e4.category) {
        var t3 = getTensorsForCurrentContenxt(e4.name, a2, r2);
        null != t3 && t3.forEach(function(e5) {
          if (e5 && !n2.has(e5.id)) {
            var t4 = o2[e5.id];
            1 === t4 ? (e5.dispose(), delete o2[e5.id]) : null != t4 && o2[e5.id]--;
          }
        });
      }
    }));
  }, e2.prototype.executeAsync = function(e3, t2) {
    return __awaiter2(this, void 0, void 0, function() {
      var a2, r2, n2, s2, o2, p2, u2 = this;
      return __generator2(this, function(i2) {
        switch (i2.label) {
          case 0:
            return this.checkInputs(e3), this.checkInputShapeAndType(e3), this.checkOutputs(t2), a2 = {}, r2 = new ExecutionContext(this._weightMap, a2), [4, this.executeWithControlFlow(e3, r2, t2)];
          case 1:
            return n2 = i2.sent(), s2 = t2.map(function(e4) {
              return getTensor(e4, n2, r2);
            }), o2 = new Set(s2.map(function(e4) {
              return e4.id;
            })), p2 = new Set(Object.keys(e3).map(function(t3) {
              return e3[t3].id;
            })), Object.keys(n2).forEach(function(e4) {
              n2[e4].forEach(function(e5) {
                !e5 || e5.isDisposed || o2.has(e5.id) || p2.has(e5.id) || -1 !== u2.weightIds.indexOf(e5.id) || e5.dispose();
              });
            }), [2, s2];
        }
      });
    });
  }, e2.prototype.executeWithControlFlow = function(e3, t2, a2) {
    return __awaiter2(this, void 0, void 0, function() {
      var r2, n2, s2, o2, p2, u2, i2, m2, l2, c2, d2, y2, f2, g2, h2, N2, x2 = this;
      return __generator2(this, function(V2) {
        switch (V2.label) {
          case 0:
            r2 = Object.keys(e3), n2 = r2.map(function(e4) {
              return x2.graph.nodes[e4];
            }), s2 = a2.map(function(e4) {
              return x2.graph.nodes[parseNodeName(e4)[0]];
            }), o2 = getExecutionSubgraph(e3, s2, this.weightMap), p2 = o2.usedNodes, u2 = o2.missingInputs, i2 = o2.dynamicNode, m2 = o2.syncInputs, l2 = n2.concat(this.graph.weights).map(function(e4) {
              return {node: e4, contexts: t2.currentContext};
            }), c2 = __assign2({}, this.weightMap), Object.keys(e3).forEach(function(t3) {
              c2[t3] = [e3[t3]];
            }), d2 = {}, y2 = this.getFrozenTensorIds(c2), f2 = {}, V2.label = 1;
          case 1:
            return l2.length > 0 ? (g2 = this.processStack(n2, l2, t2, c2, f2, y2, a2, d2, p2), [4, Promise.all(g2)]) : [3, 3];
          case 2:
            return V2.sent(), [3, 1];
          case 3:
            if (null == i2 && console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead."), (h2 = s2.filter(function(e4) {
              return !isControlFlow(e4) && !getTensor(e4.name, c2, t2);
            }).map(function(e4) {
              return e4.name;
            })).length > 0)
              throw N2 = "", null != i2 && (N2 = "Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [" + m2 + "]"), new Error("Cannot compute the outputs [" + h2 + "] from the provided inputs [" + r2 + "]. Consider providing the following inputs: [" + u2 + "]. " + N2);
            return [2, c2];
        }
      });
    });
  }, e2.prototype.processStack = function(e3, t2, a2, r2, n2, s2, o2, p2, u2) {
    for (var i2 = this, m2 = [], l2 = function() {
      var l3 = t2.pop();
      a2.currentContext = l3.contexts;
      var d2 = "";
      if ("Enter" === l3.node.op && getParamValue("isConstant", l3.node, r2, a2) && (d2 = getNodeNameAndIndex(l3.node.name, a2)[0]), -1 === e3.indexOf(l3.node)) {
        var y2 = executeOp$16(l3.node, r2, a2);
        d2 || (d2 = getNodeNameAndIndex(l3.node.name, a2)[0]);
        var f2 = a2.currentContext;
        y2 instanceof Promise ? m2.push(y2.then(function(e4) {
          return r2[d2] = e4, a2.currentContext = f2, i2.checkTensorForDisposal(d2, l3.node, r2, a2, s2, o2, p2), i2.processChildNodes(l3.node, t2, a2, r2, n2, u2), e4;
        })) : (r2[d2] = y2, c2.checkTensorForDisposal(d2, l3.node, r2, a2, s2, o2, p2), c2.processChildNodes(l3.node, t2, a2, r2, n2, u2));
      } else
        c2.processChildNodes(l3.node, t2, a2, r2, n2, u2);
    }, c2 = this; t2.length > 0; )
      l2();
    return m2;
  }, e2.prototype.processChildNodes = function(e3, t2, a2, r2, n2, s2) {
    e3.children.forEach(function(e4) {
      var o2 = getNodeNameAndIndex(e4.name, a2)[0];
      !n2[o2] && s2.has(e4.name) && ("Merge" === e4.op ? e4.inputNames.some(function(e5) {
        return !!getTensor(e5, r2, a2);
      }) && (n2[o2] = true, t2.push({contexts: a2.currentContext, node: e4})) : e4.inputNames.every(function(e5) {
        return !!getTensor(e5, r2, a2);
      }) && (n2[o2] = true, t2.push({contexts: a2.currentContext, node: e4})));
    });
  }, e2.prototype.dispose = function() {
    var e3 = this;
    Object.keys(this.weightMap).forEach(function(t2) {
      return e3.weightMap[t2].forEach(function(e4) {
        return e4.dispose();
      });
    });
  }, e2.prototype.checkInputShapeAndType = function(e3) {
    var t2 = this;
    Object.keys(e3).forEach(function(a2) {
      var r2 = e3[a2], n2 = t2.graph.nodes[a2];
      if (n2.attrParams.shape && n2.attrParams.shape.value) {
        var s2 = n2.attrParams.shape.value, o2 = s2.length === r2.shape.length && r2.shape.every(function(e4, t3) {
          return -1 === s2[t3] || s2[t3] === e4;
        });
        tt.assert(o2, function() {
          return "The shape of dict['" + n2.name + "'] provided in model.execute(dict) must be [" + s2 + "], but was [" + r2.shape + "]";
        });
      }
      n2.attrParams.dtype && n2.attrParams.dtype.value && tt.assert(r2.dtype === n2.attrParams.dtype.value, function() {
        return "The dtype of dict['" + n2.name + "'] provided in model.execute(dict) must be " + n2.attrParams.dtype.value + ", but was " + r2.dtype;
      });
    });
  }, e2.prototype.checkInputs = function(e3) {
    var t2 = this, a2 = Object.keys(e3).filter(function(e4) {
      return !t2.graph.nodes[e4];
    });
    if (a2.length > 0)
      throw new Error("The dict provided in model.execute(dict) has keys: [" + a2 + "] that are not part of graph");
  }, e2.prototype.checkOutputs = function(e3) {
    var t2 = this;
    e3.forEach(function(e4) {
      var a2 = parseNodeName(e4)[0];
      if (!t2.graph.nodes[a2])
        throw new Error("The output '" + e4 + "' is not found in the graph");
    });
  }, e2;
}();
var TFHUB_SEARCH_PARAM = "?tfjs-format=file";
var DEFAULT_MODEL_NAME = "model.json";
var GraphModel = function() {
  function e2(e3, t2) {
    void 0 === t2 && (t2 = {}), this.modelUrl = e3, this.loadOptions = t2, this.version = "n/a", null == t2 && (this.loadOptions = {});
  }
  return Object.defineProperty(e2.prototype, "modelVersion", {get: function() {
    return this.version;
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "inputNodes", {get: function() {
    return this.executor.inputNodes;
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "outputNodes", {get: function() {
    return this.executor.outputNodes;
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "inputs", {get: function() {
    return this.executor.inputs;
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "outputs", {get: function() {
    return this.executor.outputs;
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "weights", {get: function() {
    return this.executor.weightMap;
  }, enumerable: true, configurable: true}), e2.prototype.findIOHandler = function() {
    var e3 = this.modelUrl;
    if (null != e3.load)
      this.handler = e3;
    else if (null != this.loadOptions.requestInit)
      this.handler = Af.browserHTTPRequest(e3, this.loadOptions);
    else {
      var t2 = Af.getLoadHandlers(e3, this.loadOptions.onProgress);
      if (0 === t2.length)
        t2.push(Af.browserHTTPRequest(e3, this.loadOptions));
      else if (t2.length > 1)
        throw new Error("Found more than one (" + t2.length + ") load handlers for URL '" + [e3] + "'");
      this.handler = t2[0];
    }
  }, e2.prototype.load = function() {
    return __awaiter2(this, void 0, void 0, function() {
      var e3, t2, a2;
      return __generator2(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (this.findIOHandler(), null == this.handler.load)
              throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
            return [4, this.handler.load()];
          case 1:
            return e3 = r2.sent(), t2 = e3.modelTopology, this.version = t2.versions.producer + "." + t2.versions.minConsumer, a2 = Af.decodeWeights(e3.weightData, e3.weightSpecs), this.executor = new GraphExecutor(OperationMapper.Instance.transformGraph(t2)), this.executor.weightMap = this.convertTensorMapToTensorsMap(a2), [2, true];
        }
      });
    });
  }, e2.prototype.predict = function(e3, t2) {
    return this.execute(e3, this.outputNodes);
  }, e2.prototype.normalizeInputs = function(e3) {
    if (!(e3 instanceof dt || Array.isArray(e3)))
      return e3;
    if ((e3 = Array.isArray(e3) ? e3 : [e3]).length !== this.inputNodes.length)
      throw new Error("Input tensor count mismatch,the graph model has " + this.inputNodes.length + " placeholders, while there are " + e3.length + " input tensors.");
    return this.inputNodes.reduce(function(t2, a2, r2) {
      return t2[a2] = e3[r2], t2;
    }, {});
  }, e2.prototype.normalizeOutputs = function(e3) {
    return e3 = e3 || this.outputNodes, Array.isArray(e3) ? e3 : [e3];
  }, e2.prototype.execute = function(e3, t2) {
    e3 = this.normalizeInputs(e3), t2 = this.normalizeOutputs(t2);
    var a2 = this.executor.execute(e3, t2);
    return a2.length > 1 ? a2 : a2[0];
  }, e2.prototype.executeAsync = function(e3, t2) {
    return __awaiter2(this, void 0, void 0, function() {
      var a2;
      return __generator2(this, function(r2) {
        switch (r2.label) {
          case 0:
            return e3 = this.normalizeInputs(e3), t2 = this.normalizeOutputs(t2), [4, this.executor.executeAsync(e3, t2)];
          case 1:
            return [2, (a2 = r2.sent()).length > 1 ? a2 : a2[0]];
        }
      });
    });
  }, e2.prototype.convertTensorMapToTensorsMap = function(e3) {
    return Object.keys(e3).reduce(function(t2, a2) {
      return t2[a2] = [e3[a2]], t2;
    }, {});
  }, e2.prototype.dispose = function() {
    this.executor.dispose();
  }, e2;
}();
function loadGraphModel(e2, t2) {
  return void 0 === t2 && (t2 = {}), __awaiter2(this, void 0, void 0, function() {
    var a2;
    return __generator2(this, function(r2) {
      switch (r2.label) {
        case 0:
          if (null == e2)
            throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
          return null == t2 && (t2 = {}), t2.fromTFHub && null == e2.load && (e2.endsWith("/") || (e2 += "/"), e2 = "" + e2 + DEFAULT_MODEL_NAME + TFHUB_SEARCH_PARAM), [4, (a2 = new GraphModel(e2, t2)).load()];
        case 1:
          return r2.sent(), [2, a2];
      }
    });
  });
}

// node_modules/@tensorflow-models/posenet/dist/posenet.esm.js
var extendStatics = function(e2, t2) {
  return (extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(e3, t3) {
    e3.__proto__ = t3;
  } || function(e3, t3) {
    for (var n2 in t3)
      t3.hasOwnProperty(n2) && (e3[n2] = t3[n2]);
  })(e2, t2);
};
function __extends(e2, t2) {
  function n2() {
    this.constructor = e2;
  }
  extendStatics(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (n2.prototype = t2.prototype, new n2());
}
var __assign = function() {
  return (__assign = Object.assign || function(e2) {
    for (var t2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
      for (var o2 in t2 = arguments[n2])
        Object.prototype.hasOwnProperty.call(t2, o2) && (e2[o2] = t2[o2]);
    return e2;
  }).apply(this, arguments);
};
function __awaiter(e2, t2, n2, r2) {
  return new (n2 || (n2 = Promise))(function(o2, i2) {
    function s2(e3) {
      try {
        a2(r2.next(e3));
      } catch (e4) {
        i2(e4);
      }
    }
    function u2(e3) {
      try {
        a2(r2.throw(e3));
      } catch (e4) {
        i2(e4);
      }
    }
    function a2(e3) {
      e3.done ? o2(e3.value) : new n2(function(t3) {
        t3(e3.value);
      }).then(s2, u2);
    }
    a2((r2 = r2.apply(e2, t2 || [])).next());
  });
}
function __generator(e2, t2) {
  var n2, r2, o2, i2, s2 = {label: 0, sent: function() {
    if (1 & o2[0])
      throw o2[1];
    return o2[1];
  }, trys: [], ops: []};
  return i2 = {next: u2(0), throw: u2(1), return: u2(2)}, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
    return this;
  }), i2;
  function u2(i3) {
    return function(u3) {
      return function(i4) {
        if (n2)
          throw new TypeError("Generator is already executing.");
        for (; s2; )
          try {
            if (n2 = 1, r2 && (o2 = 2 & i4[0] ? r2.return : i4[0] ? r2.throw || ((o2 = r2.return) && o2.call(r2), 0) : r2.next) && !(o2 = o2.call(r2, i4[1])).done)
              return o2;
            switch (r2 = 0, o2 && (i4 = [2 & i4[0], o2.value]), i4[0]) {
              case 0:
              case 1:
                o2 = i4;
                break;
              case 4:
                return s2.label++, {value: i4[1], done: false};
              case 5:
                s2.label++, r2 = i4[1], i4 = [0];
                continue;
              case 7:
                i4 = s2.ops.pop(), s2.trys.pop();
                continue;
              default:
                if (!(o2 = (o2 = s2.trys).length > 0 && o2[o2.length - 1]) && (6 === i4[0] || 2 === i4[0])) {
                  s2 = 0;
                  continue;
                }
                if (3 === i4[0] && (!o2 || i4[1] > o2[0] && i4[1] < o2[3])) {
                  s2.label = i4[1];
                  break;
                }
                if (6 === i4[0] && s2.label < o2[1]) {
                  s2.label = o2[1], o2 = i4;
                  break;
                }
                if (o2 && s2.label < o2[2]) {
                  s2.label = o2[2], s2.ops.push(i4);
                  break;
                }
                o2[2] && s2.ops.pop(), s2.trys.pop();
                continue;
            }
            i4 = t2.call(e2, s2);
          } catch (e3) {
            i4 = [6, e3], r2 = 0;
          } finally {
            n2 = o2 = 0;
          }
        if (5 & i4[0])
          throw i4[1];
        return {value: i4[0] ? i4[1] : void 0, done: true};
      }([i3, u3]);
    };
  }
}
var BaseModel = function() {
  function e2(e3, t2) {
    this.model = e3, this.outputStride = t2;
    var n2 = this.model.inputs[0].shape;
    tt.assert(-1 === n2[1] && -1 === n2[2], function() {
      return "Input shape [" + n2[1] + ", " + n2[2] + "] must both be equal to or -1";
    });
  }
  return e2.prototype.predict = function(e3) {
    var t2 = this;
    return je(function() {
      var n2 = t2.preprocessInput(e3.toFloat()).expandDims(0), r2 = t2.model.predict(n2).map(function(e4) {
        return e4.squeeze([0]);
      }), o2 = t2.nameOutputResults(r2);
      return {heatmapScores: o2.heatmap.sigmoid(), offsets: o2.offsets, displacementFwd: o2.displacementFwd, displacementBwd: o2.displacementBwd};
    });
  }, e2.prototype.dispose = function() {
    this.model.dispose();
  }, e2;
}();
var MobileNet = function(e2) {
  function t2() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(t2, e2), t2.prototype.preprocessInput = function(e3) {
    return je(function() {
      return qs(e3, 127.5).sub(1);
    });
  }, t2.prototype.nameOutputResults = function(e3) {
    return {offsets: e3[0], heatmap: e3[1], displacementFwd: e3[2], displacementBwd: e3[3]};
  }, t2;
}(BaseModel);
function half(e2) {
  return Math.floor(e2 / 2);
}
var MaxHeap = function() {
  function e2(e3, t2) {
    this.priorityQueue = new Array(e3), this.numberOfElements = -1, this.getElementValue = t2;
  }
  return e2.prototype.enqueue = function(e3) {
    this.priorityQueue[++this.numberOfElements] = e3, this.swim(this.numberOfElements);
  }, e2.prototype.dequeue = function() {
    var e3 = this.priorityQueue[0];
    return this.exchange(0, this.numberOfElements--), this.sink(0), this.priorityQueue[this.numberOfElements + 1] = null, e3;
  }, e2.prototype.empty = function() {
    return -1 === this.numberOfElements;
  }, e2.prototype.size = function() {
    return this.numberOfElements + 1;
  }, e2.prototype.all = function() {
    return this.priorityQueue.slice(0, this.numberOfElements + 1);
  }, e2.prototype.max = function() {
    return this.priorityQueue[0];
  }, e2.prototype.swim = function(e3) {
    for (; e3 > 0 && this.less(half(e3), e3); )
      this.exchange(e3, half(e3)), e3 = half(e3);
  }, e2.prototype.sink = function(e3) {
    for (; 2 * e3 <= this.numberOfElements; ) {
      var t2 = 2 * e3;
      if (t2 < this.numberOfElements && this.less(t2, t2 + 1) && t2++, !this.less(e3, t2))
        break;
      this.exchange(e3, t2), e3 = t2;
    }
  }, e2.prototype.getValueAt = function(e3) {
    return this.getElementValue(this.priorityQueue[e3]);
  }, e2.prototype.less = function(e3, t2) {
    return this.getValueAt(e3) < this.getValueAt(t2);
  }, e2.prototype.exchange = function(e3, t2) {
    var n2 = this.priorityQueue[e3];
    this.priorityQueue[e3] = this.priorityQueue[t2], this.priorityQueue[t2] = n2;
  }, e2;
}();
function scoreIsMaximumInLocalWindow(e2, t2, n2, r2, o2, i2) {
  for (var s2 = i2.shape, u2 = s2[0], a2 = s2[1], l2 = true, p2 = Math.max(n2 - o2, 0), c2 = Math.min(n2 + o2 + 1, u2), f2 = p2; f2 < c2; ++f2) {
    for (var d2 = Math.max(r2 - o2, 0), h2 = Math.min(r2 + o2 + 1, a2), m2 = d2; m2 < h2; ++m2)
      if (i2.get(f2, m2, e2) > t2) {
        l2 = false;
        break;
      }
    if (!l2)
      break;
  }
  return l2;
}
function buildPartWithScoreQueue(e2, t2, n2) {
  for (var r2 = n2.shape, o2 = r2[0], i2 = r2[1], s2 = r2[2], u2 = new MaxHeap(o2 * i2 * s2, function(e3) {
    return e3.score;
  }), a2 = 0; a2 < o2; ++a2)
    for (var l2 = 0; l2 < i2; ++l2)
      for (var p2 = 0; p2 < s2; ++p2) {
        var c2 = n2.get(a2, l2, p2);
        c2 < e2 || scoreIsMaximumInLocalWindow(p2, c2, a2, l2, t2, n2) && u2.enqueue({score: c2, part: {heatmapY: a2, heatmapX: l2, id: p2}});
      }
  return u2;
}
var partNames = ["nose", "leftEye", "rightEye", "leftEar", "rightEar", "leftShoulder", "rightShoulder", "leftElbow", "rightElbow", "leftWrist", "rightWrist", "leftHip", "rightHip", "leftKnee", "rightKnee", "leftAnkle", "rightAnkle"];
var NUM_KEYPOINTS = partNames.length;
var partIds = partNames.reduce(function(e2, t2, n2) {
  return e2[t2] = n2, e2;
}, {});
var connectedPartNames = [["leftHip", "leftShoulder"], ["leftElbow", "leftShoulder"], ["leftElbow", "leftWrist"], ["leftHip", "leftKnee"], ["leftKnee", "leftAnkle"], ["rightHip", "rightShoulder"], ["rightElbow", "rightShoulder"], ["rightElbow", "rightWrist"], ["rightHip", "rightKnee"], ["rightKnee", "rightAnkle"], ["leftShoulder", "rightShoulder"], ["leftHip", "rightHip"]];
var poseChain = [["nose", "leftEye"], ["leftEye", "leftEar"], ["nose", "rightEye"], ["rightEye", "rightEar"], ["nose", "leftShoulder"], ["leftShoulder", "leftElbow"], ["leftElbow", "leftWrist"], ["leftShoulder", "leftHip"], ["leftHip", "leftKnee"], ["leftKnee", "leftAnkle"], ["nose", "rightShoulder"], ["rightShoulder", "rightElbow"], ["rightElbow", "rightWrist"], ["rightShoulder", "rightHip"], ["rightHip", "rightKnee"], ["rightKnee", "rightAnkle"]];
var connectedPartIndices = connectedPartNames.map(function(e2) {
  var t2 = e2[0], n2 = e2[1];
  return [partIds[t2], partIds[n2]];
});
var partChannels = ["left_face", "right_face", "right_upper_leg_front", "right_lower_leg_back", "right_upper_leg_back", "left_lower_leg_front", "left_upper_leg_front", "left_upper_leg_back", "left_lower_leg_back", "right_feet", "right_lower_leg_front", "left_feet", "torso_front", "torso_back", "right_upper_arm_front", "right_upper_arm_back", "right_lower_arm_back", "left_lower_arm_front", "left_upper_arm_front", "left_upper_arm_back", "left_lower_arm_back", "right_hand", "right_lower_arm_front", "left_hand"];
function getOffsetPoint(e2, t2, n2, r2) {
  return {y: r2.get(e2, t2, n2), x: r2.get(e2, t2, n2 + NUM_KEYPOINTS)};
}
function getImageCoords(e2, t2, n2) {
  var r2 = getOffsetPoint(e2.heatmapY, e2.heatmapX, e2.id, n2), o2 = r2.y, i2 = r2.x;
  return {x: e2.heatmapX * t2 + i2, y: e2.heatmapY * t2 + o2};
}
function clamp(e2, t2, n2) {
  return e2 < t2 ? t2 : e2 > n2 ? n2 : e2;
}
function squaredDistance(e2, t2, n2, r2) {
  var o2 = n2 - e2, i2 = r2 - t2;
  return o2 * o2 + i2 * i2;
}
function addVectors(e2, t2) {
  return {x: e2.x + t2.x, y: e2.y + t2.y};
}
var parentChildrenTuples = poseChain.map(function(e2) {
  var t2 = e2[0], n2 = e2[1];
  return [partIds[t2], partIds[n2]];
});
var parentToChildEdges = parentChildrenTuples.map(function(e2) {
  return e2[1];
});
var childToParentEdges = parentChildrenTuples.map(function(e2) {
  return e2[0];
});
function getDisplacement(e2, t2, n2) {
  var r2 = n2.shape[2] / 2;
  return {y: n2.get(t2.y, t2.x, e2), x: n2.get(t2.y, t2.x, r2 + e2)};
}
function getStridedIndexNearPoint(e2, t2, n2, r2) {
  return {y: clamp(Math.round(e2.y / t2), 0, n2 - 1), x: clamp(Math.round(e2.x / t2), 0, r2 - 1)};
}
function traverseToTargetKeypoint(e2, t2, n2, r2, o2, i2, s2, u2) {
  void 0 === u2 && (u2 = 2);
  for (var a2 = r2.shape, l2 = a2[0], p2 = a2[1], c2 = getDisplacement(e2, getStridedIndexNearPoint(t2.position, i2, l2, p2), s2), f2 = addVectors(t2.position, c2), d2 = 0; d2 < u2; d2++) {
    var h2 = getStridedIndexNearPoint(f2, i2, l2, p2), m2 = getOffsetPoint(h2.y, h2.x, n2, o2);
    f2 = addVectors({x: h2.x * i2, y: h2.y * i2}, {x: m2.x, y: m2.y});
  }
  var g2 = getStridedIndexNearPoint(f2, i2, l2, p2), _2 = r2.get(g2.y, g2.x, n2);
  return {position: f2, part: partNames[n2], score: _2};
}
function decodePose(e2, t2, n2, r2, o2, i2) {
  var s2 = t2.shape[2], u2 = parentToChildEdges.length, a2 = new Array(s2), l2 = e2.part, p2 = e2.score, c2 = getImageCoords(l2, r2, n2);
  a2[l2.id] = {score: p2, part: partNames[l2.id], position: c2};
  for (var f2 = u2 - 1; f2 >= 0; --f2) {
    var d2 = parentToChildEdges[f2], h2 = childToParentEdges[f2];
    a2[d2] && !a2[h2] && (a2[h2] = traverseToTargetKeypoint(f2, a2[d2], h2, t2, n2, r2, i2));
  }
  for (f2 = 0; f2 < u2; ++f2) {
    d2 = childToParentEdges[f2], h2 = parentToChildEdges[f2];
    a2[d2] && !a2[h2] && (a2[h2] = traverseToTargetKeypoint(f2, a2[d2], h2, t2, n2, r2, o2));
  }
  return a2;
}
function withinNmsRadiusOfCorrespondingPoint(e2, t2, n2, r2) {
  var o2 = n2.x, i2 = n2.y;
  return e2.some(function(e3) {
    var n3 = e3.keypoints[r2].position;
    return squaredDistance(i2, o2, n3.y, n3.x) <= t2;
  });
}
function getInstanceScore(e2, t2, n2) {
  return n2.reduce(function(n3, r2, o2) {
    var i2 = r2.position, s2 = r2.score;
    return withinNmsRadiusOfCorrespondingPoint(e2, t2, i2, o2) || (n3 += s2), n3;
  }, 0) / n2.length;
}
var kLocalMaximumRadius = 1;
function decodeMultiplePoses(e2, t2, n2, r2, o2, i2, s2, u2) {
  void 0 === s2 && (s2 = 0.5), void 0 === u2 && (u2 = 20);
  for (var a2 = [], l2 = buildPartWithScoreQueue(s2, kLocalMaximumRadius, e2), p2 = u2 * u2; a2.length < i2 && !l2.empty(); ) {
    var c2 = l2.dequeue();
    if (!withinNmsRadiusOfCorrespondingPoint(a2, p2, getImageCoords(c2.part, o2, t2), c2.part.id)) {
      var f2 = decodePose(c2, e2, t2, o2, n2, r2), d2 = getInstanceScore(a2, p2, f2);
      a2.push({keypoints: f2, score: d2});
    }
  }
  return a2;
}
function mod(e2, t2) {
  return je(function() {
    var n2 = e2.div(An(t2, "int32"));
    return e2.sub(n2.mul(An(t2, "int32")));
  });
}
function argmax2d(e2) {
  var t2 = e2.shape, n2 = t2[0], r2 = t2[1], o2 = t2[2];
  return je(function() {
    var t3 = e2.reshape([n2 * r2, o2]).argMax(0), i2 = t3.div(An(r2, "int32")).expandDims(1), s2 = mod(t3, r2).expandDims(1);
    return Gn([i2, s2], 1);
  });
}
function getPointsConfidence(e2, t2) {
  for (var n2 = t2.shape[0], r2 = new Float32Array(n2), o2 = 0; o2 < n2; o2++) {
    var i2 = t2.get(o2, 0), s2 = t2.get(o2, 1);
    r2[o2] = e2.get(i2, s2, o2);
  }
  return r2;
}
function getOffsetPoint$1(e2, t2, n2, r2) {
  return {y: r2.get(e2, t2, n2), x: r2.get(e2, t2, n2 + NUM_KEYPOINTS)};
}
function getOffsetVectors(e2, t2) {
  for (var n2 = [], r2 = 0; r2 < NUM_KEYPOINTS; r2++) {
    var o2 = getOffsetPoint$1(e2.get(r2, 0).valueOf(), e2.get(r2, 1).valueOf(), r2, t2), i2 = o2.x, s2 = o2.y;
    n2.push(s2), n2.push(i2);
  }
  return Tn(n2, [NUM_KEYPOINTS, 2]);
}
function getOffsetPoints(e2, t2, n2) {
  return je(function() {
    var r2 = getOffsetVectors(e2, n2);
    return e2.toTensor().mul(An(t2, "int32")).toFloat().add(r2);
  });
}
function decodeSinglePose(e2, t2, n2) {
  return __awaiter(this, void 0, void 0, function() {
    var r2, o2, i2, s2, u2, a2, l2, p2, c2, f2;
    return __generator(this, function(d2) {
      switch (d2.label) {
        case 0:
          return r2 = 0, o2 = argmax2d(e2), [4, Promise.all([e2.buffer(), t2.buffer(), o2.buffer()])];
        case 1:
          return i2 = d2.sent(), s2 = i2[0], u2 = i2[1], a2 = i2[2], [4, (l2 = getOffsetPoints(a2, n2, u2)).buffer()];
        case 2:
          return p2 = d2.sent(), c2 = Array.from(getPointsConfidence(s2, a2)), f2 = c2.map(function(e3, t3) {
            return r2 += e3, {position: {y: p2.get(t3, 0), x: p2.get(t3, 1)}, part: partNames[t3], score: e3};
          }), o2.dispose(), l2.dispose(), [2, {keypoints: f2, score: r2 / f2.length}];
      }
    });
  });
}
var MOBILENET_BASE_URL = "https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/";
var RESNET50_BASE_URL = "https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";
function resNet50Checkpoint(e2, t2) {
  var n2 = "model-stride" + e2 + ".json";
  return 4 === t2 ? RESNET50_BASE_URL + "float/" + n2 : RESNET50_BASE_URL + "quant" + t2 + "/" + n2;
}
function mobileNetCheckpoint(e2, t2, n2) {
  var r2 = {1: "100", 0.75: "075", 0.5: "050"}, o2 = "model-stride" + e2 + ".json";
  return 4 === n2 ? MOBILENET_BASE_URL + "float/" + r2[t2] + "/" + o2 : MOBILENET_BASE_URL + "quant" + n2 + "/" + r2[t2] + "/" + o2;
}
var imageNetMean = [-123.15, -115.9, -103.06];
var ResNet = function(e2) {
  function t2() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(t2, e2), t2.prototype.preprocessInput = function(e3) {
    return e3.add(imageNetMean);
  }, t2.prototype.nameOutputResults = function(e3) {
    var t3 = e3[0], n2 = e3[1];
    return {offsets: e3[2], heatmap: e3[3], displacementFwd: t3, displacementBwd: n2};
  }, t2;
}(BaseModel);
function eitherPointDoesntMeetConfidence(e2, t2, n2) {
  return e2 < n2 || t2 < n2;
}
function getAdjacentKeyPoints(e2, t2) {
  return connectedPartIndices.reduce(function(n2, r2) {
    var o2 = r2[0], i2 = r2[1];
    return eitherPointDoesntMeetConfidence(e2[o2].score, e2[i2].score, t2) ? n2 : (n2.push([e2[o2], e2[i2]]), n2);
  }, []);
}
var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY;
var POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
function getBoundingBox(e2) {
  return e2.reduce(function(e3, t2) {
    var n2 = e3.maxX, r2 = e3.maxY, o2 = e3.minX, i2 = e3.minY, s2 = t2.position, u2 = s2.x, a2 = s2.y;
    return {maxX: Math.max(n2, u2), maxY: Math.max(r2, a2), minX: Math.min(o2, u2), minY: Math.min(i2, a2)};
  }, {maxX: NEGATIVE_INFINITY, maxY: NEGATIVE_INFINITY, minX: POSITIVE_INFINITY, minY: POSITIVE_INFINITY});
}
function getBoundingBoxPoints(e2) {
  var t2 = getBoundingBox(e2), n2 = t2.minX, r2 = t2.minY, o2 = t2.maxX, i2 = t2.maxY;
  return [{x: n2, y: r2}, {x: o2, y: r2}, {x: o2, y: i2}, {x: n2, y: i2}];
}
function toTensorBuffers3D(e2) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(t2) {
      return [2, Promise.all(e2.map(function(e3) {
        return e3.buffer();
      }))];
    });
  });
}
function scalePose(e2, t2, n2, r2, o2) {
  return void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = 0), {score: e2.score, keypoints: e2.keypoints.map(function(e3) {
    var i2 = e3.score, s2 = e3.part, u2 = e3.position;
    return {score: i2, part: s2, position: {x: u2.x * n2 + o2, y: u2.y * t2 + r2}};
  })};
}
function scalePoses(e2, t2, n2, r2, o2) {
  return void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = 0), 1 === n2 && 1 === t2 && 0 === r2 && 0 === o2 ? e2 : e2.map(function(e3) {
    return scalePose(e3, t2, n2, r2, o2);
  });
}
function flipPoseHorizontal(e2, t2) {
  return {score: e2.score, keypoints: e2.keypoints.map(function(e3) {
    var n2 = e3.score, r2 = e3.part, o2 = e3.position;
    return {score: n2, part: r2, position: {x: t2 - 1 - o2.x, y: o2.y}};
  })};
}
function flipPosesHorizontal(e2, t2) {
  return t2 <= 0 ? e2 : e2.map(function(e3) {
    return flipPoseHorizontal(e3, t2);
  });
}
function toValidInputResolution(e2, t2) {
  return isValidInputResolution(e2, t2) ? e2 : Math.floor(e2 / t2) * t2 + 1;
}
function validateInputResolution(e2) {
  tt.assert("number" == typeof e2 || "object" == typeof e2, function() {
    return "Invalid inputResolution " + e2 + ". Should be a number or an object with width and height";
  }), "object" == typeof e2 && (tt.assert("number" == typeof e2.width, function() {
    return "inputResolution.width has a value of " + e2.width + " which is invalid; it must be a number";
  }), tt.assert("number" == typeof e2.height, function() {
    return "inputResolution.height has a value of " + e2.height + " which is invalid; it must be a number";
  }));
}
function getValidInputResolutionDimensions(e2, t2) {
  return validateInputResolution(e2), "object" == typeof e2 ? [toValidInputResolution(e2.height, t2), toValidInputResolution(e2.width, t2)] : [toValidInputResolution(e2, t2), toValidInputResolution(e2, t2)];
}
var VALID_OUTPUT_STRIDES = [8, 16, 32];
function assertValidOutputStride(e2) {
  tt.assert("number" == typeof e2, function() {
    return "outputStride is not a number";
  }), tt.assert(VALID_OUTPUT_STRIDES.indexOf(e2) >= 0, function() {
    return "outputStride of " + e2 + " is invalid. It must be either 8, 16, or 32";
  });
}
function isValidInputResolution(e2, t2) {
  return (e2 - 1) % t2 == 0;
}
function assertValidResolution(e2, t2) {
  tt.assert("number" == typeof e2[0] && "number" == typeof e2[1], function() {
    return "both resolution values must be a number but had values " + e2;
  }), tt.assert(isValidInputResolution(e2[0], t2), function() {
    return "height of " + e2[0] + " is invalid for output stride " + t2 + ".";
  }), tt.assert(isValidInputResolution(e2[1], t2), function() {
    return "width of " + e2[1] + " is invalid for output stride " + t2 + ".";
  });
}
function getInputTensorDimensions(e2) {
  return e2 instanceof dt ? [e2.shape[0], e2.shape[1]] : [e2.height, e2.width];
}
function toInputTensor(e2) {
  return e2 instanceof dt ? e2 : Ff.fromPixels(e2);
}
function padAndResizeTo(e2, t2) {
  var n2 = t2[0], r2 = t2[1], o2 = getInputTensorDimensions(e2), i2 = o2[0], s2 = o2[1], u2 = r2 / n2, a2 = [0, 0, 0, 0], l2 = a2[0], p2 = a2[1], c2 = a2[2], f2 = a2[3];
  return s2 / i2 < u2 ? (l2 = 0, p2 = 0, c2 = Math.round(0.5 * (u2 * i2 - s2)), f2 = Math.round(0.5 * (u2 * i2 - s2))) : (l2 = Math.round(0.5 * (1 / u2 * s2 - i2)), p2 = Math.round(0.5 * (1 / u2 * s2 - i2)), c2 = 0, f2 = 0), {resized: je(function() {
    var t3 = toInputTensor(e2);
    return (t3 = wr(t3, [[l2, p2], [c2, f2], [0, 0]])).resizeBilinear([n2, r2]);
  }), padding: {top: l2, left: c2, right: f2, bottom: p2}};
}
function scaleAndFlipPoses(e2, t2, n2, r2, o2) {
  var i2 = t2[0], s2 = t2[1], u2 = n2[0], a2 = n2[1], l2 = scalePoses(e2, (i2 + r2.top + r2.bottom) / u2, (s2 + r2.left + r2.right) / a2, -r2.top, -r2.left);
  return o2 ? flipPosesHorizontal(l2, s2) : l2;
}
var MOBILENET_V1_CONFIG = {architecture: "MobileNetV1", outputStride: 16, multiplier: 0.75, inputResolution: 257};
var VALID_ARCHITECTURE = ["MobileNetV1", "ResNet50"];
var VALID_STRIDE = {MobileNetV1: [8, 16, 32], ResNet50: [32, 16]};
var VALID_MULTIPLIER = {MobileNetV1: [0.5, 0.75, 1], ResNet50: [1]};
var VALID_QUANT_BYTES = [1, 2, 4];
function validateModelConfig(e2) {
  if (null == (e2 = e2 || MOBILENET_V1_CONFIG).architecture && (e2.architecture = "MobileNetV1"), VALID_ARCHITECTURE.indexOf(e2.architecture) < 0)
    throw new Error("Invalid architecture " + e2.architecture + ". Should be one of " + VALID_ARCHITECTURE);
  if (null == e2.inputResolution && (e2.inputResolution = 257), validateInputResolution(e2.inputResolution), null == e2.outputStride && (e2.outputStride = 16), VALID_STRIDE[e2.architecture].indexOf(e2.outputStride) < 0)
    throw new Error("Invalid outputStride " + e2.outputStride + ". Should be one of " + VALID_STRIDE[e2.architecture] + " for architecutre " + e2.architecture + ".");
  if (null == e2.multiplier && (e2.multiplier = 1), VALID_MULTIPLIER[e2.architecture].indexOf(e2.multiplier) < 0)
    throw new Error("Invalid multiplier " + e2.multiplier + ". Should be one of " + VALID_MULTIPLIER[e2.architecture] + " for architecutre " + e2.architecture + ".");
  if (null == e2.quantBytes && (e2.quantBytes = 4), VALID_QUANT_BYTES.indexOf(e2.quantBytes) < 0)
    throw new Error("Invalid quantBytes " + e2.quantBytes + ". Should be one of " + VALID_QUANT_BYTES + " for architecutre " + e2.architecture + ".");
  return e2;
}
var SINGLE_PERSON_INFERENCE_CONFIG = {flipHorizontal: false};
var MULTI_PERSON_INFERENCE_CONFIG = {flipHorizontal: false, maxDetections: 5, scoreThreshold: 0.5, nmsRadius: 20};
function validateMultiPersonInputConfig(e2) {
  var t2 = e2.maxDetections, n2 = e2.scoreThreshold, r2 = e2.nmsRadius;
  if (t2 <= 0)
    throw new Error("Invalid maxDetections " + t2 + ". Should be > 0");
  if (n2 < 0 || n2 > 1)
    throw new Error("Invalid scoreThreshold " + n2 + ". Should be in range [0.0, 1.0]");
  if (r2 <= 0)
    throw new Error("Invalid nmsRadius " + r2 + ".");
}
var PoseNet = function() {
  function e2(e3, t2) {
    assertValidOutputStride(e3.outputStride), assertValidResolution(t2, e3.outputStride), this.baseModel = e3, this.inputResolution = t2;
  }
  return e2.prototype.estimateMultiplePoses = function(e3, t2) {
    return void 0 === t2 && (t2 = MULTI_PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function() {
      var n2, r2, o2, i2, s2, u2, a2, l2, p2, c2, f2, d2, h2, m2, g2, _2, I2, v2, y2, E2, b2;
      return __generator(this, function(N2) {
        switch (N2.label) {
          case 0:
            return n2 = __assign({}, MULTI_PERSON_INFERENCE_CONFIG, t2), validateMultiPersonInputConfig(t2), r2 = this.baseModel.outputStride, o2 = this.inputResolution, i2 = getInputTensorDimensions(e3), s2 = i2[0], u2 = i2[1], a2 = padAndResizeTo(e3, o2), l2 = a2.resized, p2 = a2.padding, c2 = this.baseModel.predict(l2), f2 = c2.heatmapScores, d2 = c2.offsets, h2 = c2.displacementFwd, m2 = c2.displacementBwd, [4, toTensorBuffers3D([f2, d2, h2, m2])];
          case 1:
            return g2 = N2.sent(), _2 = g2[0], I2 = g2[1], v2 = g2[2], y2 = g2[3], [4, decodeMultiplePoses(_2, I2, v2, y2, r2, n2.maxDetections, n2.scoreThreshold, n2.nmsRadius)];
          case 2:
            return E2 = N2.sent(), b2 = scaleAndFlipPoses(E2, [s2, u2], o2, p2, n2.flipHorizontal), f2.dispose(), d2.dispose(), h2.dispose(), m2.dispose(), l2.dispose(), [2, b2];
        }
      });
    });
  }, e2.prototype.estimateSinglePose = function(e3, t2) {
    return void 0 === t2 && (t2 = SINGLE_PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function() {
      var n2, r2, o2, i2, s2, u2, a2, l2, p2, c2, f2, d2, h2, m2, g2, _2;
      return __generator(this, function(I2) {
        switch (I2.label) {
          case 0:
            return n2 = __assign({}, SINGLE_PERSON_INFERENCE_CONFIG, t2), r2 = this.baseModel.outputStride, o2 = this.inputResolution, i2 = getInputTensorDimensions(e3), s2 = i2[0], u2 = i2[1], a2 = padAndResizeTo(e3, o2), l2 = a2.resized, p2 = a2.padding, c2 = this.baseModel.predict(l2), f2 = c2.heatmapScores, d2 = c2.offsets, h2 = c2.displacementFwd, m2 = c2.displacementBwd, [4, decodeSinglePose(f2, d2, r2)];
          case 1:
            return g2 = I2.sent(), _2 = scaleAndFlipPoses([g2], [s2, u2], o2, p2, n2.flipHorizontal), f2.dispose(), d2.dispose(), h2.dispose(), m2.dispose(), l2.dispose(), [2, _2[0]];
        }
      });
    });
  }, e2.prototype.estimatePoses = function(e3, t2) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(n2) {
        switch (n2.label) {
          case 0:
            return "single-person" !== t2.decodingMethod ? [3, 2] : [4, this.estimateSinglePose(e3, t2)];
          case 1:
            return [2, [n2.sent()]];
          case 2:
            return [2, this.estimateMultiplePoses(e3, t2)];
        }
      });
    });
  }, e2.prototype.dispose = function() {
    this.baseModel.dispose();
  }, e2;
}();
function loadMobileNet(e2) {
  return __awaiter(this, void 0, void 0, function() {
    var t2, n2, r2, o2, i2, s2, u2;
    return __generator(this, function(a2) {
      switch (a2.label) {
        case 0:
          if (t2 = e2.outputStride, n2 = e2.quantBytes, r2 = e2.multiplier, null == tf_core_esm_exports)
            throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");
          return o2 = mobileNetCheckpoint(t2, r2, n2), [4, loadGraphModel(e2.modelUrl || o2)];
        case 1:
          return i2 = a2.sent(), s2 = new MobileNet(i2, t2), u2 = getValidInputResolutionDimensions(e2.inputResolution, s2.outputStride), [2, new PoseNet(s2, u2)];
      }
    });
  });
}
function loadResNet(e2) {
  return __awaiter(this, void 0, void 0, function() {
    var t2, n2, r2, o2, i2, s2;
    return __generator(this, function(u2) {
      switch (u2.label) {
        case 0:
          if (t2 = e2.outputStride, n2 = e2.quantBytes, null == tf_core_esm_exports)
            throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");
          return r2 = resNet50Checkpoint(t2, n2), [4, loadGraphModel(e2.modelUrl || r2)];
        case 1:
          return o2 = u2.sent(), i2 = new ResNet(o2, t2), s2 = getValidInputResolutionDimensions(e2.inputResolution, i2.outputStride), [2, new PoseNet(i2, s2)];
      }
    });
  });
}
function load(e2) {
  return void 0 === e2 && (e2 = MOBILENET_V1_CONFIG), __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(t2) {
      return "ResNet50" === (e2 = validateModelConfig(e2)).architecture ? [2, loadResNet(e2)] : "MobileNetV1" === e2.architecture ? [2, loadMobileNet(e2)] : [2, null];
    });
  });
}
var version = "2.2.1";

// index.js
export {
  MobileNet,
  PoseNet,
  decodeMultiplePoses,
  decodeSinglePose,
  getAdjacentKeyPoints,
  getBoundingBox,
  getBoundingBoxPoints,
  load,
  partChannels,
  partIds,
  partNames,
  poseChain,
  scaleAndFlipPoses,
  scalePose,
  version
};
