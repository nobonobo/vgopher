let __defineProperty = Object.defineProperty;
let __commonJS = (callback, module) => () => {
  if (!module) {
    module = {exports: {}};
    callback(module.exports, module);
  }
  return module.exports;
};
let __markAsModule = (target) => {
  return __defineProperty(target, "__esModule", {value: true});
};
let __export = (target, all) => {
  __markAsModule(target);
  for (let name in all)
    __defineProperty(target, name, {get: all[name], enumerable: true});
};

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS((exports, module) => {
  "use strict";
  var buffer = require("buffer");
  var Buffer2 = buffer.Buffer;
  var safer = {};
  var key;
  for (key in buffer) {
    if (!buffer.hasOwnProperty(key))
      continue;
    if (key === "SlowBuffer" || key === "Buffer")
      continue;
    safer[key] = buffer[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key))
      continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow")
      continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e2) {
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  module.exports = safer;
});

// node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = __commonJS((exports) => {
  "use strict";
  var BOMChar = "﻿";
  exports.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
      str = BOMChar + str;
      this.addBOM = false;
    }
    return this.encoder.write(str);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  exports.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
      return res;
    if (res[0] === BOMChar) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
});

// node_modules/iconv-lite/encodings/internal.js
var require_internal = __commonJS((exports, module) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  module.exports = {
    utf8: {type: "_internal", bomAware: true},
    cesu8: {type: "_internal", bomAware: true},
    unicode11utf8: "utf8",
    ucs2: {type: "_internal", bomAware: true},
    utf16le: "ucs2",
    binary: {type: "_internal"},
    base64: {type: "_internal"},
    hex: {type: "_internal"},
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "💩") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = require("string_decoder").StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {
    };
  function InternalDecoder(options, codec) {
    this.decoder = new StringDecoder(codec.enc);
  }
  InternalDecoder.prototype.write = function(buf) {
    if (!Buffer2.isBuffer(buf)) {
      buf = Buffer2.from(buf);
    }
    return this.decoder.write(buf);
  };
  InternalDecoder.prototype.end = function() {
    return this.decoder.end();
  };
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str) {
    return Buffer2.from(str, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);
    return Buffer2.from(str, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
    for (var i2 = 0; i2 < str.length; i2++) {
      var charCode = str.charCodeAt(i2);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for (var i2 = 0; i2 < buf.length; i2++) {
      var curByte = buf[i2];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res += this.defaultCharUnicode;
            else
              res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
      res += this.defaultCharUnicode;
    return res;
  };
});

// node_modules/iconv-lite/encodings/utf32.js
var require_utf32 = __commonJS((exports) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  exports._utf32 = Utf32Codec;
  function Utf32Codec(codecOptions, iconv) {
    this.iconv = iconv;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
  }
  exports.utf32le = {type: "_utf32", isLE: true};
  exports.utf32be = {type: "_utf32", isLE: false};
  exports.ucs4le = "utf32le";
  exports.ucs4be = "utf32be";
  Utf32Codec.prototype.encoder = Utf32Encoder;
  Utf32Codec.prototype.decoder = Utf32Decoder;
  function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
  }
  Utf32Encoder.prototype.write = function(str) {
    var src = Buffer2.from(str, "ucs2");
    var dst = Buffer2.alloc(src.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;
    for (var i2 = 0; i2 < src.length; i2 += 2) {
      var code = src.readUInt16LE(i2);
      var isHighSurrogate = 55296 <= code && code < 56320;
      var isLowSurrogate = 56320 <= code && code < 57344;
      if (this.highSurrogate) {
        if (isHighSurrogate || !isLowSurrogate) {
          write32.call(dst, this.highSurrogate, offset);
          offset += 4;
        } else {
          var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
          write32.call(dst, codepoint, offset);
          offset += 4;
          this.highSurrogate = 0;
          continue;
        }
      }
      if (isHighSurrogate)
        this.highSurrogate = code;
      else {
        write32.call(dst, code, offset);
        offset += 4;
        this.highSurrogate = 0;
      }
    }
    if (offset < dst.length)
      dst = dst.slice(0, offset);
    return dst;
  };
  Utf32Encoder.prototype.end = function() {
    if (!this.highSurrogate)
      return;
    var buf = Buffer2.alloc(4);
    if (this.isLE)
      buf.writeUInt32LE(this.highSurrogate, 0);
    else
      buf.writeUInt32BE(this.highSurrogate, 0);
    this.highSurrogate = 0;
    return buf;
  };
  function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = [];
  }
  Utf32Decoder.prototype.write = function(src) {
    if (src.length === 0)
      return "";
    var i2 = 0;
    var codepoint = 0;
    var dst = Buffer2.alloc(src.length + 4);
    var offset = 0;
    var isLE = this.isLE;
    var overflow = this.overflow;
    var badChar = this.badChar;
    if (overflow.length > 0) {
      for (; i2 < src.length && overflow.length < 4; i2++)
        overflow.push(src[i2]);
      if (overflow.length === 4) {
        if (isLE) {
          codepoint = overflow[i2] | overflow[i2 + 1] << 8 | overflow[i2 + 2] << 16 | overflow[i2 + 3] << 24;
        } else {
          codepoint = overflow[i2 + 3] | overflow[i2 + 2] << 8 | overflow[i2 + 1] << 16 | overflow[i2] << 24;
        }
        overflow.length = 0;
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
    }
    for (; i2 < src.length - 3; i2 += 4) {
      if (isLE) {
        codepoint = src[i2] | src[i2 + 1] << 8 | src[i2 + 2] << 16 | src[i2 + 3] << 24;
      } else {
        codepoint = src[i2 + 3] | src[i2 + 2] << 8 | src[i2 + 1] << 16 | src[i2] << 24;
      }
      offset = _writeCodepoint(dst, offset, codepoint, badChar);
    }
    for (; i2 < src.length; i2++) {
      overflow.push(src[i2]);
    }
    return dst.slice(0, offset).toString("ucs2");
  };
  function _writeCodepoint(dst, offset, codepoint, badChar) {
    if (codepoint < 0 || codepoint > 1114111) {
      codepoint = badChar;
    }
    if (codepoint >= 65536) {
      codepoint -= 65536;
      var high = 55296 | codepoint >> 10;
      dst[offset++] = high & 255;
      dst[offset++] = high >> 8;
      var codepoint = 56320 | codepoint & 1023;
    }
    dst[offset++] = codepoint & 255;
    dst[offset++] = codepoint >> 8;
    return offset;
  }
  Utf32Decoder.prototype.end = function() {
    this.overflow.length = 0;
  };
  exports.utf32 = Utf32AutoCodec;
  exports.ucs4 = "utf32";
  function Utf32AutoCodec(options, iconv) {
    this.iconv = iconv;
  }
  Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
  Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
  function Utf32AutoEncoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
  }
  Utf32AutoEncoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf32AutoEncoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf32AutoDecoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 32)
        return "";
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i2 = 0; i2 < this.initialBufs.length; i2++)
        resStr += this.decoder.write(this.initialBufs[i2]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf32AutoDecoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i2 = 0; i2 < this.initialBufs.length; i2++)
        resStr += this.decoder.write(this.initialBufs[i2]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b2 = [];
    var charsProcessed = 0;
    var invalidLE = 0, invalidBE = 0;
    var bmpCharsLE = 0, bmpCharsBE = 0;
    outer_loop:
      for (var i2 = 0; i2 < bufs.length; i2++) {
        var buf = bufs[i2];
        for (var j2 = 0; j2 < buf.length; j2++) {
          b2.push(buf[j2]);
          if (b2.length === 4) {
            if (charsProcessed === 0) {
              if (b2[0] === 255 && b2[1] === 254 && b2[2] === 0 && b2[3] === 0) {
                return "utf-32le";
              }
              if (b2[0] === 0 && b2[1] === 0 && b2[2] === 254 && b2[3] === 255) {
                return "utf-32be";
              }
            }
            if (b2[0] !== 0 || b2[1] > 16)
              invalidBE++;
            if (b2[3] !== 0 || b2[2] > 16)
              invalidLE++;
            if (b2[0] === 0 && b2[1] === 0 && (b2[2] !== 0 || b2[3] !== 0))
              bmpCharsBE++;
            if ((b2[0] !== 0 || b2[1] !== 0) && b2[2] === 0 && b2[3] === 0)
              bmpCharsLE++;
            b2.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE)
      return "utf-32be";
    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE)
      return "utf-32le";
    return defaultEncoding || "utf-32le";
  }
});

// node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = __commonJS((exports) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  exports.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer2.from(str, "ucs2");
    for (var i2 = 0; i2 < buf.length; i2 += 2) {
      var tmp = buf[i2];
      buf[i2] = buf[i2 + 1];
      buf[i2 + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i2 = 0, j2 = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i2 = 1;
      j2 = 2;
    }
    for (; i2 < buf.length - 1; i2 += 2, j2 += 2) {
      buf2[j2] = buf[i2 + 1];
      buf2[j2 + 1] = buf[i2];
    }
    this.overflowByte = i2 == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j2).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
    this.overflowByte = -1;
  };
  exports.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 16)
        return "";
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i2 = 0; i2 < this.initialBufs.length; i2++)
        resStr += this.decoder.write(this.initialBufs[i2]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i2 = 0; i2 < this.initialBufs.length; i2++)
        resStr += this.decoder.write(this.initialBufs[i2]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b2 = [];
    var charsProcessed = 0;
    var asciiCharsLE = 0, asciiCharsBE = 0;
    outer_loop:
      for (var i2 = 0; i2 < bufs.length; i2++) {
        var buf = bufs[i2];
        for (var j2 = 0; j2 < buf.length; j2++) {
          b2.push(buf[j2]);
          if (b2.length === 2) {
            if (charsProcessed === 0) {
              if (b2[0] === 255 && b2[1] === 254)
                return "utf-16le";
              if (b2[0] === 254 && b2[1] === 255)
                return "utf-16be";
            }
            if (b2[0] === 0 && b2[1] !== 0)
              asciiCharsBE++;
            if (b2[0] !== 0 && b2[1] === 0)
              asciiCharsLE++;
            b2.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (asciiCharsBE > asciiCharsLE)
      return "utf-16be";
    if (asciiCharsBE < asciiCharsLE)
      return "utf-16le";
    return defaultEncoding || "utf-16le";
  }
});

// node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = __commonJS((exports) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  exports.utf7 = Utf7Codec;
  exports.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str) {
    return Buffer2.from(str.replace(nonDirectChars, function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }.bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i2 = 0; i2 < 256; i2++)
    base64Chars[i2] = base64Regex.test(String.fromCharCode(i2));
  var plusChar = "+".charCodeAt(0);
  var minusChar = "-".charCodeAt(0);
  var andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i3 = 0; i3 < buf.length; i3++) {
      if (!inBase64) {
        if (buf[i3] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i3), "ascii");
          lastI = i3 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i3]]) {
          if (i3 == lastI && buf[i3] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i3), "ascii");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i3] != minusChar)
            i3--;
          lastI = i3 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  exports.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
    for (var i3 = 0; i3 < str.length; i3++) {
      var uChar = str.charCodeAt(i3);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i3 = 0; i3 < buf.length; i3++) {
      if (!inBase64) {
        if (buf[i3] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i3), "ascii");
          lastI = i3 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i3]]) {
          if (i3 == lastI && buf[i3] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i3), "ascii").replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i3] != minusChar)
            i3--;
          lastI = i3 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
});

// node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = __commonJS((exports) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  exports._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i2 = 0; i2 < 128; i2++)
        asciiString += String.fromCharCode(i2);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i2 = 0; i2 < codecOptions.chars.length; i2++)
      encodeBuf[codecOptions.chars.charCodeAt(i2)] = i2;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer2.alloc(str.length);
    for (var i2 = 0; i2 < str.length; i2++)
      buf[i2] = this.encodeBuf[str.charCodeAt(i2)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i2 = 0; i2 < buf.length; i2++) {
      idx1 = buf[i2] * 2;
      idx2 = i2 * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
});

// node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = __commonJS((exports, module) => {
  "use strict";
  module.exports = {
    "10029": "maccenteuro",
    maccenteuro: {
      type: "_sbcs",
      chars: "ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ"
    },
    "808": "cp808",
    ibm808: "cp808",
    cp808: {
      type: "_sbcs",
      chars: "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№€■ "
    },
    mik: {
      type: "_sbcs",
      chars: "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя└┴┬├─┼╣║╚╔╩╦╠═╬┐░▒▓│┤№§╗╝┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
    },
    cp720: {
      type: "_sbcs",
      chars: "éâàçêëèïîّْô¤ـûùءآأؤ£إئابةتثجحخدذرزسشص«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀ضطظعغفµقكلمنهوىي≡ًٌٍَُِ≈°∙·√ⁿ²■ "
    },
    ascii8bit: "ascii",
    usascii: "ascii",
    ansix34: "ascii",
    ansix341968: "ascii",
    ansix341986: "ascii",
    csascii: "ascii",
    cp367: "ascii",
    ibm367: "ascii",
    isoir6: "ascii",
    iso646us: "ascii",
    iso646irv: "ascii",
    us: "ascii",
    latin1: "iso88591",
    latin2: "iso88592",
    latin3: "iso88593",
    latin4: "iso88594",
    latin5: "iso88599",
    latin6: "iso885910",
    latin7: "iso885913",
    latin8: "iso885914",
    latin9: "iso885915",
    latin10: "iso885916",
    csisolatin1: "iso88591",
    csisolatin2: "iso88592",
    csisolatin3: "iso88593",
    csisolatin4: "iso88594",
    csisolatincyrillic: "iso88595",
    csisolatinarabic: "iso88596",
    csisolatingreek: "iso88597",
    csisolatinhebrew: "iso88598",
    csisolatin5: "iso88599",
    csisolatin6: "iso885910",
    l1: "iso88591",
    l2: "iso88592",
    l3: "iso88593",
    l4: "iso88594",
    l5: "iso88599",
    l6: "iso885910",
    l7: "iso885913",
    l8: "iso885914",
    l9: "iso885915",
    l10: "iso885916",
    isoir14: "iso646jp",
    isoir57: "iso646cn",
    isoir100: "iso88591",
    isoir101: "iso88592",
    isoir109: "iso88593",
    isoir110: "iso88594",
    isoir144: "iso88595",
    isoir127: "iso88596",
    isoir126: "iso88597",
    isoir138: "iso88598",
    isoir148: "iso88599",
    isoir157: "iso885910",
    isoir166: "tis620",
    isoir179: "iso885913",
    isoir199: "iso885914",
    isoir203: "iso885915",
    isoir226: "iso885916",
    cp819: "iso88591",
    ibm819: "iso88591",
    cyrillic: "iso88595",
    arabic: "iso88596",
    arabic8: "iso88596",
    ecma114: "iso88596",
    asmo708: "iso88596",
    greek: "iso88597",
    greek8: "iso88597",
    ecma118: "iso88597",
    elot928: "iso88597",
    hebrew: "iso88598",
    hebrew8: "iso88598",
    turkish: "iso88599",
    turkish8: "iso88599",
    thai: "iso885911",
    thai8: "iso885911",
    celtic: "iso885914",
    celtic8: "iso885914",
    isoceltic: "iso885914",
    tis6200: "tis620",
    tis62025291: "tis620",
    tis62025330: "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    cspc8codepage437: "cp437",
    cspc775baltic: "cp775",
    cspc850multilingual: "cp850",
    cspcp852: "cp852",
    cspc862latinhebrew: "cp862",
    cpgr: "cp869",
    msee: "cp1250",
    mscyrl: "cp1251",
    msansi: "cp1252",
    msgreek: "cp1253",
    msturk: "cp1254",
    mshebr: "cp1255",
    msarab: "cp1256",
    winbaltrim: "cp1257",
    cp20866: "koi8r",
    "20866": "koi8r",
    ibm878: "koi8r",
    cskoi8r: "koi8r",
    cp21866: "koi8u",
    "21866": "koi8u",
    ibm1168: "koi8u",
    strk10482002: "rk1048",
    tcvn5712: "tcvn",
    tcvn57121: "tcvn",
    gb198880: "iso646cn",
    cn: "iso646cn",
    csiso14jisc6220ro: "iso646jp",
    jisc62201969ro: "iso646jp",
    jp: "iso646jp",
    cshproman8: "hproman8",
    r8: "hproman8",
    roman8: "hproman8",
    xroman8: "hproman8",
    ibm1051: "hproman8",
    mac: "macintosh",
    csmacintosh: "macintosh"
  };
});

// node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = __commonJS((exports, module) => {
  "use strict";
  module.exports = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    windows874: {
      type: "_sbcs",
      chars: "€����…�����������‘’“”•–—�������� กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
    },
    win874: "windows874",
    cp874: "windows874",
    windows1250: {
      type: "_sbcs",
      chars: "€�‚�„…†‡�‰Š‹ŚŤŽŹ�‘’“”•–—�™š›śťžź ˇ˘Ł¤Ą¦§¨©Ş«¬­®Ż°±˛ł´µ¶·¸ąş»Ľ˝ľżŔÁÂĂÄĹĆÇČÉĘËĚÍÎĎĐŃŇÓÔŐÖ×ŘŮÚŰÜÝŢßŕáâăäĺćçčéęëěíîďđńňóôőö÷řůúűüýţ˙"
    },
    win1250: "windows1250",
    cp1250: "windows1250",
    windows1251: {
      type: "_sbcs",
      chars: "ЂЃ‚ѓ„…†‡€‰Љ‹ЊЌЋЏђ‘’“”•–—�™љ›њќћџ ЎўЈ¤Ґ¦§Ё©Є«¬­®Ї°±Ііґµ¶·ё№є»јЅѕїАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
    },
    win1251: "windows1251",
    cp1251: "windows1251",
    windows1252: {
      type: "_sbcs",
      chars: "€�‚ƒ„…†‡ˆ‰Š‹Œ�Ž��‘’“”•–—˜™š›œ�žŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
    },
    win1252: "windows1252",
    cp1252: "windows1252",
    windows1253: {
      type: "_sbcs",
      chars: "€�‚ƒ„…†‡�‰�‹�����‘’“”•–—�™�›���� ΅Ά£¤¥¦§¨©�«¬­®―°±²³΄µ¶·ΈΉΊ»Ό½ΎΏΐΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ�ΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ�"
    },
    win1253: "windows1253",
    cp1253: "windows1253",
    windows1254: {
      type: "_sbcs",
      chars: "€�‚ƒ„…†‡ˆ‰Š‹Œ����‘’“”•–—˜™š›œ��Ÿ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ"
    },
    win1254: "windows1254",
    cp1254: "windows1254",
    windows1255: {
      type: "_sbcs",
      chars: "€�‚ƒ„…†‡ˆ‰�‹�����‘’“”•–—˜™�›���� ¡¢£₪¥¦§¨©×«¬­®¯°±²³´µ¶·¸¹÷»¼½¾¿ְֱֲֳִֵֶַָֹֺֻּֽ־ֿ׀ׁׂ׃װױײ׳״�������אבגדהוזחטיךכלםמןנסעףפץצקרשת��‎‏�"
    },
    win1255: "windows1255",
    cp1255: "windows1255",
    windows1256: {
      type: "_sbcs",
      chars: "€پ‚ƒ„…†‡ˆ‰ٹ‹Œچژڈگ‘’“”•–—ک™ڑ›œ‌‍ں ،¢£¤¥¦§¨©ھ«¬­®¯°±²³´µ¶·¸¹؛»¼½¾؟ہءآأؤإئابةتثجحخدذرزسشصض×طظعغـفقكàلâمنهوçèéêëىيîïًٌٍَôُِ÷ّùْûü‎‏ے"
    },
    win1256: "windows1256",
    cp1256: "windows1256",
    windows1257: {
      type: "_sbcs",
      chars: "€�‚�„…†‡�‰�‹�¨ˇ¸�‘’“”•–—�™�›�¯˛� �¢£¤�¦§Ø©Ŗ«¬­®Æ°±²³´µ¶·ø¹ŗ»¼½¾æĄĮĀĆÄÅĘĒČÉŹĖĢĶĪĻŠŃŅÓŌÕÖ×ŲŁŚŪÜŻŽßąįāćäåęēčéźėģķīļšńņóōõö÷ųłśūüżž˙"
    },
    win1257: "windows1257",
    cp1257: "windows1257",
    windows1258: {
      type: "_sbcs",
      chars: "€�‚ƒ„…†‡ˆ‰�‹Œ����‘’“”•–—˜™�›œ��Ÿ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ"
    },
    win1258: "windows1258",
    cp1258: "windows1258",
    iso88591: {
      type: "_sbcs",
      chars: " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
    },
    cp28591: "iso88591",
    iso88592: {
      type: "_sbcs",
      chars: " Ą˘Ł¤ĽŚ§¨ŠŞŤŹ­ŽŻ°ą˛ł´ľśˇ¸šşťź˝žżŔÁÂĂÄĹĆÇČÉĘËĚÍÎĎĐŃŇÓÔŐÖ×ŘŮÚŰÜÝŢßŕáâăäĺćçčéęëěíîďđńňóôőö÷řůúűüýţ˙"
    },
    cp28592: "iso88592",
    iso88593: {
      type: "_sbcs",
      chars: " Ħ˘£¤�Ĥ§¨İŞĞĴ­�Ż°ħ²³´µĥ·¸ışğĵ½�żÀÁÂ�ÄĊĈÇÈÉÊËÌÍÎÏ�ÑÒÓÔĠÖ×ĜÙÚÛÜŬŜßàáâ�äċĉçèéêëìíîï�ñòóôġö÷ĝùúûüŭŝ˙"
    },
    cp28593: "iso88593",
    iso88594: {
      type: "_sbcs",
      chars: " ĄĸŖ¤ĨĻ§¨ŠĒĢŦ­Ž¯°ą˛ŗ´ĩļˇ¸šēģŧŊžŋĀÁÂÃÄÅÆĮČÉĘËĖÍÎĪĐŅŌĶÔÕÖ×ØŲÚÛÜŨŪßāáâãäåæįčéęëėíîīđņōķôõö÷øųúûüũū˙"
    },
    cp28594: "iso88594",
    iso88595: {
      type: "_sbcs",
      chars: " ЁЂЃЄЅІЇЈЉЊЋЌ­ЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя№ёђѓєѕіїјљњћќ§ўџ"
    },
    cp28595: "iso88595",
    iso88596: {
      type: "_sbcs",
      chars: " ���¤�������،­�������������؛���؟�ءآأؤإئابةتثجحخدذرزسشصضطظعغ�����ـفقكلمنهوىيًٌٍَُِّْ�������������"
    },
    cp28596: "iso88596",
    iso88597: {
      type: "_sbcs",
      chars: " ‘’£€₯¦§¨©ͺ«¬­�―°±²³΄΅Ά·ΈΉΊ»Ό½ΎΏΐΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ�ΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ�"
    },
    cp28597: "iso88597",
    iso88598: {
      type: "_sbcs",
      chars: " �¢£¤¥¦§¨©×«¬­®¯°±²³´µ¶·¸¹÷»¼½¾��������������������������������‗אבגדהוזחטיךכלםמןנסעףפץצקרשת��‎‏�"
    },
    cp28598: "iso88598",
    iso88599: {
      type: "_sbcs",
      chars: " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ"
    },
    cp28599: "iso88599",
    iso885910: {
      type: "_sbcs",
      chars: " ĄĒĢĪĨĶ§ĻĐŠŦŽ­ŪŊ°ąēģīĩķ·ļđšŧž―ūŋĀÁÂÃÄÅÆĮČÉĘËĖÍÎÏÐŅŌÓÔÕÖŨØŲÚÛÜÝÞßāáâãäåæįčéęëėíîïðņōóôõöũøųúûüýþĸ"
    },
    cp28600: "iso885910",
    iso885911: {
      type: "_sbcs",
      chars: " กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
    },
    cp28601: "iso885911",
    iso885913: {
      type: "_sbcs",
      chars: " ”¢£¤„¦§Ø©Ŗ«¬­®Æ°±²³“µ¶·ø¹ŗ»¼½¾æĄĮĀĆÄÅĘĒČÉŹĖĢĶĪĻŠŃŅÓŌÕÖ×ŲŁŚŪÜŻŽßąįāćäåęēčéźėģķīļšńņóōõö÷ųłśūüżž’"
    },
    cp28603: "iso885913",
    iso885914: {
      type: "_sbcs",
      chars: " Ḃḃ£ĊċḊ§Ẁ©ẂḋỲ­®ŸḞḟĠġṀṁ¶ṖẁṗẃṠỳẄẅṡÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏŴÑÒÓÔÕÖṪØÙÚÛÜÝŶßàáâãäåæçèéêëìíîïŵñòóôõöṫøùúûüýŷÿ"
    },
    cp28604: "iso885914",
    iso885915: {
      type: "_sbcs",
      chars: " ¡¢£€¥Š§š©ª«¬­®¯°±²³Žµ¶·ž¹º»ŒœŸ¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
    },
    cp28605: "iso885915",
    iso885916: {
      type: "_sbcs",
      chars: " ĄąŁ€„Š§š©Ș«Ź­źŻ°±ČłŽ”¶·žčș»ŒœŸżÀÁÂĂÄĆÆÇÈÉÊËÌÍÎÏĐŃÒÓÔŐÖŚŰÙÚÛÜĘȚßàáâăäćæçèéêëìíîïđńòóôőöśűùúûüęțÿ"
    },
    cp28606: "iso885916",
    cp437: {
      type: "_sbcs",
      chars: "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
    },
    ibm437: "cp437",
    csibm437: "cp437",
    cp737: {
      type: "_sbcs",
      chars: "ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρσςτυφχψ░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀ωάέήϊίόύϋώΆΈΉΊΌΎΏ±≥≤ΪΫ÷≈°∙·√ⁿ²■ "
    },
    ibm737: "cp737",
    csibm737: "cp737",
    cp775: {
      type: "_sbcs",
      chars: "ĆüéāäģåćłēŖŗīŹÄÅÉæÆōöĢ¢ŚśÖÜø£Ø×¤ĀĪóŻżź”¦©®¬½¼Ł«»░▒▓│┤ĄČĘĖ╣║╗╝ĮŠ┐└┴┬├─┼ŲŪ╚╔╩╦╠═╬Žąčęėįšųūž┘┌█▄▌▐▀ÓßŌŃõÕµńĶķĻļņĒŅ’­±“¾¶§÷„°∙·¹³²■ "
    },
    ibm775: "cp775",
    csibm775: "cp775",
    cp850: {
      type: "_sbcs",
      chars: "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈıÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±‗¾¶§÷¸°¨·¹³²■ "
    },
    ibm850: "cp850",
    csibm850: "cp850",
    cp852: {
      type: "_sbcs",
      chars: "ÇüéâäůćçłëŐőîŹÄĆÉĹĺôöĽľŚśÖÜŤťŁ×čáíóúĄąŽžĘę¬źČş«»░▒▓│┤ÁÂĚŞ╣║╗╝Żż┐└┴┬├─┼Ăă╚╔╩╦╠═╬¤đĐĎËďŇÍÎě┘┌█▄ŢŮ▀ÓßÔŃńňŠšŔÚŕŰýÝţ´­˝˛ˇ˘§÷¸°¨˙űŘř■ "
    },
    ibm852: "cp852",
    csibm852: "cp852",
    cp855: {
      type: "_sbcs",
      chars: "ђЂѓЃёЁєЄѕЅіІїЇјЈљЉњЊћЋќЌўЎџЏюЮъЪаАбБцЦдДеЕфФгГ«»░▒▓│┤хХиИ╣║╗╝йЙ┐└┴┬├─┼кК╚╔╩╦╠═╬¤лЛмМнНоОп┘┌█▄Пя▀ЯрРсСтТуУжЖвВьЬ№­ыЫзЗшШэЭщЩчЧ§■ "
    },
    ibm855: "cp855",
    csibm855: "cp855",
    cp856: {
      type: "_sbcs",
      chars: "אבגדהוזחטיךכלםמןנסעףפץצקרשת�£�×����������®¬½¼�«»░▒▓│┤���©╣║╗╝¢¥┐└┴┬├─┼��╚╔╩╦╠═╬¤���������┘┌█▄¦�▀������µ�������¯´­±‗¾¶§÷¸°¨·¹³²■ "
    },
    ibm856: "cp856",
    csibm856: "cp856",
    cp857: {
      type: "_sbcs",
      chars: "ÇüéâäàåçêëèïîıÄÅÉæÆôöòûùİÖÜø£ØŞşáíóúñÑĞğ¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ºªÊËÈ�ÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµ�×ÚÛÙìÿ¯´­±�¾¶§÷¸°¨·¹³²■ "
    },
    ibm857: "cp857",
    csibm857: "cp857",
    cp858: {
      type: "_sbcs",
      chars: "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈ€ÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±‗¾¶§÷¸°¨·¹³²■ "
    },
    ibm858: "cp858",
    csibm858: "cp858",
    cp860: {
      type: "_sbcs",
      chars: "ÇüéâãàÁçêÊèÍÔìÃÂÉÀÈôõòÚùÌÕÜ¢£Ù₧ÓáíóúñÑªº¿Ò¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
    },
    ibm860: "cp860",
    csibm860: "cp860",
    cp861: {
      type: "_sbcs",
      chars: "ÇüéâäàåçêëèÐðÞÄÅÉæÆôöþûÝýÖÜø£Ø₧ƒáíóúÁÍÓÚ¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
    },
    ibm861: "cp861",
    csibm861: "cp861",
    cp862: {
      type: "_sbcs",
      chars: "אבגדהוזחטיךכלםמןנסעףפץצקרשת¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
    },
    ibm862: "cp862",
    csibm862: "cp862",
    cp863: {
      type: "_sbcs",
      chars: "ÇüéâÂà¶çêëèïî‗À§ÉÈÊôËÏûù¤ÔÜ¢£ÙÛƒ¦´óú¨¸³¯Î⌐¬½¼¾«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
    },
    ibm863: "cp863",
    csibm863: "cp863",
    cp864: {
      type: "_sbcs",
      chars: "\0\b	\n\v\f\r !\"#$٪&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~°·∙√▒─│┼┤┬├┴┐┌└┘β∞φ±½¼≈«»ﻷﻸ��ﻻﻼ� ­ﺂ£¤ﺄ��ﺎﺏﺕﺙ،ﺝﺡﺥ٠١٢٣٤٥٦٧٨٩ﻑ؛ﺱﺵﺹ؟¢ﺀﺁﺃﺅﻊﺋﺍﺑﺓﺗﺛﺟﺣﺧﺩﺫﺭﺯﺳﺷﺻﺿﻁﻅﻋﻏ¦¬÷×ﻉـﻓﻗﻛﻟﻣﻧﻫﻭﻯﻳﺽﻌﻎﻍﻡﹽّﻥﻩﻬﻰﻲﻐﻕﻵﻶﻝﻙﻱ■�"
    },
    ibm864: "cp864",
    csibm864: "cp864",
    cp865: {
      type: "_sbcs",
      chars: "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø₧ƒáíóúñÑªº¿⌐¬½¼¡«¤░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ "
    },
    ibm865: "cp865",
    csibm865: "cp865",
    cp866: {
      type: "_sbcs",
      chars: "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№¤■ "
    },
    ibm866: "cp866",
    csibm866: "cp866",
    cp869: {
      type: "_sbcs",
      chars: "������Ά�·¬¦‘’Έ―ΉΊΪΌ��ΎΫ©Ώ²³ά£έήίϊΐόύΑΒΓΔΕΖΗ½ΘΙ«»░▒▓│┤ΚΛΜΝ╣║╗╝ΞΟ┐└┴┬├─┼ΠΡ╚╔╩╦╠═╬ΣΤΥΦΧΨΩαβγ┘┌█▄δε▀ζηθικλμνξοπρσςτ΄­±υφχ§ψ΅°¨ωϋΰώ■ "
    },
    ibm869: "cp869",
    csibm869: "cp869",
    cp922: {
      type: "_sbcs",
      chars: " ¡¢£¤¥¦§¨©ª«¬­®‾°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏŠÑÒÓÔÕÖ×ØÙÚÛÜÝŽßàáâãäåæçèéêëìíîïšñòóôõö÷øùúûüýžÿ"
    },
    ibm922: "cp922",
    csibm922: "cp922",
    cp1046: {
      type: "_sbcs",
      chars: "ﺈ×÷ﹱ■│─┐┌└┘ﹹﹻﹽﹿﹷﺊﻰﻳﻲﻎﻏﻐﻶﻸﻺﻼ ¤ﺋﺑﺗﺛﺟﺣ،­ﺧﺳ٠١٢٣٤٥٦٧٨٩ﺷ؛ﺻﺿﻊ؟ﻋءآأؤإئابةتثجحخدذرزسشصضطﻇعغﻌﺂﺄﺎﻓـفقكلمنهوىيًٌٍَُِّْﻗﻛﻟﻵﻷﻹﻻﻣﻧﻬﻩ�"
    },
    ibm1046: "cp1046",
    csibm1046: "cp1046",
    cp1124: {
      type: "_sbcs",
      chars: " ЁЂҐЄЅІЇЈЉЊЋЌ­ЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя№ёђґєѕіїјљњћќ§ўџ"
    },
    ibm1124: "cp1124",
    csibm1124: "cp1124",
    cp1125: {
      type: "_sbcs",
      chars: "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёҐґЄєІіЇї·√№¤■ "
    },
    ibm1125: "cp1125",
    csibm1125: "cp1125",
    cp1129: {
      type: "_sbcs",
      chars: " ¡¢£¤¥¦§œ©ª«¬­®¯°±²³Ÿµ¶·Œ¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ"
    },
    ibm1129: "cp1129",
    csibm1129: "cp1129",
    cp1133: {
      type: "_sbcs",
      chars: " ກຂຄງຈສຊຍດຕຖທນບປຜຝພຟມຢຣລວຫອຮ���ຯະາຳິີຶືຸູຼັົຽ���ເແໂໃໄ່້໊໋໌ໍໆ�ໜໝ₭����������������໐໑໒໓໔໕໖໗໘໙��¢¬¦�"
    },
    ibm1133: "cp1133",
    csibm1133: "cp1133",
    cp1161: {
      type: "_sbcs",
      chars: "��������������������������������่กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู้๊๋€฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛¢¬¦ "
    },
    ibm1161: "cp1161",
    csibm1161: "cp1161",
    cp1162: {
      type: "_sbcs",
      chars: "€…‘’“”•–— กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
    },
    ibm1162: "cp1162",
    csibm1162: "cp1162",
    cp1163: {
      type: "_sbcs",
      chars: " ¡¢£€¥¦§œ©ª«¬­®¯°±²³Ÿµ¶·Œ¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ"
    },
    ibm1163: "cp1163",
    csibm1163: "cp1163",
    maccroatian: {
      type: "_sbcs",
      chars: "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊�©⁄¤‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ"
    },
    maccyrillic: {
      type: "_sbcs",
      chars: "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°¢£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµ∂ЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю¤"
    },
    macgreek: {
      type: "_sbcs",
      chars: "Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦­ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ�"
    },
    maciceland: {
      type: "_sbcs",
      chars: "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
    },
    macroman: {
      type: "_sbcs",
      chars: "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
    },
    macromania: {
      type: "_sbcs",
      chars: "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂŞ∞±≤≥¥µ∂∑∏π∫ªºΩăş¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›Ţţ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
    },
    macthai: {
      type: "_sbcs",
      chars: "«»…“”�•‘’� กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู﻿​–—฿เแโใไๅๆ็่้๊๋์ํ™๏๐๑๒๓๔๕๖๗๘๙®©����"
    },
    macturkish: {
      type: "_sbcs",
      chars: "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙ�ˆ˜¯˘˙˚¸˝˛ˇ"
    },
    macukraine: {
      type: "_sbcs",
      chars: "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю¤"
    },
    koi8r: {
      type: "_sbcs",
      chars: "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ё╓╔╕╖╗╘╙╚╛╜╝╞╟╠╡Ё╢╣╤╥╦╧╨╩╪╫╬©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
    },
    koi8u: {
      type: "_sbcs",
      chars: "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ёє╔ії╗╘╙╚╛ґ╝╞╟╠╡ЁЄ╣ІЇ╦╧╨╩╪Ґ╬©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
    },
    koi8ru: {
      type: "_sbcs",
      chars: "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ёє╔ії╗╘╙╚╛ґў╞╟╠╡ЁЄ╣ІЇ╦╧╨╩╪ҐЎ©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
    },
    koi8t: {
      type: "_sbcs",
      chars: "қғ‚Ғ„…†‡�‰ҳ‹ҲҷҶ�Қ‘’“”•–—�™�›�����ӯӮё¤ӣ¦§���«¬­®�°±²Ё�Ӣ¶·�№�»���©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ"
    },
    armscii8: {
      type: "_sbcs",
      chars: " �և։)(»«—.՝,-֊…՜՛՞ԱաԲբԳգԴդԵեԶզԷէԸըԹթԺժԻիԼլԽխԾծԿկՀհՁձՂղՃճՄմՅյՆնՇշՈոՉչՊպՋջՌռՍսՎվՏտՐրՑցՒւՓփՔքՕօՖֆ՚�"
    },
    rk1048: {
      type: "_sbcs",
      chars: "ЂЃ‚ѓ„…†‡€‰Љ‹ЊҚҺЏђ‘’“”•–—�™љ›њқһџ ҰұӘ¤Ө¦§Ё©Ғ«¬­®Ү°±Ііөµ¶·ё№ғ»әҢңүАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
    },
    tcvn: {
      type: "_sbcs",
      chars: "\0ÚỤỪỬỮ\b	\n\v\f\rỨỰỲỶỸÝỴ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ÀẢÃÁẠẶẬÈẺẼÉẸỆÌỈĨÍỊÒỎÕÓỌỘỜỞỠỚỢÙỦŨ ĂÂÊÔƠƯĐăâêôơưđẶ̀̀̉̃́àảãáạẲằẳẵắẴẮẦẨẪẤỀặầẩẫấậèỂẻẽéẹềểễếệìỉỄẾỒĩíịòỔỏõóọồổỗốộờởỡớợùỖủũúụừửữứựỳỷỹýỵỐ"
    },
    georgianacademy: {
      type: "_sbcs",
      chars: "‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿აბგდევზთიკლმნოპჟრსტუფქღყშჩცძწჭხჯჰჱჲჳჴჵჶçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
    },
    georgianps: {
      type: "_sbcs",
      chars: "‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿აბგდევზჱთიკლმნჲოპჟრსტჳუფქღყშჩცძწჭხჴჯჰჵæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
    },
    pt154: {
      type: "_sbcs",
      chars: "ҖҒӮғ„…ҶҮҲүҠӢҢҚҺҸҗ‘’“”•–—ҳҷҡӣңқһҹ ЎўЈӨҘҰ§Ё©Ә«¬ӯ®Ҝ°ұІіҙө¶·ё№ә»јҪҫҝАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
    },
    viscii: {
      type: "_sbcs",
      chars: "\0ẲẴẪ\b	\n\v\f\rỶỸỴ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ẠẮẰẶẤẦẨẬẼẸẾỀỂỄỆỐỒỔỖỘỢỚỜỞỊỎỌỈỦŨỤỲÕắằặấầẩậẽẹếềểễệốồổỗỠƠộờởịỰỨỪỬơớƯÀÁÂÃẢĂẳẵÈÉÊẺÌÍĨỳĐứÒÓÔạỷừửÙÚỹỵÝỡưàáâãảăữẫèéêẻìíĩỉđựòóôõỏọụùúũủýợỮ"
    },
    iso646cn: {
      type: "_sbcs",
      chars: "\0\b	\n\v\f\r !\"#¥%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}‾��������������������������������������������������������������������������������������������������������������������������������"
    },
    iso646jp: {
      type: "_sbcs",
      chars: "\0\b	\n\v\f\r !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[¥]^_`abcdefghijklmnopqrstuvwxyz{|}‾��������������������������������������������������������������������������������������������������������������������������������"
    },
    hproman8: {
      type: "_sbcs",
      chars: " ÀÂÈÊËÎÏ´ˋˆ¨˜ÙÛ₤¯Ýý°ÇçÑñ¡¿¤£¥§ƒ¢âêôûáéóúàèòùäëöüÅîØÆåíøæÄìÖÜÉïßÔÁÃãÐðÍÌÓÒÕõŠšÚŸÿÞþ·µ¶¾—¼½ªº«■»±�"
    },
    macintosh: {
      type: "_sbcs",
      chars: "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ"
    },
    ascii: {
      type: "_sbcs",
      chars: "��������������������������������������������������������������������������������������������������������������������������������"
    },
    tis620: {
      type: "_sbcs",
      chars: "���������������������������������กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����"
    }
  };
});

// node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = __commonJS((exports) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  exports._dbcs = DBCSCodec;
  var UNASSIGNED = -1;
  var GB18030_CODE = -2;
  var SEQ_START = -10;
  var NODE_START = -1e3;
  var UNASSIGNED_NODE = new Array(256);
  var DEF_CHAR = -1;
  for (var i2 = 0; i2 < 256; i2++)
    UNASSIGNED_NODE[i2] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i3 = 0; i3 < mappingTable.length; i3++)
      this._addDecodeChunk(mappingTable[i3]);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var commonThirdByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var commonFourthByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var firstByteNode = this.decodeTables[0];
      for (var i3 = 129; i3 <= 254; i3++) {
        var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i3]];
        for (var j2 = 48; j2 <= 57; j2++) {
          if (secondByteNode[j2] === UNASSIGNED) {
            secondByteNode[j2] = NODE_START - commonThirdByteNodeIdx;
          } else if (secondByteNode[j2] > NODE_START) {
            throw new Error("gb18030 decode tables conflict at byte 2");
          }
          var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j2]];
          for (var k2 = 129; k2 <= 254; k2++) {
            if (thirdByteNode[k2] === UNASSIGNED) {
              thirdByteNode[k2] = NODE_START - commonFourthByteNodeIdx;
            } else if (thirdByteNode[k2] === NODE_START - commonFourthByteNodeIdx) {
              continue;
            } else if (thirdByteNode[k2] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 3");
            }
            var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k2]];
            for (var l2 = 48; l2 <= 57; l2++) {
              if (fourthByteNode[l2] === UNASSIGNED)
                fourthByteNode[l2] = GB18030_CODE;
            }
          }
        }
      }
    }
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i3 = 0; i3 < codecOptions.encodeSkipVals.length; i3++) {
        var val = codecOptions.encodeSkipVals[i3];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j2 = val.from; j2 <= val.to; j2++)
            skipEncodeChars[j2] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED)
      this.defCharSB = "?".charCodeAt(0);
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>>= 8)
      bytes.push(addr & 255);
    if (bytes.length == 0)
      bytes.push(0);
    var node = this.decodeTables[0];
    for (var i3 = bytes.length - 1; i3 > 0; i3--) {
      var val = node[bytes[i3]];
      if (val == UNASSIGNED) {
        node[bytes[i3]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k2 = 1; k2 < chunk.length; k2++) {
      var part = chunk[k2];
      if (typeof part === "string") {
        for (var l2 = 0; l2 < part.length; ) {
          var code = part.charCodeAt(l2++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l2++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq = [];
            for (var m2 = 0; m2 < len; m2++)
              seq.push(part.charCodeAt(l2++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l2 = 0; l2 < part; l2++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === void 0)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node;
    if (bucket[low] <= SEQ_START) {
      node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node = {};
      if (bucket[low] !== UNASSIGNED)
        node[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node);
    }
    for (var j2 = 1; j2 < seq.length - 1; j2++) {
      var oldVal = node[uCode];
      if (typeof oldVal === "object")
        node = oldVal;
      else {
        node = node[uCode] = {};
        if (oldVal !== void 0)
          node[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for (var i3 = 0; i3 < 256; i3++) {
      var uCode = node[i3];
      var mbCode = prefix + i3;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0) {
        this._setEncodeChar(uCode, mbCode);
        hasValues = true;
      } else if (uCode <= NODE_START) {
        var subNodeIdx = NODE_START - uCode;
        if (!subNodeEmpty[subNodeIdx]) {
          var newPrefix = mbCode << 8 >>> 0;
          if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
            hasValues = true;
          else
            subNodeEmpty[subNodeIdx] = true;
        }
      } else if (uCode <= SEQ_START) {
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        hasValues = true;
      }
    }
    return hasValues;
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = void 0;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i3 = 0, j2 = 0;
    while (true) {
      if (nextChar === -1) {
        if (i3 == str.length)
          break;
        var uCode = str.charCodeAt(i3++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == void 0) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== void 0) {
            dbcsCode = resCode;
            nextChar = uCode;
          } else {
          }
        }
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j2++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j2++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j2++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j2++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j2++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j2++] = dbcsCode >> 8;
        newBuf[j2++] = dbcsCode & 255;
      } else if (dbcsCode < 16777216) {
        newBuf[j2++] = dbcsCode >> 16;
        newBuf[j2++] = dbcsCode >> 8 & 255;
        newBuf[j2++] = dbcsCode & 255;
      } else {
        newBuf[j2++] = dbcsCode >>> 24;
        newBuf[j2++] = dbcsCode >>> 16 & 255;
        newBuf[j2++] = dbcsCode >>> 8 & 255;
        newBuf[j2++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j2);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === void 0)
      return;
    var newBuf = Buffer2.alloc(10), j2 = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== void 0) {
        if (dbcsCode < 256) {
          newBuf[j2++] = dbcsCode;
        } else {
          newBuf[j2++] = dbcsCode >> 8;
          newBuf[j2++] = dbcsCode & 255;
        }
      } else {
      }
      this.seqObj = void 0;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j2++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j2);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBytes = [];
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
    for (var i3 = 0, j2 = 0; i3 < buf.length; i3++) {
      var curByte = i3 >= 0 ? buf[i3] : prevBytes[i3 + prevOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) {
      } else if (uCode === UNASSIGNED) {
        uCode = this.defaultCharUnicode.charCodeAt(0);
        i3 = seqStart;
      } else if (uCode === GB18030_CODE) {
        if (i3 >= 3) {
          var ptr = (buf[i3 - 3] - 129) * 12600 + (buf[i3 - 2] - 48) * 1260 + (buf[i3 - 1] - 129) * 10 + (curByte - 48);
        } else {
          var ptr = (prevBytes[i3 - 3 + prevOffset] - 129) * 12600 + ((i3 - 2 >= 0 ? buf[i3 - 2] : prevBytes[i3 - 2 + prevOffset]) - 48) * 1260 + ((i3 - 1 >= 0 ? buf[i3 - 1] : prevBytes[i3 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
        }
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k2 = 0; k2 < seq.length - 1; k2++) {
          uCode = seq[k2];
          newBuf[j2++] = uCode & 255;
          newBuf[j2++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode >= 65536) {
        uCode -= 65536;
        var uCodeLead = 55296 | uCode >> 10;
        newBuf[j2++] = uCodeLead & 255;
        newBuf[j2++] = uCodeLead >> 8;
        uCode = 56320 | uCode & 1023;
      }
      newBuf[j2++] = uCode & 255;
      newBuf[j2++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i3 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
    return newBuf.slice(0, j2).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBytes.length > 0) {
      ret += this.defaultCharUnicode;
      var bytesArr = this.prevBytes.slice(1);
      this.prevBytes = [];
      this.nodeIdx = 0;
      if (bytesArr.length > 0)
        ret += this.write(bytesArr);
    }
    this.prevBytes = [];
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l2 = 0, r2 = table.length;
    while (l2 < r2 - 1) {
      var mid = l2 + (r2 - l2 + 1 >> 1);
      if (table[mid] <= val)
        l2 = mid;
      else
        r2 = mid;
    }
    return l2;
  }
});

// node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\0", 128],
    ["a1", "｡", 62],
    ["8140", "　、。，．・：；？！゛゜´｀¨＾￣＿ヽヾゝゞ〃仝々〆〇ー―‐／＼～∥｜…‥‘’“”（）〔〕［］｛｝〈", 9, "＋－±×"],
    ["8180", "÷＝≠＜＞≦≧∞∴♂♀°′″℃￥＄￠￡％＃＆＊＠§☆★○●◎◇◆□■△▲▽▼※〒→←↑↓〓"],
    ["81b8", "∈∋⊆⊇⊂⊃∪∩"],
    ["81c8", "∧∨￢⇒⇔∀∃"],
    ["81da", "∠⊥⌒∂∇≡≒≪≫√∽∝∵∫∬"],
    ["81f0", "Å‰♯♭♪†‡¶"],
    ["81fc", "◯"],
    ["824f", "０", 9],
    ["8260", "Ａ", 25],
    ["8281", "ａ", 25],
    ["829f", "ぁ", 82],
    ["8340", "ァ", 62],
    ["8380", "ム", 22],
    ["839f", "Α", 16, "Σ", 6],
    ["83bf", "α", 16, "σ", 6],
    ["8440", "А", 5, "ЁЖ", 25],
    ["8470", "а", 5, "ёж", 7],
    ["8480", "о", 17],
    ["849f", "─│┌┐┘└├┬┤┴┼━┃┏┓┛┗┣┳┫┻╋┠┯┨┷┿┝┰┥┸╂"],
    ["8740", "①", 19, "Ⅰ", 9],
    ["875f", "㍉㌔㌢㍍㌘㌧㌃㌶㍑㍗㌍㌦㌣㌫㍊㌻㎜㎝㎞㎎㎏㏄㎡"],
    ["877e", "㍻"],
    ["8780", "〝〟№㏍℡㊤", 4, "㈱㈲㈹㍾㍽㍼≒≡∫∮∑√⊥∠∟⊿∵∩∪"],
    ["889f", "亜唖娃阿哀愛挨姶逢葵茜穐悪握渥旭葦芦鯵梓圧斡扱宛姐虻飴絢綾鮎或粟袷安庵按暗案闇鞍杏以伊位依偉囲夷委威尉惟意慰易椅為畏異移維緯胃萎衣謂違遺医井亥域育郁磯一壱溢逸稲茨芋鰯允印咽員因姻引飲淫胤蔭"],
    ["8940", "院陰隠韻吋右宇烏羽迂雨卯鵜窺丑碓臼渦嘘唄欝蔚鰻姥厩浦瓜閏噂云運雲荏餌叡営嬰影映曳栄永泳洩瑛盈穎頴英衛詠鋭液疫益駅悦謁越閲榎厭円"],
    ["8980", "園堰奄宴延怨掩援沿演炎焔煙燕猿縁艶苑薗遠鉛鴛塩於汚甥凹央奥往応押旺横欧殴王翁襖鴬鴎黄岡沖荻億屋憶臆桶牡乙俺卸恩温穏音下化仮何伽価佳加可嘉夏嫁家寡科暇果架歌河火珂禍禾稼箇花苛茄荷華菓蝦課嘩貨迦過霞蚊俄峨我牙画臥芽蛾賀雅餓駕介会解回塊壊廻快怪悔恢懐戒拐改"],
    ["8a40", "魁晦械海灰界皆絵芥蟹開階貝凱劾外咳害崖慨概涯碍蓋街該鎧骸浬馨蛙垣柿蛎鈎劃嚇各廓拡撹格核殻獲確穫覚角赫較郭閣隔革学岳楽額顎掛笠樫"],
    ["8a80", "橿梶鰍潟割喝恰括活渇滑葛褐轄且鰹叶椛樺鞄株兜竃蒲釜鎌噛鴨栢茅萱粥刈苅瓦乾侃冠寒刊勘勧巻喚堪姦完官寛干幹患感慣憾換敢柑桓棺款歓汗漢澗潅環甘監看竿管簡緩缶翰肝艦莞観諌貫還鑑間閑関陥韓館舘丸含岸巌玩癌眼岩翫贋雁頑顔願企伎危喜器基奇嬉寄岐希幾忌揮机旗既期棋棄"],
    ["8b40", "機帰毅気汽畿祈季稀紀徽規記貴起軌輝飢騎鬼亀偽儀妓宜戯技擬欺犠疑祇義蟻誼議掬菊鞠吉吃喫桔橘詰砧杵黍却客脚虐逆丘久仇休及吸宮弓急救"],
    ["8b80", "朽求汲泣灸球究窮笈級糾給旧牛去居巨拒拠挙渠虚許距鋸漁禦魚亨享京供侠僑兇競共凶協匡卿叫喬境峡強彊怯恐恭挟教橋況狂狭矯胸脅興蕎郷鏡響饗驚仰凝尭暁業局曲極玉桐粁僅勤均巾錦斤欣欽琴禁禽筋緊芹菌衿襟謹近金吟銀九倶句区狗玖矩苦躯駆駈駒具愚虞喰空偶寓遇隅串櫛釧屑屈"],
    ["8c40", "掘窟沓靴轡窪熊隈粂栗繰桑鍬勲君薫訓群軍郡卦袈祁係傾刑兄啓圭珪型契形径恵慶慧憩掲携敬景桂渓畦稽系経継繋罫茎荊蛍計詣警軽頚鶏芸迎鯨"],
    ["8c80", "劇戟撃激隙桁傑欠決潔穴結血訣月件倹倦健兼券剣喧圏堅嫌建憲懸拳捲検権牽犬献研硯絹県肩見謙賢軒遣鍵険顕験鹸元原厳幻弦減源玄現絃舷言諺限乎個古呼固姑孤己庫弧戸故枯湖狐糊袴股胡菰虎誇跨鈷雇顧鼓五互伍午呉吾娯後御悟梧檎瑚碁語誤護醐乞鯉交佼侯候倖光公功効勾厚口向"],
    ["8d40", "后喉坑垢好孔孝宏工巧巷幸広庚康弘恒慌抗拘控攻昂晃更杭校梗構江洪浩港溝甲皇硬稿糠紅紘絞綱耕考肯肱腔膏航荒行衡講貢購郊酵鉱砿鋼閤降"],
    ["8d80", "項香高鴻剛劫号合壕拷濠豪轟麹克刻告国穀酷鵠黒獄漉腰甑忽惚骨狛込此頃今困坤墾婚恨懇昏昆根梱混痕紺艮魂些佐叉唆嵯左差査沙瑳砂詐鎖裟坐座挫債催再最哉塞妻宰彩才採栽歳済災采犀砕砦祭斎細菜裁載際剤在材罪財冴坂阪堺榊肴咲崎埼碕鷺作削咋搾昨朔柵窄策索錯桜鮭笹匙冊刷"],
    ["8e40", "察拶撮擦札殺薩雑皐鯖捌錆鮫皿晒三傘参山惨撒散桟燦珊産算纂蚕讃賛酸餐斬暫残仕仔伺使刺司史嗣四士始姉姿子屍市師志思指支孜斯施旨枝止"],
    ["8e80", "死氏獅祉私糸紙紫肢脂至視詞詩試誌諮資賜雌飼歯事似侍児字寺慈持時次滋治爾璽痔磁示而耳自蒔辞汐鹿式識鴫竺軸宍雫七叱執失嫉室悉湿漆疾質実蔀篠偲柴芝屡蕊縞舎写射捨赦斜煮社紗者謝車遮蛇邪借勺尺杓灼爵酌釈錫若寂弱惹主取守手朱殊狩珠種腫趣酒首儒受呪寿授樹綬需囚収周"],
    ["8f40", "宗就州修愁拾洲秀秋終繍習臭舟蒐衆襲讐蹴輯週酋酬集醜什住充十従戎柔汁渋獣縦重銃叔夙宿淑祝縮粛塾熟出術述俊峻春瞬竣舜駿准循旬楯殉淳"],
    ["8f80", "準潤盾純巡遵醇順処初所暑曙渚庶緒署書薯藷諸助叙女序徐恕鋤除傷償勝匠升召哨商唱嘗奨妾娼宵将小少尚庄床廠彰承抄招掌捷昇昌昭晶松梢樟樵沼消渉湘焼焦照症省硝礁祥称章笑粧紹肖菖蒋蕉衝裳訟証詔詳象賞醤鉦鍾鐘障鞘上丈丞乗冗剰城場壌嬢常情擾条杖浄状畳穣蒸譲醸錠嘱埴飾"],
    ["9040", "拭植殖燭織職色触食蝕辱尻伸信侵唇娠寝審心慎振新晋森榛浸深申疹真神秦紳臣芯薪親診身辛進針震人仁刃塵壬尋甚尽腎訊迅陣靭笥諏須酢図厨"],
    ["9080", "逗吹垂帥推水炊睡粋翠衰遂酔錐錘随瑞髄崇嵩数枢趨雛据杉椙菅頗雀裾澄摺寸世瀬畝是凄制勢姓征性成政整星晴棲栖正清牲生盛精聖声製西誠誓請逝醒青静斉税脆隻席惜戚斥昔析石積籍績脊責赤跡蹟碩切拙接摂折設窃節説雪絶舌蝉仙先千占宣専尖川戦扇撰栓栴泉浅洗染潜煎煽旋穿箭線"],
    ["9140", "繊羨腺舛船薦詮賎践選遷銭銑閃鮮前善漸然全禅繕膳糎噌塑岨措曾曽楚狙疏疎礎祖租粗素組蘇訴阻遡鼠僧創双叢倉喪壮奏爽宋層匝惣想捜掃挿掻"],
    ["9180", "操早曹巣槍槽漕燥争痩相窓糟総綜聡草荘葬蒼藻装走送遭鎗霜騒像増憎臓蔵贈造促側則即息捉束測足速俗属賊族続卒袖其揃存孫尊損村遜他多太汰詑唾堕妥惰打柁舵楕陀駄騨体堆対耐岱帯待怠態戴替泰滞胎腿苔袋貸退逮隊黛鯛代台大第醍題鷹滝瀧卓啄宅托択拓沢濯琢託鐸濁諾茸凧蛸只"],
    ["9240", "叩但達辰奪脱巽竪辿棚谷狸鱈樽誰丹単嘆坦担探旦歎淡湛炭短端箪綻耽胆蛋誕鍛団壇弾断暖檀段男談値知地弛恥智池痴稚置致蜘遅馳築畜竹筑蓄"],
    ["9280", "逐秩窒茶嫡着中仲宙忠抽昼柱注虫衷註酎鋳駐樗瀦猪苧著貯丁兆凋喋寵帖帳庁弔張彫徴懲挑暢朝潮牒町眺聴脹腸蝶調諜超跳銚長頂鳥勅捗直朕沈珍賃鎮陳津墜椎槌追鎚痛通塚栂掴槻佃漬柘辻蔦綴鍔椿潰坪壷嬬紬爪吊釣鶴亭低停偵剃貞呈堤定帝底庭廷弟悌抵挺提梯汀碇禎程締艇訂諦蹄逓"],
    ["9340", "邸鄭釘鼎泥摘擢敵滴的笛適鏑溺哲徹撤轍迭鉄典填天展店添纏甜貼転顛点伝殿澱田電兎吐堵塗妬屠徒斗杜渡登菟賭途都鍍砥砺努度土奴怒倒党冬"],
    ["9380", "凍刀唐塔塘套宕島嶋悼投搭東桃梼棟盗淘湯涛灯燈当痘祷等答筒糖統到董蕩藤討謄豆踏逃透鐙陶頭騰闘働動同堂導憧撞洞瞳童胴萄道銅峠鴇匿得徳涜特督禿篤毒独読栃橡凸突椴届鳶苫寅酉瀞噸屯惇敦沌豚遁頓呑曇鈍奈那内乍凪薙謎灘捺鍋楢馴縄畷南楠軟難汝二尼弐迩匂賑肉虹廿日乳入"],
    ["9440", "如尿韮任妊忍認濡禰祢寧葱猫熱年念捻撚燃粘乃廼之埜嚢悩濃納能脳膿農覗蚤巴把播覇杷波派琶破婆罵芭馬俳廃拝排敗杯盃牌背肺輩配倍培媒梅"],
    ["9480", "楳煤狽買売賠陪這蝿秤矧萩伯剥博拍柏泊白箔粕舶薄迫曝漠爆縛莫駁麦函箱硲箸肇筈櫨幡肌畑畠八鉢溌発醗髪伐罰抜筏閥鳩噺塙蛤隼伴判半反叛帆搬斑板氾汎版犯班畔繁般藩販範釆煩頒飯挽晩番盤磐蕃蛮匪卑否妃庇彼悲扉批披斐比泌疲皮碑秘緋罷肥被誹費避非飛樋簸備尾微枇毘琵眉美"],
    ["9540", "鼻柊稗匹疋髭彦膝菱肘弼必畢筆逼桧姫媛紐百謬俵彪標氷漂瓢票表評豹廟描病秒苗錨鋲蒜蛭鰭品彬斌浜瀕貧賓頻敏瓶不付埠夫婦富冨布府怖扶敷"],
    ["9580", "斧普浮父符腐膚芙譜負賦赴阜附侮撫武舞葡蕪部封楓風葺蕗伏副復幅服福腹複覆淵弗払沸仏物鮒分吻噴墳憤扮焚奮粉糞紛雰文聞丙併兵塀幣平弊柄並蔽閉陛米頁僻壁癖碧別瞥蔑箆偏変片篇編辺返遍便勉娩弁鞭保舗鋪圃捕歩甫補輔穂募墓慕戊暮母簿菩倣俸包呆報奉宝峰峯崩庖抱捧放方朋"],
    ["9640", "法泡烹砲縫胞芳萌蓬蜂褒訪豊邦鋒飽鳳鵬乏亡傍剖坊妨帽忘忙房暴望某棒冒紡肪膨謀貌貿鉾防吠頬北僕卜墨撲朴牧睦穆釦勃没殆堀幌奔本翻凡盆"],
    ["9680", "摩磨魔麻埋妹昧枚毎哩槙幕膜枕鮪柾鱒桝亦俣又抹末沫迄侭繭麿万慢満漫蔓味未魅巳箕岬密蜜湊蓑稔脈妙粍民眠務夢無牟矛霧鵡椋婿娘冥名命明盟迷銘鳴姪牝滅免棉綿緬面麺摸模茂妄孟毛猛盲網耗蒙儲木黙目杢勿餅尤戻籾貰問悶紋門匁也冶夜爺耶野弥矢厄役約薬訳躍靖柳薮鑓愉愈油癒"],
    ["9740", "諭輸唯佑優勇友宥幽悠憂揖有柚湧涌猶猷由祐裕誘遊邑郵雄融夕予余与誉輿預傭幼妖容庸揚揺擁曜楊様洋溶熔用窯羊耀葉蓉要謡踊遥陽養慾抑欲"],
    ["9780", "沃浴翌翼淀羅螺裸来莱頼雷洛絡落酪乱卵嵐欄濫藍蘭覧利吏履李梨理璃痢裏裡里離陸律率立葎掠略劉流溜琉留硫粒隆竜龍侶慮旅虜了亮僚両凌寮料梁涼猟療瞭稜糧良諒遼量陵領力緑倫厘林淋燐琳臨輪隣鱗麟瑠塁涙累類令伶例冷励嶺怜玲礼苓鈴隷零霊麗齢暦歴列劣烈裂廉恋憐漣煉簾練聯"],
    ["9840", "蓮連錬呂魯櫓炉賂路露労婁廊弄朗楼榔浪漏牢狼篭老聾蝋郎六麓禄肋録論倭和話歪賄脇惑枠鷲亙亘鰐詫藁蕨椀湾碗腕"],
    ["989f", "弌丐丕个丱丶丼丿乂乖乘亂亅豫亊舒弍于亞亟亠亢亰亳亶从仍仄仆仂仗仞仭仟价伉佚估佛佝佗佇佶侈侏侘佻佩佰侑佯來侖儘俔俟俎俘俛俑俚俐俤俥倚倨倔倪倥倅伜俶倡倩倬俾俯們倆偃假會偕偐偈做偖偬偸傀傚傅傴傲"],
    ["9940", "僉僊傳僂僖僞僥僭僣僮價僵儉儁儂儖儕儔儚儡儺儷儼儻儿兀兒兌兔兢竸兩兪兮冀冂囘册冉冏冑冓冕冖冤冦冢冩冪冫决冱冲冰况冽凅凉凛几處凩凭"],
    ["9980", "凰凵凾刄刋刔刎刧刪刮刳刹剏剄剋剌剞剔剪剴剩剳剿剽劍劔劒剱劈劑辨辧劬劭劼劵勁勍勗勞勣勦飭勠勳勵勸勹匆匈甸匍匐匏匕匚匣匯匱匳匸區卆卅丗卉卍凖卞卩卮夘卻卷厂厖厠厦厥厮厰厶參簒雙叟曼燮叮叨叭叺吁吽呀听吭吼吮吶吩吝呎咏呵咎呟呱呷呰咒呻咀呶咄咐咆哇咢咸咥咬哄哈咨"],
    ["9a40", "咫哂咤咾咼哘哥哦唏唔哽哮哭哺哢唹啀啣啌售啜啅啖啗唸唳啝喙喀咯喊喟啻啾喘喞單啼喃喩喇喨嗚嗅嗟嗄嗜嗤嗔嘔嗷嘖嗾嗽嘛嗹噎噐營嘴嘶嘲嘸"],
    ["9a80", "噫噤嘯噬噪嚆嚀嚊嚠嚔嚏嚥嚮嚶嚴囂嚼囁囃囀囈囎囑囓囗囮囹圀囿圄圉圈國圍圓團圖嗇圜圦圷圸坎圻址坏坩埀垈坡坿垉垓垠垳垤垪垰埃埆埔埒埓堊埖埣堋堙堝塲堡塢塋塰毀塒堽塹墅墹墟墫墺壞墻墸墮壅壓壑壗壙壘壥壜壤壟壯壺壹壻壼壽夂夊夐夛梦夥夬夭夲夸夾竒奕奐奎奚奘奢奠奧奬奩"],
    ["9b40", "奸妁妝佞侫妣妲姆姨姜妍姙姚娥娟娑娜娉娚婀婬婉娵娶婢婪媚媼媾嫋嫂媽嫣嫗嫦嫩嫖嫺嫻嬌嬋嬖嬲嫐嬪嬶嬾孃孅孀孑孕孚孛孥孩孰孳孵學斈孺宀"],
    ["9b80", "它宦宸寃寇寉寔寐寤實寢寞寥寫寰寶寳尅將專對尓尠尢尨尸尹屁屆屎屓屐屏孱屬屮乢屶屹岌岑岔妛岫岻岶岼岷峅岾峇峙峩峽峺峭嶌峪崋崕崗嵜崟崛崑崔崢崚崙崘嵌嵒嵎嵋嵬嵳嵶嶇嶄嶂嶢嶝嶬嶮嶽嶐嶷嶼巉巍巓巒巖巛巫已巵帋帚帙帑帛帶帷幄幃幀幎幗幔幟幢幤幇幵并幺麼广庠廁廂廈廐廏"],
    ["9c40", "廖廣廝廚廛廢廡廨廩廬廱廳廰廴廸廾弃弉彝彜弋弑弖弩弭弸彁彈彌彎弯彑彖彗彙彡彭彳彷徃徂彿徊很徑徇從徙徘徠徨徭徼忖忻忤忸忱忝悳忿怡恠"],
    ["9c80", "怙怐怩怎怱怛怕怫怦怏怺恚恁恪恷恟恊恆恍恣恃恤恂恬恫恙悁悍惧悃悚悄悛悖悗悒悧悋惡悸惠惓悴忰悽惆悵惘慍愕愆惶惷愀惴惺愃愡惻惱愍愎慇愾愨愧慊愿愼愬愴愽慂慄慳慷慘慙慚慫慴慯慥慱慟慝慓慵憙憖憇憬憔憚憊憑憫憮懌懊應懷懈懃懆憺懋罹懍懦懣懶懺懴懿懽懼懾戀戈戉戍戌戔戛"],
    ["9d40", "戞戡截戮戰戲戳扁扎扞扣扛扠扨扼抂抉找抒抓抖拔抃抔拗拑抻拏拿拆擔拈拜拌拊拂拇抛拉挌拮拱挧挂挈拯拵捐挾捍搜捏掖掎掀掫捶掣掏掉掟掵捫"],
    ["9d80", "捩掾揩揀揆揣揉插揶揄搖搴搆搓搦搶攝搗搨搏摧摯摶摎攪撕撓撥撩撈撼據擒擅擇撻擘擂擱擧舉擠擡抬擣擯攬擶擴擲擺攀擽攘攜攅攤攣攫攴攵攷收攸畋效敖敕敍敘敞敝敲數斂斃變斛斟斫斷旃旆旁旄旌旒旛旙无旡旱杲昊昃旻杳昵昶昴昜晏晄晉晁晞晝晤晧晨晟晢晰暃暈暎暉暄暘暝曁暹曉暾暼"],
    ["9e40", "曄暸曖曚曠昿曦曩曰曵曷朏朖朞朦朧霸朮朿朶杁朸朷杆杞杠杙杣杤枉杰枩杼杪枌枋枦枡枅枷柯枴柬枳柩枸柤柞柝柢柮枹柎柆柧檜栞框栩桀桍栲桎"],
    ["9e80", "梳栫桙档桷桿梟梏梭梔條梛梃檮梹桴梵梠梺椏梍桾椁棊椈棘椢椦棡椌棍棔棧棕椶椒椄棗棣椥棹棠棯椨椪椚椣椡棆楹楷楜楸楫楔楾楮椹楴椽楙椰楡楞楝榁楪榲榮槐榿槁槓榾槎寨槊槝榻槃榧樮榑榠榜榕榴槞槨樂樛槿權槹槲槧樅榱樞槭樔槫樊樒櫁樣樓橄樌橲樶橸橇橢橙橦橈樸樢檐檍檠檄檢檣"],
    ["9f40", "檗蘗檻櫃櫂檸檳檬櫞櫑櫟檪櫚櫪櫻欅蘖櫺欒欖鬱欟欸欷盜欹飮歇歃歉歐歙歔歛歟歡歸歹歿殀殄殃殍殘殕殞殤殪殫殯殲殱殳殷殼毆毋毓毟毬毫毳毯"],
    ["9f80", "麾氈氓气氛氤氣汞汕汢汪沂沍沚沁沛汾汨汳沒沐泄泱泓沽泗泅泝沮沱沾沺泛泯泙泪洟衍洶洫洽洸洙洵洳洒洌浣涓浤浚浹浙涎涕濤涅淹渕渊涵淇淦涸淆淬淞淌淨淒淅淺淙淤淕淪淮渭湮渮渙湲湟渾渣湫渫湶湍渟湃渺湎渤滿渝游溂溪溘滉溷滓溽溯滄溲滔滕溏溥滂溟潁漑灌滬滸滾漿滲漱滯漲滌"],
    ["e040", "漾漓滷澆潺潸澁澀潯潛濳潭澂潼潘澎澑濂潦澳澣澡澤澹濆澪濟濕濬濔濘濱濮濛瀉瀋濺瀑瀁瀏濾瀛瀚潴瀝瀘瀟瀰瀾瀲灑灣炙炒炯烱炬炸炳炮烟烋烝"],
    ["e080", "烙焉烽焜焙煥煕熈煦煢煌煖煬熏燻熄熕熨熬燗熹熾燒燉燔燎燠燬燧燵燼燹燿爍爐爛爨爭爬爰爲爻爼爿牀牆牋牘牴牾犂犁犇犒犖犢犧犹犲狃狆狄狎狒狢狠狡狹狷倏猗猊猜猖猝猴猯猩猥猾獎獏默獗獪獨獰獸獵獻獺珈玳珎玻珀珥珮珞璢琅瑯琥珸琲琺瑕琿瑟瑙瑁瑜瑩瑰瑣瑪瑶瑾璋璞璧瓊瓏瓔珱"],
    ["e140", "瓠瓣瓧瓩瓮瓲瓰瓱瓸瓷甄甃甅甌甎甍甕甓甞甦甬甼畄畍畊畉畛畆畚畩畤畧畫畭畸當疆疇畴疊疉疂疔疚疝疥疣痂疳痃疵疽疸疼疱痍痊痒痙痣痞痾痿"],
    ["e180", "痼瘁痰痺痲痳瘋瘍瘉瘟瘧瘠瘡瘢瘤瘴瘰瘻癇癈癆癜癘癡癢癨癩癪癧癬癰癲癶癸發皀皃皈皋皎皖皓皙皚皰皴皸皹皺盂盍盖盒盞盡盥盧盪蘯盻眈眇眄眩眤眞眥眦眛眷眸睇睚睨睫睛睥睿睾睹瞎瞋瞑瞠瞞瞰瞶瞹瞿瞼瞽瞻矇矍矗矚矜矣矮矼砌砒礦砠礪硅碎硴碆硼碚碌碣碵碪碯磑磆磋磔碾碼磅磊磬"],
    ["e240", "磧磚磽磴礇礒礑礙礬礫祀祠祗祟祚祕祓祺祿禊禝禧齋禪禮禳禹禺秉秕秧秬秡秣稈稍稘稙稠稟禀稱稻稾稷穃穗穉穡穢穩龝穰穹穽窈窗窕窘窖窩竈窰"],
    ["e280", "窶竅竄窿邃竇竊竍竏竕竓站竚竝竡竢竦竭竰笂笏笊笆笳笘笙笞笵笨笶筐筺笄筍笋筌筅筵筥筴筧筰筱筬筮箝箘箟箍箜箚箋箒箏筝箙篋篁篌篏箴篆篝篩簑簔篦篥籠簀簇簓篳篷簗簍篶簣簧簪簟簷簫簽籌籃籔籏籀籐籘籟籤籖籥籬籵粃粐粤粭粢粫粡粨粳粲粱粮粹粽糀糅糂糘糒糜糢鬻糯糲糴糶糺紆"],
    ["e340", "紂紜紕紊絅絋紮紲紿紵絆絳絖絎絲絨絮絏絣經綉絛綏絽綛綺綮綣綵緇綽綫總綢綯緜綸綟綰緘緝緤緞緻緲緡縅縊縣縡縒縱縟縉縋縢繆繦縻縵縹繃縷"],
    ["e380", "縲縺繧繝繖繞繙繚繹繪繩繼繻纃緕繽辮繿纈纉續纒纐纓纔纖纎纛纜缸缺罅罌罍罎罐网罕罔罘罟罠罨罩罧罸羂羆羃羈羇羌羔羞羝羚羣羯羲羹羮羶羸譱翅翆翊翕翔翡翦翩翳翹飜耆耄耋耒耘耙耜耡耨耿耻聊聆聒聘聚聟聢聨聳聲聰聶聹聽聿肄肆肅肛肓肚肭冐肬胛胥胙胝胄胚胖脉胯胱脛脩脣脯腋"],
    ["e440", "隋腆脾腓腑胼腱腮腥腦腴膃膈膊膀膂膠膕膤膣腟膓膩膰膵膾膸膽臀臂膺臉臍臑臙臘臈臚臟臠臧臺臻臾舁舂舅與舊舍舐舖舩舫舸舳艀艙艘艝艚艟艤"],
    ["e480", "艢艨艪艫舮艱艷艸艾芍芒芫芟芻芬苡苣苟苒苴苳苺莓范苻苹苞茆苜茉苙茵茴茖茲茱荀茹荐荅茯茫茗茘莅莚莪莟莢莖茣莎莇莊荼莵荳荵莠莉莨菴萓菫菎菽萃菘萋菁菷萇菠菲萍萢萠莽萸蔆菻葭萪萼蕚蒄葷葫蒭葮蒂葩葆萬葯葹萵蓊葢蒹蒿蒟蓙蓍蒻蓚蓐蓁蓆蓖蒡蔡蓿蓴蔗蔘蔬蔟蔕蔔蓼蕀蕣蕘蕈"],
    ["e540", "蕁蘂蕋蕕薀薤薈薑薊薨蕭薔薛藪薇薜蕷蕾薐藉薺藏薹藐藕藝藥藜藹蘊蘓蘋藾藺蘆蘢蘚蘰蘿虍乕虔號虧虱蚓蚣蚩蚪蚋蚌蚶蚯蛄蛆蚰蛉蠣蚫蛔蛞蛩蛬"],
    ["e580", "蛟蛛蛯蜒蜆蜈蜀蜃蛻蜑蜉蜍蛹蜊蜴蜿蜷蜻蜥蜩蜚蝠蝟蝸蝌蝎蝴蝗蝨蝮蝙蝓蝣蝪蠅螢螟螂螯蟋螽蟀蟐雖螫蟄螳蟇蟆螻蟯蟲蟠蠏蠍蟾蟶蟷蠎蟒蠑蠖蠕蠢蠡蠱蠶蠹蠧蠻衄衂衒衙衞衢衫袁衾袞衵衽袵衲袂袗袒袮袙袢袍袤袰袿袱裃裄裔裘裙裝裹褂裼裴裨裲褄褌褊褓襃褞褥褪褫襁襄褻褶褸襌褝襠襞"],
    ["e640", "襦襤襭襪襯襴襷襾覃覈覊覓覘覡覩覦覬覯覲覺覽覿觀觚觜觝觧觴觸訃訖訐訌訛訝訥訶詁詛詒詆詈詼詭詬詢誅誂誄誨誡誑誥誦誚誣諄諍諂諚諫諳諧"],
    ["e680", "諤諱謔諠諢諷諞諛謌謇謚諡謖謐謗謠謳鞫謦謫謾謨譁譌譏譎證譖譛譚譫譟譬譯譴譽讀讌讎讒讓讖讙讚谺豁谿豈豌豎豐豕豢豬豸豺貂貉貅貊貍貎貔豼貘戝貭貪貽貲貳貮貶賈賁賤賣賚賽賺賻贄贅贊贇贏贍贐齎贓賍贔贖赧赭赱赳趁趙跂趾趺跏跚跖跌跛跋跪跫跟跣跼踈踉跿踝踞踐踟蹂踵踰踴蹊"],
    ["e740", "蹇蹉蹌蹐蹈蹙蹤蹠踪蹣蹕蹶蹲蹼躁躇躅躄躋躊躓躑躔躙躪躡躬躰軆躱躾軅軈軋軛軣軼軻軫軾輊輅輕輒輙輓輜輟輛輌輦輳輻輹轅轂輾轌轉轆轎轗轜"],
    ["e780", "轢轣轤辜辟辣辭辯辷迚迥迢迪迯邇迴逅迹迺逑逕逡逍逞逖逋逧逶逵逹迸遏遐遑遒逎遉逾遖遘遞遨遯遶隨遲邂遽邁邀邊邉邏邨邯邱邵郢郤扈郛鄂鄒鄙鄲鄰酊酖酘酣酥酩酳酲醋醉醂醢醫醯醪醵醴醺釀釁釉釋釐釖釟釡釛釼釵釶鈞釿鈔鈬鈕鈑鉞鉗鉅鉉鉤鉈銕鈿鉋鉐銜銖銓銛鉚鋏銹銷鋩錏鋺鍄錮"],
    ["e840", "錙錢錚錣錺錵錻鍜鍠鍼鍮鍖鎰鎬鎭鎔鎹鏖鏗鏨鏥鏘鏃鏝鏐鏈鏤鐚鐔鐓鐃鐇鐐鐶鐫鐵鐡鐺鑁鑒鑄鑛鑠鑢鑞鑪鈩鑰鑵鑷鑽鑚鑼鑾钁鑿閂閇閊閔閖閘閙"],
    ["e880", "閠閨閧閭閼閻閹閾闊濶闃闍闌闕闔闖關闡闥闢阡阨阮阯陂陌陏陋陷陜陞陝陟陦陲陬隍隘隕隗險隧隱隲隰隴隶隸隹雎雋雉雍襍雜霍雕雹霄霆霈霓霎霑霏霖霙霤霪霰霹霽霾靄靆靈靂靉靜靠靤靦靨勒靫靱靹鞅靼鞁靺鞆鞋鞏鞐鞜鞨鞦鞣鞳鞴韃韆韈韋韜韭齏韲竟韶韵頏頌頸頤頡頷頽顆顏顋顫顯顰"],
    ["e940", "顱顴顳颪颯颱颶飄飃飆飩飫餃餉餒餔餘餡餝餞餤餠餬餮餽餾饂饉饅饐饋饑饒饌饕馗馘馥馭馮馼駟駛駝駘駑駭駮駱駲駻駸騁騏騅駢騙騫騷驅驂驀驃"],
    ["e980", "騾驕驍驛驗驟驢驥驤驩驫驪骭骰骼髀髏髑髓體髞髟髢髣髦髯髫髮髴髱髷髻鬆鬘鬚鬟鬢鬣鬥鬧鬨鬩鬪鬮鬯鬲魄魃魏魍魎魑魘魴鮓鮃鮑鮖鮗鮟鮠鮨鮴鯀鯊鮹鯆鯏鯑鯒鯣鯢鯤鯔鯡鰺鯲鯱鯰鰕鰔鰉鰓鰌鰆鰈鰒鰊鰄鰮鰛鰥鰤鰡鰰鱇鰲鱆鰾鱚鱠鱧鱶鱸鳧鳬鳰鴉鴈鳫鴃鴆鴪鴦鶯鴣鴟鵄鴕鴒鵁鴿鴾鵆鵈"],
    ["ea40", "鵝鵞鵤鵑鵐鵙鵲鶉鶇鶫鵯鵺鶚鶤鶩鶲鷄鷁鶻鶸鶺鷆鷏鷂鷙鷓鷸鷦鷭鷯鷽鸚鸛鸞鹵鹹鹽麁麈麋麌麒麕麑麝麥麩麸麪麭靡黌黎黏黐黔黜點黝黠黥黨黯"],
    ["ea80", "黴黶黷黹黻黼黽鼇鼈皷鼕鼡鼬鼾齊齒齔齣齟齠齡齦齧齬齪齷齲齶龕龜龠堯槇遙瑤凜熙"],
    ["ed40", "纊褜鍈銈蓜俉炻昱棈鋹曻彅丨仡仼伀伃伹佖侒侊侚侔俍偀倢俿倞偆偰偂傔僴僘兊兤冝冾凬刕劜劦勀勛匀匇匤卲厓厲叝﨎咜咊咩哿喆坙坥垬埈埇﨏"],
    ["ed80", "塚增墲夋奓奛奝奣妤妺孖寀甯寘寬尞岦岺峵崧嵓﨑嵂嵭嶸嶹巐弡弴彧德忞恝悅悊惞惕愠惲愑愷愰憘戓抦揵摠撝擎敎昀昕昻昉昮昞昤晥晗晙晴晳暙暠暲暿曺朎朗杦枻桒柀栁桄棏﨓楨﨔榘槢樰橫橆橳橾櫢櫤毖氿汜沆汯泚洄涇浯涖涬淏淸淲淼渹湜渧渼溿澈澵濵瀅瀇瀨炅炫焏焄煜煆煇凞燁燾犱"],
    ["ee40", "犾猤猪獷玽珉珖珣珒琇珵琦琪琩琮瑢璉璟甁畯皂皜皞皛皦益睆劯砡硎硤硺礰礼神祥禔福禛竑竧靖竫箞精絈絜綷綠緖繒罇羡羽茁荢荿菇菶葈蒴蕓蕙"],
    ["ee80", "蕫﨟薰蘒﨡蠇裵訒訷詹誧誾諟諸諶譓譿賰賴贒赶﨣軏﨤逸遧郞都鄕鄧釚釗釞釭釮釤釥鈆鈐鈊鈺鉀鈼鉎鉙鉑鈹鉧銧鉷鉸鋧鋗鋙鋐﨧鋕鋠鋓錥錡鋻﨨錞鋿錝錂鍰鍗鎤鏆鏞鏸鐱鑅鑈閒隆﨩隝隯霳霻靃靍靏靑靕顗顥飯飼餧館馞驎髙髜魵魲鮏鮱鮻鰀鵰鵫鶴鸙黑"],
    ["eeef", "ⅰ", 9, "￢￤＇＂"],
    ["f040", "", 62],
    ["f080", "", 124],
    ["f140", "", 62],
    ["f180", "", 124],
    ["f240", "", 62],
    ["f280", "", 124],
    ["f340", "", 62],
    ["f380", "", 124],
    ["f440", "", 62],
    ["f480", "", 124],
    ["f540", "", 62],
    ["f580", "", 124],
    ["f640", "", 62],
    ["f680", "", 124],
    ["f740", "", 62],
    ["f780", "", 124],
    ["f840", "", 62],
    ["f880", "", 124],
    ["f940", ""],
    ["fa40", "ⅰ", 9, "Ⅰ", 9, "￢￤＇＂㈱№℡∵纊褜鍈銈蓜俉炻昱棈鋹曻彅丨仡仼伀伃伹佖侒侊侚侔俍偀倢俿倞偆偰偂傔僴僘兊"],
    ["fa80", "兤冝冾凬刕劜劦勀勛匀匇匤卲厓厲叝﨎咜咊咩哿喆坙坥垬埈埇﨏塚增墲夋奓奛奝奣妤妺孖寀甯寘寬尞岦岺峵崧嵓﨑嵂嵭嶸嶹巐弡弴彧德忞恝悅悊惞惕愠惲愑愷愰憘戓抦揵摠撝擎敎昀昕昻昉昮昞昤晥晗晙晴晳暙暠暲暿曺朎朗杦枻桒柀栁桄棏﨓楨﨔榘槢樰橫橆橳橾櫢櫤毖氿汜沆汯泚洄涇浯"],
    ["fb40", "涖涬淏淸淲淼渹湜渧渼溿澈澵濵瀅瀇瀨炅炫焏焄煜煆煇凞燁燾犱犾猤猪獷玽珉珖珣珒琇珵琦琪琩琮瑢璉璟甁畯皂皜皞皛皦益睆劯砡硎硤硺礰礼神"],
    ["fb80", "祥禔福禛竑竧靖竫箞精絈絜綷綠緖繒罇羡羽茁荢荿菇菶葈蒴蕓蕙蕫﨟薰蘒﨡蠇裵訒訷詹誧誾諟諸諶譓譿賰賴贒赶﨣軏﨤逸遧郞都鄕鄧釚釗釞釭釮釤釥鈆鈐鈊鈺鉀鈼鉎鉙鉑鈹鉧銧鉷鉸鋧鋗鋙鋐﨧鋕鋠鋓錥錡鋻﨨錞鋿錝錂鍰鍗鎤鏆鏞鏸鐱鑅鑈閒隆﨩隝隯霳霻靃靍靏靑靕顗顥飯飼餧館馞驎髙"],
    ["fc40", "髜魵魲鮏鮱鮻鰀鵰鵫鶴鸙黑"]
  ];
});

// node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\0", 127],
    ["8ea1", "｡", 62],
    ["a1a1", "　、。，．・：；？！゛゜´｀¨＾￣＿ヽヾゝゞ〃仝々〆〇ー―‐／＼～∥｜…‥‘’“”（）〔〕［］｛｝〈", 9, "＋－±×÷＝≠＜＞≦≧∞∴♂♀°′″℃￥＄￠￡％＃＆＊＠§☆★○●◎◇"],
    ["a2a1", "◆□■△▲▽▼※〒→←↑↓〓"],
    ["a2ba", "∈∋⊆⊇⊂⊃∪∩"],
    ["a2ca", "∧∨￢⇒⇔∀∃"],
    ["a2dc", "∠⊥⌒∂∇≡≒≪≫√∽∝∵∫∬"],
    ["a2f2", "Å‰♯♭♪†‡¶"],
    ["a2fe", "◯"],
    ["a3b0", "０", 9],
    ["a3c1", "Ａ", 25],
    ["a3e1", "ａ", 25],
    ["a4a1", "ぁ", 82],
    ["a5a1", "ァ", 85],
    ["a6a1", "Α", 16, "Σ", 6],
    ["a6c1", "α", 16, "σ", 6],
    ["a7a1", "А", 5, "ЁЖ", 25],
    ["a7d1", "а", 5, "ёж", 25],
    ["a8a1", "─│┌┐┘└├┬┤┴┼━┃┏┓┛┗┣┳┫┻╋┠┯┨┷┿┝┰┥┸╂"],
    ["ada1", "①", 19, "Ⅰ", 9],
    ["adc0", "㍉㌔㌢㍍㌘㌧㌃㌶㍑㍗㌍㌦㌣㌫㍊㌻㎜㎝㎞㎎㎏㏄㎡"],
    ["addf", "㍻〝〟№㏍℡㊤", 4, "㈱㈲㈹㍾㍽㍼≒≡∫∮∑√⊥∠∟⊿∵∩∪"],
    ["b0a1", "亜唖娃阿哀愛挨姶逢葵茜穐悪握渥旭葦芦鯵梓圧斡扱宛姐虻飴絢綾鮎或粟袷安庵按暗案闇鞍杏以伊位依偉囲夷委威尉惟意慰易椅為畏異移維緯胃萎衣謂違遺医井亥域育郁磯一壱溢逸稲茨芋鰯允印咽員因姻引飲淫胤蔭"],
    ["b1a1", "院陰隠韻吋右宇烏羽迂雨卯鵜窺丑碓臼渦嘘唄欝蔚鰻姥厩浦瓜閏噂云運雲荏餌叡営嬰影映曳栄永泳洩瑛盈穎頴英衛詠鋭液疫益駅悦謁越閲榎厭円園堰奄宴延怨掩援沿演炎焔煙燕猿縁艶苑薗遠鉛鴛塩於汚甥凹央奥往応"],
    ["b2a1", "押旺横欧殴王翁襖鴬鴎黄岡沖荻億屋憶臆桶牡乙俺卸恩温穏音下化仮何伽価佳加可嘉夏嫁家寡科暇果架歌河火珂禍禾稼箇花苛茄荷華菓蝦課嘩貨迦過霞蚊俄峨我牙画臥芽蛾賀雅餓駕介会解回塊壊廻快怪悔恢懐戒拐改"],
    ["b3a1", "魁晦械海灰界皆絵芥蟹開階貝凱劾外咳害崖慨概涯碍蓋街該鎧骸浬馨蛙垣柿蛎鈎劃嚇各廓拡撹格核殻獲確穫覚角赫較郭閣隔革学岳楽額顎掛笠樫橿梶鰍潟割喝恰括活渇滑葛褐轄且鰹叶椛樺鞄株兜竃蒲釜鎌噛鴨栢茅萱"],
    ["b4a1", "粥刈苅瓦乾侃冠寒刊勘勧巻喚堪姦完官寛干幹患感慣憾換敢柑桓棺款歓汗漢澗潅環甘監看竿管簡緩缶翰肝艦莞観諌貫還鑑間閑関陥韓館舘丸含岸巌玩癌眼岩翫贋雁頑顔願企伎危喜器基奇嬉寄岐希幾忌揮机旗既期棋棄"],
    ["b5a1", "機帰毅気汽畿祈季稀紀徽規記貴起軌輝飢騎鬼亀偽儀妓宜戯技擬欺犠疑祇義蟻誼議掬菊鞠吉吃喫桔橘詰砧杵黍却客脚虐逆丘久仇休及吸宮弓急救朽求汲泣灸球究窮笈級糾給旧牛去居巨拒拠挙渠虚許距鋸漁禦魚亨享京"],
    ["b6a1", "供侠僑兇競共凶協匡卿叫喬境峡強彊怯恐恭挟教橋況狂狭矯胸脅興蕎郷鏡響饗驚仰凝尭暁業局曲極玉桐粁僅勤均巾錦斤欣欽琴禁禽筋緊芹菌衿襟謹近金吟銀九倶句区狗玖矩苦躯駆駈駒具愚虞喰空偶寓遇隅串櫛釧屑屈"],
    ["b7a1", "掘窟沓靴轡窪熊隈粂栗繰桑鍬勲君薫訓群軍郡卦袈祁係傾刑兄啓圭珪型契形径恵慶慧憩掲携敬景桂渓畦稽系経継繋罫茎荊蛍計詣警軽頚鶏芸迎鯨劇戟撃激隙桁傑欠決潔穴結血訣月件倹倦健兼券剣喧圏堅嫌建憲懸拳捲"],
    ["b8a1", "検権牽犬献研硯絹県肩見謙賢軒遣鍵険顕験鹸元原厳幻弦減源玄現絃舷言諺限乎個古呼固姑孤己庫弧戸故枯湖狐糊袴股胡菰虎誇跨鈷雇顧鼓五互伍午呉吾娯後御悟梧檎瑚碁語誤護醐乞鯉交佼侯候倖光公功効勾厚口向"],
    ["b9a1", "后喉坑垢好孔孝宏工巧巷幸広庚康弘恒慌抗拘控攻昂晃更杭校梗構江洪浩港溝甲皇硬稿糠紅紘絞綱耕考肯肱腔膏航荒行衡講貢購郊酵鉱砿鋼閤降項香高鴻剛劫号合壕拷濠豪轟麹克刻告国穀酷鵠黒獄漉腰甑忽惚骨狛込"],
    ["baa1", "此頃今困坤墾婚恨懇昏昆根梱混痕紺艮魂些佐叉唆嵯左差査沙瑳砂詐鎖裟坐座挫債催再最哉塞妻宰彩才採栽歳済災采犀砕砦祭斎細菜裁載際剤在材罪財冴坂阪堺榊肴咲崎埼碕鷺作削咋搾昨朔柵窄策索錯桜鮭笹匙冊刷"],
    ["bba1", "察拶撮擦札殺薩雑皐鯖捌錆鮫皿晒三傘参山惨撒散桟燦珊産算纂蚕讃賛酸餐斬暫残仕仔伺使刺司史嗣四士始姉姿子屍市師志思指支孜斯施旨枝止死氏獅祉私糸紙紫肢脂至視詞詩試誌諮資賜雌飼歯事似侍児字寺慈持時"],
    ["bca1", "次滋治爾璽痔磁示而耳自蒔辞汐鹿式識鴫竺軸宍雫七叱執失嫉室悉湿漆疾質実蔀篠偲柴芝屡蕊縞舎写射捨赦斜煮社紗者謝車遮蛇邪借勺尺杓灼爵酌釈錫若寂弱惹主取守手朱殊狩珠種腫趣酒首儒受呪寿授樹綬需囚収周"],
    ["bda1", "宗就州修愁拾洲秀秋終繍習臭舟蒐衆襲讐蹴輯週酋酬集醜什住充十従戎柔汁渋獣縦重銃叔夙宿淑祝縮粛塾熟出術述俊峻春瞬竣舜駿准循旬楯殉淳準潤盾純巡遵醇順処初所暑曙渚庶緒署書薯藷諸助叙女序徐恕鋤除傷償"],
    ["bea1", "勝匠升召哨商唱嘗奨妾娼宵将小少尚庄床廠彰承抄招掌捷昇昌昭晶松梢樟樵沼消渉湘焼焦照症省硝礁祥称章笑粧紹肖菖蒋蕉衝裳訟証詔詳象賞醤鉦鍾鐘障鞘上丈丞乗冗剰城場壌嬢常情擾条杖浄状畳穣蒸譲醸錠嘱埴飾"],
    ["bfa1", "拭植殖燭織職色触食蝕辱尻伸信侵唇娠寝審心慎振新晋森榛浸深申疹真神秦紳臣芯薪親診身辛進針震人仁刃塵壬尋甚尽腎訊迅陣靭笥諏須酢図厨逗吹垂帥推水炊睡粋翠衰遂酔錐錘随瑞髄崇嵩数枢趨雛据杉椙菅頗雀裾"],
    ["c0a1", "澄摺寸世瀬畝是凄制勢姓征性成政整星晴棲栖正清牲生盛精聖声製西誠誓請逝醒青静斉税脆隻席惜戚斥昔析石積籍績脊責赤跡蹟碩切拙接摂折設窃節説雪絶舌蝉仙先千占宣専尖川戦扇撰栓栴泉浅洗染潜煎煽旋穿箭線"],
    ["c1a1", "繊羨腺舛船薦詮賎践選遷銭銑閃鮮前善漸然全禅繕膳糎噌塑岨措曾曽楚狙疏疎礎祖租粗素組蘇訴阻遡鼠僧創双叢倉喪壮奏爽宋層匝惣想捜掃挿掻操早曹巣槍槽漕燥争痩相窓糟総綜聡草荘葬蒼藻装走送遭鎗霜騒像増憎"],
    ["c2a1", "臓蔵贈造促側則即息捉束測足速俗属賊族続卒袖其揃存孫尊損村遜他多太汰詑唾堕妥惰打柁舵楕陀駄騨体堆対耐岱帯待怠態戴替泰滞胎腿苔袋貸退逮隊黛鯛代台大第醍題鷹滝瀧卓啄宅托択拓沢濯琢託鐸濁諾茸凧蛸只"],
    ["c3a1", "叩但達辰奪脱巽竪辿棚谷狸鱈樽誰丹単嘆坦担探旦歎淡湛炭短端箪綻耽胆蛋誕鍛団壇弾断暖檀段男談値知地弛恥智池痴稚置致蜘遅馳築畜竹筑蓄逐秩窒茶嫡着中仲宙忠抽昼柱注虫衷註酎鋳駐樗瀦猪苧著貯丁兆凋喋寵"],
    ["c4a1", "帖帳庁弔張彫徴懲挑暢朝潮牒町眺聴脹腸蝶調諜超跳銚長頂鳥勅捗直朕沈珍賃鎮陳津墜椎槌追鎚痛通塚栂掴槻佃漬柘辻蔦綴鍔椿潰坪壷嬬紬爪吊釣鶴亭低停偵剃貞呈堤定帝底庭廷弟悌抵挺提梯汀碇禎程締艇訂諦蹄逓"],
    ["c5a1", "邸鄭釘鼎泥摘擢敵滴的笛適鏑溺哲徹撤轍迭鉄典填天展店添纏甜貼転顛点伝殿澱田電兎吐堵塗妬屠徒斗杜渡登菟賭途都鍍砥砺努度土奴怒倒党冬凍刀唐塔塘套宕島嶋悼投搭東桃梼棟盗淘湯涛灯燈当痘祷等答筒糖統到"],
    ["c6a1", "董蕩藤討謄豆踏逃透鐙陶頭騰闘働動同堂導憧撞洞瞳童胴萄道銅峠鴇匿得徳涜特督禿篤毒独読栃橡凸突椴届鳶苫寅酉瀞噸屯惇敦沌豚遁頓呑曇鈍奈那内乍凪薙謎灘捺鍋楢馴縄畷南楠軟難汝二尼弐迩匂賑肉虹廿日乳入"],
    ["c7a1", "如尿韮任妊忍認濡禰祢寧葱猫熱年念捻撚燃粘乃廼之埜嚢悩濃納能脳膿農覗蚤巴把播覇杷波派琶破婆罵芭馬俳廃拝排敗杯盃牌背肺輩配倍培媒梅楳煤狽買売賠陪這蝿秤矧萩伯剥博拍柏泊白箔粕舶薄迫曝漠爆縛莫駁麦"],
    ["c8a1", "函箱硲箸肇筈櫨幡肌畑畠八鉢溌発醗髪伐罰抜筏閥鳩噺塙蛤隼伴判半反叛帆搬斑板氾汎版犯班畔繁般藩販範釆煩頒飯挽晩番盤磐蕃蛮匪卑否妃庇彼悲扉批披斐比泌疲皮碑秘緋罷肥被誹費避非飛樋簸備尾微枇毘琵眉美"],
    ["c9a1", "鼻柊稗匹疋髭彦膝菱肘弼必畢筆逼桧姫媛紐百謬俵彪標氷漂瓢票表評豹廟描病秒苗錨鋲蒜蛭鰭品彬斌浜瀕貧賓頻敏瓶不付埠夫婦富冨布府怖扶敷斧普浮父符腐膚芙譜負賦赴阜附侮撫武舞葡蕪部封楓風葺蕗伏副復幅服"],
    ["caa1", "福腹複覆淵弗払沸仏物鮒分吻噴墳憤扮焚奮粉糞紛雰文聞丙併兵塀幣平弊柄並蔽閉陛米頁僻壁癖碧別瞥蔑箆偏変片篇編辺返遍便勉娩弁鞭保舗鋪圃捕歩甫補輔穂募墓慕戊暮母簿菩倣俸包呆報奉宝峰峯崩庖抱捧放方朋"],
    ["cba1", "法泡烹砲縫胞芳萌蓬蜂褒訪豊邦鋒飽鳳鵬乏亡傍剖坊妨帽忘忙房暴望某棒冒紡肪膨謀貌貿鉾防吠頬北僕卜墨撲朴牧睦穆釦勃没殆堀幌奔本翻凡盆摩磨魔麻埋妹昧枚毎哩槙幕膜枕鮪柾鱒桝亦俣又抹末沫迄侭繭麿万慢満"],
    ["cca1", "漫蔓味未魅巳箕岬密蜜湊蓑稔脈妙粍民眠務夢無牟矛霧鵡椋婿娘冥名命明盟迷銘鳴姪牝滅免棉綿緬面麺摸模茂妄孟毛猛盲網耗蒙儲木黙目杢勿餅尤戻籾貰問悶紋門匁也冶夜爺耶野弥矢厄役約薬訳躍靖柳薮鑓愉愈油癒"],
    ["cda1", "諭輸唯佑優勇友宥幽悠憂揖有柚湧涌猶猷由祐裕誘遊邑郵雄融夕予余与誉輿預傭幼妖容庸揚揺擁曜楊様洋溶熔用窯羊耀葉蓉要謡踊遥陽養慾抑欲沃浴翌翼淀羅螺裸来莱頼雷洛絡落酪乱卵嵐欄濫藍蘭覧利吏履李梨理璃"],
    ["cea1", "痢裏裡里離陸律率立葎掠略劉流溜琉留硫粒隆竜龍侶慮旅虜了亮僚両凌寮料梁涼猟療瞭稜糧良諒遼量陵領力緑倫厘林淋燐琳臨輪隣鱗麟瑠塁涙累類令伶例冷励嶺怜玲礼苓鈴隷零霊麗齢暦歴列劣烈裂廉恋憐漣煉簾練聯"],
    ["cfa1", "蓮連錬呂魯櫓炉賂路露労婁廊弄朗楼榔浪漏牢狼篭老聾蝋郎六麓禄肋録論倭和話歪賄脇惑枠鷲亙亘鰐詫藁蕨椀湾碗腕"],
    ["d0a1", "弌丐丕个丱丶丼丿乂乖乘亂亅豫亊舒弍于亞亟亠亢亰亳亶从仍仄仆仂仗仞仭仟价伉佚估佛佝佗佇佶侈侏侘佻佩佰侑佯來侖儘俔俟俎俘俛俑俚俐俤俥倚倨倔倪倥倅伜俶倡倩倬俾俯們倆偃假會偕偐偈做偖偬偸傀傚傅傴傲"],
    ["d1a1", "僉僊傳僂僖僞僥僭僣僮價僵儉儁儂儖儕儔儚儡儺儷儼儻儿兀兒兌兔兢竸兩兪兮冀冂囘册冉冏冑冓冕冖冤冦冢冩冪冫决冱冲冰况冽凅凉凛几處凩凭凰凵凾刄刋刔刎刧刪刮刳刹剏剄剋剌剞剔剪剴剩剳剿剽劍劔劒剱劈劑辨"],
    ["d2a1", "辧劬劭劼劵勁勍勗勞勣勦飭勠勳勵勸勹匆匈甸匍匐匏匕匚匣匯匱匳匸區卆卅丗卉卍凖卞卩卮夘卻卷厂厖厠厦厥厮厰厶參簒雙叟曼燮叮叨叭叺吁吽呀听吭吼吮吶吩吝呎咏呵咎呟呱呷呰咒呻咀呶咄咐咆哇咢咸咥咬哄哈咨"],
    ["d3a1", "咫哂咤咾咼哘哥哦唏唔哽哮哭哺哢唹啀啣啌售啜啅啖啗唸唳啝喙喀咯喊喟啻啾喘喞單啼喃喩喇喨嗚嗅嗟嗄嗜嗤嗔嘔嗷嘖嗾嗽嘛嗹噎噐營嘴嘶嘲嘸噫噤嘯噬噪嚆嚀嚊嚠嚔嚏嚥嚮嚶嚴囂嚼囁囃囀囈囎囑囓囗囮囹圀囿圄圉"],
    ["d4a1", "圈國圍圓團圖嗇圜圦圷圸坎圻址坏坩埀垈坡坿垉垓垠垳垤垪垰埃埆埔埒埓堊埖埣堋堙堝塲堡塢塋塰毀塒堽塹墅墹墟墫墺壞墻墸墮壅壓壑壗壙壘壥壜壤壟壯壺壹壻壼壽夂夊夐夛梦夥夬夭夲夸夾竒奕奐奎奚奘奢奠奧奬奩"],
    ["d5a1", "奸妁妝佞侫妣妲姆姨姜妍姙姚娥娟娑娜娉娚婀婬婉娵娶婢婪媚媼媾嫋嫂媽嫣嫗嫦嫩嫖嫺嫻嬌嬋嬖嬲嫐嬪嬶嬾孃孅孀孑孕孚孛孥孩孰孳孵學斈孺宀它宦宸寃寇寉寔寐寤實寢寞寥寫寰寶寳尅將專對尓尠尢尨尸尹屁屆屎屓"],
    ["d6a1", "屐屏孱屬屮乢屶屹岌岑岔妛岫岻岶岼岷峅岾峇峙峩峽峺峭嶌峪崋崕崗嵜崟崛崑崔崢崚崙崘嵌嵒嵎嵋嵬嵳嵶嶇嶄嶂嶢嶝嶬嶮嶽嶐嶷嶼巉巍巓巒巖巛巫已巵帋帚帙帑帛帶帷幄幃幀幎幗幔幟幢幤幇幵并幺麼广庠廁廂廈廐廏"],
    ["d7a1", "廖廣廝廚廛廢廡廨廩廬廱廳廰廴廸廾弃弉彝彜弋弑弖弩弭弸彁彈彌彎弯彑彖彗彙彡彭彳彷徃徂彿徊很徑徇從徙徘徠徨徭徼忖忻忤忸忱忝悳忿怡恠怙怐怩怎怱怛怕怫怦怏怺恚恁恪恷恟恊恆恍恣恃恤恂恬恫恙悁悍惧悃悚"],
    ["d8a1", "悄悛悖悗悒悧悋惡悸惠惓悴忰悽惆悵惘慍愕愆惶惷愀惴惺愃愡惻惱愍愎慇愾愨愧慊愿愼愬愴愽慂慄慳慷慘慙慚慫慴慯慥慱慟慝慓慵憙憖憇憬憔憚憊憑憫憮懌懊應懷懈懃懆憺懋罹懍懦懣懶懺懴懿懽懼懾戀戈戉戍戌戔戛"],
    ["d9a1", "戞戡截戮戰戲戳扁扎扞扣扛扠扨扼抂抉找抒抓抖拔抃抔拗拑抻拏拿拆擔拈拜拌拊拂拇抛拉挌拮拱挧挂挈拯拵捐挾捍搜捏掖掎掀掫捶掣掏掉掟掵捫捩掾揩揀揆揣揉插揶揄搖搴搆搓搦搶攝搗搨搏摧摯摶摎攪撕撓撥撩撈撼"],
    ["daa1", "據擒擅擇撻擘擂擱擧舉擠擡抬擣擯攬擶擴擲擺攀擽攘攜攅攤攣攫攴攵攷收攸畋效敖敕敍敘敞敝敲數斂斃變斛斟斫斷旃旆旁旄旌旒旛旙无旡旱杲昊昃旻杳昵昶昴昜晏晄晉晁晞晝晤晧晨晟晢晰暃暈暎暉暄暘暝曁暹曉暾暼"],
    ["dba1", "曄暸曖曚曠昿曦曩曰曵曷朏朖朞朦朧霸朮朿朶杁朸朷杆杞杠杙杣杤枉杰枩杼杪枌枋枦枡枅枷柯枴柬枳柩枸柤柞柝柢柮枹柎柆柧檜栞框栩桀桍栲桎梳栫桙档桷桿梟梏梭梔條梛梃檮梹桴梵梠梺椏梍桾椁棊椈棘椢椦棡椌棍"],
    ["dca1", "棔棧棕椶椒椄棗棣椥棹棠棯椨椪椚椣椡棆楹楷楜楸楫楔楾楮椹楴椽楙椰楡楞楝榁楪榲榮槐榿槁槓榾槎寨槊槝榻槃榧樮榑榠榜榕榴槞槨樂樛槿權槹槲槧樅榱樞槭樔槫樊樒櫁樣樓橄樌橲樶橸橇橢橙橦橈樸樢檐檍檠檄檢檣"],
    ["dda1", "檗蘗檻櫃櫂檸檳檬櫞櫑櫟檪櫚櫪櫻欅蘖櫺欒欖鬱欟欸欷盜欹飮歇歃歉歐歙歔歛歟歡歸歹歿殀殄殃殍殘殕殞殤殪殫殯殲殱殳殷殼毆毋毓毟毬毫毳毯麾氈氓气氛氤氣汞汕汢汪沂沍沚沁沛汾汨汳沒沐泄泱泓沽泗泅泝沮沱沾"],
    ["dea1", "沺泛泯泙泪洟衍洶洫洽洸洙洵洳洒洌浣涓浤浚浹浙涎涕濤涅淹渕渊涵淇淦涸淆淬淞淌淨淒淅淺淙淤淕淪淮渭湮渮渙湲湟渾渣湫渫湶湍渟湃渺湎渤滿渝游溂溪溘滉溷滓溽溯滄溲滔滕溏溥滂溟潁漑灌滬滸滾漿滲漱滯漲滌"],
    ["dfa1", "漾漓滷澆潺潸澁澀潯潛濳潭澂潼潘澎澑濂潦澳澣澡澤澹濆澪濟濕濬濔濘濱濮濛瀉瀋濺瀑瀁瀏濾瀛瀚潴瀝瀘瀟瀰瀾瀲灑灣炙炒炯烱炬炸炳炮烟烋烝烙焉烽焜焙煥煕熈煦煢煌煖煬熏燻熄熕熨熬燗熹熾燒燉燔燎燠燬燧燵燼"],
    ["e0a1", "燹燿爍爐爛爨爭爬爰爲爻爼爿牀牆牋牘牴牾犂犁犇犒犖犢犧犹犲狃狆狄狎狒狢狠狡狹狷倏猗猊猜猖猝猴猯猩猥猾獎獏默獗獪獨獰獸獵獻獺珈玳珎玻珀珥珮珞璢琅瑯琥珸琲琺瑕琿瑟瑙瑁瑜瑩瑰瑣瑪瑶瑾璋璞璧瓊瓏瓔珱"],
    ["e1a1", "瓠瓣瓧瓩瓮瓲瓰瓱瓸瓷甄甃甅甌甎甍甕甓甞甦甬甼畄畍畊畉畛畆畚畩畤畧畫畭畸當疆疇畴疊疉疂疔疚疝疥疣痂疳痃疵疽疸疼疱痍痊痒痙痣痞痾痿痼瘁痰痺痲痳瘋瘍瘉瘟瘧瘠瘡瘢瘤瘴瘰瘻癇癈癆癜癘癡癢癨癩癪癧癬癰"],
    ["e2a1", "癲癶癸發皀皃皈皋皎皖皓皙皚皰皴皸皹皺盂盍盖盒盞盡盥盧盪蘯盻眈眇眄眩眤眞眥眦眛眷眸睇睚睨睫睛睥睿睾睹瞎瞋瞑瞠瞞瞰瞶瞹瞿瞼瞽瞻矇矍矗矚矜矣矮矼砌砒礦砠礪硅碎硴碆硼碚碌碣碵碪碯磑磆磋磔碾碼磅磊磬"],
    ["e3a1", "磧磚磽磴礇礒礑礙礬礫祀祠祗祟祚祕祓祺祿禊禝禧齋禪禮禳禹禺秉秕秧秬秡秣稈稍稘稙稠稟禀稱稻稾稷穃穗穉穡穢穩龝穰穹穽窈窗窕窘窖窩竈窰窶竅竄窿邃竇竊竍竏竕竓站竚竝竡竢竦竭竰笂笏笊笆笳笘笙笞笵笨笶筐"],
    ["e4a1", "筺笄筍笋筌筅筵筥筴筧筰筱筬筮箝箘箟箍箜箚箋箒箏筝箙篋篁篌篏箴篆篝篩簑簔篦篥籠簀簇簓篳篷簗簍篶簣簧簪簟簷簫簽籌籃籔籏籀籐籘籟籤籖籥籬籵粃粐粤粭粢粫粡粨粳粲粱粮粹粽糀糅糂糘糒糜糢鬻糯糲糴糶糺紆"],
    ["e5a1", "紂紜紕紊絅絋紮紲紿紵絆絳絖絎絲絨絮絏絣經綉絛綏絽綛綺綮綣綵緇綽綫總綢綯緜綸綟綰緘緝緤緞緻緲緡縅縊縣縡縒縱縟縉縋縢繆繦縻縵縹繃縷縲縺繧繝繖繞繙繚繹繪繩繼繻纃緕繽辮繿纈纉續纒纐纓纔纖纎纛纜缸缺"],
    ["e6a1", "罅罌罍罎罐网罕罔罘罟罠罨罩罧罸羂羆羃羈羇羌羔羞羝羚羣羯羲羹羮羶羸譱翅翆翊翕翔翡翦翩翳翹飜耆耄耋耒耘耙耜耡耨耿耻聊聆聒聘聚聟聢聨聳聲聰聶聹聽聿肄肆肅肛肓肚肭冐肬胛胥胙胝胄胚胖脉胯胱脛脩脣脯腋"],
    ["e7a1", "隋腆脾腓腑胼腱腮腥腦腴膃膈膊膀膂膠膕膤膣腟膓膩膰膵膾膸膽臀臂膺臉臍臑臙臘臈臚臟臠臧臺臻臾舁舂舅與舊舍舐舖舩舫舸舳艀艙艘艝艚艟艤艢艨艪艫舮艱艷艸艾芍芒芫芟芻芬苡苣苟苒苴苳苺莓范苻苹苞茆苜茉苙"],
    ["e8a1", "茵茴茖茲茱荀茹荐荅茯茫茗茘莅莚莪莟莢莖茣莎莇莊荼莵荳荵莠莉莨菴萓菫菎菽萃菘萋菁菷萇菠菲萍萢萠莽萸蔆菻葭萪萼蕚蒄葷葫蒭葮蒂葩葆萬葯葹萵蓊葢蒹蒿蒟蓙蓍蒻蓚蓐蓁蓆蓖蒡蔡蓿蓴蔗蔘蔬蔟蔕蔔蓼蕀蕣蕘蕈"],
    ["e9a1", "蕁蘂蕋蕕薀薤薈薑薊薨蕭薔薛藪薇薜蕷蕾薐藉薺藏薹藐藕藝藥藜藹蘊蘓蘋藾藺蘆蘢蘚蘰蘿虍乕虔號虧虱蚓蚣蚩蚪蚋蚌蚶蚯蛄蛆蚰蛉蠣蚫蛔蛞蛩蛬蛟蛛蛯蜒蜆蜈蜀蜃蛻蜑蜉蜍蛹蜊蜴蜿蜷蜻蜥蜩蜚蝠蝟蝸蝌蝎蝴蝗蝨蝮蝙"],
    ["eaa1", "蝓蝣蝪蠅螢螟螂螯蟋螽蟀蟐雖螫蟄螳蟇蟆螻蟯蟲蟠蠏蠍蟾蟶蟷蠎蟒蠑蠖蠕蠢蠡蠱蠶蠹蠧蠻衄衂衒衙衞衢衫袁衾袞衵衽袵衲袂袗袒袮袙袢袍袤袰袿袱裃裄裔裘裙裝裹褂裼裴裨裲褄褌褊褓襃褞褥褪褫襁襄褻褶褸襌褝襠襞"],
    ["eba1", "襦襤襭襪襯襴襷襾覃覈覊覓覘覡覩覦覬覯覲覺覽覿觀觚觜觝觧觴觸訃訖訐訌訛訝訥訶詁詛詒詆詈詼詭詬詢誅誂誄誨誡誑誥誦誚誣諄諍諂諚諫諳諧諤諱謔諠諢諷諞諛謌謇謚諡謖謐謗謠謳鞫謦謫謾謨譁譌譏譎證譖譛譚譫"],
    ["eca1", "譟譬譯譴譽讀讌讎讒讓讖讙讚谺豁谿豈豌豎豐豕豢豬豸豺貂貉貅貊貍貎貔豼貘戝貭貪貽貲貳貮貶賈賁賤賣賚賽賺賻贄贅贊贇贏贍贐齎贓賍贔贖赧赭赱赳趁趙跂趾趺跏跚跖跌跛跋跪跫跟跣跼踈踉跿踝踞踐踟蹂踵踰踴蹊"],
    ["eda1", "蹇蹉蹌蹐蹈蹙蹤蹠踪蹣蹕蹶蹲蹼躁躇躅躄躋躊躓躑躔躙躪躡躬躰軆躱躾軅軈軋軛軣軼軻軫軾輊輅輕輒輙輓輜輟輛輌輦輳輻輹轅轂輾轌轉轆轎轗轜轢轣轤辜辟辣辭辯辷迚迥迢迪迯邇迴逅迹迺逑逕逡逍逞逖逋逧逶逵逹迸"],
    ["eea1", "遏遐遑遒逎遉逾遖遘遞遨遯遶隨遲邂遽邁邀邊邉邏邨邯邱邵郢郤扈郛鄂鄒鄙鄲鄰酊酖酘酣酥酩酳酲醋醉醂醢醫醯醪醵醴醺釀釁釉釋釐釖釟釡釛釼釵釶鈞釿鈔鈬鈕鈑鉞鉗鉅鉉鉤鉈銕鈿鉋鉐銜銖銓銛鉚鋏銹銷鋩錏鋺鍄錮"],
    ["efa1", "錙錢錚錣錺錵錻鍜鍠鍼鍮鍖鎰鎬鎭鎔鎹鏖鏗鏨鏥鏘鏃鏝鏐鏈鏤鐚鐔鐓鐃鐇鐐鐶鐫鐵鐡鐺鑁鑒鑄鑛鑠鑢鑞鑪鈩鑰鑵鑷鑽鑚鑼鑾钁鑿閂閇閊閔閖閘閙閠閨閧閭閼閻閹閾闊濶闃闍闌闕闔闖關闡闥闢阡阨阮阯陂陌陏陋陷陜陞"],
    ["f0a1", "陝陟陦陲陬隍隘隕隗險隧隱隲隰隴隶隸隹雎雋雉雍襍雜霍雕雹霄霆霈霓霎霑霏霖霙霤霪霰霹霽霾靄靆靈靂靉靜靠靤靦靨勒靫靱靹鞅靼鞁靺鞆鞋鞏鞐鞜鞨鞦鞣鞳鞴韃韆韈韋韜韭齏韲竟韶韵頏頌頸頤頡頷頽顆顏顋顫顯顰"],
    ["f1a1", "顱顴顳颪颯颱颶飄飃飆飩飫餃餉餒餔餘餡餝餞餤餠餬餮餽餾饂饉饅饐饋饑饒饌饕馗馘馥馭馮馼駟駛駝駘駑駭駮駱駲駻駸騁騏騅駢騙騫騷驅驂驀驃騾驕驍驛驗驟驢驥驤驩驫驪骭骰骼髀髏髑髓體髞髟髢髣髦髯髫髮髴髱髷"],
    ["f2a1", "髻鬆鬘鬚鬟鬢鬣鬥鬧鬨鬩鬪鬮鬯鬲魄魃魏魍魎魑魘魴鮓鮃鮑鮖鮗鮟鮠鮨鮴鯀鯊鮹鯆鯏鯑鯒鯣鯢鯤鯔鯡鰺鯲鯱鯰鰕鰔鰉鰓鰌鰆鰈鰒鰊鰄鰮鰛鰥鰤鰡鰰鱇鰲鱆鰾鱚鱠鱧鱶鱸鳧鳬鳰鴉鴈鳫鴃鴆鴪鴦鶯鴣鴟鵄鴕鴒鵁鴿鴾鵆鵈"],
    ["f3a1", "鵝鵞鵤鵑鵐鵙鵲鶉鶇鶫鵯鵺鶚鶤鶩鶲鷄鷁鶻鶸鶺鷆鷏鷂鷙鷓鷸鷦鷭鷯鷽鸚鸛鸞鹵鹹鹽麁麈麋麌麒麕麑麝麥麩麸麪麭靡黌黎黏黐黔黜點黝黠黥黨黯黴黶黷黹黻黼黽鼇鼈皷鼕鼡鼬鼾齊齒齔齣齟齠齡齦齧齬齪齷齲齶龕龜龠"],
    ["f4a1", "堯槇遙瑤凜熙"],
    ["f9a1", "纊褜鍈銈蓜俉炻昱棈鋹曻彅丨仡仼伀伃伹佖侒侊侚侔俍偀倢俿倞偆偰偂傔僴僘兊兤冝冾凬刕劜劦勀勛匀匇匤卲厓厲叝﨎咜咊咩哿喆坙坥垬埈埇﨏塚增墲夋奓奛奝奣妤妺孖寀甯寘寬尞岦岺峵崧嵓﨑嵂嵭嶸嶹巐弡弴彧德"],
    ["faa1", "忞恝悅悊惞惕愠惲愑愷愰憘戓抦揵摠撝擎敎昀昕昻昉昮昞昤晥晗晙晴晳暙暠暲暿曺朎朗杦枻桒柀栁桄棏﨓楨﨔榘槢樰橫橆橳橾櫢櫤毖氿汜沆汯泚洄涇浯涖涬淏淸淲淼渹湜渧渼溿澈澵濵瀅瀇瀨炅炫焏焄煜煆煇凞燁燾犱"],
    ["fba1", "犾猤猪獷玽珉珖珣珒琇珵琦琪琩琮瑢璉璟甁畯皂皜皞皛皦益睆劯砡硎硤硺礰礼神祥禔福禛竑竧靖竫箞精絈絜綷綠緖繒罇羡羽茁荢荿菇菶葈蒴蕓蕙蕫﨟薰蘒﨡蠇裵訒訷詹誧誾諟諸諶譓譿賰賴贒赶﨣軏﨤逸遧郞都鄕鄧釚"],
    ["fca1", "釗釞釭釮釤釥鈆鈐鈊鈺鉀鈼鉎鉙鉑鈹鉧銧鉷鉸鋧鋗鋙鋐﨧鋕鋠鋓錥錡鋻﨨錞鋿錝錂鍰鍗鎤鏆鏞鏸鐱鑅鑈閒隆﨩隝隯霳霻靃靍靏靑靕顗顥飯飼餧館馞驎髙髜魵魲鮏鮱鮻鰀鵰鵫鶴鸙黑"],
    ["fcf1", "ⅰ", 9, "￢￤＇＂"],
    ["8fa2af", "˘ˇ¸˙˝¯˛˚～΄΅"],
    ["8fa2c2", "¡¦¿"],
    ["8fa2eb", "ºª©®™¤№"],
    ["8fa6e1", "ΆΈΉΊΪ"],
    ["8fa6e7", "Ό"],
    ["8fa6e9", "ΎΫ"],
    ["8fa6ec", "Ώ"],
    ["8fa6f1", "άέήίϊΐόςύϋΰώ"],
    ["8fa7c2", "Ђ", 10, "ЎЏ"],
    ["8fa7f2", "ђ", 10, "ўџ"],
    ["8fa9a1", "ÆĐ"],
    ["8fa9a4", "Ħ"],
    ["8fa9a6", "Ĳ"],
    ["8fa9a8", "ŁĿ"],
    ["8fa9ab", "ŊØŒ"],
    ["8fa9af", "ŦÞ"],
    ["8fa9c1", "æđðħıĳĸłŀŉŋøœßŧþ"],
    ["8faaa1", "ÁÀÄÂĂǍĀĄÅÃĆĈČÇĊĎÉÈËÊĚĖĒĘ"],
    ["8faaba", "ĜĞĢĠĤÍÌÏÎǏİĪĮĨĴĶĹĽĻŃŇŅÑÓÒÖÔǑŐŌÕŔŘŖŚŜŠŞŤŢÚÙÜÛŬǓŰŪŲŮŨǗǛǙǕŴÝŸŶŹŽŻ"],
    ["8faba1", "áàäâăǎāąåãćĉčçċďéèëêěėēęǵĝğ"],
    ["8fabbd", "ġĥíìïîǐ"],
    ["8fabc5", "īįĩĵķĺľļńňņñóòöôǒőōõŕřŗśŝšşťţúùüûŭǔűūųůũǘǜǚǖŵýÿŷźžż"],
    ["8fb0a1", "丂丄丅丌丒丟丣两丨丫丮丯丰丵乀乁乄乇乑乚乜乣乨乩乴乵乹乿亍亖亗亝亯亹仃仐仚仛仠仡仢仨仯仱仳仵份仾仿伀伂伃伈伋伌伒伕伖众伙伮伱你伳伵伷伹伻伾佀佂佈佉佋佌佒佔佖佘佟佣佪佬佮佱佷佸佹佺佽佾侁侂侄"],
    ["8fb1a1", "侅侉侊侌侎侐侒侓侔侗侙侚侞侟侲侷侹侻侼侽侾俀俁俅俆俈俉俋俌俍俏俒俜俠俢俰俲俼俽俿倀倁倄倇倊倌倎倐倓倗倘倛倜倝倞倢倧倮倰倲倳倵偀偁偂偅偆偊偌偎偑偒偓偗偙偟偠偢偣偦偧偪偭偰偱倻傁傃傄傆傊傎傏傐"],
    ["8fb2a1", "傒傓傔傖傛傜傞", 4, "傪傯傰傹傺傽僀僃僄僇僌僎僐僓僔僘僜僝僟僢僤僦僨僩僯僱僶僺僾儃儆儇儈儋儌儍儎僲儐儗儙儛儜儝儞儣儧儨儬儭儯儱儳儴儵儸儹兂兊兏兓兕兗兘兟兤兦兾冃冄冋冎冘冝冡冣冭冸冺冼冾冿凂"],
    ["8fb3a1", "凈减凑凒凓凕凘凞凢凥凮凲凳凴凷刁刂刅划刓刕刖刘刢刨刱刲刵刼剅剉剕剗剘剚剜剟剠剡剦剮剷剸剹劀劂劅劊劌劓劕劖劗劘劚劜劤劥劦劧劯劰劶劷劸劺劻劽勀勄勆勈勌勏勑勔勖勛勜勡勥勨勩勪勬勰勱勴勶勷匀匃匊匋"],
    ["8fb4a1", "匌匑匓匘匛匜匞匟匥匧匨匩匫匬匭匰匲匵匼匽匾卂卌卋卙卛卡卣卥卬卭卲卹卾厃厇厈厎厓厔厙厝厡厤厪厫厯厲厴厵厷厸厺厽叀叅叏叒叓叕叚叝叞叠另叧叵吂吓吚吡吧吨吪启吱吴吵呃呄呇呍呏呞呢呤呦呧呩呫呭呮呴呿"],
    ["8fb5a1", "咁咃咅咈咉咍咑咕咖咜咟咡咦咧咩咪咭咮咱咷咹咺咻咿哆哊响哎哠哪哬哯哶哼哾哿唀唁唅唈唉唌唍唎唕唪唫唲唵唶唻唼唽啁啇啉啊啍啐啑啘啚啛啞啠啡啤啦啿喁喂喆喈喎喏喑喒喓喔喗喣喤喭喲喿嗁嗃嗆嗉嗋嗌嗎嗑嗒"],
    ["8fb6a1", "嗓嗗嗘嗛嗞嗢嗩嗶嗿嘅嘈嘊嘍", 5, "嘙嘬嘰嘳嘵嘷嘹嘻嘼嘽嘿噀噁噃噄噆噉噋噍噏噔噞噠噡噢噣噦噩噭噯噱噲噵嚄嚅嚈嚋嚌嚕嚙嚚嚝嚞嚟嚦嚧嚨嚩嚫嚬嚭嚱嚳嚷嚾囅囉囊囋囏囐囌囍囙囜囝囟囡囤", 4, "囱囫园"],
    ["8fb7a1", "囶囷圁圂圇圊圌圑圕圚圛圝圠圢圣圤圥圩圪圬圮圯圳圴圽圾圿坅坆坌坍坒坢坥坧坨坫坭", 4, "坳坴坵坷坹坺坻坼坾垁垃垌垔垗垙垚垜垝垞垟垡垕垧垨垩垬垸垽埇埈埌埏埕埝埞埤埦埧埩埭埰埵埶埸埽埾埿堃堄堈堉埡"],
    ["8fb8a1", "堌堍堛堞堟堠堦堧堭堲堹堿塉塌塍塏塐塕塟塡塤塧塨塸塼塿墀墁墇墈墉墊墌墍墏墐墔墖墝墠墡墢墦墩墱墲壄墼壂壈壍壎壐壒壔壖壚壝壡壢壩壳夅夆夋夌夒夓夔虁夝夡夣夤夨夯夰夳夵夶夿奃奆奒奓奙奛奝奞奟奡奣奫奭"],
    ["8fb9a1", "奯奲奵奶她奻奼妋妌妎妒妕妗妟妤妧妭妮妯妰妳妷妺妼姁姃姄姈姊姍姒姝姞姟姣姤姧姮姯姱姲姴姷娀娄娌娍娎娒娓娞娣娤娧娨娪娭娰婄婅婇婈婌婐婕婞婣婥婧婭婷婺婻婾媋媐媓媖媙媜媞媟媠媢媧媬媱媲媳媵媸媺媻媿"],
    ["8fbaa1", "嫄嫆嫈嫏嫚嫜嫠嫥嫪嫮嫵嫶嫽嬀嬁嬈嬗嬴嬙嬛嬝嬡嬥嬭嬸孁孋孌孒孖孞孨孮孯孼孽孾孿宁宄宆宊宎宐宑宓宔宖宨宩宬宭宯宱宲宷宺宼寀寁寍寏寖", 4, "寠寯寱寴寽尌尗尞尟尣尦尩尫尬尮尰尲尵尶屙屚屜屢屣屧屨屩"],
    ["8fbba1", "屭屰屴屵屺屻屼屽岇岈岊岏岒岝岟岠岢岣岦岪岲岴岵岺峉峋峒峝峗峮峱峲峴崁崆崍崒崫崣崤崦崧崱崴崹崽崿嵂嵃嵆嵈嵕嵑嵙嵊嵟嵠嵡嵢嵤嵪嵭嵰嵹嵺嵾嵿嶁嶃嶈嶊嶒嶓嶔嶕嶙嶛嶟嶠嶧嶫嶰嶴嶸嶹巃巇巋巐巎巘巙巠巤"],
    ["8fbca1", "巩巸巹帀帇帍帒帔帕帘帟帠帮帨帲帵帾幋幐幉幑幖幘幛幜幞幨幪", 4, "幰庀庋庎庢庤庥庨庪庬庱庳庽庾庿廆廌廋廎廑廒廔廕廜廞廥廫异弆弇弈弎弙弜弝弡弢弣弤弨弫弬弮弰弴弶弻弽弿彀彄彅彇彍彐彔彘彛彠彣彤彧"],
    ["8fbda1", "彯彲彴彵彸彺彽彾徉徍徏徖徜徝徢徧徫徤徬徯徰徱徸忄忇忈忉忋忐", 4, "忞忡忢忨忩忪忬忭忮忯忲忳忶忺忼怇怊怍怓怔怗怘怚怟怤怭怳怵恀恇恈恉恌恑恔恖恗恝恡恧恱恾恿悂悆悈悊悎悑悓悕悘悝悞悢悤悥您悰悱悷"],
    ["8fbea1", "悻悾惂惄惈惉惊惋惎惏惔惕惙惛惝惞惢惥惲惵惸惼惽愂愇愊愌愐", 4, "愖愗愙愜愞愢愪愫愰愱愵愶愷愹慁慅慆慉慞慠慬慲慸慻慼慿憀憁憃憄憋憍憒憓憗憘憜憝憟憠憥憨憪憭憸憹憼懀懁懂懎懏懕懜懝懞懟懡懢懧懩懥"],
    ["8fbfa1", "懬懭懯戁戃戄戇戓戕戜戠戢戣戧戩戫戹戽扂扃扄扆扌扐扑扒扔扖扚扜扤扭扯扳扺扽抍抎抏抐抦抨抳抶抷抺抾抿拄拎拕拖拚拪拲拴拼拽挃挄挊挋挍挐挓挖挘挩挪挭挵挶挹挼捁捂捃捄捆捊捋捎捒捓捔捘捛捥捦捬捭捱捴捵"],
    ["8fc0a1", "捸捼捽捿掂掄掇掊掐掔掕掙掚掞掤掦掭掮掯掽揁揅揈揎揑揓揔揕揜揠揥揪揬揲揳揵揸揹搉搊搐搒搔搘搞搠搢搤搥搩搪搯搰搵搽搿摋摏摑摒摓摔摚摛摜摝摟摠摡摣摭摳摴摻摽撅撇撏撐撑撘撙撛撝撟撡撣撦撨撬撳撽撾撿"],
    ["8fc1a1", "擄擉擊擋擌擎擐擑擕擗擤擥擩擪擭擰擵擷擻擿攁攄攈攉攊攏攓攔攖攙攛攞攟攢攦攩攮攱攺攼攽敃敇敉敐敒敔敟敠敧敫敺敽斁斅斊斒斕斘斝斠斣斦斮斲斳斴斿旂旈旉旎旐旔旖旘旟旰旲旴旵旹旾旿昀昄昈昉昍昑昒昕昖昝"],
    ["8fc2a1", "昞昡昢昣昤昦昩昪昫昬昮昰昱昳昹昷晀晅晆晊晌晑晎晗晘晙晛晜晠晡曻晪晫晬晾晳晵晿晷晸晹晻暀晼暋暌暍暐暒暙暚暛暜暟暠暤暭暱暲暵暻暿曀曂曃曈曌曎曏曔曛曟曨曫曬曮曺朅朇朎朓朙朜朠朢朳朾杅杇杈杌杔杕杝"],
    ["8fc3a1", "杦杬杮杴杶杻极构枎枏枑枓枖枘枙枛枰枱枲枵枻枼枽柹柀柂柃柅柈柉柒柗柙柜柡柦柰柲柶柷桒栔栙栝栟栨栧栬栭栯栰栱栳栻栿桄桅桊桌桕桗桘桛桫桮", 4, "桵桹桺桻桼梂梄梆梈梖梘梚梜梡梣梥梩梪梮梲梻棅棈棌棏"],
    ["8fc4a1", "棐棑棓棖棙棜棝棥棨棪棫棬棭棰棱棵棶棻棼棽椆椉椊椐椑椓椖椗椱椳椵椸椻楂楅楉楎楗楛楣楤楥楦楨楩楬楰楱楲楺楻楿榀榍榒榖榘榡榥榦榨榫榭榯榷榸榺榼槅槈槑槖槗槢槥槮槯槱槳槵槾樀樁樃樏樑樕樚樝樠樤樨樰樲"],
    ["8fc5a1", "樴樷樻樾樿橅橆橉橊橎橐橑橒橕橖橛橤橧橪橱橳橾檁檃檆檇檉檋檑檛檝檞檟檥檫檯檰檱檴檽檾檿櫆櫉櫈櫌櫐櫔櫕櫖櫜櫝櫤櫧櫬櫰櫱櫲櫼櫽欂欃欆欇欉欏欐欑欗欛欞欤欨欫欬欯欵欶欻欿歆歊歍歒歖歘歝歠歧歫歮歰歵歽"],
    ["8fc6a1", "歾殂殅殗殛殟殠殢殣殨殩殬殭殮殰殸殹殽殾毃毄毉毌毖毚毡毣毦毧毮毱毷毹毿氂氄氅氉氍氎氐氒氙氟氦氧氨氬氮氳氵氶氺氻氿汊汋汍汏汒汔汙汛汜汫汭汯汴汶汸汹汻沅沆沇沉沔沕沗沘沜沟沰沲沴泂泆泍泏泐泑泒泔泖"],
    ["8fc7a1", "泚泜泠泧泩泫泬泮泲泴洄洇洊洎洏洑洓洚洦洧洨汧洮洯洱洹洼洿浗浞浟浡浥浧浯浰浼涂涇涑涒涔涖涗涘涪涬涴涷涹涽涿淄淈淊淎淏淖淛淝淟淠淢淥淩淯淰淴淶淼渀渄渞渢渧渲渶渹渻渼湄湅湈湉湋湏湑湒湓湔湗湜湝湞"],
    ["8fc8a1", "湢湣湨湳湻湽溍溓溙溠溧溭溮溱溳溻溿滀滁滃滇滈滊滍滎滏滫滭滮滹滻滽漄漈漊漌漍漖漘漚漛漦漩漪漯漰漳漶漻漼漭潏潑潒潓潗潙潚潝潞潡潢潨潬潽潾澃澇澈澋澌澍澐澒澓澔澖澚澟澠澥澦澧澨澮澯澰澵澶澼濅濇濈濊"],
    ["8fc9a1", "濚濞濨濩濰濵濹濼濽瀀瀅瀆瀇瀍瀗瀠瀣瀯瀴瀷瀹瀼灃灄灈灉灊灋灔灕灝灞灎灤灥灬灮灵灶灾炁炅炆炔", 4, "炛炤炫炰炱炴炷烊烑烓烔烕烖烘烜烤烺焃", 4, "焋焌焏焞焠焫焭焯焰焱焸煁煅煆煇煊煋煐煒煗煚煜煞煠"],
    ["8fcaa1", "煨煹熀熅熇熌熒熚熛熠熢熯熰熲熳熺熿燀燁燄燋燌燓燖燙燚燜燸燾爀爇爈爉爓爗爚爝爟爤爫爯爴爸爹牁牂牃牅牎牏牐牓牕牖牚牜牞牠牣牨牫牮牯牱牷牸牻牼牿犄犉犍犎犓犛犨犭犮犱犴犾狁狇狉狌狕狖狘狟狥狳狴狺狻"],
    ["8fcba1", "狾猂猄猅猇猋猍猒猓猘猙猞猢猤猧猨猬猱猲猵猺猻猽獃獍獐獒獖獘獝獞獟獠獦獧獩獫獬獮獯獱獷獹獼玀玁玃玅玆玎玐玓玕玗玘玜玞玟玠玢玥玦玪玫玭玵玷玹玼玽玿珅珆珉珋珌珏珒珓珖珙珝珡珣珦珧珩珴珵珷珹珺珻珽"],
    ["8fcca1", "珿琀琁琄琇琊琑琚琛琤琦琨", 9, "琹瑀瑃瑄瑆瑇瑋瑍瑑瑒瑗瑝瑢瑦瑧瑨瑫瑭瑮瑱瑲璀璁璅璆璇璉璏璐璑璒璘璙璚璜璟璠璡璣璦璨璩璪璫璮璯璱璲璵璹璻璿瓈瓉瓌瓐瓓瓘瓚瓛瓞瓟瓤瓨瓪瓫瓯瓴瓺瓻瓼瓿甆"],
    ["8fcda1", "甒甖甗甠甡甤甧甩甪甯甶甹甽甾甿畀畃畇畈畎畐畒畗畞畟畡畯畱畹", 5, "疁疅疐疒疓疕疙疜疢疤疴疺疿痀痁痄痆痌痎痏痗痜痟痠痡痤痧痬痮痯痱痹瘀瘂瘃瘄瘇瘈瘊瘌瘏瘒瘓瘕瘖瘙瘛瘜瘝瘞瘣瘥瘦瘩瘭瘲瘳瘵瘸瘹"],
    ["8fcea1", "瘺瘼癊癀癁癃癄癅癉癋癕癙癟癤癥癭癮癯癱癴皁皅皌皍皕皛皜皝皟皠皢", 6, "皪皭皽盁盅盉盋盌盎盔盙盠盦盨盬盰盱盶盹盼眀眆眊眎眒眔眕眗眙眚眜眢眨眭眮眯眴眵眶眹眽眾睂睅睆睊睍睎睏睒睖睗睜睞睟睠睢"],
    ["8fcfa1", "睤睧睪睬睰睲睳睴睺睽瞀瞄瞌瞍瞔瞕瞖瞚瞟瞢瞧瞪瞮瞯瞱瞵瞾矃矉矑矒矕矙矞矟矠矤矦矪矬矰矱矴矸矻砅砆砉砍砎砑砝砡砢砣砭砮砰砵砷硃硄硇硈硌硎硒硜硞硠硡硣硤硨硪确硺硾碊碏碔碘碡碝碞碟碤碨碬碭碰碱碲碳"],
    ["8fd0a1", "碻碽碿磇磈磉磌磎磒磓磕磖磤磛磟磠磡磦磪磲磳礀磶磷磺磻磿礆礌礐礚礜礞礟礠礥礧礩礭礱礴礵礻礽礿祄祅祆祊祋祏祑祔祘祛祜祧祩祫祲祹祻祼祾禋禌禑禓禔禕禖禘禛禜禡禨禩禫禯禱禴禸离秂秄秇秈秊秏秔秖秚秝秞"],
    ["8fd1a1", "秠秢秥秪秫秭秱秸秼稂稃稇稉稊稌稑稕稛稞稡稧稫稭稯稰稴稵稸稹稺穄穅穇穈穌穕穖穙穜穝穟穠穥穧穪穭穵穸穾窀窂窅窆窊窋窐窑窔窞窠窣窬窳窵窹窻窼竆竉竌竎竑竛竨竩竫竬竱竴竻竽竾笇笔笟笣笧笩笪笫笭笮笯笰"],
    ["8fd2a1", "笱笴笽笿筀筁筇筎筕筠筤筦筩筪筭筯筲筳筷箄箉箎箐箑箖箛箞箠箥箬箯箰箲箵箶箺箻箼箽篂篅篈篊篔篖篗篙篚篛篨篪篲篴篵篸篹篺篼篾簁簂簃簄簆簉簋簌簎簏簙簛簠簥簦簨簬簱簳簴簶簹簺籆籊籕籑籒籓籙", 5],
    ["8fd3a1", "籡籣籧籩籭籮籰籲籹籼籽粆粇粏粔粞粠粦粰粶粷粺粻粼粿糄糇糈糉糍糏糓糔糕糗糙糚糝糦糩糫糵紃紇紈紉紏紑紒紓紖紝紞紣紦紪紭紱紼紽紾絀絁絇絈絍絑絓絗絙絚絜絝絥絧絪絰絸絺絻絿綁綂綃綅綆綈綋綌綍綑綖綗綝"],
    ["8fd4a1", "綞綦綧綪綳綶綷綹緂", 4, "緌緍緎緗緙縀緢緥緦緪緫緭緱緵緶緹緺縈縐縑縕縗縜縝縠縧縨縬縭縯縳縶縿繄繅繇繎繐繒繘繟繡繢繥繫繮繯繳繸繾纁纆纇纊纍纑纕纘纚纝纞缼缻缽缾缿罃罄罇罏罒罓罛罜罝罡罣罤罥罦罭"],
    ["8fd5a1", "罱罽罾罿羀羋羍羏羐羑羖羗羜羡羢羦羪羭羴羼羿翀翃翈翎翏翛翟翣翥翨翬翮翯翲翺翽翾翿耇耈耊耍耎耏耑耓耔耖耝耞耟耠耤耦耬耮耰耴耵耷耹耺耼耾聀聄聠聤聦聭聱聵肁肈肎肜肞肦肧肫肸肹胈胍胏胒胔胕胗胘胠胭胮"],
    ["8fd6a1", "胰胲胳胶胹胺胾脃脋脖脗脘脜脞脠脤脧脬脰脵脺脼腅腇腊腌腒腗腠腡腧腨腩腭腯腷膁膐膄膅膆膋膎膖膘膛膞膢膮膲膴膻臋臃臅臊臎臏臕臗臛臝臞臡臤臫臬臰臱臲臵臶臸臹臽臿舀舃舏舓舔舙舚舝舡舢舨舲舴舺艃艄艅艆"],
    ["8fd7a1", "艋艎艏艑艖艜艠艣艧艭艴艻艽艿芀芁芃芄芇芉芊芎芑芔芖芘芚芛芠芡芣芤芧芨芩芪芮芰芲芴芷芺芼芾芿苆苐苕苚苠苢苤苨苪苭苯苶苷苽苾茀茁茇茈茊茋荔茛茝茞茟茡茢茬茭茮茰茳茷茺茼茽荂荃荄荇荍荎荑荕荖荗荰荸"],
    ["8fd8a1", "荽荿莀莂莄莆莍莒莔莕莘莙莛莜莝莦莧莩莬莾莿菀菇菉菏菐菑菔菝荓菨菪菶菸菹菼萁萆萊萏萑萕萙莭萯萹葅葇葈葊葍葏葑葒葖葘葙葚葜葠葤葥葧葪葰葳葴葶葸葼葽蒁蒅蒒蒓蒕蒞蒦蒨蒩蒪蒯蒱蒴蒺蒽蒾蓀蓂蓇蓈蓌蓏蓓"],
    ["8fd9a1", "蓜蓧蓪蓯蓰蓱蓲蓷蔲蓺蓻蓽蔂蔃蔇蔌蔎蔐蔜蔞蔢蔣蔤蔥蔧蔪蔫蔯蔳蔴蔶蔿蕆蕏", 4, "蕖蕙蕜", 6, "蕤蕫蕯蕹蕺蕻蕽蕿薁薅薆薉薋薌薏薓薘薝薟薠薢薥薧薴薶薷薸薼薽薾薿藂藇藊藋藎薭藘藚藟藠藦藨藭藳藶藼"],
    ["8fdaa1", "藿蘀蘄蘅蘍蘎蘐蘑蘒蘘蘙蘛蘞蘡蘧蘩蘶蘸蘺蘼蘽虀虂虆虒虓虖虗虘虙虝虠", 4, "虩虬虯虵虶虷虺蚍蚑蚖蚘蚚蚜蚡蚦蚧蚨蚭蚱蚳蚴蚵蚷蚸蚹蚿蛀蛁蛃蛅蛑蛒蛕蛗蛚蛜蛠蛣蛥蛧蚈蛺蛼蛽蜄蜅蜇蜋蜎蜏蜐蜓蜔蜙蜞蜟蜡蜣"],
    ["8fdba1", "蜨蜮蜯蜱蜲蜹蜺蜼蜽蜾蝀蝃蝅蝍蝘蝝蝡蝤蝥蝯蝱蝲蝻螃", 6, "螋螌螐螓螕螗螘螙螞螠螣螧螬螭螮螱螵螾螿蟁蟈蟉蟊蟎蟕蟖蟙蟚蟜蟟蟢蟣蟤蟪蟫蟭蟱蟳蟸蟺蟿蠁蠃蠆蠉蠊蠋蠐蠙蠒蠓蠔蠘蠚蠛蠜蠞蠟蠨蠭蠮蠰蠲蠵"],
    ["8fdca1", "蠺蠼衁衃衅衈衉衊衋衎衑衕衖衘衚衜衟衠衤衩衱衹衻袀袘袚袛袜袟袠袨袪袺袽袾裀裊", 4, "裑裒裓裛裞裧裯裰裱裵裷褁褆褍褎褏褕褖褘褙褚褜褠褦褧褨褰褱褲褵褹褺褾襀襂襅襆襉襏襒襗襚襛襜襡襢襣襫襮襰襳襵襺"],
    ["8fdda1", "襻襼襽覉覍覐覔覕覛覜覟覠覥覰覴覵覶覷覼觔", 4, "觥觩觫觭觱觳觶觹觽觿訄訅訇訏訑訒訔訕訞訠訢訤訦訫訬訯訵訷訽訾詀詃詅詇詉詍詎詓詖詗詘詜詝詡詥詧詵詶詷詹詺詻詾詿誀誃誆誋誏誐誒誖誗誙誟誧誩誮誯誳"],
    ["8fdea1", "誶誷誻誾諃諆諈諉諊諑諓諔諕諗諝諟諬諰諴諵諶諼諿謅謆謋謑謜謞謟謊謭謰謷謼譂", 4, "譈譒譓譔譙譍譞譣譭譶譸譹譼譾讁讄讅讋讍讏讔讕讜讞讟谸谹谽谾豅豇豉豋豏豑豓豔豗豘豛豝豙豣豤豦豨豩豭豳豵豶豻豾貆"],
    ["8fdfa1", "貇貋貐貒貓貙貛貜貤貹貺賅賆賉賋賏賖賕賙賝賡賨賬賯賰賲賵賷賸賾賿贁贃贉贒贗贛赥赩赬赮赿趂趄趈趍趐趑趕趞趟趠趦趫趬趯趲趵趷趹趻跀跅跆跇跈跊跎跑跔跕跗跙跤跥跧跬跰趼跱跲跴跽踁踄踅踆踋踑踔踖踠踡踢"],
    ["8fe0a1", "踣踦踧踱踳踶踷踸踹踽蹀蹁蹋蹍蹎蹏蹔蹛蹜蹝蹞蹡蹢蹩蹬蹭蹯蹰蹱蹹蹺蹻躂躃躉躐躒躕躚躛躝躞躢躧躩躭躮躳躵躺躻軀軁軃軄軇軏軑軔軜軨軮軰軱軷軹軺軭輀輂輇輈輏輐輖輗輘輞輠輡輣輥輧輨輬輭輮輴輵輶輷輺轀轁"],
    ["8fe1a1", "轃轇轏轑", 4, "轘轝轞轥辝辠辡辤辥辦辵辶辸达迀迁迆迊迋迍运迒迓迕迠迣迤迨迮迱迵迶迻迾适逄逈逌逘逛逨逩逯逪逬逭逳逴逷逿遃遄遌遛遝遢遦遧遬遰遴遹邅邈邋邌邎邐邕邗邘邙邛邠邡邢邥邰邲邳邴邶邽郌邾郃"],
    ["8fe2a1", "郄郅郇郈郕郗郘郙郜郝郟郥郒郶郫郯郰郴郾郿鄀鄄鄅鄆鄈鄍鄐鄔鄖鄗鄘鄚鄜鄞鄠鄥鄢鄣鄧鄩鄮鄯鄱鄴鄶鄷鄹鄺鄼鄽酃酇酈酏酓酗酙酚酛酡酤酧酭酴酹酺酻醁醃醅醆醊醎醑醓醔醕醘醞醡醦醨醬醭醮醰醱醲醳醶醻醼醽醿"],
    ["8fe3a1", "釂釃釅釓釔釗釙釚釞釤釥釩釪釬", 5, "釷釹釻釽鈀鈁鈄鈅鈆鈇鈉鈊鈌鈐鈒鈓鈖鈘鈜鈝鈣鈤鈥鈦鈨鈮鈯鈰鈳鈵鈶鈸鈹鈺鈼鈾鉀鉂鉃鉆鉇鉊鉍鉎鉏鉑鉘鉙鉜鉝鉠鉡鉥鉧鉨鉩鉮鉯鉰鉵", 4, "鉻鉼鉽鉿銈銉銊銍銎銒銗"],
    ["8fe4a1", "銙銟銠銤銥銧銨銫銯銲銶銸銺銻銼銽銿", 4, "鋅鋆鋇鋈鋋鋌鋍鋎鋐鋓鋕鋗鋘鋙鋜鋝鋟鋠鋡鋣鋥鋧鋨鋬鋮鋰鋹鋻鋿錀錂錈錍錑錔錕錜錝錞錟錡錤錥錧錩錪錳錴錶錷鍇鍈鍉鍐鍑鍒鍕鍗鍘鍚鍞鍤鍥鍧鍩鍪鍭鍯鍰鍱鍳鍴鍶"],
    ["8fe5a1", "鍺鍽鍿鎀鎁鎂鎈鎊鎋鎍鎏鎒鎕鎘鎛鎞鎡鎣鎤鎦鎨鎫鎴鎵鎶鎺鎩鏁鏄鏅鏆鏇鏉", 4, "鏓鏙鏜鏞鏟鏢鏦鏧鏹鏷鏸鏺鏻鏽鐁鐂鐄鐈鐉鐍鐎鐏鐕鐖鐗鐟鐮鐯鐱鐲鐳鐴鐻鐿鐽鑃鑅鑈鑊鑌鑕鑙鑜鑟鑡鑣鑨鑫鑭鑮鑯鑱鑲钄钃镸镹"],
    ["8fe6a1", "镾閄閈閌閍閎閝閞閟閡閦閩閫閬閴閶閺閽閿闆闈闉闋闐闑闒闓闙闚闝闞闟闠闤闦阝阞阢阤阥阦阬阱阳阷阸阹阺阼阽陁陒陔陖陗陘陡陮陴陻陼陾陿隁隂隃隄隉隑隖隚隝隟隤隥隦隩隮隯隳隺雊雒嶲雘雚雝雞雟雩雯雱雺霂"],
    ["8fe7a1", "霃霅霉霚霛霝霡霢霣霨霱霳靁靃靊靎靏靕靗靘靚靛靣靧靪靮靳靶靷靸靻靽靿鞀鞉鞕鞖鞗鞙鞚鞞鞟鞢鞬鞮鞱鞲鞵鞶鞸鞹鞺鞼鞾鞿韁韄韅韇韉韊韌韍韎韐韑韔韗韘韙韝韞韠韛韡韤韯韱韴韷韸韺頇頊頙頍頎頔頖頜頞頠頣頦"],
    ["8fe8a1", "頫頮頯頰頲頳頵頥頾顄顇顊顑顒顓顖顗顙顚顢顣顥顦顪顬颫颭颮颰颴颷颸颺颻颿飂飅飈飌飡飣飥飦飧飪飳飶餂餇餈餑餕餖餗餚餛餜餟餢餦餧餫餱", 4, "餹餺餻餼饀饁饆饇饈饍饎饔饘饙饛饜饞饟饠馛馝馟馦馰馱馲馵"],
    ["8fe9a1", "馹馺馽馿駃駉駓駔駙駚駜駞駧駪駫駬駰駴駵駹駽駾騂騃騄騋騌騐騑騖騞騠騢騣騤騧騭騮騳騵騶騸驇驁驄驊驋驌驎驑驔驖驝骪骬骮骯骲骴骵骶骹骻骾骿髁髃髆髈髎髐髒髕髖髗髛髜髠髤髥髧髩髬髲髳髵髹髺髽髿", 4],
    ["8feaa1", "鬄鬅鬈鬉鬋鬌鬍鬎鬐鬒鬖鬙鬛鬜鬠鬦鬫鬭鬳鬴鬵鬷鬹鬺鬽魈魋魌魕魖魗魛魞魡魣魥魦魨魪", 4, "魳魵魷魸魹魿鮀鮄鮅鮆鮇鮉鮊鮋鮍鮏鮐鮔鮚鮝鮞鮦鮧鮩鮬鮰鮱鮲鮷鮸鮻鮼鮾鮿鯁鯇鯈鯎鯐鯗鯘鯝鯟鯥鯧鯪鯫鯯鯳鯷鯸"],
    ["8feba1", "鯹鯺鯽鯿鰀鰂鰋鰏鰑鰖鰘鰙鰚鰜鰞鰢鰣鰦", 4, "鰱鰵鰶鰷鰽鱁鱃鱄鱅鱉鱊鱎鱏鱐鱓鱔鱖鱘鱛鱝鱞鱟鱣鱩鱪鱜鱫鱨鱮鱰鱲鱵鱷鱻鳦鳲鳷鳹鴋鴂鴑鴗鴘鴜鴝鴞鴯鴰鴲鴳鴴鴺鴼鵅鴽鵂鵃鵇鵊鵓鵔鵟鵣鵢鵥鵩鵪鵫鵰鵶鵷鵻"],
    ["8feca1", "鵼鵾鶃鶄鶆鶊鶍鶎鶒鶓鶕鶖鶗鶘鶡鶪鶬鶮鶱鶵鶹鶼鶿鷃鷇鷉鷊鷔鷕鷖鷗鷚鷞鷟鷠鷥鷧鷩鷫鷮鷰鷳鷴鷾鸊鸂鸇鸎鸐鸑鸒鸕鸖鸙鸜鸝鹺鹻鹼麀麂麃麄麅麇麎麏麖麘麛麞麤麨麬麮麯麰麳麴麵黆黈黋黕黟黤黧黬黭黮黰黱黲黵"],
    ["8feda1", "黸黿鼂鼃鼉鼏鼐鼑鼒鼔鼖鼗鼙鼚鼛鼟鼢鼦鼪鼫鼯鼱鼲鼴鼷鼹鼺鼼鼽鼿齁齃", 4, "齓齕齖齗齘齚齝齞齨齩齭", 4, "齳齵齺齽龏龐龑龒龔龖龗龞龡龢龣龥"]
  ];
});

// node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\0", 127, "€"],
    ["8140", "丂丄丅丆丏丒丗丟丠両丣並丩丮丯丱丳丵丷丼乀乁乂乄乆乊乑乕乗乚乛乢乣乤乥乧乨乪", 5, "乲乴", 9, "乿", 6, "亇亊"],
    ["8180", "亐亖亗亙亜亝亞亣亪亯亰亱亴亶亷亸亹亼亽亾仈仌仏仐仒仚仛仜仠仢仦仧仩仭仮仯仱仴仸仹仺仼仾伀伂", 6, "伋伌伒", 4, "伜伝伡伣伨伩伬伭伮伱伳伵伷伹伻伾", 4, "佄佅佇", 5, "佒佔佖佡佢佦佨佪佫佭佮佱佲併佷佸佹佺佽侀侁侂侅來侇侊侌侎侐侒侓侕侖侘侙侚侜侞侟価侢"],
    ["8240", "侤侫侭侰", 4, "侶", 8, "俀俁係俆俇俈俉俋俌俍俒", 4, "俙俛俠俢俤俥俧俫俬俰俲俴俵俶俷俹俻俼俽俿", 11],
    ["8280", "個倎倐們倓倕倖倗倛倝倞倠倢倣値倧倫倯", 10, "倻倽倿偀偁偂偄偅偆偉偊偋偍偐", 4, "偖偗偘偙偛偝", 7, "偦", 5, "偭", 8, "偸偹偺偼偽傁傂傃傄傆傇傉傊傋傌傎", 20, "傤傦傪傫傭", 4, "傳", 6, "傼"],
    ["8340", "傽", 17, "僐", 5, "僗僘僙僛", 10, "僨僩僪僫僯僰僱僲僴僶", 4, "僼", 9, "儈"],
    ["8380", "儉儊儌", 5, "儓", 13, "儢", 28, "兂兇兊兌兎兏児兒兓兗兘兙兛兝", 4, "兣兤兦內兩兪兯兲兺兾兿冃冄円冇冊冋冎冏冐冑冓冔冘冚冝冞冟冡冣冦", 4, "冭冮冴冸冹冺冾冿凁凂凃凅凈凊凍凎凐凒", 5],
    ["8440", "凘凙凚凜凞凟凢凣凥", 5, "凬凮凱凲凴凷凾刄刅刉刋刌刏刐刓刔刕刜刞刟刡刢刣別刦刧刪刬刯刱刲刴刵刼刾剄", 5, "剋剎剏剒剓剕剗剘"],
    ["8480", "剙剚剛剝剟剠剢剣剤剦剨剫剬剭剮剰剱剳", 9, "剾劀劃", 4, "劉", 6, "劑劒劔", 6, "劜劤劥劦劧劮劯劰労", 9, "勀勁勂勄勅勆勈勊勌勍勎勏勑勓勔動勗務", 5, "勠勡勢勣勥", 10, "勱", 7, "勻勼勽匁匂匃匄匇匉匊匋匌匎"],
    ["8540", "匑匒匓匔匘匛匜匞匟匢匤匥匧匨匩匫匬匭匯", 9, "匼匽區卂卄卆卋卌卍卐協単卙卛卝卥卨卪卬卭卲卶卹卻卼卽卾厀厁厃厇厈厊厎厏"],
    ["8580", "厐", 4, "厖厗厙厛厜厞厠厡厤厧厪厫厬厭厯", 6, "厷厸厹厺厼厽厾叀參", 4, "収叏叐叒叓叕叚叜叝叞叡叢叧叴叺叾叿吀吂吅吇吋吔吘吙吚吜吢吤吥吪吰吳吶吷吺吽吿呁呂呄呅呇呉呌呍呎呏呑呚呝", 4, "呣呥呧呩", 7, "呴呹呺呾呿咁咃咅咇咈咉咊咍咑咓咗咘咜咞咟咠咡"],
    ["8640", "咢咥咮咰咲咵咶咷咹咺咼咾哃哅哊哋哖哘哛哠", 4, "哫哬哯哰哱哴", 5, "哻哾唀唂唃唄唅唈唊", 4, "唒唓唕", 5, "唜唝唞唟唡唥唦"],
    ["8680", "唨唩唫唭唲唴唵唶唸唹唺唻唽啀啂啅啇啈啋", 4, "啑啒啓啔啗", 4, "啝啞啟啠啢啣啨啩啫啯", 5, "啹啺啽啿喅喆喌喍喎喐喒喓喕喖喗喚喛喞喠", 6, "喨", 8, "喲喴営喸喺喼喿", 4, "嗆嗇嗈嗊嗋嗎嗏嗐嗕嗗", 4, "嗞嗠嗢嗧嗩嗭嗮嗰嗱嗴嗶嗸", 4, "嗿嘂嘃嘄嘅"],
    ["8740", "嘆嘇嘊嘋嘍嘐", 7, "嘙嘚嘜嘝嘠嘡嘢嘥嘦嘨嘩嘪嘫嘮嘯嘰嘳嘵嘷嘸嘺嘼嘽嘾噀", 11, "噏", 4, "噕噖噚噛噝", 4],
    ["8780", "噣噥噦噧噭噮噯噰噲噳噴噵噷噸噹噺噽", 7, "嚇", 6, "嚐嚑嚒嚔", 14, "嚤", 10, "嚰", 6, "嚸嚹嚺嚻嚽", 12, "囋", 8, "囕囖囘囙囜団囥", 5, "囬囮囯囲図囶囷囸囻囼圀圁圂圅圇國", 6],
    ["8840", "園", 9, "圝圞圠圡圢圤圥圦圧圫圱圲圴", 4, "圼圽圿坁坃坄坅坆坈坉坋坒", 4, "坘坙坢坣坥坧坬坮坰坱坲坴坵坸坹坺坽坾坿垀"],
    ["8880", "垁垇垈垉垊垍", 4, "垔", 6, "垜垝垞垟垥垨垪垬垯垰垱垳垵垶垷垹", 8, "埄", 6, "埌埍埐埑埓埖埗埛埜埞埡埢埣埥", 7, "埮埰埱埲埳埵埶執埻埼埾埿堁堃堄堅堈堉堊堌堎堏堐堒堓堔堖堗堘堚堛堜堝堟堢堣堥", 4, "堫", 4, "報堲堳場堶", 7],
    ["8940", "堾", 5, "塅", 6, "塎塏塐塒塓塕塖塗塙", 4, "塟", 5, "塦", 4, "塭", 16, "塿墂墄墆墇墈墊墋墌"],
    ["8980", "墍", 4, "墔", 4, "墛墜墝墠", 7, "墪", 17, "墽墾墿壀壂壃壄壆", 10, "壒壓壔壖", 13, "壥", 5, "壭壯壱売壴壵壷壸壺", 7, "夃夅夆夈", 4, "夎夐夑夒夓夗夘夛夝夞夠夡夢夣夦夨夬夰夲夳夵夶夻"],
    ["8a40", "夽夾夿奀奃奅奆奊奌奍奐奒奓奙奛", 4, "奡奣奤奦", 12, "奵奷奺奻奼奾奿妀妅妉妋妌妎妏妐妑妔妕妘妚妛妜妝妟妠妡妢妦"],
    ["8a80", "妧妬妭妰妱妳", 5, "妺妼妽妿", 6, "姇姈姉姌姍姎姏姕姖姙姛姞", 4, "姤姦姧姩姪姫姭", 11, "姺姼姽姾娀娂娊娋娍娎娏娐娒娔娕娖娗娙娚娛娝娞娡娢娤娦娧娨娪", 6, "娳娵娷", 4, "娽娾娿婁", 4, "婇婈婋", 9, "婖婗婘婙婛", 5],
    ["8b40", "婡婣婤婥婦婨婩婫", 8, "婸婹婻婼婽婾媀", 17, "媓", 6, "媜", 13, "媫媬"],
    ["8b80", "媭", 4, "媴媶媷媹", 4, "媿嫀嫃", 5, "嫊嫋嫍", 4, "嫓嫕嫗嫙嫚嫛嫝嫞嫟嫢嫤嫥嫧嫨嫪嫬", 4, "嫲", 22, "嬊", 11, "嬘", 25, "嬳嬵嬶嬸", 7, "孁", 6],
    ["8c40", "孈", 7, "孒孖孞孠孡孧孨孫孭孮孯孲孴孶孷學孹孻孼孾孿宂宆宊宍宎宐宑宒宔宖実宧宨宩宬宭宮宯宱宲宷宺宻宼寀寁寃寈寉寊寋寍寎寏"],
    ["8c80", "寑寔", 8, "寠寢寣實寧審", 4, "寯寱", 6, "寽対尀専尃尅將專尋尌對導尐尒尓尗尙尛尞尟尠尡尣尦尨尩尪尫尭尮尯尰尲尳尵尶尷屃屄屆屇屌屍屒屓屔屖屗屘屚屛屜屝屟屢層屧", 6, "屰屲", 6, "屻屼屽屾岀岃", 4, "岉岊岋岎岏岒岓岕岝", 4, "岤", 4],
    ["8d40", "岪岮岯岰岲岴岶岹岺岻岼岾峀峂峃峅", 5, "峌", 5, "峓", 5, "峚", 6, "峢峣峧峩峫峬峮峯峱", 9, "峼", 4],
    ["8d80", "崁崄崅崈", 5, "崏", 4, "崕崗崘崙崚崜崝崟", 4, "崥崨崪崫崬崯", 4, "崵", 7, "崿", 7, "嵈嵉嵍", 10, "嵙嵚嵜嵞", 10, "嵪嵭嵮嵰嵱嵲嵳嵵", 12, "嶃", 21, "嶚嶛嶜嶞嶟嶠"],
    ["8e40", "嶡", 21, "嶸", 12, "巆", 6, "巎", 12, "巜巟巠巣巤巪巬巭"],
    ["8e80", "巰巵巶巸", 4, "巿帀帄帇帉帊帋帍帎帒帓帗帞", 7, "帨", 4, "帯帰帲", 4, "帹帺帾帿幀幁幃幆", 5, "幍", 6, "幖", 4, "幜幝幟幠幣", 14, "幵幷幹幾庁庂広庅庈庉庌庍庎庒庘庛庝庡庢庣庤庨", 4, "庮", 4, "庴庺庻庼庽庿", 6],
    ["8f40", "廆廇廈廋", 5, "廔廕廗廘廙廚廜", 11, "廩廫", 8, "廵廸廹廻廼廽弅弆弇弉弌弍弎弐弒弔弖弙弚弜弝弞弡弢弣弤"],
    ["8f80", "弨弫弬弮弰弲", 6, "弻弽弾弿彁", 14, "彑彔彙彚彛彜彞彟彠彣彥彧彨彫彮彯彲彴彵彶彸彺彽彾彿徃徆徍徎徏徑従徔徖徚徛徝從徟徠徢", 5, "復徫徬徯", 5, "徶徸徹徺徻徾", 4, "忇忈忊忋忎忓忔忕忚忛応忞忟忢忣忥忦忨忩忬忯忰忲忳忴忶忷忹忺忼怇"],
    ["9040", "怈怉怋怌怐怑怓怗怘怚怞怟怢怣怤怬怭怮怰", 4, "怶", 4, "怽怾恀恄", 6, "恌恎恏恑恓恔恖恗恘恛恜恞恟恠恡恥恦恮恱恲恴恵恷恾悀"],
    ["9080", "悁悂悅悆悇悈悊悋悎悏悐悑悓悕悗悘悙悜悞悡悢悤悥悧悩悪悮悰悳悵悶悷悹悺悽", 7, "惇惈惉惌", 4, "惒惓惔惖惗惙惛惞惡", 4, "惪惱惲惵惷惸惻", 4, "愂愃愄愅愇愊愋愌愐", 4, "愖愗愘愙愛愜愝愞愡愢愥愨愩愪愬", 18, "慀", 6],
    ["9140", "慇慉態慍慏慐慒慓慔慖", 6, "慞慟慠慡慣慤慥慦慩", 6, "慱慲慳慴慶慸", 18, "憌憍憏", 4, "憕"],
    ["9180", "憖", 6, "憞", 8, "憪憫憭", 9, "憸", 5, "憿懀懁懃", 4, "應懌", 4, "懓懕", 16, "懧", 13, "懶", 8, "戀", 5, "戇戉戓戔戙戜戝戞戠戣戦戧戨戩戫戭戯戰戱戲戵戶戸", 4, "扂扄扅扆扊"],
    ["9240", "扏扐払扖扗扙扚扜", 6, "扤扥扨扱扲扴扵扷扸扺扻扽抁抂抃抅抆抇抈抋", 5, "抔抙抜抝択抣抦抧抩抪抭抮抯抰抲抳抴抶抷抸抺抾拀拁"],
    ["9280", "拃拋拏拑拕拝拞拠拡拤拪拫拰拲拵拸拹拺拻挀挃挄挅挆挊挋挌挍挏挐挒挓挔挕挗挘挙挜挦挧挩挬挭挮挰挱挳", 5, "挻挼挾挿捀捁捄捇捈捊捑捒捓捔捖", 7, "捠捤捥捦捨捪捫捬捯捰捲捳捴捵捸捹捼捽捾捿掁掃掄掅掆掋掍掑掓掔掕掗掙", 6, "採掤掦掫掯掱掲掵掶掹掻掽掿揀"],
    ["9340", "揁揂揃揅揇揈揊揋揌揑揓揔揕揗", 6, "揟揢揤", 4, "揫揬揮揯揰揱揳揵揷揹揺揻揼揾搃搄搆", 4, "損搎搑搒搕", 5, "搝搟搢搣搤"],
    ["9380", "搥搧搨搩搫搮", 5, "搵", 4, "搻搼搾摀摂摃摉摋", 6, "摓摕摖摗摙", 4, "摟", 7, "摨摪摫摬摮", 9, "摻", 6, "撃撆撈", 8, "撓撔撗撘撚撛撜撝撟", 4, "撥撦撧撨撪撫撯撱撲撳撴撶撹撻撽撾撿擁擃擄擆", 6, "擏擑擓擔擕擖擙據"],
    ["9440", "擛擜擝擟擠擡擣擥擧", 24, "攁", 7, "攊", 7, "攓", 4, "攙", 8],
    ["9480", "攢攣攤攦", 4, "攬攭攰攱攲攳攷攺攼攽敀", 4, "敆敇敊敋敍敎敐敒敓敔敗敘敚敜敟敠敡敤敥敧敨敩敪敭敮敯敱敳敵敶數", 14, "斈斉斊斍斎斏斒斔斕斖斘斚斝斞斠斢斣斦斨斪斬斮斱", 7, "斺斻斾斿旀旂旇旈旉旊旍旐旑旓旔旕旘", 7, "旡旣旤旪旫"],
    ["9540", "旲旳旴旵旸旹旻", 4, "昁昄昅昇昈昉昋昍昐昑昒昖昗昘昚昛昜昞昡昢昣昤昦昩昪昫昬昮昰昲昳昷", 4, "昽昿晀時晄", 6, "晍晎晐晑晘"],
    ["9580", "晙晛晜晝晞晠晢晣晥晧晩", 4, "晱晲晳晵晸晹晻晼晽晿暀暁暃暅暆暈暉暊暋暍暎暏暐暒暓暔暕暘", 4, "暞", 8, "暩", 4, "暯", 4, "暵暶暷暸暺暻暼暽暿", 25, "曚曞", 7, "曧曨曪", 5, "曱曵曶書曺曻曽朁朂會"],
    ["9640", "朄朅朆朇朌朎朏朑朒朓朖朘朙朚朜朞朠", 5, "朧朩朮朰朲朳朶朷朸朹朻朼朾朿杁杄杅杇杊杋杍杒杔杕杗", 4, "杝杢杣杤杦杧杫杬杮東杴杶"],
    ["9680", "杸杹杺杻杽枀枂枃枅枆枈枊枌枍枎枏枑枒枓枔枖枙枛枟枠枡枤枦枩枬枮枱枲枴枹", 7, "柂柅", 9, "柕柖柗柛柟柡柣柤柦柧柨柪柫柭柮柲柵", 7, "柾栁栂栃栄栆栍栐栒栔栕栘", 4, "栞栟栠栢", 6, "栫", 6, "栴栵栶栺栻栿桇桋桍桏桒桖", 5],
    ["9740", "桜桝桞桟桪桬", 7, "桵桸", 8, "梂梄梇", 7, "梐梑梒梔梕梖梘", 9, "梣梤梥梩梪梫梬梮梱梲梴梶梷梸"],
    ["9780", "梹", 6, "棁棃", 5, "棊棌棎棏棐棑棓棔棖棗棙棛", 4, "棡棢棤", 9, "棯棲棳棴棶棷棸棻棽棾棿椀椂椃椄椆", 4, "椌椏椑椓", 11, "椡椢椣椥", 7, "椮椯椱椲椳椵椶椷椸椺椻椼椾楀楁楃", 16, "楕楖楘楙楛楜楟"],
    ["9840", "楡楢楤楥楧楨楩楪楬業楯楰楲", 4, "楺楻楽楾楿榁榃榅榊榋榌榎", 5, "榖榗榙榚榝", 9, "榩榪榬榮榯榰榲榳榵榶榸榹榺榼榽"],
    ["9880", "榾榿槀槂", 7, "構槍槏槑槒槓槕", 5, "槜槝槞槡", 11, "槮槯槰槱槳", 9, "槾樀", 9, "樋", 11, "標", 5, "樠樢", 5, "権樫樬樭樮樰樲樳樴樶", 6, "樿", 4, "橅橆橈", 7, "橑", 6, "橚"],
    ["9940", "橜", 4, "橢橣橤橦", 10, "橲", 6, "橺橻橽橾橿檁檂檃檅", 8, "檏檒", 4, "檘", 7, "檡", 5],
    ["9980", "檧檨檪檭", 114, "欥欦欨", 6],
    ["9a40", "欯欰欱欳欴欵欶欸欻欼欽欿歀歁歂歄歅歈歊歋歍", 11, "歚", 7, "歨歩歫", 13, "歺歽歾歿殀殅殈"],
    ["9a80", "殌殎殏殐殑殔殕殗殘殙殜", 4, "殢", 7, "殫", 7, "殶殸", 6, "毀毃毄毆", 4, "毌毎毐毑毘毚毜", 4, "毢", 7, "毬毭毮毰毱毲毴毶毷毸毺毻毼毾", 6, "氈", 4, "氎氒気氜氝氞氠氣氥氫氬氭氱氳氶氷氹氺氻氼氾氿汃汄汅汈汋", 4, "汑汒汓汖汘"],
    ["9b40", "汙汚汢汣汥汦汧汫", 4, "汱汳汵汷汸決汻汼汿沀沄沇沊沋沍沎沑沒沕沖沗沘沚沜沝沞沠沢沨沬沯沰沴沵沶沷沺泀況泂泃泆泇泈泋泍泎泏泑泒泘"],
    ["9b80", "泙泚泜泝泟泤泦泧泩泬泭泲泴泹泿洀洂洃洅洆洈洉洊洍洏洐洑洓洔洕洖洘洜洝洟", 5, "洦洨洩洬洭洯洰洴洶洷洸洺洿浀浂浄浉浌浐浕浖浗浘浛浝浟浡浢浤浥浧浨浫浬浭浰浱浲浳浵浶浹浺浻浽", 4, "涃涄涆涇涊涋涍涏涐涒涖", 4, "涜涢涥涬涭涰涱涳涴涶涷涹", 5, "淁淂淃淈淉淊"],
    ["9c40", "淍淎淏淐淒淓淔淕淗淚淛淜淟淢淣淥淧淨淩淪淭淯淰淲淴淵淶淸淺淽", 7, "渆渇済渉渋渏渒渓渕渘渙減渜渞渟渢渦渧渨渪測渮渰渱渳渵"],
    ["9c80", "渶渷渹渻", 7, "湅", 7, "湏湐湑湒湕湗湙湚湜湝湞湠", 10, "湬湭湯", 14, "満溁溂溄溇溈溊", 4, "溑", 6, "溙溚溛溝溞溠溡溣溤溦溨溩溫溬溭溮溰溳溵溸溹溼溾溿滀滃滄滅滆滈滉滊滌滍滎滐滒滖滘滙滛滜滝滣滧滪", 5],
    ["9d40", "滰滱滲滳滵滶滷滸滺", 7, "漃漄漅漇漈漊", 4, "漐漑漒漖", 9, "漡漢漣漥漦漧漨漬漮漰漲漴漵漷", 6, "漿潀潁潂"],
    ["9d80", "潃潄潅潈潉潊潌潎", 9, "潙潚潛潝潟潠潡潣潤潥潧", 5, "潯潰潱潳潵潶潷潹潻潽", 6, "澅澆澇澊澋澏", 12, "澝澞澟澠澢", 4, "澨", 10, "澴澵澷澸澺", 5, "濁濃", 5, "濊", 6, "濓", 10, "濟濢濣濤濥"],
    ["9e40", "濦", 7, "濰", 32, "瀒", 7, "瀜", 6, "瀤", 6],
    ["9e80", "瀫", 9, "瀶瀷瀸瀺", 17, "灍灎灐", 13, "灟", 11, "灮灱灲灳灴灷灹灺灻災炁炂炃炄炆炇炈炋炌炍炏炐炑炓炗炘炚炛炞", 12, "炰炲炴炵炶為炾炿烄烅烆烇烉烋", 12, "烚"],
    ["9f40", "烜烝烞烠烡烢烣烥烪烮烰", 6, "烸烺烻烼烾", 10, "焋", 4, "焑焒焔焗焛", 10, "焧", 7, "焲焳焴"],
    ["9f80", "焵焷", 13, "煆煇煈煉煋煍煏", 12, "煝煟", 4, "煥煩", 4, "煯煰煱煴煵煶煷煹煻煼煾", 5, "熅", 4, "熋熌熍熎熐熑熒熓熕熖熗熚", 4, "熡", 6, "熩熪熫熭", 5, "熴熶熷熸熺", 8, "燄", 9, "燏", 4],
    ["a040", "燖", 9, "燡燢燣燤燦燨", 5, "燯", 9, "燺", 11, "爇", 19],
    ["a080", "爛爜爞", 9, "爩爫爭爮爯爲爳爴爺爼爾牀", 6, "牉牊牋牎牏牐牑牓牔牕牗牘牚牜牞牠牣牤牥牨牪牫牬牭牰牱牳牴牶牷牸牻牼牽犂犃犅", 4, "犌犎犐犑犓", 11, "犠", 11, "犮犱犲犳犵犺", 6, "狅狆狇狉狊狋狌狏狑狓狔狕狖狘狚狛"],
    ["a1a1", "　、。·ˉˇ¨〃々—～‖…‘’“”〔〕〈", 7, "〖〗【】±×÷∶∧∨∑∏∪∩∈∷√⊥∥∠⌒⊙∫∮≡≌≈∽∝≠≮≯≤≥∞∵∴♂♀°′″℃＄¤￠￡‰§№☆★○●◎◇◆□■△▲※→←↑↓〓"],
    ["a2a1", "ⅰ", 9],
    ["a2b1", "⒈", 19, "⑴", 19, "①", 9],
    ["a2e5", "㈠", 9],
    ["a2f1", "Ⅰ", 11],
    ["a3a1", "！＂＃￥％", 88, "￣"],
    ["a4a1", "ぁ", 82],
    ["a5a1", "ァ", 85],
    ["a6a1", "Α", 16, "Σ", 6],
    ["a6c1", "α", 16, "σ", 6],
    ["a6e0", "︵︶︹︺︿﹀︽︾﹁﹂﹃﹄"],
    ["a6ee", "︻︼︷︸︱"],
    ["a6f4", "︳︴"],
    ["a7a1", "А", 5, "ЁЖ", 25],
    ["a7d1", "а", 5, "ёж", 25],
    ["a840", "ˊˋ˙–―‥‵℅℉↖↗↘↙∕∟∣≒≦≧⊿═", 35, "▁", 6],
    ["a880", "█", 7, "▓▔▕▼▽◢◣◤◥☉⊕〒〝〞"],
    ["a8a1", "āáǎàēéěèīíǐìōóǒòūúǔùǖǘǚǜüêɑ"],
    ["a8bd", "ńň"],
    ["a8c0", "ɡ"],
    ["a8c5", "ㄅ", 36],
    ["a940", "〡", 8, "㊣㎎㎏㎜㎝㎞㎡㏄㏎㏑㏒㏕︰￢￤"],
    ["a959", "℡㈱"],
    ["a95c", "‐"],
    ["a960", "ー゛゜ヽヾ〆ゝゞ﹉", 9, "﹔﹕﹖﹗﹙", 8],
    ["a980", "﹢", 4, "﹨﹩﹪﹫"],
    ["a996", "〇"],
    ["a9a4", "─", 75],
    ["aa40", "狜狝狟狢", 5, "狪狫狵狶狹狽狾狿猀猂猄", 5, "猋猌猍猏猐猑猒猔猘猙猚猟猠猣猤猦猧猨猭猯猰猲猳猵猶猺猻猼猽獀", 8],
    ["aa80", "獉獊獋獌獎獏獑獓獔獕獖獘", 7, "獡", 10, "獮獰獱"],
    ["ab40", "獲", 11, "獿", 4, "玅玆玈玊玌玍玏玐玒玓玔玕玗玘玙玚玜玝玞玠玡玣", 5, "玪玬玭玱玴玵玶玸玹玼玽玾玿珁珃", 4],
    ["ab80", "珋珌珎珒", 6, "珚珛珜珝珟珡珢珣珤珦珨珪珫珬珮珯珰珱珳", 4],
    ["ac40", "珸", 10, "琄琇琈琋琌琍琎琑", 8, "琜", 5, "琣琤琧琩琫琭琯琱琲琷", 4, "琽琾琿瑀瑂", 11],
    ["ac80", "瑎", 6, "瑖瑘瑝瑠", 12, "瑮瑯瑱", 4, "瑸瑹瑺"],
    ["ad40", "瑻瑼瑽瑿璂璄璅璆璈璉璊璌璍璏璑", 10, "璝璟", 7, "璪", 15, "璻", 12],
    ["ad80", "瓈", 9, "瓓", 8, "瓝瓟瓡瓥瓧", 6, "瓰瓱瓲"],
    ["ae40", "瓳瓵瓸", 6, "甀甁甂甃甅", 7, "甎甐甒甔甕甖甗甛甝甞甠", 4, "甦甧甪甮甴甶甹甼甽甿畁畂畃畄畆畇畉畊畍畐畑畒畓畕畖畗畘"],
    ["ae80", "畝", 7, "畧畨畩畫", 6, "畳畵當畷畺", 4, "疀疁疂疄疅疇"],
    ["af40", "疈疉疊疌疍疎疐疓疕疘疛疜疞疢疦", 4, "疭疶疷疺疻疿痀痁痆痋痌痎痏痐痑痓痗痙痚痜痝痟痠痡痥痩痬痭痮痯痲痳痵痶痷痸痺痻痽痾瘂瘄瘆瘇"],
    ["af80", "瘈瘉瘋瘍瘎瘏瘑瘒瘓瘔瘖瘚瘜瘝瘞瘡瘣瘧瘨瘬瘮瘯瘱瘲瘶瘷瘹瘺瘻瘽癁療癄"],
    ["b040", "癅", 6, "癎", 5, "癕癗", 4, "癝癟癠癡癢癤", 6, "癬癭癮癰", 7, "癹発發癿皀皁皃皅皉皊皌皍皏皐皒皔皕皗皘皚皛"],
    ["b080", "皜", 7, "皥", 8, "皯皰皳皵", 9, "盀盁盃啊阿埃挨哎唉哀皑癌蔼矮艾碍爱隘鞍氨安俺按暗岸胺案肮昂盎凹敖熬翱袄傲奥懊澳芭捌扒叭吧笆八疤巴拔跋靶把耙坝霸罢爸白柏百摆佰败拜稗斑班搬扳般颁板版扮拌伴瓣半办绊邦帮梆榜膀绑棒磅蚌镑傍谤苞胞包褒剥"],
    ["b140", "盄盇盉盋盌盓盕盙盚盜盝盞盠", 4, "盦", 7, "盰盳盵盶盷盺盻盽盿眀眂眃眅眆眊県眎", 10, "眛眜眝眞眡眣眤眥眧眪眫"],
    ["b180", "眬眮眰", 4, "眹眻眽眾眿睂睄睅睆睈", 7, "睒", 7, "睜薄雹保堡饱宝抱报暴豹鲍爆杯碑悲卑北辈背贝钡倍狈备惫焙被奔苯本笨崩绷甭泵蹦迸逼鼻比鄙笔彼碧蓖蔽毕毙毖币庇痹闭敝弊必辟壁臂避陛鞭边编贬扁便变卞辨辩辫遍标彪膘表鳖憋别瘪彬斌濒滨宾摈兵冰柄丙秉饼炳"],
    ["b240", "睝睞睟睠睤睧睩睪睭", 11, "睺睻睼瞁瞂瞃瞆", 5, "瞏瞐瞓", 11, "瞡瞣瞤瞦瞨瞫瞭瞮瞯瞱瞲瞴瞶", 4],
    ["b280", "瞼瞾矀", 12, "矎", 8, "矘矙矚矝", 4, "矤病并玻菠播拨钵波博勃搏铂箔伯帛舶脖膊渤泊驳捕卜哺补埠不布步簿部怖擦猜裁材才财睬踩采彩菜蔡餐参蚕残惭惨灿苍舱仓沧藏操糙槽曹草厕策侧册测层蹭插叉茬茶查碴搽察岔差诧拆柴豺搀掺蝉馋谗缠铲产阐颤昌猖"],
    ["b340", "矦矨矪矯矰矱矲矴矵矷矹矺矻矼砃", 5, "砊砋砎砏砐砓砕砙砛砞砠砡砢砤砨砪砫砮砯砱砲砳砵砶砽砿硁硂硃硄硆硈硉硊硋硍硏硑硓硔硘硙硚"],
    ["b380", "硛硜硞", 11, "硯", 7, "硸硹硺硻硽", 6, "场尝常长偿肠厂敞畅唱倡超抄钞朝嘲潮巢吵炒车扯撤掣彻澈郴臣辰尘晨忱沉陈趁衬撑称城橙成呈乘程惩澄诚承逞骋秤吃痴持匙池迟弛驰耻齿侈尺赤翅斥炽充冲虫崇宠抽酬畴踌稠愁筹仇绸瞅丑臭初出橱厨躇锄雏滁除楚"],
    ["b440", "碄碅碆碈碊碋碏碐碒碔碕碖碙碝碞碠碢碤碦碨", 7, "碵碶碷碸確碻碼碽碿磀磂磃磄磆磇磈磌磍磎磏磑磒磓磖磗磘磚", 9],
    ["b480", "磤磥磦磧磩磪磫磭", 4, "磳磵磶磸磹磻", 5, "礂礃礄礆", 6, "础储矗搐触处揣川穿椽传船喘串疮窗幢床闯创吹炊捶锤垂春椿醇唇淳纯蠢戳绰疵茨磁雌辞慈瓷词此刺赐次聪葱囱匆从丛凑粗醋簇促蹿篡窜摧崔催脆瘁粹淬翠村存寸磋撮搓措挫错搭达答瘩打大呆歹傣戴带殆代贷袋待逮"],
    ["b540", "礍", 5, "礔", 9, "礟", 4, "礥", 14, "礵", 4, "礽礿祂祃祄祅祇祊", 8, "祔祕祘祙祡祣"],
    ["b580", "祤祦祩祪祫祬祮祰", 6, "祹祻", 4, "禂禃禆禇禈禉禋禌禍禎禐禑禒怠耽担丹单郸掸胆旦氮但惮淡诞弹蛋当挡党荡档刀捣蹈倒岛祷导到稻悼道盗德得的蹬灯登等瞪凳邓堤低滴迪敌笛狄涤翟嫡抵底地蒂第帝弟递缔颠掂滇碘点典靛垫电佃甸店惦奠淀殿碉叼雕凋刁掉吊钓调跌爹碟蝶迭谍叠"],
    ["b640", "禓", 6, "禛", 11, "禨", 10, "禴", 4, "禼禿秂秄秅秇秈秊秌秎秏秐秓秔秖秗秙", 5, "秠秡秢秥秨秪"],
    ["b680", "秬秮秱", 6, "秹秺秼秾秿稁稄稅稇稈稉稊稌稏", 4, "稕稖稘稙稛稜丁盯叮钉顶鼎锭定订丢东冬董懂动栋侗恫冻洞兜抖斗陡豆逗痘都督毒犊独读堵睹赌杜镀肚度渡妒端短锻段断缎堆兑队对墩吨蹲敦顿囤钝盾遁掇哆多夺垛躲朵跺舵剁惰堕蛾峨鹅俄额讹娥恶厄扼遏鄂饿恩而儿耳尔饵洱二"],
    ["b740", "稝稟稡稢稤", 14, "稴稵稶稸稺稾穀", 5, "穇", 9, "穒", 4, "穘", 16],
    ["b780", "穩", 6, "穱穲穳穵穻穼穽穾窂窅窇窉窊窋窌窎窏窐窓窔窙窚窛窞窡窢贰发罚筏伐乏阀法珐藩帆番翻樊矾钒繁凡烦反返范贩犯饭泛坊芳方肪房防妨仿访纺放菲非啡飞肥匪诽吠肺废沸费芬酚吩氛分纷坟焚汾粉奋份忿愤粪丰封枫蜂峰锋风疯烽逢冯缝讽奉凤佛否夫敷肤孵扶拂辐幅氟符伏俘服"],
    ["b840", "窣窤窧窩窪窫窮", 4, "窴", 10, "竀", 10, "竌", 9, "竗竘竚竛竜竝竡竢竤竧", 5, "竮竰竱竲竳"],
    ["b880", "竴", 4, "竻竼竾笀笁笂笅笇笉笌笍笎笐笒笓笖笗笘笚笜笝笟笡笢笣笧笩笭浮涪福袱弗甫抚辅俯釜斧脯腑府腐赴副覆赋复傅付阜父腹负富讣附妇缚咐噶嘎该改概钙盖溉干甘杆柑竿肝赶感秆敢赣冈刚钢缸肛纲岗港杠篙皋高膏羔糕搞镐稿告哥歌搁戈鸽胳疙割革葛格蛤阁隔铬个各给根跟耕更庚羹"],
    ["b940", "笯笰笲笴笵笶笷笹笻笽笿", 5, "筆筈筊筍筎筓筕筗筙筜筞筟筡筣", 10, "筯筰筳筴筶筸筺筼筽筿箁箂箃箄箆", 6, "箎箏"],
    ["b980", "箑箒箓箖箘箙箚箛箞箟箠箣箤箥箮箯箰箲箳箵箶箷箹", 7, "篂篃範埂耿梗工攻功恭龚供躬公宫弓巩汞拱贡共钩勾沟苟狗垢构购够辜菇咕箍估沽孤姑鼓古蛊骨谷股故顾固雇刮瓜剐寡挂褂乖拐怪棺关官冠观管馆罐惯灌贯光广逛瑰规圭硅归龟闺轨鬼诡癸桂柜跪贵刽辊滚棍锅郭国果裹过哈"],
    ["ba40", "篅篈築篊篋篍篎篏篐篒篔", 4, "篛篜篞篟篠篢篣篤篧篨篩篫篬篭篯篰篲", 4, "篸篹篺篻篽篿", 7, "簈簉簊簍簎簐", 5, "簗簘簙"],
    ["ba80", "簚", 4, "簠", 5, "簨簩簫", 12, "簹", 5, "籂骸孩海氦亥害骇酣憨邯韩含涵寒函喊罕翰撼捍旱憾悍焊汗汉夯杭航壕嚎豪毫郝好耗号浩呵喝荷菏核禾和何合盒貉阂河涸赫褐鹤贺嘿黑痕很狠恨哼亨横衡恒轰哄烘虹鸿洪宏弘红喉侯猴吼厚候后呼乎忽瑚壶葫胡蝴狐糊湖"],
    ["bb40", "籃", 9, "籎", 36, "籵", 5, "籾", 9],
    ["bb80", "粈粊", 6, "粓粔粖粙粚粛粠粡粣粦粧粨粩粫粬粭粯粰粴", 4, "粺粻弧虎唬护互沪户花哗华猾滑画划化话槐徊怀淮坏欢环桓还缓换患唤痪豢焕涣宦幻荒慌黄磺蝗簧皇凰惶煌晃幌恍谎灰挥辉徽恢蛔回毁悔慧卉惠晦贿秽会烩汇讳诲绘荤昏婚魂浑混豁活伙火获或惑霍货祸击圾基机畸稽积箕"],
    ["bc40", "粿糀糂糃糄糆糉糋糎", 6, "糘糚糛糝糞糡", 6, "糩", 5, "糰", 7, "糹糺糼", 13, "紋", 5],
    ["bc80", "紑", 14, "紡紣紤紥紦紨紩紪紬紭紮細", 6, "肌饥迹激讥鸡姬绩缉吉极棘辑籍集及急疾汲即嫉级挤几脊己蓟技冀季伎祭剂悸济寄寂计记既忌际妓继纪嘉枷夹佳家加荚颊贾甲钾假稼价架驾嫁歼监坚尖笺间煎兼肩艰奸缄茧检柬碱硷拣捡简俭剪减荐槛鉴践贱见键箭件"],
    ["bd40", "紷", 54, "絯", 7],
    ["bd80", "絸", 32, "健舰剑饯渐溅涧建僵姜将浆江疆蒋桨奖讲匠酱降蕉椒礁焦胶交郊浇骄娇嚼搅铰矫侥脚狡角饺缴绞剿教酵轿较叫窖揭接皆秸街阶截劫节桔杰捷睫竭洁结解姐戒藉芥界借介疥诫届巾筋斤金今津襟紧锦仅谨进靳晋禁近烬浸"],
    ["be40", "継", 12, "綧", 6, "綯", 42],
    ["be80", "線", 32, "尽劲荆兢茎睛晶鲸京惊精粳经井警景颈静境敬镜径痉靖竟竞净炯窘揪究纠玖韭久灸九酒厩救旧臼舅咎就疚鞠拘狙疽居驹菊局咀矩举沮聚拒据巨具距踞锯俱句惧炬剧捐鹃娟倦眷卷绢撅攫抉掘倔爵觉决诀绝均菌钧军君峻"],
    ["bf40", "緻", 62],
    ["bf80", "縺縼", 4, "繂", 4, "繈", 21, "俊竣浚郡骏喀咖卡咯开揩楷凯慨刊堪勘坎砍看康慷糠扛抗亢炕考拷烤靠坷苛柯棵磕颗科壳咳可渴克刻客课肯啃垦恳坑吭空恐孔控抠口扣寇枯哭窟苦酷库裤夸垮挎跨胯块筷侩快宽款匡筐狂框矿眶旷况亏盔岿窥葵奎魁傀"],
    ["c040", "繞", 35, "纃", 23, "纜纝纞"],
    ["c080", "纮纴纻纼绖绤绬绹缊缐缞缷缹缻", 6, "罃罆", 9, "罒罓馈愧溃坤昆捆困括扩廓阔垃拉喇蜡腊辣啦莱来赖蓝婪栏拦篮阑兰澜谰揽览懒缆烂滥琅榔狼廊郎朗浪捞劳牢老佬姥酪烙涝勒乐雷镭蕾磊累儡垒擂肋类泪棱楞冷厘梨犁黎篱狸离漓理李里鲤礼莉荔吏栗丽厉励砾历利傈例俐"],
    ["c140", "罖罙罛罜罝罞罠罣", 4, "罫罬罭罯罰罳罵罶罷罸罺罻罼罽罿羀羂", 7, "羋羍羏", 4, "羕", 4, "羛羜羠羢羣羥羦羨", 6, "羱"],
    ["c180", "羳", 4, "羺羻羾翀翂翃翄翆翇翈翉翋翍翏", 4, "翖翗翙", 5, "翢翣痢立粒沥隶力璃哩俩联莲连镰廉怜涟帘敛脸链恋炼练粮凉梁粱良两辆量晾亮谅撩聊僚疗燎寥辽潦了撂镣廖料列裂烈劣猎琳林磷霖临邻鳞淋凛赁吝拎玲菱零龄铃伶羚凌灵陵岭领另令溜琉榴硫馏留刘瘤流柳六龙聋咙笼窿"],
    ["c240", "翤翧翨翪翫翬翭翯翲翴", 6, "翽翾翿耂耇耈耉耊耎耏耑耓耚耛耝耞耟耡耣耤耫", 5, "耲耴耹耺耼耾聀聁聄聅聇聈聉聎聏聐聑聓聕聖聗"],
    ["c280", "聙聛", 13, "聫", 5, "聲", 11, "隆垄拢陇楼娄搂篓漏陋芦卢颅庐炉掳卤虏鲁麓碌露路赂鹿潞禄录陆戮驴吕铝侣旅履屡缕虑氯律率滤绿峦挛孪滦卵乱掠略抡轮伦仑沦纶论萝螺罗逻锣箩骡裸落洛骆络妈麻玛码蚂马骂嘛吗埋买麦卖迈脉瞒馒蛮满蔓曼慢漫"],
    ["c340", "聾肁肂肅肈肊肍", 5, "肔肕肗肙肞肣肦肧肨肬肰肳肵肶肸肹肻胅胇", 4, "胏", 6, "胘胟胠胢胣胦胮胵胷胹胻胾胿脀脁脃脄脅脇脈脋"],
    ["c380", "脌脕脗脙脛脜脝脟", 12, "脭脮脰脳脴脵脷脹", 4, "脿谩芒茫盲氓忙莽猫茅锚毛矛铆卯茂冒帽貌贸么玫枚梅酶霉煤没眉媒镁每美昧寐妹媚门闷们萌蒙檬盟锰猛梦孟眯醚靡糜迷谜弥米秘觅泌蜜密幂棉眠绵冕免勉娩缅面苗描瞄藐秒渺庙妙蔑灭民抿皿敏悯闽明螟鸣铭名命谬摸"],
    ["c440", "腀", 5, "腇腉腍腎腏腒腖腗腘腛", 4, "腡腢腣腤腦腨腪腫腬腯腲腳腵腶腷腸膁膃", 4, "膉膋膌膍膎膐膒", 5, "膙膚膞", 4, "膤膥"],
    ["c480", "膧膩膫", 7, "膴", 5, "膼膽膾膿臄臅臇臈臉臋臍", 6, "摹蘑模膜磨摩魔抹末莫墨默沫漠寞陌谋牟某拇牡亩姆母墓暮幕募慕木目睦牧穆拿哪呐钠那娜纳氖乃奶耐奈南男难囊挠脑恼闹淖呢馁内嫩能妮霓倪泥尼拟你匿腻逆溺蔫拈年碾撵捻念娘酿鸟尿捏聂孽啮镊镍涅您柠狞凝宁"],
    ["c540", "臔", 14, "臤臥臦臨臩臫臮", 4, "臵", 5, "臽臿舃與", 4, "舎舏舑舓舕", 5, "舝舠舤舥舦舧舩舮舲舺舼舽舿"],
    ["c580", "艀艁艂艃艅艆艈艊艌艍艎艐", 7, "艙艛艜艝艞艠", 7, "艩拧泞牛扭钮纽脓浓农弄奴努怒女暖虐疟挪懦糯诺哦欧鸥殴藕呕偶沤啪趴爬帕怕琶拍排牌徘湃派攀潘盘磐盼畔判叛乓庞旁耪胖抛咆刨炮袍跑泡呸胚培裴赔陪配佩沛喷盆砰抨烹澎彭蓬棚硼篷膨朋鹏捧碰坯砒霹批披劈琵毗"],
    ["c640", "艪艫艬艭艱艵艶艷艸艻艼芀芁芃芅芆芇芉芌芐芓芔芕芖芚芛芞芠芢芣芧芲芵芶芺芻芼芿苀苂苃苅苆苉苐苖苙苚苝苢苧苨苩苪苬苭苮苰苲苳苵苶苸"],
    ["c680", "苺苼", 4, "茊茋茍茐茒茓茖茘茙茝", 9, "茩茪茮茰茲茷茻茽啤脾疲皮匹痞僻屁譬篇偏片骗飘漂瓢票撇瞥拼频贫品聘乒坪苹萍平凭瓶评屏坡泼颇婆破魄迫粕剖扑铺仆莆葡菩蒲埔朴圃普浦谱曝瀑期欺栖戚妻七凄漆柒沏其棋奇歧畦崎脐齐旗祈祁骑起岂乞企启契砌器气迄弃汽泣讫掐"],
    ["c740", "茾茿荁荂荄荅荈荊", 4, "荓荕", 4, "荝荢荰", 6, "荹荺荾", 6, "莇莈莊莋莌莍莏莐莑莔莕莖莗莙莚莝莟莡", 6, "莬莭莮"],
    ["c780", "莯莵莻莾莿菂菃菄菆菈菉菋菍菎菐菑菒菓菕菗菙菚菛菞菢菣菤菦菧菨菫菬菭恰洽牵扦钎铅千迁签仟谦乾黔钱钳前潜遣浅谴堑嵌欠歉枪呛腔羌墙蔷强抢橇锹敲悄桥瞧乔侨巧鞘撬翘峭俏窍切茄且怯窃钦侵亲秦琴勤芹擒禽寝沁青轻氢倾卿清擎晴氰情顷请庆琼穷秋丘邱球求囚酋泅趋区蛆曲躯屈驱渠"],
    ["c840", "菮華菳", 4, "菺菻菼菾菿萀萂萅萇萈萉萊萐萒", 5, "萙萚萛萞", 5, "萩", 7, "萲", 5, "萹萺萻萾", 7, "葇葈葉"],
    ["c880", "葊", 6, "葒", 4, "葘葝葞葟葠葢葤", 4, "葪葮葯葰葲葴葷葹葻葼取娶龋趣去圈颧权醛泉全痊拳犬券劝缺炔瘸却鹊榷确雀裙群然燃冉染瓤壤攘嚷让饶扰绕惹热壬仁人忍韧任认刃妊纫扔仍日戎茸蓉荣融熔溶容绒冗揉柔肉茹蠕儒孺如辱乳汝入褥软阮蕊瑞锐闰润若弱撒洒萨腮鳃塞赛三叁"],
    ["c940", "葽", 4, "蒃蒄蒅蒆蒊蒍蒏", 7, "蒘蒚蒛蒝蒞蒟蒠蒢", 12, "蒰蒱蒳蒵蒶蒷蒻蒼蒾蓀蓂蓃蓅蓆蓇蓈蓋蓌蓎蓏蓒蓔蓕蓗"],
    ["c980", "蓘", 4, "蓞蓡蓢蓤蓧", 4, "蓭蓮蓯蓱", 10, "蓽蓾蔀蔁蔂伞散桑嗓丧搔骚扫嫂瑟色涩森僧莎砂杀刹沙纱傻啥煞筛晒珊苫杉山删煽衫闪陕擅赡膳善汕扇缮墒伤商赏晌上尚裳梢捎稍烧芍勺韶少哨邵绍奢赊蛇舌舍赦摄射慑涉社设砷申呻伸身深娠绅神沈审婶甚肾慎渗声生甥牲升绳"],
    ["ca40", "蔃", 8, "蔍蔎蔏蔐蔒蔔蔕蔖蔘蔙蔛蔜蔝蔞蔠蔢", 8, "蔭", 9, "蔾", 4, "蕄蕅蕆蕇蕋", 10],
    ["ca80", "蕗蕘蕚蕛蕜蕝蕟", 4, "蕥蕦蕧蕩", 8, "蕳蕵蕶蕷蕸蕼蕽蕿薀薁省盛剩胜圣师失狮施湿诗尸虱十石拾时什食蚀实识史矢使屎驶始式示士世柿事拭誓逝势是嗜噬适仕侍释饰氏市恃室视试收手首守寿授售受瘦兽蔬枢梳殊抒输叔舒淑疏书赎孰熟薯暑曙署蜀黍鼠属术述树束戍竖墅庶数漱"],
    ["cb40", "薂薃薆薈", 6, "薐", 10, "薝", 6, "薥薦薧薩薫薬薭薱", 5, "薸薺", 6, "藂", 6, "藊", 4, "藑藒"],
    ["cb80", "藔藖", 5, "藝", 6, "藥藦藧藨藪", 14, "恕刷耍摔衰甩帅栓拴霜双爽谁水睡税吮瞬顺舜说硕朔烁斯撕嘶思私司丝死肆寺嗣四伺似饲巳松耸怂颂送宋讼诵搜艘擞嗽苏酥俗素速粟僳塑溯宿诉肃酸蒜算虽隋随绥髓碎岁穗遂隧祟孙损笋蓑梭唆缩琐索锁所塌他它她塔"],
    ["cc40", "藹藺藼藽藾蘀", 4, "蘆", 10, "蘒蘓蘔蘕蘗", 15, "蘨蘪", 13, "蘹蘺蘻蘽蘾蘿虀"],
    ["cc80", "虁", 11, "虒虓處", 4, "虛虜虝號虠虡虣", 7, "獭挞蹋踏胎苔抬台泰酞太态汰坍摊贪瘫滩坛檀痰潭谭谈坦毯袒碳探叹炭汤塘搪堂棠膛唐糖倘躺淌趟烫掏涛滔绦萄桃逃淘陶讨套特藤腾疼誊梯剔踢锑提题蹄啼体替嚏惕涕剃屉天添填田甜恬舔腆挑条迢眺跳贴铁帖厅听烃"],
    ["cd40", "虭虯虰虲", 6, "蚃", 6, "蚎", 4, "蚔蚖", 5, "蚞", 4, "蚥蚦蚫蚭蚮蚲蚳蚷蚸蚹蚻", 4, "蛁蛂蛃蛅蛈蛌蛍蛒蛓蛕蛖蛗蛚蛜"],
    ["cd80", "蛝蛠蛡蛢蛣蛥蛦蛧蛨蛪蛫蛬蛯蛵蛶蛷蛺蛻蛼蛽蛿蜁蜄蜅蜆蜋蜌蜎蜏蜐蜑蜔蜖汀廷停亭庭挺艇通桐酮瞳同铜彤童桶捅筒统痛偷投头透凸秃突图徒途涂屠土吐兔湍团推颓腿蜕褪退吞屯臀拖托脱鸵陀驮驼椭妥拓唾挖哇蛙洼娃瓦袜歪外豌弯湾玩顽丸烷完碗挽晚皖惋宛婉万腕汪王亡枉网往旺望忘妄威"],
    ["ce40", "蜙蜛蜝蜟蜠蜤蜦蜧蜨蜪蜫蜬蜭蜯蜰蜲蜳蜵蜶蜸蜹蜺蜼蜽蝀", 6, "蝊蝋蝍蝏蝐蝑蝒蝔蝕蝖蝘蝚", 5, "蝡蝢蝦", 7, "蝯蝱蝲蝳蝵"],
    ["ce80", "蝷蝸蝹蝺蝿螀螁螄螆螇螉螊螌螎", 4, "螔螕螖螘", 6, "螠", 4, "巍微危韦违桅围唯惟为潍维苇萎委伟伪尾纬未蔚味畏胃喂魏位渭谓尉慰卫瘟温蚊文闻纹吻稳紊问嗡翁瓮挝蜗涡窝我斡卧握沃巫呜钨乌污诬屋无芜梧吾吴毋武五捂午舞伍侮坞戊雾晤物勿务悟误昔熙析西硒矽晰嘻吸锡牺"],
    ["cf40", "螥螦螧螩螪螮螰螱螲螴螶螷螸螹螻螼螾螿蟁", 4, "蟇蟈蟉蟌", 4, "蟔", 6, "蟜蟝蟞蟟蟡蟢蟣蟤蟦蟧蟨蟩蟫蟬蟭蟯", 9],
    ["cf80", "蟺蟻蟼蟽蟿蠀蠁蠂蠄", 5, "蠋", 7, "蠔蠗蠘蠙蠚蠜", 4, "蠣稀息希悉膝夕惜熄烯溪汐犀檄袭席习媳喜铣洗系隙戏细瞎虾匣霞辖暇峡侠狭下厦夏吓掀锨先仙鲜纤咸贤衔舷闲涎弦嫌显险现献县腺馅羡宪陷限线相厢镶香箱襄湘乡翔祥详想响享项巷橡像向象萧硝霄削哮嚣销消宵淆晓"],
    ["d040", "蠤", 13, "蠳", 5, "蠺蠻蠽蠾蠿衁衂衃衆", 5, "衎", 5, "衕衖衘衚", 6, "衦衧衪衭衯衱衳衴衵衶衸衹衺"],
    ["d080", "衻衼袀袃袆袇袉袊袌袎袏袐袑袓袔袕袗", 4, "袝", 4, "袣袥", 5, "小孝校肖啸笑效楔些歇蝎鞋协挟携邪斜胁谐写械卸蟹懈泄泻谢屑薪芯锌欣辛新忻心信衅星腥猩惺兴刑型形邢行醒幸杏性姓兄凶胸匈汹雄熊休修羞朽嗅锈秀袖绣墟戌需虚嘘须徐许蓄酗叙旭序畜恤絮婿绪续轩喧宣悬旋玄"],
    ["d140", "袬袮袯袰袲", 4, "袸袹袺袻袽袾袿裀裃裄裇裈裊裋裌裍裏裐裑裓裖裗裚", 4, "裠裡裦裧裩", 6, "裲裵裶裷裺裻製裿褀褁褃", 5],
    ["d180", "褉褋", 4, "褑褔", 4, "褜", 4, "褢褣褤褦褧褨褩褬褭褮褯褱褲褳褵褷选癣眩绚靴薛学穴雪血勋熏循旬询寻驯巡殉汛训讯逊迅压押鸦鸭呀丫芽牙蚜崖衙涯雅哑亚讶焉咽阉烟淹盐严研蜒岩延言颜阎炎沿奄掩眼衍演艳堰燕厌砚雁唁彦焰宴谚验殃央鸯秧杨扬佯疡羊洋阳氧仰痒养样漾邀腰妖瑶"],
    ["d240", "褸", 8, "襂襃襅", 24, "襠", 5, "襧", 19, "襼"],
    ["d280", "襽襾覀覂覄覅覇", 26, "摇尧遥窑谣姚咬舀药要耀椰噎耶爷野冶也页掖业叶曳腋夜液一壹医揖铱依伊衣颐夷遗移仪胰疑沂宜姨彝椅蚁倚已乙矣以艺抑易邑屹亿役臆逸肄疫亦裔意毅忆义益溢诣议谊译异翼翌绎茵荫因殷音阴姻吟银淫寅饮尹引隐"],
    ["d340", "覢", 30, "觃觍觓觔觕觗觘觙觛觝觟觠觡觢觤觧觨觩觪觬觭觮觰觱觲觴", 6],
    ["d380", "觻", 4, "訁", 5, "計", 21, "印英樱婴鹰应缨莹萤营荧蝇迎赢盈影颖硬映哟拥佣臃痈庸雍踊蛹咏泳涌永恿勇用幽优悠忧尤由邮铀犹油游酉有友右佑釉诱又幼迂淤于盂榆虞愚舆余俞逾鱼愉渝渔隅予娱雨与屿禹宇语羽玉域芋郁吁遇喻峪御愈欲狱育誉"],
    ["d440", "訞", 31, "訿", 8, "詉", 21],
    ["d480", "詟", 25, "詺", 6, "浴寓裕预豫驭鸳渊冤元垣袁原援辕园员圆猿源缘远苑愿怨院曰约越跃钥岳粤月悦阅耘云郧匀陨允运蕴酝晕韵孕匝砸杂栽哉灾宰载再在咱攒暂赞赃脏葬遭糟凿藻枣早澡蚤躁噪造皂灶燥责择则泽贼怎增憎曾赠扎喳渣札轧"],
    ["d540", "誁", 7, "誋", 7, "誔", 46],
    ["d580", "諃", 32, "铡闸眨栅榨咋乍炸诈摘斋宅窄债寨瞻毡詹粘沾盏斩辗崭展蘸栈占战站湛绽樟章彰漳张掌涨杖丈帐账仗胀瘴障招昭找沼赵照罩兆肇召遮折哲蛰辙者锗蔗这浙珍斟真甄砧臻贞针侦枕疹诊震振镇阵蒸挣睁征狰争怔整拯正政"],
    ["d640", "諤", 34, "謈", 27],
    ["d680", "謤謥謧", 30, "帧症郑证芝枝支吱蜘知肢脂汁之织职直植殖执值侄址指止趾只旨纸志挚掷至致置帜峙制智秩稚质炙痔滞治窒中盅忠钟衷终种肿重仲众舟周州洲诌粥轴肘帚咒皱宙昼骤珠株蛛朱猪诸诛逐竹烛煮拄瞩嘱主著柱助蛀贮铸筑"],
    ["d740", "譆", 31, "譧", 4, "譭", 25],
    ["d780", "讇", 24, "讬讱讻诇诐诪谉谞住注祝驻抓爪拽专砖转撰赚篆桩庄装妆撞壮状椎锥追赘坠缀谆准捉拙卓桌琢茁酌啄着灼浊兹咨资姿滋淄孜紫仔籽滓子自渍字鬃棕踪宗综总纵邹走奏揍租足卒族祖诅阻组钻纂嘴醉最罪尊遵昨左佐柞做作坐座"],
    ["d840", "谸", 8, "豂豃豄豅豈豊豋豍", 7, "豖豗豘豙豛", 5, "豣", 6, "豬", 6, "豴豵豶豷豻", 6, "貃貄貆貇"],
    ["d880", "貈貋貍", 6, "貕貖貗貙", 20, "亍丌兀丐廿卅丕亘丞鬲孬噩丨禺丿匕乇夭爻卮氐囟胤馗毓睾鼗丶亟鼐乜乩亓芈孛啬嘏仄厍厝厣厥厮靥赝匚叵匦匮匾赜卦卣刂刈刎刭刳刿剀剌剞剡剜蒯剽劂劁劐劓冂罔亻仃仉仂仨仡仫仞伛仳伢佤仵伥伧伉伫佞佧攸佚佝"],
    ["d940", "貮", 62],
    ["d980", "賭", 32, "佟佗伲伽佶佴侑侉侃侏佾佻侪佼侬侔俦俨俪俅俚俣俜俑俟俸倩偌俳倬倏倮倭俾倜倌倥倨偾偃偕偈偎偬偻傥傧傩傺僖儆僭僬僦僮儇儋仝氽佘佥俎龠汆籴兮巽黉馘冁夔勹匍訇匐凫夙兕亠兖亳衮袤亵脔裒禀嬴蠃羸冫冱冽冼"],
    ["da40", "贎", 14, "贠赑赒赗赟赥赨赩赪赬赮赯赱赲赸", 8, "趂趃趆趇趈趉趌", 4, "趒趓趕", 9, "趠趡"],
    ["da80", "趢趤", 12, "趲趶趷趹趻趽跀跁跂跅跇跈跉跊跍跐跒跓跔凇冖冢冥讠讦讧讪讴讵讷诂诃诋诏诎诒诓诔诖诘诙诜诟诠诤诨诩诮诰诳诶诹诼诿谀谂谄谇谌谏谑谒谔谕谖谙谛谘谝谟谠谡谥谧谪谫谮谯谲谳谵谶卩卺阝阢阡阱阪阽阼陂陉陔陟陧陬陲陴隈隍隗隰邗邛邝邙邬邡邴邳邶邺"],
    ["db40", "跕跘跙跜跠跡跢跥跦跧跩跭跮跰跱跲跴跶跼跾", 6, "踆踇踈踋踍踎踐踑踒踓踕", 7, "踠踡踤", 4, "踫踭踰踲踳踴踶踷踸踻踼踾"],
    ["db80", "踿蹃蹅蹆蹌", 4, "蹓", 5, "蹚", 11, "蹧蹨蹪蹫蹮蹱邸邰郏郅邾郐郄郇郓郦郢郜郗郛郫郯郾鄄鄢鄞鄣鄱鄯鄹酃酆刍奂劢劬劭劾哿勐勖勰叟燮矍廴凵凼鬯厶弁畚巯坌垩垡塾墼壅壑圩圬圪圳圹圮圯坜圻坂坩垅坫垆坼坻坨坭坶坳垭垤垌垲埏垧垴垓垠埕埘埚埙埒垸埴埯埸埤埝"],
    ["dc40", "蹳蹵蹷", 4, "蹽蹾躀躂躃躄躆躈", 6, "躑躒躓躕", 6, "躝躟", 11, "躭躮躰躱躳", 6, "躻", 7],
    ["dc80", "軃", 10, "軏", 21, "堋堍埽埭堀堞堙塄堠塥塬墁墉墚墀馨鼙懿艹艽艿芏芊芨芄芎芑芗芙芫芸芾芰苈苊苣芘芷芮苋苌苁芩芴芡芪芟苄苎芤苡茉苷苤茏茇苜苴苒苘茌苻苓茑茚茆茔茕苠苕茜荑荛荜茈莒茼茴茱莛荞茯荏荇荃荟荀茗荠茭茺茳荦荥"],
    ["dd40", "軥", 62],
    ["dd80", "輤", 32, "荨茛荩荬荪荭荮莰荸莳莴莠莪莓莜莅荼莶莩荽莸荻莘莞莨莺莼菁萁菥菘堇萘萋菝菽菖萜萸萑萆菔菟萏萃菸菹菪菅菀萦菰菡葜葑葚葙葳蒇蒈葺蒉葸萼葆葩葶蒌蒎萱葭蓁蓍蓐蓦蒽蓓蓊蒿蒺蓠蒡蒹蒴蒗蓥蓣蔌甍蔸蓰蔹蔟蔺"],
    ["de40", "轅", 32, "轪辀辌辒辝辠辡辢辤辥辦辧辪辬辭辮辯農辳辴辵辷辸辺辻込辿迀迃迆"],
    ["de80", "迉", 4, "迏迒迖迗迚迠迡迣迧迬迯迱迲迴迵迶迺迻迼迾迿逇逈逌逎逓逕逘蕖蔻蓿蓼蕙蕈蕨蕤蕞蕺瞢蕃蕲蕻薤薨薇薏蕹薮薜薅薹薷薰藓藁藜藿蘧蘅蘩蘖蘼廾弈夼奁耷奕奚奘匏尢尥尬尴扌扪抟抻拊拚拗拮挢拶挹捋捃掭揶捱捺掎掴捭掬掊捩掮掼揲揸揠揿揄揞揎摒揆掾摅摁搋搛搠搌搦搡摞撄摭撖"],
    ["df40", "這逜連逤逥逧", 5, "逰", 4, "逷逹逺逽逿遀遃遅遆遈", 4, "過達違遖遙遚遜", 5, "遤遦遧適遪遫遬遯", 4, "遶", 6, "遾邁"],
    ["df80", "還邅邆邇邉邊邌", 4, "邒邔邖邘邚邜邞邟邠邤邥邧邨邩邫邭邲邷邼邽邿郀摺撷撸撙撺擀擐擗擤擢攉攥攮弋忒甙弑卟叱叽叩叨叻吒吖吆呋呒呓呔呖呃吡呗呙吣吲咂咔呷呱呤咚咛咄呶呦咝哐咭哂咴哒咧咦哓哔呲咣哕咻咿哌哙哚哜咩咪咤哝哏哞唛哧唠哽唔哳唢唣唏唑唧唪啧喏喵啉啭啁啕唿啐唼"],
    ["e040", "郂郃郆郈郉郋郌郍郒郔郕郖郘郙郚郞郟郠郣郤郥郩郪郬郮郰郱郲郳郵郶郷郹郺郻郼郿鄀鄁鄃鄅", 19, "鄚鄛鄜"],
    ["e080", "鄝鄟鄠鄡鄤", 10, "鄰鄲", 6, "鄺", 8, "酄唷啖啵啶啷唳唰啜喋嗒喃喱喹喈喁喟啾嗖喑啻嗟喽喾喔喙嗪嗷嗉嘟嗑嗫嗬嗔嗦嗝嗄嗯嗥嗲嗳嗌嗍嗨嗵嗤辔嘞嘈嘌嘁嘤嘣嗾嘀嘧嘭噘嘹噗嘬噍噢噙噜噌噔嚆噤噱噫噻噼嚅嚓嚯囔囗囝囡囵囫囹囿圄圊圉圜帏帙帔帑帱帻帼"],
    ["e140", "酅酇酈酑酓酔酕酖酘酙酛酜酟酠酦酧酨酫酭酳酺酻酼醀", 4, "醆醈醊醎醏醓", 6, "醜", 5, "醤", 5, "醫醬醰醱醲醳醶醷醸醹醻"],
    ["e180", "醼", 10, "釈釋釐釒", 9, "針", 8, "帷幄幔幛幞幡岌屺岍岐岖岈岘岙岑岚岜岵岢岽岬岫岱岣峁岷峄峒峤峋峥崂崃崧崦崮崤崞崆崛嵘崾崴崽嵬嵛嵯嵝嵫嵋嵊嵩嵴嶂嶙嶝豳嶷巅彳彷徂徇徉後徕徙徜徨徭徵徼衢彡犭犰犴犷犸狃狁狎狍狒狨狯狩狲狴狷猁狳猃狺"],
    ["e240", "釦", 62],
    ["e280", "鈥", 32, "狻猗猓猡猊猞猝猕猢猹猥猬猸猱獐獍獗獠獬獯獾舛夥飧夤夂饣饧", 5, "饴饷饽馀馄馇馊馍馐馑馓馔馕庀庑庋庖庥庠庹庵庾庳赓廒廑廛廨廪膺忄忉忖忏怃忮怄忡忤忾怅怆忪忭忸怙怵怦怛怏怍怩怫怊怿怡恸恹恻恺恂"],
    ["e340", "鉆", 45, "鉵", 16],
    ["e380", "銆", 7, "銏", 24, "恪恽悖悚悭悝悃悒悌悛惬悻悱惝惘惆惚悴愠愦愕愣惴愀愎愫慊慵憬憔憧憷懔懵忝隳闩闫闱闳闵闶闼闾阃阄阆阈阊阋阌阍阏阒阕阖阗阙阚丬爿戕氵汔汜汊沣沅沐沔沌汨汩汴汶沆沩泐泔沭泷泸泱泗沲泠泖泺泫泮沱泓泯泾"],
    ["e440", "銨", 5, "銯", 24, "鋉", 31],
    ["e480", "鋩", 32, "洹洧洌浃浈洇洄洙洎洫浍洮洵洚浏浒浔洳涑浯涞涠浞涓涔浜浠浼浣渚淇淅淞渎涿淠渑淦淝淙渖涫渌涮渫湮湎湫溲湟溆湓湔渲渥湄滟溱溘滠漭滢溥溧溽溻溷滗溴滏溏滂溟潢潆潇漤漕滹漯漶潋潴漪漉漩澉澍澌潸潲潼潺濑"],
    ["e540", "錊", 51, "錿", 10],
    ["e580", "鍊", 31, "鍫濉澧澹澶濂濡濮濞濠濯瀚瀣瀛瀹瀵灏灞宀宄宕宓宥宸甯骞搴寤寮褰寰蹇謇辶迓迕迥迮迤迩迦迳迨逅逄逋逦逑逍逖逡逵逶逭逯遄遑遒遐遨遘遢遛暹遴遽邂邈邃邋彐彗彖彘尻咫屐屙孱屣屦羼弪弩弭艴弼鬻屮妁妃妍妩妪妣"],
    ["e640", "鍬", 34, "鎐", 27],
    ["e680", "鎬", 29, "鏋鏌鏍妗姊妫妞妤姒妲妯姗妾娅娆姝娈姣姘姹娌娉娲娴娑娣娓婀婧婊婕娼婢婵胬媪媛婷婺媾嫫媲嫒嫔媸嫠嫣嫱嫖嫦嫘嫜嬉嬗嬖嬲嬷孀尕尜孚孥孳孑孓孢驵驷驸驺驿驽骀骁骅骈骊骐骒骓骖骘骛骜骝骟骠骢骣骥骧纟纡纣纥纨纩"],
    ["e740", "鏎", 7, "鏗", 54],
    ["e780", "鐎", 32, "纭纰纾绀绁绂绉绋绌绐绔绗绛绠绡绨绫绮绯绱绲缍绶绺绻绾缁缂缃缇缈缋缌缏缑缒缗缙缜缛缟缡", 6, "缪缫缬缭缯", 4, "缵幺畿巛甾邕玎玑玮玢玟珏珂珑玷玳珀珉珈珥珙顼琊珩珧珞玺珲琏琪瑛琦琥琨琰琮琬"],
    ["e840", "鐯", 14, "鐿", 43, "鑬鑭鑮鑯"],
    ["e880", "鑰", 20, "钑钖钘铇铏铓铔铚铦铻锜锠琛琚瑁瑜瑗瑕瑙瑷瑭瑾璜璎璀璁璇璋璞璨璩璐璧瓒璺韪韫韬杌杓杞杈杩枥枇杪杳枘枧杵枨枞枭枋杷杼柰栉柘栊柩枰栌柙枵柚枳柝栀柃枸柢栎柁柽栲栳桠桡桎桢桄桤梃栝桕桦桁桧桀栾桊桉栩梵梏桴桷梓桫棂楮棼椟椠棹"],
    ["e940", "锧锳锽镃镈镋镕镚镠镮镴镵長", 7, "門", 42],
    ["e980", "閫", 32, "椤棰椋椁楗棣椐楱椹楠楂楝榄楫榀榘楸椴槌榇榈槎榉楦楣楹榛榧榻榫榭槔榱槁槊槟榕槠榍槿樯槭樗樘橥槲橄樾檠橐橛樵檎橹樽樨橘橼檑檐檩檗檫猷獒殁殂殇殄殒殓殍殚殛殡殪轫轭轱轲轳轵轶轸轷轹轺轼轾辁辂辄辇辋"],
    ["ea40", "闌", 27, "闬闿阇阓阘阛阞阠阣", 6, "阫阬阭阯阰阷阸阹阺阾陁陃陊陎陏陑陒陓陖陗"],
    ["ea80", "陘陙陚陜陝陞陠陣陥陦陫陭", 4, "陳陸", 12, "隇隉隊辍辎辏辘辚軎戋戗戛戟戢戡戥戤戬臧瓯瓴瓿甏甑甓攴旮旯旰昊昙杲昃昕昀炅曷昝昴昱昶昵耆晟晔晁晏晖晡晗晷暄暌暧暝暾曛曜曦曩贲贳贶贻贽赀赅赆赈赉赇赍赕赙觇觊觋觌觎觏觐觑牮犟牝牦牯牾牿犄犋犍犏犒挈挲掰"],
    ["eb40", "隌階隑隒隓隕隖隚際隝", 9, "隨", 7, "隱隲隴隵隷隸隺隻隿雂雃雈雊雋雐雑雓雔雖", 9, "雡", 6, "雫"],
    ["eb80", "雬雭雮雰雱雲雴雵雸雺電雼雽雿霂霃霅霊霋霌霐霑霒霔霕霗", 4, "霝霟霠搿擘耄毪毳毽毵毹氅氇氆氍氕氘氙氚氡氩氤氪氲攵敕敫牍牒牖爰虢刖肟肜肓肼朊肽肱肫肭肴肷胧胨胩胪胛胂胄胙胍胗朐胝胫胱胴胭脍脎胲胼朕脒豚脶脞脬脘脲腈腌腓腴腙腚腱腠腩腼腽腭腧塍媵膈膂膑滕膣膪臌朦臊膻"],
    ["ec40", "霡", 8, "霫霬霮霯霱霳", 4, "霺霻霼霽霿", 18, "靔靕靗靘靚靜靝靟靣靤靦靧靨靪", 7],
    ["ec80", "靲靵靷", 4, "靽", 7, "鞆", 4, "鞌鞎鞏鞐鞓鞕鞖鞗鞙", 4, "臁膦欤欷欹歃歆歙飑飒飓飕飙飚殳彀毂觳斐齑斓於旆旄旃旌旎旒旖炀炜炖炝炻烀炷炫炱烨烊焐焓焖焯焱煳煜煨煅煲煊煸煺熘熳熵熨熠燠燔燧燹爝爨灬焘煦熹戾戽扃扈扉礻祀祆祉祛祜祓祚祢祗祠祯祧祺禅禊禚禧禳忑忐"],
    ["ed40", "鞞鞟鞡鞢鞤", 6, "鞬鞮鞰鞱鞳鞵", 46],
    ["ed80", "韤韥韨韮", 4, "韴韷", 23, "怼恝恚恧恁恙恣悫愆愍慝憩憝懋懑戆肀聿沓泶淼矶矸砀砉砗砘砑斫砭砜砝砹砺砻砟砼砥砬砣砩硎硭硖硗砦硐硇硌硪碛碓碚碇碜碡碣碲碹碥磔磙磉磬磲礅磴礓礤礞礴龛黹黻黼盱眄眍盹眇眈眚眢眙眭眦眵眸睐睑睇睃睚睨"],
    ["ee40", "頏", 62],
    ["ee80", "顎", 32, "睢睥睿瞍睽瞀瞌瞑瞟瞠瞰瞵瞽町畀畎畋畈畛畲畹疃罘罡罟詈罨罴罱罹羁罾盍盥蠲钅钆钇钋钊钌钍钏钐钔钗钕钚钛钜钣钤钫钪钭钬钯钰钲钴钶", 4, "钼钽钿铄铈", 6, "铐铑铒铕铖铗铙铘铛铞铟铠铢铤铥铧铨铪"],
    ["ef40", "顯", 5, "颋颎颒颕颙颣風", 37, "飏飐飔飖飗飛飜飝飠", 4],
    ["ef80", "飥飦飩", 30, "铩铫铮铯铳铴铵铷铹铼铽铿锃锂锆锇锉锊锍锎锏锒", 4, "锘锛锝锞锟锢锪锫锩锬锱锲锴锶锷锸锼锾锿镂锵镄镅镆镉镌镎镏镒镓镔镖镗镘镙镛镞镟镝镡镢镤", 8, "镯镱镲镳锺矧矬雉秕秭秣秫稆嵇稃稂稞稔"],
    ["f040", "餈", 4, "餎餏餑", 28, "餯", 26],
    ["f080", "饊", 9, "饖", 12, "饤饦饳饸饹饻饾馂馃馉稹稷穑黏馥穰皈皎皓皙皤瓞瓠甬鸠鸢鸨", 4, "鸲鸱鸶鸸鸷鸹鸺鸾鹁鹂鹄鹆鹇鹈鹉鹋鹌鹎鹑鹕鹗鹚鹛鹜鹞鹣鹦", 6, "鹱鹭鹳疒疔疖疠疝疬疣疳疴疸痄疱疰痃痂痖痍痣痨痦痤痫痧瘃痱痼痿瘐瘀瘅瘌瘗瘊瘥瘘瘕瘙"],
    ["f140", "馌馎馚", 10, "馦馧馩", 47],
    ["f180", "駙", 32, "瘛瘼瘢瘠癀瘭瘰瘿瘵癃瘾瘳癍癞癔癜癖癫癯翊竦穸穹窀窆窈窕窦窠窬窨窭窳衤衩衲衽衿袂袢裆袷袼裉裢裎裣裥裱褚裼裨裾裰褡褙褓褛褊褴褫褶襁襦襻疋胥皲皴矜耒耔耖耜耠耢耥耦耧耩耨耱耋耵聃聆聍聒聩聱覃顸颀颃"],
    ["f240", "駺", 62],
    ["f280", "騹", 32, "颉颌颍颏颔颚颛颞颟颡颢颥颦虍虔虬虮虿虺虼虻蚨蚍蚋蚬蚝蚧蚣蚪蚓蚩蚶蛄蚵蛎蚰蚺蚱蚯蛉蛏蚴蛩蛱蛲蛭蛳蛐蜓蛞蛴蛟蛘蛑蜃蜇蛸蜈蜊蜍蜉蜣蜻蜞蜥蜮蜚蜾蝈蜴蜱蜩蜷蜿螂蜢蝽蝾蝻蝠蝰蝌蝮螋蝓蝣蝼蝤蝙蝥螓螯螨蟒"],
    ["f340", "驚", 17, "驲骃骉骍骎骔骕骙骦骩", 6, "骲骳骴骵骹骻骽骾骿髃髄髆", 4, "髍髎髏髐髒體髕髖髗髙髚髛髜"],
    ["f380", "髝髞髠髢髣髤髥髧髨髩髪髬髮髰", 8, "髺髼", 6, "鬄鬅鬆蟆螈螅螭螗螃螫蟥螬螵螳蟋蟓螽蟑蟀蟊蟛蟪蟠蟮蠖蠓蟾蠊蠛蠡蠹蠼缶罂罄罅舐竺竽笈笃笄笕笊笫笏筇笸笪笙笮笱笠笥笤笳笾笞筘筚筅筵筌筝筠筮筻筢筲筱箐箦箧箸箬箝箨箅箪箜箢箫箴篑篁篌篝篚篥篦篪簌篾篼簏簖簋"],
    ["f440", "鬇鬉", 5, "鬐鬑鬒鬔", 10, "鬠鬡鬢鬤", 10, "鬰鬱鬳", 7, "鬽鬾鬿魀魆魊魋魌魎魐魒魓魕", 5],
    ["f480", "魛", 32, "簟簪簦簸籁籀臾舁舂舄臬衄舡舢舣舭舯舨舫舸舻舳舴舾艄艉艋艏艚艟艨衾袅袈裘裟襞羝羟羧羯羰羲籼敉粑粝粜粞粢粲粼粽糁糇糌糍糈糅糗糨艮暨羿翎翕翥翡翦翩翮翳糸絷綦綮繇纛麸麴赳趄趔趑趱赧赭豇豉酊酐酎酏酤"],
    ["f540", "魼", 62],
    ["f580", "鮻", 32, "酢酡酰酩酯酽酾酲酴酹醌醅醐醍醑醢醣醪醭醮醯醵醴醺豕鹾趸跫踅蹙蹩趵趿趼趺跄跖跗跚跞跎跏跛跆跬跷跸跣跹跻跤踉跽踔踝踟踬踮踣踯踺蹀踹踵踽踱蹉蹁蹂蹑蹒蹊蹰蹶蹼蹯蹴躅躏躔躐躜躞豸貂貊貅貘貔斛觖觞觚觜"],
    ["f640", "鯜", 62],
    ["f680", "鰛", 32, "觥觫觯訾謦靓雩雳雯霆霁霈霏霎霪霭霰霾龀龃龅", 5, "龌黾鼋鼍隹隼隽雎雒瞿雠銎銮鋈錾鍪鏊鎏鐾鑫鱿鲂鲅鲆鲇鲈稣鲋鲎鲐鲑鲒鲔鲕鲚鲛鲞", 5, "鲥", 4, "鲫鲭鲮鲰", 7, "鲺鲻鲼鲽鳄鳅鳆鳇鳊鳋"],
    ["f740", "鰼", 62],
    ["f780", "鱻鱽鱾鲀鲃鲄鲉鲊鲌鲏鲓鲖鲗鲘鲙鲝鲪鲬鲯鲹鲾", 4, "鳈鳉鳑鳒鳚鳛鳠鳡鳌", 4, "鳓鳔鳕鳗鳘鳙鳜鳝鳟鳢靼鞅鞑鞒鞔鞯鞫鞣鞲鞴骱骰骷鹘骶骺骼髁髀髅髂髋髌髑魅魃魇魉魈魍魑飨餍餮饕饔髟髡髦髯髫髻髭髹鬈鬏鬓鬟鬣麽麾縻麂麇麈麋麒鏖麝麟黛黜黝黠黟黢黩黧黥黪黯鼢鼬鼯鼹鼷鼽鼾齄"],
    ["f840", "鳣", 62],
    ["f880", "鴢", 32],
    ["f940", "鵃", 62],
    ["f980", "鶂", 32],
    ["fa40", "鶣", 62],
    ["fa80", "鷢", 32],
    ["fb40", "鸃", 27, "鸤鸧鸮鸰鸴鸻鸼鹀鹍鹐鹒鹓鹔鹖鹙鹝鹟鹠鹡鹢鹥鹮鹯鹲鹴", 9, "麀"],
    ["fb80", "麁麃麄麅麆麉麊麌", 5, "麔", 8, "麞麠", 5, "麧麨麩麪"],
    ["fc40", "麫", 8, "麵麶麷麹麺麼麿", 4, "黅黆黇黈黊黋黌黐黒黓黕黖黗黙黚點黡黣黤黦黨黫黬黭黮黰", 8, "黺黽黿", 6],
    ["fc80", "鼆", 4, "鼌鼏鼑鼒鼔鼕鼖鼘鼚", 5, "鼡鼣", 8, "鼭鼮鼰鼱"],
    ["fd40", "鼲", 4, "鼸鼺鼼鼿", 4, "齅", 10, "齒", 38],
    ["fd80", "齹", 5, "龁龂龍", 11, "龜龝龞龡", 4, "郎凉秊裏隣"],
    ["fe40", "兀嗀﨎﨏﨑﨓﨔礼﨟蘒﨡﨣﨤﨧﨨﨩"]
  ];
});

// node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = __commonJS((exports, module) => {
  module.exports = [
    ["a140", "", 62],
    ["a180", "", 32],
    ["a240", "", 62],
    ["a280", "", 32],
    ["a2ab", "", 5],
    ["a2e3", "€"],
    ["a2ef", ""],
    ["a2fd", ""],
    ["a340", "", 62],
    ["a380", "", 31, "　"],
    ["a440", "", 62],
    ["a480", "", 32],
    ["a4f4", "", 10],
    ["a540", "", 62],
    ["a580", "", 32],
    ["a5f7", "", 7],
    ["a640", "", 62],
    ["a680", "", 32],
    ["a6b9", "", 7],
    ["a6d9", "", 6],
    ["a6ec", ""],
    ["a6f3", ""],
    ["a6f6", "", 8],
    ["a740", "", 62],
    ["a780", "", 32],
    ["a7c2", "", 14],
    ["a7f2", "", 12],
    ["a896", "", 10],
    ["a8bc", "ḿ"],
    ["a8bf", "ǹ"],
    ["a8c1", ""],
    ["a8ea", "", 20],
    ["a958", ""],
    ["a95b", ""],
    ["a95d", ""],
    ["a989", "〾⿰", 11],
    ["a997", "", 12],
    ["a9f0", "", 14],
    ["aaa1", "", 93],
    ["aba1", "", 93],
    ["aca1", "", 93],
    ["ada1", "", 93],
    ["aea1", "", 93],
    ["afa1", "", 93],
    ["d7fa", "", 4],
    ["f8a1", "", 93],
    ["f9a1", "", 93],
    ["faa1", "", 93],
    ["fba1", "", 93],
    ["fca1", "", 93],
    ["fda1", "", 93],
    ["fe50", "⺁⺄㑳㑇⺈⺋㖞㘚㘎⺌⺗㥮㤘㧏㧟㩳㧐㭎㱮㳠⺧⺪䁖䅟⺮䌷⺳⺶⺷䎱䎬⺻䏝䓖䙡䙌"],
    ["fe80", "䜣䜩䝼䞍⻊䥇䥺䥽䦂䦃䦅䦆䦟䦛䦷䦶䲣䲟䲠䲡䱷䲢䴓", 6, "䶮", 93],
    ["8135f437", ""]
  ];
});

// node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = __commonJS((exports, module) => {
  module.exports = {uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3]};
});

// node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\0", 127],
    ["8141", "갂갃갅갆갋", 4, "갘갞갟갡갢갣갥", 6, "갮갲갳갴"],
    ["8161", "갵갶갷갺갻갽갾갿걁", 9, "걌걎", 5, "걕"],
    ["8181", "걖걗걙걚걛걝", 18, "걲걳걵걶걹걻", 4, "겂겇겈겍겎겏겑겒겓겕", 6, "겞겢", 5, "겫겭겮겱", 6, "겺겾겿곀곂곃곅곆곇곉곊곋곍", 7, "곖곘", 7, "곢곣곥곦곩곫곭곮곲곴곷", 4, "곾곿괁괂괃괅괇", 4, "괎괐괒괓"],
    ["8241", "괔괕괖괗괙괚괛괝괞괟괡", 7, "괪괫괮", 5],
    ["8261", "괶괷괹괺괻괽", 6, "굆굈굊", 5, "굑굒굓굕굖굗"],
    ["8281", "굙", 7, "굢굤", 7, "굮굯굱굲굷굸굹굺굾궀궃", 4, "궊궋궍궎궏궑", 10, "궞", 5, "궥", 17, "궸", 7, "귂귃귅귆귇귉", 6, "귒귔", 7, "귝귞귟귡귢귣귥", 18],
    ["8341", "귺귻귽귾긂", 5, "긊긌긎", 5, "긕", 7],
    ["8361", "긝", 18, "긲긳긵긶긹긻긼"],
    ["8381", "긽긾긿깂깄깇깈깉깋깏깑깒깓깕깗", 4, "깞깢깣깤깦깧깪깫깭깮깯깱", 6, "깺깾", 5, "꺆", 5, "꺍", 46, "꺿껁껂껃껅", 6, "껎껒", 5, "껚껛껝", 8],
    ["8441", "껦껧껩껪껬껮", 5, "껵껶껷껹껺껻껽", 8],
    ["8461", "꼆꼉꼊꼋꼌꼎꼏꼑", 18],
    ["8481", "꼤", 7, "꼮꼯꼱꼳꼵", 6, "꼾꽀꽄꽅꽆꽇꽊", 5, "꽑", 10, "꽞", 5, "꽦", 18, "꽺", 5, "꾁꾂꾃꾅꾆꾇꾉", 6, "꾒꾓꾔꾖", 5, "꾝", 26, "꾺꾻꾽꾾"],
    ["8541", "꾿꿁", 5, "꿊꿌꿏", 4, "꿕", 6, "꿝", 4],
    ["8561", "꿢", 5, "꿪", 5, "꿲꿳꿵꿶꿷꿹", 6, "뀂뀃"],
    ["8581", "뀅", 6, "뀍뀎뀏뀑뀒뀓뀕", 6, "뀞", 9, "뀩", 26, "끆끇끉끋끍끏끐끑끒끖끘끚끛끜끞", 29, "끾끿낁낂낃낅", 6, "낎낐낒", 5, "낛낝낞낣낤"],
    ["8641", "낥낦낧낪낰낲낶낷낹낺낻낽", 6, "냆냊", 5, "냒"],
    ["8661", "냓냕냖냗냙", 6, "냡냢냣냤냦", 10],
    ["8681", "냱", 22, "넊넍넎넏넑넔넕넖넗넚넞", 4, "넦넧넩넪넫넭", 6, "넶넺", 5, "녂녃녅녆녇녉", 6, "녒녓녖녗녙녚녛녝녞녟녡", 22, "녺녻녽녾녿놁놃", 4, "놊놌놎놏놐놑놕놖놗놙놚놛놝"],
    ["8741", "놞", 9, "놩", 15],
    ["8761", "놹", 18, "뇍뇎뇏뇑뇒뇓뇕"],
    ["8781", "뇖", 5, "뇞뇠", 7, "뇪뇫뇭뇮뇯뇱", 7, "뇺뇼뇾", 5, "눆눇눉눊눍", 6, "눖눘눚", 5, "눡", 18, "눵", 6, "눽", 26, "뉙뉚뉛뉝뉞뉟뉡", 6, "뉪", 4],
    ["8841", "뉯", 4, "뉶", 5, "뉽", 6, "늆늇늈늊", 4],
    ["8861", "늏늒늓늕늖늗늛", 4, "늢늤늧늨늩늫늭늮늯늱늲늳늵늶늷"],
    ["8881", "늸", 15, "닊닋닍닎닏닑닓", 4, "닚닜닞닟닠닡닣닧닩닪닰닱닲닶닼닽닾댂댃댅댆댇댉", 6, "댒댖", 5, "댝", 54, "덗덙덚덝덠덡덢덣"],
    ["8941", "덦덨덪덬덭덯덲덳덵덶덷덹", 6, "뎂뎆", 5, "뎍"],
    ["8961", "뎎뎏뎑뎒뎓뎕", 10, "뎢", 5, "뎩뎪뎫뎭"],
    ["8981", "뎮", 21, "돆돇돉돊돍돏돑돒돓돖돘돚돜돞돟돡돢돣돥돦돧돩", 18, "돽", 18, "됑", 6, "됙됚됛됝됞됟됡", 6, "됪됬", 7, "됵", 15],
    ["8a41", "둅", 10, "둒둓둕둖둗둙", 6, "둢둤둦"],
    ["8a61", "둧", 4, "둭", 18, "뒁뒂"],
    ["8a81", "뒃", 4, "뒉", 19, "뒞", 5, "뒥뒦뒧뒩뒪뒫뒭", 7, "뒶뒸뒺", 5, "듁듂듃듅듆듇듉", 6, "듑듒듓듔듖", 5, "듞듟듡듢듥듧", 4, "듮듰듲", 5, "듹", 26, "딖딗딙딚딝"],
    ["8b41", "딞", 5, "딦딫", 4, "딲딳딵딶딷딹", 6, "땂땆"],
    ["8b61", "땇땈땉땊땎땏땑땒땓땕", 6, "땞땢", 8],
    ["8b81", "땫", 52, "떢떣떥떦떧떩떬떭떮떯떲떶", 4, "떾떿뗁뗂뗃뗅", 6, "뗎뗒", 5, "뗙", 18, "뗭", 18],
    ["8c41", "똀", 15, "똒똓똕똖똗똙", 4],
    ["8c61", "똞", 6, "똦", 5, "똭", 6, "똵", 5],
    ["8c81", "똻", 12, "뙉", 26, "뙥뙦뙧뙩", 50, "뚞뚟뚡뚢뚣뚥", 5, "뚭뚮뚯뚰뚲", 16],
    ["8d41", "뛃", 16, "뛕", 8],
    ["8d61", "뛞", 17, "뛱뛲뛳뛵뛶뛷뛹뛺"],
    ["8d81", "뛻", 4, "뜂뜃뜄뜆", 33, "뜪뜫뜭뜮뜱", 6, "뜺뜼", 7, "띅띆띇띉띊띋띍", 6, "띖", 9, "띡띢띣띥띦띧띩", 6, "띲띴띶", 5, "띾띿랁랂랃랅", 6, "랎랓랔랕랚랛랝랞"],
    ["8e41", "랟랡", 6, "랪랮", 5, "랶랷랹", 8],
    ["8e61", "럂", 4, "럈럊", 19],
    ["8e81", "럞", 13, "럮럯럱럲럳럵", 6, "럾렂", 4, "렊렋렍렎렏렑", 6, "렚렜렞", 5, "렦렧렩렪렫렭", 6, "렶렺", 5, "롁롂롃롅", 11, "롒롔", 7, "롞롟롡롢롣롥", 6, "롮롰롲", 5, "롹롺롻롽", 7],
    ["8f41", "뢅", 7, "뢎", 17],
    ["8f61", "뢠", 7, "뢩", 6, "뢱뢲뢳뢵뢶뢷뢹", 4],
    ["8f81", "뢾뢿룂룄룆", 5, "룍룎룏룑룒룓룕", 7, "룞룠룢", 5, "룪룫룭룮룯룱", 6, "룺룼룾", 5, "뤅", 18, "뤙", 6, "뤡", 26, "뤾뤿륁륂륃륅", 6, "륍륎륐륒", 5],
    ["9041", "륚륛륝륞륟륡", 6, "륪륬륮", 5, "륶륷륹륺륻륽"],
    ["9061", "륾", 5, "릆릈릋릌릏", 15],
    ["9081", "릟", 12, "릮릯릱릲릳릵", 6, "릾맀맂", 5, "맊맋맍맓", 4, "맚맜맟맠맢맦맧맩맪맫맭", 6, "맶맻", 4, "먂", 5, "먉", 11, "먖", 33, "먺먻먽먾먿멁멃멄멅멆"],
    ["9141", "멇멊멌멏멐멑멒멖멗멙멚멛멝", 6, "멦멪", 5],
    ["9161", "멲멳멵멶멷멹", 9, "몆몈몉몊몋몍", 5],
    ["9181", "몓", 20, "몪몭몮몯몱몳", 4, "몺몼몾", 5, "뫅뫆뫇뫉", 14, "뫚", 33, "뫽뫾뫿묁묂묃묅", 7, "묎묐묒", 5, "묙묚묛묝묞묟묡", 6],
    ["9241", "묨묪묬", 7, "묷묹묺묿", 4, "뭆뭈뭊뭋뭌뭎뭑뭒"],
    ["9261", "뭓뭕뭖뭗뭙", 7, "뭢뭤", 7, "뭭", 4],
    ["9281", "뭲", 21, "뮉뮊뮋뮍뮎뮏뮑", 18, "뮥뮦뮧뮩뮪뮫뮭", 6, "뮵뮶뮸", 7, "믁믂믃믅믆믇믉", 6, "믑믒믔", 35, "믺믻믽믾밁"],
    ["9341", "밃", 4, "밊밎밐밒밓밙밚밠밡밢밣밦밨밪밫밬밮밯밲밳밵"],
    ["9361", "밶밷밹", 6, "뱂뱆뱇뱈뱊뱋뱎뱏뱑", 8],
    ["9381", "뱚뱛뱜뱞", 37, "벆벇벉벊벍벏", 4, "벖벘벛", 4, "벢벣벥벦벩", 6, "벲벶", 5, "벾벿볁볂볃볅", 7, "볎볒볓볔볖볗볙볚볛볝", 22, "볷볹볺볻볽"],
    ["9441", "볾", 5, "봆봈봊", 5, "봑봒봓봕", 8],
    ["9461", "봞", 5, "봥", 6, "봭", 12],
    ["9481", "봺", 5, "뵁", 6, "뵊뵋뵍뵎뵏뵑", 6, "뵚", 9, "뵥뵦뵧뵩", 22, "붂붃붅붆붋", 4, "붒붔붖붗붘붛붝", 6, "붥", 10, "붱", 6, "붹", 24],
    ["9541", "뷒뷓뷖뷗뷙뷚뷛뷝", 11, "뷪", 5, "뷱"],
    ["9561", "뷲뷳뷵뷶뷷뷹", 6, "븁븂븄븆", 5, "븎븏븑븒븓"],
    ["9581", "븕", 6, "븞븠", 35, "빆빇빉빊빋빍빏", 4, "빖빘빜빝빞빟빢빣빥빦빧빩빫", 4, "빲빶", 4, "빾빿뺁뺂뺃뺅", 6, "뺎뺒", 5, "뺚", 13, "뺩", 14],
    ["9641", "뺸", 23, "뻒뻓"],
    ["9661", "뻕뻖뻙", 6, "뻡뻢뻦", 5, "뻭", 8],
    ["9681", "뻶", 10, "뼂", 5, "뼊", 13, "뼚뼞", 33, "뽂뽃뽅뽆뽇뽉", 6, "뽒뽓뽔뽖", 44],
    ["9741", "뾃", 16, "뾕", 8],
    ["9761", "뾞", 17, "뾱", 7],
    ["9781", "뾹", 11, "뿆", 5, "뿎뿏뿑뿒뿓뿕", 6, "뿝뿞뿠뿢", 89, "쀽쀾쀿"],
    ["9841", "쁀", 16, "쁒", 5, "쁙쁚쁛"],
    ["9861", "쁝쁞쁟쁡", 6, "쁪", 15],
    ["9881", "쁺", 21, "삒삓삕삖삗삙", 6, "삢삤삦", 5, "삮삱삲삷", 4, "삾샂샃샄샆샇샊샋샍샎샏샑", 6, "샚샞", 5, "샦샧샩샪샫샭", 6, "샶샸샺", 5, "섁섂섃섅섆섇섉", 6, "섑섒섓섔섖", 5, "섡섢섥섨섩섪섫섮"],
    ["9941", "섲섳섴섵섷섺섻섽섾섿셁", 6, "셊셎", 5, "셖셗"],
    ["9961", "셙셚셛셝", 6, "셦셪", 5, "셱셲셳셵셶셷셹셺셻"],
    ["9981", "셼", 8, "솆", 5, "솏솑솒솓솕솗", 4, "솞솠솢솣솤솦솧솪솫솭솮솯솱", 11, "솾", 5, "쇅쇆쇇쇉쇊쇋쇍", 6, "쇕쇖쇙", 6, "쇡쇢쇣쇥쇦쇧쇩", 6, "쇲쇴", 7, "쇾쇿숁숂숃숅", 6, "숎숐숒", 5, "숚숛숝숞숡숢숣"],
    ["9a41", "숤숥숦숧숪숬숮숰숳숵", 16],
    ["9a61", "쉆쉇쉉", 6, "쉒쉓쉕쉖쉗쉙", 6, "쉡쉢쉣쉤쉦"],
    ["9a81", "쉧", 4, "쉮쉯쉱쉲쉳쉵", 6, "쉾슀슂", 5, "슊", 5, "슑", 6, "슙슚슜슞", 5, "슦슧슩슪슫슮", 5, "슶슸슺", 33, "싞싟싡싢싥", 5, "싮싰싲싳싴싵싷싺싽싾싿쌁", 6, "쌊쌋쌎쌏"],
    ["9b41", "쌐쌑쌒쌖쌗쌙쌚쌛쌝", 6, "쌦쌧쌪", 8],
    ["9b61", "쌳", 17, "썆", 7],
    ["9b81", "썎", 25, "썪썫썭썮썯썱썳", 4, "썺썻썾", 5, "쎅쎆쎇쎉쎊쎋쎍", 50, "쏁", 22, "쏚"],
    ["9c41", "쏛쏝쏞쏡쏣", 4, "쏪쏫쏬쏮", 5, "쏶쏷쏹", 5],
    ["9c61", "쏿", 8, "쐉", 6, "쐑", 9],
    ["9c81", "쐛", 8, "쐥", 6, "쐭쐮쐯쐱쐲쐳쐵", 6, "쐾", 9, "쑉", 26, "쑦쑧쑩쑪쑫쑭", 6, "쑶쑷쑸쑺", 5, "쒁", 18, "쒕", 6, "쒝", 12],
    ["9d41", "쒪", 13, "쒹쒺쒻쒽", 8],
    ["9d61", "쓆", 25],
    ["9d81", "쓠", 8, "쓪", 5, "쓲쓳쓵쓶쓷쓹쓻쓼쓽쓾씂", 9, "씍씎씏씑씒씓씕", 6, "씝", 10, "씪씫씭씮씯씱", 6, "씺씼씾", 5, "앆앇앋앏앐앑앒앖앚앛앜앟앢앣앥앦앧앩", 6, "앲앶", 5, "앾앿얁얂얃얅얆얈얉얊얋얎얐얒얓얔"],
    ["9e41", "얖얙얚얛얝얞얟얡", 7, "얪", 9, "얶"],
    ["9e61", "얷얺얿", 4, "엋엍엏엒엓엕엖엗엙", 6, "엢엤엦엧"],
    ["9e81", "엨엩엪엫엯엱엲엳엵엸엹엺엻옂옃옄옉옊옋옍옎옏옑", 6, "옚옝", 6, "옦옧옩옪옫옯옱옲옶옸옺옼옽옾옿왂왃왅왆왇왉", 6, "왒왖", 5, "왞왟왡", 10, "왭왮왰왲", 5, "왺왻왽왾왿욁", 6, "욊욌욎", 5, "욖욗욙욚욛욝", 6, "욦"],
    ["9f41", "욨욪", 5, "욲욳욵욶욷욻", 4, "웂웄웆", 5, "웎"],
    ["9f61", "웏웑웒웓웕", 6, "웞웟웢", 5, "웪웫웭웮웯웱웲"],
    ["9f81", "웳", 4, "웺웻웼웾", 5, "윆윇윉윊윋윍", 6, "윖윘윚", 5, "윢윣윥윦윧윩", 6, "윲윴윶윸윹윺윻윾윿읁읂읃읅", 4, "읋읎읐읙읚읛읝읞읟읡", 6, "읩읪읬", 7, "읶읷읹읺읻읿잀잁잂잆잋잌잍잏잒잓잕잙잛", 4, "잢잧", 4, "잮잯잱잲잳잵잶잷"],
    ["a041", "잸잹잺잻잾쟂", 5, "쟊쟋쟍쟏쟑", 6, "쟙쟚쟛쟜"],
    ["a061", "쟞", 5, "쟥쟦쟧쟩쟪쟫쟭", 13],
    ["a081", "쟻", 4, "젂젃젅젆젇젉젋", 4, "젒젔젗", 4, "젞젟젡젢젣젥", 6, "젮젰젲", 5, "젹젺젻젽젾젿졁", 6, "졊졋졎", 5, "졕", 26, "졲졳졵졶졷졹졻", 4, "좂좄좈좉좊좎", 5, "좕", 7, "좞좠좢좣좤"],
    ["a141", "좥좦좧좩", 18, "좾좿죀죁"],
    ["a161", "죂죃죅죆죇죉죊죋죍", 6, "죖죘죚", 5, "죢죣죥"],
    ["a181", "죦", 14, "죶", 5, "죾죿줁줂줃줇", 4, "줎　、。·‥…¨〃­―∥＼∼‘’“”〔〕〈", 9, "±×÷≠≤≥∞∴°′″℃Å￠￡￥♂♀∠⊥⌒∂∇≡≒§※☆★○●◎◇◆□■△▲▽▼→←↑↓↔〓≪≫√∽∝∵∫∬∈∋⊆⊇⊂⊃∪∩∧∨￢"],
    ["a241", "줐줒", 5, "줙", 18],
    ["a261", "줭", 6, "줵", 18],
    ["a281", "쥈", 7, "쥒쥓쥕쥖쥗쥙", 6, "쥢쥤", 7, "쥭쥮쥯⇒⇔∀∃´～ˇ˘˝˚˙¸˛¡¿ː∮∑∏¤℉‰◁◀▷▶♤♠♡♥♧♣⊙◈▣◐◑▒▤▥▨▧▦▩♨☏☎☜☞¶†‡↕↗↙↖↘♭♩♪♬㉿㈜№㏇™㏂㏘℡€®"],
    ["a341", "쥱쥲쥳쥵", 6, "쥽", 10, "즊즋즍즎즏"],
    ["a361", "즑", 6, "즚즜즞", 16],
    ["a381", "즯", 16, "짂짃짅짆짉짋", 4, "짒짔짗짘짛！", 58, "￦］", 32, "￣"],
    ["a441", "짞짟짡짣짥짦짨짩짪짫짮짲", 5, "짺짻짽짾짿쨁쨂쨃쨄"],
    ["a461", "쨅쨆쨇쨊쨎", 5, "쨕쨖쨗쨙", 12],
    ["a481", "쨦쨧쨨쨪", 28, "ㄱ", 93],
    ["a541", "쩇", 4, "쩎쩏쩑쩒쩓쩕", 6, "쩞쩢", 5, "쩩쩪"],
    ["a561", "쩫", 17, "쩾", 5, "쪅쪆"],
    ["a581", "쪇", 16, "쪙", 14, "ⅰ", 9],
    ["a5b0", "Ⅰ", 9],
    ["a5c1", "Α", 16, "Σ", 6],
    ["a5e1", "α", 16, "σ", 6],
    ["a641", "쪨", 19, "쪾쪿쫁쫂쫃쫅"],
    ["a661", "쫆", 5, "쫎쫐쫒쫔쫕쫖쫗쫚", 5, "쫡", 6],
    ["a681", "쫨쫩쫪쫫쫭", 6, "쫵", 18, "쬉쬊─│┌┐┘└├┬┤┴┼━┃┏┓┛┗┣┳┫┻╋┠┯┨┷┿┝┰┥┸╂┒┑┚┙┖┕┎┍┞┟┡┢┦┧┩┪┭┮┱┲┵┶┹┺┽┾╀╁╃", 7],
    ["a741", "쬋", 4, "쬑쬒쬓쬕쬖쬗쬙", 6, "쬢", 7],
    ["a761", "쬪", 22, "쭂쭃쭄"],
    ["a781", "쭅쭆쭇쭊쭋쭍쭎쭏쭑", 6, "쭚쭛쭜쭞", 5, "쭥", 7, "㎕㎖㎗ℓ㎘㏄㎣㎤㎥㎦㎙", 9, "㏊㎍㎎㎏㏏㎈㎉㏈㎧㎨㎰", 9, "㎀", 4, "㎺", 5, "㎐", 4, "Ω㏀㏁㎊㎋㎌㏖㏅㎭㎮㎯㏛㎩㎪㎫㎬㏝㏐㏓㏃㏉㏜㏆"],
    ["a841", "쭭", 10, "쭺", 14],
    ["a861", "쮉", 18, "쮝", 6],
    ["a881", "쮤", 19, "쮹", 11, "ÆÐªĦ"],
    ["a8a6", "Ĳ"],
    ["a8a8", "ĿŁØŒºÞŦŊ"],
    ["a8b1", "㉠", 27, "ⓐ", 25, "①", 14, "½⅓⅔¼¾⅛⅜⅝⅞"],
    ["a941", "쯅", 14, "쯕", 10],
    ["a961", "쯠쯡쯢쯣쯥쯦쯨쯪", 18],
    ["a981", "쯽", 14, "찎찏찑찒찓찕", 6, "찞찟찠찣찤æđðħıĳĸŀłøœßþŧŋŉ㈀", 27, "⒜", 25, "⑴", 14, "¹²³⁴ⁿ₁₂₃₄"],
    ["aa41", "찥찦찪찫찭찯찱", 6, "찺찿", 4, "챆챇챉챊챋챍챎"],
    ["aa61", "챏", 4, "챖챚", 5, "챡챢챣챥챧챩", 6, "챱챲"],
    ["aa81", "챳챴챶", 29, "ぁ", 82],
    ["ab41", "첔첕첖첗첚첛첝첞첟첡", 6, "첪첮", 5, "첶첷첹"],
    ["ab61", "첺첻첽", 6, "쳆쳈쳊", 5, "쳑쳒쳓쳕", 5],
    ["ab81", "쳛", 8, "쳥", 6, "쳭쳮쳯쳱", 12, "ァ", 85],
    ["ac41", "쳾쳿촀촂", 5, "촊촋촍촎촏촑", 6, "촚촜촞촟촠"],
    ["ac61", "촡촢촣촥촦촧촩촪촫촭", 11, "촺", 4],
    ["ac81", "촿", 28, "쵝쵞쵟А", 5, "ЁЖ", 25],
    ["acd1", "а", 5, "ёж", 25],
    ["ad41", "쵡쵢쵣쵥", 6, "쵮쵰쵲", 5, "쵹", 7],
    ["ad61", "춁", 6, "춉", 10, "춖춗춙춚춛춝춞춟"],
    ["ad81", "춠춡춢춣춦춨춪", 5, "춱", 18, "췅"],
    ["ae41", "췆", 5, "췍췎췏췑", 16],
    ["ae61", "췢", 5, "췩췪췫췭췮췯췱", 6, "췺췼췾", 4],
    ["ae81", "츃츅츆츇츉츊츋츍", 6, "츕츖츗츘츚", 5, "츢츣츥츦츧츩츪츫"],
    ["af41", "츬츭츮츯츲츴츶", 19],
    ["af61", "칊", 13, "칚칛칝칞칢", 5, "칪칬"],
    ["af81", "칮", 5, "칶칷칹칺칻칽", 6, "캆캈캊", 5, "캒캓캕캖캗캙"],
    ["b041", "캚", 5, "캢캦", 5, "캮", 12],
    ["b061", "캻", 5, "컂", 19],
    ["b081", "컖", 13, "컦컧컩컪컭", 6, "컶컺", 5, "가각간갇갈갉갊감", 7, "같", 4, "갠갤갬갭갯갰갱갸갹갼걀걋걍걔걘걜거걱건걷걸걺검겁것겄겅겆겉겊겋게겐겔겜겝겟겠겡겨격겪견겯결겸겹겻겼경곁계곈곌곕곗고곡곤곧골곪곬곯곰곱곳공곶과곽관괄괆"],
    ["b141", "켂켃켅켆켇켉", 6, "켒켔켖", 5, "켝켞켟켡켢켣"],
    ["b161", "켥", 6, "켮켲", 5, "켹", 11],
    ["b181", "콅", 14, "콖콗콙콚콛콝", 6, "콦콨콪콫콬괌괍괏광괘괜괠괩괬괭괴괵괸괼굄굅굇굉교굔굘굡굣구국군굳굴굵굶굻굼굽굿궁궂궈궉권궐궜궝궤궷귀귁귄귈귐귑귓규균귤그극근귿글긁금급긋긍긔기긱긴긷길긺김깁깃깅깆깊까깍깎깐깔깖깜깝깟깠깡깥깨깩깬깰깸"],
    ["b241", "콭콮콯콲콳콵콶콷콹", 6, "쾁쾂쾃쾄쾆", 5, "쾍"],
    ["b261", "쾎", 18, "쾢", 5, "쾩"],
    ["b281", "쾪", 5, "쾱", 18, "쿅", 6, "깹깻깼깽꺄꺅꺌꺼꺽꺾껀껄껌껍껏껐껑께껙껜껨껫껭껴껸껼꼇꼈꼍꼐꼬꼭꼰꼲꼴꼼꼽꼿꽁꽂꽃꽈꽉꽐꽜꽝꽤꽥꽹꾀꾄꾈꾐꾑꾕꾜꾸꾹꾼꿀꿇꿈꿉꿋꿍꿎꿔꿜꿨꿩꿰꿱꿴꿸뀀뀁뀄뀌뀐뀔뀜뀝뀨끄끅끈끊끌끎끓끔끕끗끙"],
    ["b341", "쿌", 19, "쿢쿣쿥쿦쿧쿩"],
    ["b361", "쿪", 5, "쿲쿴쿶", 5, "쿽쿾쿿퀁퀂퀃퀅", 5],
    ["b381", "퀋", 5, "퀒", 5, "퀙", 19, "끝끼끽낀낄낌낍낏낑나낙낚난낟날낡낢남납낫", 4, "낱낳내낵낸낼냄냅냇냈냉냐냑냔냘냠냥너넉넋넌널넒넓넘넙넛넜넝넣네넥넨넬넴넵넷넸넹녀녁년녈념녑녔녕녘녜녠노녹논놀놂놈놉놋농높놓놔놘놜놨뇌뇐뇔뇜뇝"],
    ["b441", "퀮", 5, "퀶퀷퀹퀺퀻퀽", 6, "큆큈큊", 5],
    ["b461", "큑큒큓큕큖큗큙", 6, "큡", 10, "큮큯"],
    ["b481", "큱큲큳큵", 6, "큾큿킀킂", 18, "뇟뇨뇩뇬뇰뇹뇻뇽누눅눈눋눌눔눕눗눙눠눴눼뉘뉜뉠뉨뉩뉴뉵뉼늄늅늉느늑는늘늙늚늠늡늣능늦늪늬늰늴니닉닌닐닒님닙닛닝닢다닥닦단닫", 4, "닳담답닷", 4, "닿대댁댄댈댐댑댓댔댕댜더덕덖던덛덜덞덟덤덥"],
    ["b541", "킕", 14, "킦킧킩킪킫킭", 5],
    ["b561", "킳킶킸킺", 5, "탂탃탅탆탇탊", 5, "탒탖", 4],
    ["b581", "탛탞탟탡탢탣탥", 6, "탮탲", 5, "탹", 11, "덧덩덫덮데덱덴델뎀뎁뎃뎄뎅뎌뎐뎔뎠뎡뎨뎬도독돈돋돌돎돐돔돕돗동돛돝돠돤돨돼됐되된될됨됩됫됴두둑둔둘둠둡둣둥둬뒀뒈뒝뒤뒨뒬뒵뒷뒹듀듄듈듐듕드득든듣들듦듬듭듯등듸디딕딘딛딜딤딥딧딨딩딪따딱딴딸"],
    ["b641", "턅", 7, "턎", 17],
    ["b661", "턠", 15, "턲턳턵턶턷턹턻턼턽턾"],
    ["b681", "턿텂텆", 5, "텎텏텑텒텓텕", 6, "텞텠텢", 5, "텩텪텫텭땀땁땃땄땅땋때땍땐땔땜땝땟땠땡떠떡떤떨떪떫떰떱떳떴떵떻떼떽뗀뗄뗌뗍뗏뗐뗑뗘뗬또똑똔똘똥똬똴뙈뙤뙨뚜뚝뚠뚤뚫뚬뚱뛔뛰뛴뛸뜀뜁뜅뜨뜩뜬뜯뜰뜸뜹뜻띄띈띌띔띕띠띤띨띰띱띳띵라락란랄람랍랏랐랑랒랖랗"],
    ["b741", "텮", 13, "텽", 6, "톅톆톇톉톊"],
    ["b761", "톋", 20, "톢톣톥톦톧"],
    ["b781", "톩", 6, "톲톴톶톷톸톹톻톽톾톿퇁", 14, "래랙랜랠램랩랫랬랭랴략랸럇량러럭런럴럼럽럿렀렁렇레렉렌렐렘렙렛렝려력련렬렴렵렷렸령례롄롑롓로록론롤롬롭롯롱롸롼뢍뢨뢰뢴뢸룀룁룃룅료룐룔룝룟룡루룩룬룰룸룹룻룽뤄뤘뤠뤼뤽륀륄륌륏륑류륙륜률륨륩"],
    ["b841", "퇐", 7, "퇙", 17],
    ["b861", "퇫", 8, "퇵퇶퇷퇹", 13],
    ["b881", "툈툊", 5, "툑", 24, "륫륭르륵른를름릅릇릉릊릍릎리릭린릴림립릿링마막만많", 4, "맘맙맛망맞맡맣매맥맨맬맴맵맷맸맹맺먀먁먈먕머먹먼멀멂멈멉멋멍멎멓메멕멘멜멤멥멧멨멩며멱면멸몃몄명몇몌모목몫몬몰몲몸몹못몽뫄뫈뫘뫙뫼"],
    ["b941", "툪툫툮툯툱툲툳툵", 6, "툾퉀퉂", 5, "퉉퉊퉋퉌"],
    ["b961", "퉍", 14, "퉝", 6, "퉥퉦퉧퉨"],
    ["b981", "퉩", 22, "튂튃튅튆튇튉튊튋튌묀묄묍묏묑묘묜묠묩묫무묵묶문묻물묽묾뭄뭅뭇뭉뭍뭏뭐뭔뭘뭡뭣뭬뮈뮌뮐뮤뮨뮬뮴뮷므믄믈믐믓미믹민믿밀밂밈밉밋밌밍및밑바", 4, "받", 4, "밤밥밧방밭배백밴밸뱀뱁뱃뱄뱅뱉뱌뱍뱐뱝버벅번벋벌벎범법벗"],
    ["ba41", "튍튎튏튒튓튔튖", 5, "튝튞튟튡튢튣튥", 6, "튭"],
    ["ba61", "튮튯튰튲", 5, "튺튻튽튾틁틃", 4, "틊틌", 5],
    ["ba81", "틒틓틕틖틗틙틚틛틝", 6, "틦", 9, "틲틳틵틶틷틹틺벙벚베벡벤벧벨벰벱벳벴벵벼벽변별볍볏볐병볕볘볜보복볶본볼봄봅봇봉봐봔봤봬뵀뵈뵉뵌뵐뵘뵙뵤뵨부북분붇불붉붊붐붑붓붕붙붚붜붤붰붸뷔뷕뷘뷜뷩뷰뷴뷸븀븃븅브븍븐블븜븝븟비빅빈빌빎빔빕빗빙빚빛빠빡빤"],
    ["bb41", "틻", 4, "팂팄팆", 5, "팏팑팒팓팕팗", 4, "팞팢팣"],
    ["bb61", "팤팦팧팪팫팭팮팯팱", 6, "팺팾", 5, "퍆퍇퍈퍉"],
    ["bb81", "퍊", 31, "빨빪빰빱빳빴빵빻빼빽뺀뺄뺌뺍뺏뺐뺑뺘뺙뺨뻐뻑뻔뻗뻘뻠뻣뻤뻥뻬뼁뼈뼉뼘뼙뼛뼜뼝뽀뽁뽄뽈뽐뽑뽕뾔뾰뿅뿌뿍뿐뿔뿜뿟뿡쀼쁑쁘쁜쁠쁨쁩삐삑삔삘삠삡삣삥사삭삯산삳살삵삶삼삽삿샀상샅새색샌샐샘샙샛샜생샤"],
    ["bc41", "퍪", 17, "퍾퍿펁펂펃펅펆펇"],
    ["bc61", "펈펉펊펋펎펒", 5, "펚펛펝펞펟펡", 6, "펪펬펮"],
    ["bc81", "펯", 4, "펵펶펷펹펺펻펽", 6, "폆폇폊", 5, "폑", 5, "샥샨샬샴샵샷샹섀섄섈섐섕서", 4, "섣설섦섧섬섭섯섰성섶세섹센셀셈셉셋셌셍셔셕션셜셤셥셧셨셩셰셴셸솅소속솎손솔솖솜솝솟송솥솨솩솬솰솽쇄쇈쇌쇔쇗쇘쇠쇤쇨쇰쇱쇳쇼쇽숀숄숌숍숏숑수숙순숟술숨숩숫숭"],
    ["bd41", "폗폙", 7, "폢폤", 7, "폮폯폱폲폳폵폶폷"],
    ["bd61", "폸폹폺폻폾퐀퐂", 5, "퐉", 13],
    ["bd81", "퐗", 5, "퐞", 25, "숯숱숲숴쉈쉐쉑쉔쉘쉠쉥쉬쉭쉰쉴쉼쉽쉿슁슈슉슐슘슛슝스슥슨슬슭슴습슷승시식신싣실싫심십싯싱싶싸싹싻싼쌀쌈쌉쌌쌍쌓쌔쌕쌘쌜쌤쌥쌨쌩썅써썩썬썰썲썸썹썼썽쎄쎈쎌쏀쏘쏙쏜쏟쏠쏢쏨쏩쏭쏴쏵쏸쐈쐐쐤쐬쐰"],
    ["be41", "퐸", 7, "푁푂푃푅", 14],
    ["be61", "푔", 7, "푝푞푟푡푢푣푥", 7, "푮푰푱푲"],
    ["be81", "푳", 4, "푺푻푽푾풁풃", 4, "풊풌풎", 5, "풕", 8, "쐴쐼쐽쑈쑤쑥쑨쑬쑴쑵쑹쒀쒔쒜쒸쒼쓩쓰쓱쓴쓸쓺쓿씀씁씌씐씔씜씨씩씬씰씸씹씻씽아악안앉않알앍앎앓암압앗았앙앝앞애액앤앨앰앱앳앴앵야약얀얄얇얌얍얏양얕얗얘얜얠얩어억언얹얻얼얽얾엄", 6, "엌엎"],
    ["bf41", "풞", 10, "풪", 14],
    ["bf61", "풹", 18, "퓍퓎퓏퓑퓒퓓퓕"],
    ["bf81", "퓖", 5, "퓝퓞퓠", 7, "퓩퓪퓫퓭퓮퓯퓱", 6, "퓹퓺퓼에엑엔엘엠엡엣엥여역엮연열엶엷염", 5, "옅옆옇예옌옐옘옙옛옜오옥온올옭옮옰옳옴옵옷옹옻와왁완왈왐왑왓왔왕왜왝왠왬왯왱외왹왼욀욈욉욋욍요욕욘욜욤욥욧용우욱운울욹욺움웁웃웅워웍원월웜웝웠웡웨"],
    ["c041", "퓾", 5, "픅픆픇픉픊픋픍", 6, "픖픘", 5],
    ["c061", "픞", 25],
    ["c081", "픸픹픺픻픾픿핁핂핃핅", 6, "핎핐핒", 5, "핚핛핝핞핟핡핢핣웩웬웰웸웹웽위윅윈윌윔윕윗윙유육윤율윰윱윳융윷으윽은을읊음읍읏응", 7, "읜읠읨읫이익인일읽읾잃임입잇있잉잊잎자작잔잖잗잘잚잠잡잣잤장잦재잭잰잴잼잽잿쟀쟁쟈쟉쟌쟎쟐쟘쟝쟤쟨쟬저적전절젊"],
    ["c141", "핤핦핧핪핬핮", 5, "핶핷핹핺핻핽", 6, "햆햊햋"],
    ["c161", "햌햍햎햏햑", 19, "햦햧"],
    ["c181", "햨", 31, "점접젓정젖제젝젠젤젬젭젯젱져젼졀졈졉졌졍졔조족존졸졺좀좁좃종좆좇좋좌좍좔좝좟좡좨좼좽죄죈죌죔죕죗죙죠죡죤죵주죽준줄줅줆줌줍줏중줘줬줴쥐쥑쥔쥘쥠쥡쥣쥬쥰쥴쥼즈즉즌즐즘즙즛증지직진짇질짊짐집짓"],
    ["c241", "헊헋헍헎헏헑헓", 4, "헚헜헞", 5, "헦헧헩헪헫헭헮"],
    ["c261", "헯", 4, "헶헸헺", 5, "혂혃혅혆혇혉", 6, "혒"],
    ["c281", "혖", 5, "혝혞혟혡혢혣혥", 7, "혮", 9, "혺혻징짖짙짚짜짝짠짢짤짧짬짭짯짰짱째짹짼쨀쨈쨉쨋쨌쨍쨔쨘쨩쩌쩍쩐쩔쩜쩝쩟쩠쩡쩨쩽쪄쪘쪼쪽쫀쫄쫌쫍쫏쫑쫓쫘쫙쫠쫬쫴쬈쬐쬔쬘쬠쬡쭁쭈쭉쭌쭐쭘쭙쭝쭤쭸쭹쮜쮸쯔쯤쯧쯩찌찍찐찔찜찝찡찢찧차착찬찮찰참찹찻"],
    ["c341", "혽혾혿홁홂홃홄홆홇홊홌홎홏홐홒홓홖홗홙홚홛홝", 4],
    ["c361", "홢", 4, "홨홪", 5, "홲홳홵", 11],
    ["c381", "횁횂횄횆", 5, "횎횏횑횒횓횕", 7, "횞횠횢", 5, "횩횪찼창찾채책챈챌챔챕챗챘챙챠챤챦챨챰챵처척천철첨첩첫첬청체첵첸첼쳄쳅쳇쳉쳐쳔쳤쳬쳰촁초촉촌촐촘촙촛총촤촨촬촹최쵠쵤쵬쵭쵯쵱쵸춈추축춘출춤춥춧충춰췄췌췐취췬췰췸췹췻췽츄츈츌츔츙츠측츤츨츰츱츳층"],
    ["c441", "횫횭횮횯횱", 7, "횺횼", 7, "훆훇훉훊훋"],
    ["c461", "훍훎훏훐훒훓훕훖훘훚", 5, "훡훢훣훥훦훧훩", 4],
    ["c481", "훮훯훱훲훳훴훶", 5, "훾훿휁휂휃휅", 11, "휒휓휔치칙친칟칠칡침칩칫칭카칵칸칼캄캅캇캉캐캑캔캘캠캡캣캤캥캬캭컁커컥컨컫컬컴컵컷컸컹케켁켄켈켐켑켓켕켜켠켤켬켭켯켰켱켸코콕콘콜콤콥콧콩콰콱콴콸쾀쾅쾌쾡쾨쾰쿄쿠쿡쿤쿨쿰쿱쿳쿵쿼퀀퀄퀑퀘퀭퀴퀵퀸퀼"],
    ["c541", "휕휖휗휚휛휝휞휟휡", 6, "휪휬휮", 5, "휶휷휹"],
    ["c561", "휺휻휽", 6, "흅흆흈흊", 5, "흒흓흕흚", 4],
    ["c581", "흟흢흤흦흧흨흪흫흭흮흯흱흲흳흵", 6, "흾흿힀힂", 5, "힊힋큄큅큇큉큐큔큘큠크큭큰클큼큽킁키킥킨킬킴킵킷킹타탁탄탈탉탐탑탓탔탕태택탠탤탬탭탯탰탱탸턍터턱턴털턺텀텁텃텄텅테텍텐텔템텝텟텡텨텬텼톄톈토톡톤톨톰톱톳통톺톼퇀퇘퇴퇸툇툉툐투툭툰툴툼툽툿퉁퉈퉜"],
    ["c641", "힍힎힏힑", 6, "힚힜힞", 5],
    ["c6a1", "퉤튀튁튄튈튐튑튕튜튠튤튬튱트특튼튿틀틂틈틉틋틔틘틜틤틥티틱틴틸팀팁팃팅파팍팎판팔팖팜팝팟팠팡팥패팩팬팰팸팹팻팼팽퍄퍅퍼퍽펀펄펌펍펏펐펑페펙펜펠펨펩펫펭펴편펼폄폅폈평폐폘폡폣포폭폰폴폼폽폿퐁"],
    ["c7a1", "퐈퐝푀푄표푠푤푭푯푸푹푼푿풀풂품풉풋풍풔풩퓌퓐퓔퓜퓟퓨퓬퓰퓸퓻퓽프픈플픔픕픗피픽핀필핌핍핏핑하학한할핥함합핫항해핵핸핼햄햅햇했행햐향허헉헌헐헒험헙헛헝헤헥헨헬헴헵헷헹혀혁현혈혐협혓혔형혜혠"],
    ["c8a1", "혤혭호혹혼홀홅홈홉홋홍홑화확환활홧황홰홱홴횃횅회획횐횔횝횟횡효횬횰횹횻후훅훈훌훑훔훗훙훠훤훨훰훵훼훽휀휄휑휘휙휜휠휨휩휫휭휴휵휸휼흄흇흉흐흑흔흖흗흘흙흠흡흣흥흩희흰흴흼흽힁히힉힌힐힘힙힛힝"],
    ["caa1", "伽佳假價加可呵哥嘉嫁家暇架枷柯歌珂痂稼苛茄街袈訶賈跏軻迦駕刻却各恪慤殼珏脚覺角閣侃刊墾奸姦干幹懇揀杆柬桿澗癎看磵稈竿簡肝艮艱諫間乫喝曷渴碣竭葛褐蝎鞨勘坎堪嵌感憾戡敢柑橄減甘疳監瞰紺邯鑑鑒龕"],
    ["cba1", "匣岬甲胛鉀閘剛堈姜岡崗康强彊慷江畺疆糠絳綱羌腔舡薑襁講鋼降鱇介价個凱塏愷愾慨改槪漑疥皆盖箇芥蓋豈鎧開喀客坑更粳羹醵倨去居巨拒据據擧渠炬祛距踞車遽鉅鋸乾件健巾建愆楗腱虔蹇鍵騫乞傑杰桀儉劍劒檢"],
    ["cca1", "瞼鈐黔劫怯迲偈憩揭擊格檄激膈覡隔堅牽犬甄絹繭肩見譴遣鵑抉決潔結缺訣兼慊箝謙鉗鎌京俓倞傾儆勁勍卿坰境庚徑慶憬擎敬景暻更梗涇炅烱璟璥瓊痙硬磬竟競絅經耕耿脛莖警輕逕鏡頃頸驚鯨係啓堺契季屆悸戒桂械"],
    ["cda1", "棨溪界癸磎稽系繫繼計誡谿階鷄古叩告呱固姑孤尻庫拷攷故敲暠枯槁沽痼皐睾稿羔考股膏苦苽菰藁蠱袴誥賈辜錮雇顧高鼓哭斛曲梏穀谷鵠困坤崑昆梱棍滾琨袞鯤汨滑骨供公共功孔工恐恭拱控攻珙空蚣貢鞏串寡戈果瓜"],
    ["cea1", "科菓誇課跨過鍋顆廓槨藿郭串冠官寬慣棺款灌琯瓘管罐菅觀貫關館刮恝括适侊光匡壙廣曠洸炚狂珖筐胱鑛卦掛罫乖傀塊壞怪愧拐槐魁宏紘肱轟交僑咬喬嬌嶠巧攪敎校橋狡皎矯絞翹膠蕎蛟較轎郊餃驕鮫丘久九仇俱具勾"],
    ["cfa1", "區口句咎嘔坵垢寇嶇廐懼拘救枸柩構歐毆毬求溝灸狗玖球瞿矩究絿耉臼舅舊苟衢謳購軀逑邱鉤銶駒驅鳩鷗龜國局菊鞠鞫麴君窘群裙軍郡堀屈掘窟宮弓穹窮芎躬倦券勸卷圈拳捲權淃眷厥獗蕨蹶闕机櫃潰詭軌饋句晷歸貴"],
    ["d0a1", "鬼龜叫圭奎揆槻珪硅窺竅糾葵規赳逵閨勻均畇筠菌鈞龜橘克剋劇戟棘極隙僅劤勤懃斤根槿瑾筋芹菫覲謹近饉契今妗擒昑檎琴禁禽芩衾衿襟金錦伋及急扱汲級給亘兢矜肯企伎其冀嗜器圻基埼夔奇妓寄岐崎己幾忌技旗旣"],
    ["d1a1", "朞期杞棋棄機欺氣汽沂淇玘琦琪璂璣畸畿碁磯祁祇祈祺箕紀綺羈耆耭肌記譏豈起錡錤飢饑騎騏驥麒緊佶吉拮桔金喫儺喇奈娜懦懶拏拿癩", 5, "那樂", 4, "諾酪駱亂卵暖欄煖爛蘭難鸞捏捺南嵐枏楠湳濫男藍襤拉"],
    ["d2a1", "納臘蠟衲囊娘廊", 4, "乃來內奈柰耐冷女年撚秊念恬拈捻寧寗努勞奴弩怒擄櫓爐瑙盧", 5, "駑魯", 10, "濃籠聾膿農惱牢磊腦賂雷尿壘", 7, "嫩訥杻紐勒", 5, "能菱陵尼泥匿溺多茶"],
    ["d3a1", "丹亶但單團壇彖斷旦檀段湍短端簞緞蛋袒鄲鍛撻澾獺疸達啖坍憺擔曇淡湛潭澹痰聃膽蕁覃談譚錟沓畓答踏遝唐堂塘幢戇撞棠當糖螳黨代垈坮大對岱帶待戴擡玳臺袋貸隊黛宅德悳倒刀到圖堵塗導屠島嶋度徒悼挑掉搗桃"],
    ["d4a1", "棹櫂淘渡滔濤燾盜睹禱稻萄覩賭跳蹈逃途道都鍍陶韜毒瀆牘犢獨督禿篤纛讀墩惇敦旽暾沌焞燉豚頓乭突仝冬凍動同憧東桐棟洞潼疼瞳童胴董銅兜斗杜枓痘竇荳讀豆逗頭屯臀芚遁遯鈍得嶝橙燈登等藤謄鄧騰喇懶拏癩羅"],
    ["d5a1", "蘿螺裸邏樂洛烙珞絡落諾酪駱丹亂卵欄欒瀾爛蘭鸞剌辣嵐擥攬欖濫籃纜藍襤覽拉臘蠟廊朗浪狼琅瑯螂郞來崍徠萊冷掠略亮倆兩凉梁樑粮粱糧良諒輛量侶儷勵呂廬慮戾旅櫚濾礪藜蠣閭驢驪麗黎力曆歷瀝礫轢靂憐戀攣漣"],
    ["d6a1", "煉璉練聯蓮輦連鍊冽列劣洌烈裂廉斂殮濂簾獵令伶囹寧岺嶺怜玲笭羚翎聆逞鈴零靈領齡例澧禮醴隷勞怒撈擄櫓潞瀘爐盧老蘆虜路輅露魯鷺鹵碌祿綠菉錄鹿麓論壟弄朧瀧瓏籠聾儡瀨牢磊賂賚賴雷了僚寮廖料燎療瞭聊蓼"],
    ["d7a1", "遼鬧龍壘婁屢樓淚漏瘻累縷蔞褸鏤陋劉旒柳榴流溜瀏琉瑠留瘤硫謬類六戮陸侖倫崙淪綸輪律慄栗率隆勒肋凜凌楞稜綾菱陵俚利厘吏唎履悧李梨浬犁狸理璃異痢籬罹羸莉裏裡里釐離鯉吝潾燐璘藺躪隣鱗麟林淋琳臨霖砬"],
    ["d8a1", "立笠粒摩瑪痲碼磨馬魔麻寞幕漠膜莫邈万卍娩巒彎慢挽晩曼滿漫灣瞞萬蔓蠻輓饅鰻唜抹末沫茉襪靺亡妄忘忙望網罔芒茫莽輞邙埋妹媒寐昧枚梅每煤罵買賣邁魅脈貊陌驀麥孟氓猛盲盟萌冪覓免冕勉棉沔眄眠綿緬面麵滅"],
    ["d9a1", "蔑冥名命明暝椧溟皿瞑茗蓂螟酩銘鳴袂侮冒募姆帽慕摸摹暮某模母毛牟牡瑁眸矛耗芼茅謀謨貌木沐牧目睦穆鶩歿沒夢朦蒙卯墓妙廟描昴杳渺猫竗苗錨務巫憮懋戊拇撫无楙武毋無珷畝繆舞茂蕪誣貿霧鵡墨默們刎吻問文"],
    ["daa1", "汶紊紋聞蚊門雯勿沕物味媚尾嵋彌微未梶楣渼湄眉米美薇謎迷靡黴岷悶愍憫敏旻旼民泯玟珉緡閔密蜜謐剝博拍搏撲朴樸泊珀璞箔粕縛膊舶薄迫雹駁伴半反叛拌搬攀斑槃泮潘班畔瘢盤盼磐磻礬絆般蟠返頒飯勃拔撥渤潑"],
    ["dba1", "發跋醱鉢髮魃倣傍坊妨尨幇彷房放方旁昉枋榜滂磅紡肪膀舫芳蒡蚌訪謗邦防龐倍俳北培徘拜排杯湃焙盃背胚裴裵褙賠輩配陪伯佰帛柏栢白百魄幡樊煩燔番磻繁蕃藩飜伐筏罰閥凡帆梵氾汎泛犯範范法琺僻劈壁擘檗璧癖"],
    ["dca1", "碧蘗闢霹便卞弁變辨辯邊別瞥鱉鼈丙倂兵屛幷昞昺柄棅炳甁病秉竝輧餠騈保堡報寶普步洑湺潽珤甫菩補褓譜輔伏僕匐卜宓復服福腹茯蔔複覆輹輻馥鰒本乶俸奉封峯峰捧棒烽熢琫縫蓬蜂逢鋒鳳不付俯傅剖副否咐埠夫婦"],
    ["dda1", "孚孵富府復扶敷斧浮溥父符簿缶腐腑膚艀芙莩訃負賦賻赴趺部釜阜附駙鳧北分吩噴墳奔奮忿憤扮昐汾焚盆粉糞紛芬賁雰不佛弗彿拂崩朋棚硼繃鵬丕備匕匪卑妃婢庇悲憊扉批斐枇榧比毖毗毘沸泌琵痺砒碑秕秘粃緋翡肥"],
    ["dea1", "脾臂菲蜚裨誹譬費鄙非飛鼻嚬嬪彬斌檳殯浜濱瀕牝玭貧賓頻憑氷聘騁乍事些仕伺似使俟僿史司唆嗣四士奢娑寫寺射巳師徙思捨斜斯柶査梭死沙泗渣瀉獅砂社祀祠私篩紗絲肆舍莎蓑蛇裟詐詞謝賜赦辭邪飼駟麝削數朔索"],
    ["dfa1", "傘刪山散汕珊産疝算蒜酸霰乷撒殺煞薩三參杉森渗芟蔘衫揷澁鈒颯上傷像償商喪嘗孀尙峠常床庠廂想桑橡湘爽牀狀相祥箱翔裳觴詳象賞霜塞璽賽嗇塞穡索色牲生甥省笙墅壻嶼序庶徐恕抒捿敍暑曙書栖棲犀瑞筮絮緖署"],
    ["e0a1", "胥舒薯西誓逝鋤黍鼠夕奭席惜昔晳析汐淅潟石碩蓆釋錫仙僊先善嬋宣扇敾旋渲煽琁瑄璇璿癬禪線繕羨腺膳船蘚蟬詵跣選銑鐥饍鮮卨屑楔泄洩渫舌薛褻設說雪齧剡暹殲纖蟾贍閃陝攝涉燮葉城姓宬性惺成星晟猩珹盛省筬"],
    ["e1a1", "聖聲腥誠醒世勢歲洗稅笹細說貰召嘯塑宵小少巢所掃搔昭梳沼消溯瀟炤燒甦疏疎瘙笑篠簫素紹蔬蕭蘇訴逍遡邵銷韶騷俗屬束涑粟續謖贖速孫巽損蓀遜飡率宋悚松淞訟誦送頌刷殺灑碎鎖衰釗修受嗽囚垂壽嫂守岫峀帥愁"],
    ["e2a1", "戍手授搜收數樹殊水洙漱燧狩獸琇璲瘦睡秀穗竪粹綏綬繡羞脩茱蒐蓚藪袖誰讐輸遂邃酬銖銹隋隧隨雖需須首髓鬚叔塾夙孰宿淑潚熟琡璹肅菽巡徇循恂旬栒楯橓殉洵淳珣盾瞬筍純脣舜荀蓴蕣詢諄醇錞順馴戌術述鉥崇崧"],
    ["e3a1", "嵩瑟膝蝨濕拾習褶襲丞乘僧勝升承昇繩蠅陞侍匙嘶始媤尸屎屍市弑恃施是時枾柴猜矢示翅蒔蓍視試詩諡豕豺埴寔式息拭植殖湜熄篒蝕識軾食飾伸侁信呻娠宸愼新晨燼申神紳腎臣莘薪藎蜃訊身辛辰迅失室實悉審尋心沁"],
    ["e4a1", "沈深瀋甚芯諶什十拾雙氏亞俄兒啞娥峨我牙芽莪蛾衙訝阿雅餓鴉鵝堊岳嶽幄惡愕握樂渥鄂鍔顎鰐齷安岸按晏案眼雁鞍顔鮟斡謁軋閼唵岩巖庵暗癌菴闇壓押狎鴨仰央怏昻殃秧鴦厓哀埃崖愛曖涯碍艾隘靄厄扼掖液縊腋額"],
    ["e5a1", "櫻罌鶯鸚也倻冶夜惹揶椰爺耶若野弱掠略約若葯蒻藥躍亮佯兩凉壤孃恙揚攘敭暘梁楊樣洋瀁煬痒瘍禳穰糧羊良襄諒讓釀陽量養圄御於漁瘀禦語馭魚齬億憶抑檍臆偃堰彦焉言諺孼蘖俺儼嚴奄掩淹嶪業円予余勵呂女如廬"],
    ["e6a1", "旅歟汝濾璵礖礪與艅茹輿轝閭餘驪麗黎亦力域役易曆歷疫繹譯轢逆驛嚥堧姸娟宴年延憐戀捐挻撚椽沇沿涎涓淵演漣烟然煙煉燃燕璉硏硯秊筵緣練縯聯衍軟輦蓮連鉛鍊鳶列劣咽悅涅烈熱裂說閱厭廉念捻染殮炎焰琰艶苒"],
    ["e7a1", "簾閻髥鹽曄獵燁葉令囹塋寧嶺嶸影怜映暎楹榮永泳渶潁濚瀛瀯煐營獰玲瑛瑩瓔盈穎纓羚聆英詠迎鈴鍈零霙靈領乂倪例刈叡曳汭濊猊睿穢芮藝蘂禮裔詣譽豫醴銳隸霓預五伍俉傲午吾吳嗚塢墺奧娛寤悟惡懊敖旿晤梧汚澳"],
    ["e8a1", "烏熬獒筽蜈誤鰲鼇屋沃獄玉鈺溫瑥瘟穩縕蘊兀壅擁瓮甕癰翁邕雍饔渦瓦窩窪臥蛙蝸訛婉完宛梡椀浣玩琓琬碗緩翫脘腕莞豌阮頑曰往旺枉汪王倭娃歪矮外嵬巍猥畏了僚僥凹堯夭妖姚寥寮尿嶢拗搖撓擾料曜樂橈燎燿瑤療"],
    ["e9a1", "窈窯繇繞耀腰蓼蟯要謠遙遼邀饒慾欲浴縟褥辱俑傭冗勇埇墉容庸慂榕涌湧溶熔瑢用甬聳茸蓉踊鎔鏞龍于佑偶優又友右宇寓尤愚憂旴牛玗瑀盂祐禑禹紆羽芋藕虞迂遇郵釪隅雨雩勖彧旭昱栯煜稶郁頊云暈橒殞澐熉耘芸蕓"],
    ["eaa1", "運隕雲韻蔚鬱亐熊雄元原員圓園垣媛嫄寃怨愿援沅洹湲源爰猿瑗苑袁轅遠阮院願鴛月越鉞位偉僞危圍委威尉慰暐渭爲瑋緯胃萎葦蔿蝟衛褘謂違韋魏乳侑儒兪劉唯喩孺宥幼幽庾悠惟愈愉揄攸有杻柔柚柳楡楢油洧流游溜"],
    ["eba1", "濡猶猷琉瑜由留癒硫紐維臾萸裕誘諛諭踰蹂遊逾遺酉釉鍮類六堉戮毓肉育陸倫允奫尹崙淪潤玧胤贇輪鈗閏律慄栗率聿戎瀜絨融隆垠恩慇殷誾銀隱乙吟淫蔭陰音飮揖泣邑凝應膺鷹依倚儀宜意懿擬椅毅疑矣義艤薏蟻衣誼"],
    ["eca1", "議醫二以伊利吏夷姨履已弛彛怡易李梨泥爾珥理異痍痢移罹而耳肄苡荑裏裡貽貳邇里離飴餌匿溺瀷益翊翌翼謚人仁刃印吝咽因姻寅引忍湮燐璘絪茵藺蚓認隣靭靷鱗麟一佚佾壹日溢逸鎰馹任壬妊姙恁林淋稔臨荏賃入卄"],
    ["eda1", "立笠粒仍剩孕芿仔刺咨姉姿子字孜恣慈滋炙煮玆瓷疵磁紫者自茨蔗藉諮資雌作勺嚼斫昨灼炸爵綽芍酌雀鵲孱棧殘潺盞岑暫潛箴簪蠶雜丈仗匠場墻壯奬將帳庄張掌暲杖樟檣欌漿牆狀獐璋章粧腸臟臧莊葬蔣薔藏裝贓醬長"],
    ["eea1", "障再哉在宰才材栽梓渽滓災縡裁財載齋齎爭箏諍錚佇低儲咀姐底抵杵楮樗沮渚狙猪疽箸紵苧菹著藷詛貯躇這邸雎齟勣吊嫡寂摘敵滴狄炙的積笛籍績翟荻謫賊赤跡蹟迪迹適鏑佃佺傳全典前剪塡塼奠專展廛悛戰栓殿氈澱"],
    ["efa1", "煎琠田甸畑癲筌箋箭篆纏詮輾轉鈿銓錢鐫電顚顫餞切截折浙癤竊節絶占岾店漸点粘霑鮎點接摺蝶丁井亭停偵呈姃定幀庭廷征情挺政整旌晶晸柾楨檉正汀淀淨渟湞瀞炡玎珽町睛碇禎程穽精綎艇訂諪貞鄭酊釘鉦鋌錠霆靖"],
    ["f0a1", "靜頂鼎制劑啼堤帝弟悌提梯濟祭第臍薺製諸蹄醍除際霽題齊俎兆凋助嘲弔彫措操早晁曺曹朝條棗槽漕潮照燥爪璪眺祖祚租稠窕粗糟組繰肇藻蚤詔調趙躁造遭釣阻雕鳥族簇足鏃存尊卒拙猝倧宗從悰慫棕淙琮種終綜縱腫"],
    ["f1a1", "踪踵鍾鐘佐坐左座挫罪主住侏做姝胄呪周嗾奏宙州廚晝朱柱株注洲湊澍炷珠疇籌紂紬綢舟蛛註誅走躊輳週酎酒鑄駐竹粥俊儁准埈寯峻晙樽浚準濬焌畯竣蠢逡遵雋駿茁中仲衆重卽櫛楫汁葺增憎曾拯烝甑症繒蒸證贈之只"],
    ["f2a1", "咫地址志持指摯支旨智枝枳止池沚漬知砥祉祗紙肢脂至芝芷蜘誌識贄趾遲直稙稷織職唇嗔塵振搢晉晋桭榛殄津溱珍瑨璡畛疹盡眞瞋秦縉縝臻蔯袗診賑軫辰進鎭陣陳震侄叱姪嫉帙桎瓆疾秩窒膣蛭質跌迭斟朕什執潗緝輯"],
    ["f3a1", "鏶集徵懲澄且侘借叉嗟嵯差次此磋箚茶蹉車遮捉搾着窄錯鑿齪撰澯燦璨瓚竄簒纂粲纘讚贊鑽餐饌刹察擦札紮僭參塹慘慙懺斬站讒讖倉倡創唱娼廠彰愴敞昌昶暢槍滄漲猖瘡窓脹艙菖蒼債埰寀寨彩採砦綵菜蔡采釵冊柵策"],
    ["f4a1", "責凄妻悽處倜刺剔尺慽戚拓擲斥滌瘠脊蹠陟隻仟千喘天川擅泉淺玔穿舛薦賤踐遷釧闡阡韆凸哲喆徹撤澈綴輟轍鐵僉尖沾添甛瞻簽籤詹諂堞妾帖捷牒疊睫諜貼輒廳晴淸聽菁請靑鯖切剃替涕滯締諦逮遞體初剿哨憔抄招梢"],
    ["f5a1", "椒楚樵炒焦硝礁礎秒稍肖艸苕草蕉貂超酢醋醮促囑燭矗蜀觸寸忖村邨叢塚寵悤憁摠總聰蔥銃撮催崔最墜抽推椎楸樞湫皺秋芻萩諏趨追鄒酋醜錐錘鎚雛騶鰍丑畜祝竺筑築縮蓄蹙蹴軸逐春椿瑃出朮黜充忠沖蟲衝衷悴膵萃"],
    ["f6a1", "贅取吹嘴娶就炊翠聚脆臭趣醉驟鷲側仄厠惻測層侈値嗤峙幟恥梔治淄熾痔痴癡稚穉緇緻置致蚩輜雉馳齒則勅飭親七柒漆侵寢枕沈浸琛砧針鍼蟄秤稱快他咤唾墮妥惰打拖朶楕舵陀馱駝倬卓啄坼度托拓擢晫柝濁濯琢琸託"],
    ["f7a1", "鐸呑嘆坦彈憚歎灘炭綻誕奪脫探眈耽貪塔搭榻宕帑湯糖蕩兌台太怠態殆汰泰笞胎苔跆邰颱宅擇澤撑攄兎吐土討慟桶洞痛筒統通堆槌腿褪退頹偸套妬投透鬪慝特闖坡婆巴把播擺杷波派爬琶破罷芭跛頗判坂板版瓣販辦鈑"],
    ["f8a1", "阪八叭捌佩唄悖敗沛浿牌狽稗覇貝彭澎烹膨愎便偏扁片篇編翩遍鞭騙貶坪平枰萍評吠嬖幣廢弊斃肺蔽閉陛佈包匍匏咆哺圃布怖抛抱捕暴泡浦疱砲胞脯苞葡蒲袍褒逋鋪飽鮑幅暴曝瀑爆輻俵剽彪慓杓標漂瓢票表豹飇飄驃"],
    ["f9a1", "品稟楓諷豊風馮彼披疲皮被避陂匹弼必泌珌畢疋筆苾馝乏逼下何厦夏廈昰河瑕荷蝦賀遐霞鰕壑學虐謔鶴寒恨悍旱汗漢澣瀚罕翰閑閒限韓割轄函含咸啣喊檻涵緘艦銜陷鹹合哈盒蛤閤闔陜亢伉姮嫦巷恒抗杭桁沆港缸肛航"],
    ["faa1", "行降項亥偕咳垓奚孩害懈楷海瀣蟹解該諧邂駭骸劾核倖幸杏荇行享向嚮珦鄕響餉饗香噓墟虛許憲櫶獻軒歇險驗奕爀赫革俔峴弦懸晛泫炫玄玹現眩睍絃絢縣舷衒見賢鉉顯孑穴血頁嫌俠協夾峽挾浹狹脅脇莢鋏頰亨兄刑型"],
    ["fba1", "形泂滎瀅灐炯熒珩瑩荊螢衡逈邢鎣馨兮彗惠慧暳蕙蹊醯鞋乎互呼壕壺好岵弧戶扈昊晧毫浩淏湖滸澔濠濩灝狐琥瑚瓠皓祜糊縞胡芦葫蒿虎號蝴護豪鎬頀顥惑或酷婚昏混渾琿魂忽惚笏哄弘汞泓洪烘紅虹訌鴻化和嬅樺火畵"],
    ["fca1", "禍禾花華話譁貨靴廓擴攫確碻穫丸喚奐宦幻患換歡晥桓渙煥環紈還驩鰥活滑猾豁闊凰幌徨恍惶愰慌晃晄榥況湟滉潢煌璜皇篁簧荒蝗遑隍黃匯回廻徊恢悔懷晦會檜淮澮灰獪繪膾茴蛔誨賄劃獲宖橫鐄哮嚆孝效斅曉梟涍淆"],
    ["fda1", "爻肴酵驍侯候厚后吼喉嗅帿後朽煦珝逅勛勳塤壎焄熏燻薰訓暈薨喧暄煊萱卉喙毁彙徽揮暉煇諱輝麾休携烋畦虧恤譎鷸兇凶匈洶胸黑昕欣炘痕吃屹紇訖欠欽歆吸恰洽翕興僖凞喜噫囍姬嬉希憙憘戱晞曦熙熹熺犧禧稀羲詰"]
  ];
});

// node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = __commonJS((exports, module) => {
  module.exports = [
    ["0", "\0", 127],
    ["a140", "　，、。．‧；：？！︰…‥﹐﹑﹒·﹔﹕﹖﹗｜–︱—︳╴︴﹏（）︵︶｛｝︷︸〔〕︹︺【】︻︼《》︽︾〈〉︿﹀「」﹁﹂『』﹃﹄﹙﹚"],
    ["a1a1", "﹛﹜﹝﹞‘’“”〝〞‵′＃＆＊※§〃○●△▲◎☆★◇◆□■▽▼㊣℅¯￣＿ˍ﹉﹊﹍﹎﹋﹌﹟﹠﹡＋－×÷±√＜＞＝≦≧≠∞≒≡﹢", 4, "～∩∪⊥∠∟⊿㏒㏑∫∮∵∴♀♂⊕⊙↑↓←→↖↗↙↘∥∣／"],
    ["a240", "＼∕﹨＄￥〒￠￡％＠℃℉﹩﹪﹫㏕㎜㎝㎞㏎㎡㎎㎏㏄°兙兛兞兝兡兣嗧瓩糎▁", 7, "▏▎▍▌▋▊▉┼┴┬┤├▔─│▕┌┐└┘╭"],
    ["a2a1", "╮╰╯═╞╪╡◢◣◥◤╱╲╳０", 9, "Ⅰ", 9, "〡", 8, "十卄卅Ａ", 25, "ａ", 21],
    ["a340", "ｗｘｙｚΑ", 16, "Σ", 6, "α", 16, "σ", 6, "ㄅ", 10],
    ["a3a1", "ㄐ", 25, "˙ˉˊˇˋ"],
    ["a3e1", "€"],
    ["a440", "一乙丁七乃九了二人儿入八几刀刁力匕十卜又三下丈上丫丸凡久么也乞于亡兀刃勺千叉口土士夕大女子孑孓寸小尢尸山川工己已巳巾干廾弋弓才"],
    ["a4a1", "丑丐不中丰丹之尹予云井互五亢仁什仃仆仇仍今介仄元允內六兮公冗凶分切刈勻勾勿化匹午升卅卞厄友及反壬天夫太夭孔少尤尺屯巴幻廿弔引心戈戶手扎支文斗斤方日曰月木欠止歹毋比毛氏水火爪父爻片牙牛犬王丙"],
    ["a540", "世丕且丘主乍乏乎以付仔仕他仗代令仙仞充兄冉冊冬凹出凸刊加功包匆北匝仟半卉卡占卯卮去可古右召叮叩叨叼司叵叫另只史叱台句叭叻四囚外"],
    ["a5a1", "央失奴奶孕它尼巨巧左市布平幼弁弘弗必戊打扔扒扑斥旦朮本未末札正母民氐永汁汀氾犯玄玉瓜瓦甘生用甩田由甲申疋白皮皿目矛矢石示禾穴立丞丟乒乓乩亙交亦亥仿伉伙伊伕伍伐休伏仲件任仰仳份企伋光兇兆先全"],
    ["a640", "共再冰列刑划刎刖劣匈匡匠印危吉吏同吊吐吁吋各向名合吃后吆吒因回囝圳地在圭圬圯圩夙多夷夸妄奸妃好她如妁字存宇守宅安寺尖屹州帆并年"],
    ["a6a1", "式弛忙忖戎戌戍成扣扛托收早旨旬旭曲曳有朽朴朱朵次此死氖汝汗汙江池汐汕污汛汍汎灰牟牝百竹米糸缶羊羽老考而耒耳聿肉肋肌臣自至臼舌舛舟艮色艾虫血行衣西阡串亨位住佇佗佞伴佛何估佐佑伽伺伸佃佔似但佣"],
    ["a740", "作你伯低伶余佝佈佚兌克免兵冶冷別判利刪刨劫助努劬匣即卵吝吭吞吾否呎吧呆呃吳呈呂君吩告吹吻吸吮吵吶吠吼呀吱含吟听囪困囤囫坊坑址坍"],
    ["a7a1", "均坎圾坐坏圻壯夾妝妒妨妞妣妙妖妍妤妓妊妥孝孜孚孛完宋宏尬局屁尿尾岐岑岔岌巫希序庇床廷弄弟彤形彷役忘忌志忍忱快忸忪戒我抄抗抖技扶抉扭把扼找批扳抒扯折扮投抓抑抆改攻攸旱更束李杏材村杜杖杞杉杆杠"],
    ["a840", "杓杗步每求汞沙沁沈沉沅沛汪決沐汰沌汨沖沒汽沃汲汾汴沆汶沍沔沘沂灶灼災灸牢牡牠狄狂玖甬甫男甸皂盯矣私秀禿究系罕肖肓肝肘肛肚育良芒"],
    ["a8a1", "芋芍見角言谷豆豕貝赤走足身車辛辰迂迆迅迄巡邑邢邪邦那酉釆里防阮阱阪阬並乖乳事些亞享京佯依侍佳使佬供例來侃佰併侈佩佻侖佾侏侑佺兔兒兕兩具其典冽函刻券刷刺到刮制剁劾劻卒協卓卑卦卷卸卹取叔受味呵"],
    ["a940", "咖呸咕咀呻呷咄咒咆呼咐呱呶和咚呢周咋命咎固垃坷坪坩坡坦坤坼夜奉奇奈奄奔妾妻委妹妮姑姆姐姍始姓姊妯妳姒姅孟孤季宗定官宜宙宛尚屈居"],
    ["a9a1", "屆岷岡岸岩岫岱岳帘帚帖帕帛帑幸庚店府底庖延弦弧弩往征彿彼忝忠忽念忿怏怔怯怵怖怪怕怡性怩怫怛或戕房戾所承拉拌拄抿拂抹拒招披拓拔拋拈抨抽押拐拙拇拍抵拚抱拘拖拗拆抬拎放斧於旺昔易昌昆昂明昀昏昕昊"],
    ["aa40", "昇服朋杭枋枕東果杳杷枇枝林杯杰板枉松析杵枚枓杼杪杲欣武歧歿氓氛泣注泳沱泌泥河沽沾沼波沫法泓沸泄油況沮泗泅泱沿治泡泛泊沬泯泜泖泠"],
    ["aaa1", "炕炎炒炊炙爬爭爸版牧物狀狎狙狗狐玩玨玟玫玥甽疝疙疚的盂盲直知矽社祀祁秉秈空穹竺糾罔羌羋者肺肥肢肱股肫肩肴肪肯臥臾舍芳芝芙芭芽芟芹花芬芥芯芸芣芰芾芷虎虱初表軋迎返近邵邸邱邶采金長門阜陀阿阻附"],
    ["ab40", "陂隹雨青非亟亭亮信侵侯便俠俑俏保促侶俘俟俊俗侮俐俄係俚俎俞侷兗冒冑冠剎剃削前剌剋則勇勉勃勁匍南卻厚叛咬哀咨哎哉咸咦咳哇哂咽咪品"],
    ["aba1", "哄哈咯咫咱咻咩咧咿囿垂型垠垣垢城垮垓奕契奏奎奐姜姘姿姣姨娃姥姪姚姦威姻孩宣宦室客宥封屎屏屍屋峙峒巷帝帥帟幽庠度建弈弭彥很待徊律徇後徉怒思怠急怎怨恍恰恨恢恆恃恬恫恪恤扁拜挖按拼拭持拮拽指拱拷"],
    ["ac40", "拯括拾拴挑挂政故斫施既春昭映昧是星昨昱昤曷柿染柱柔某柬架枯柵柩柯柄柑枴柚查枸柏柞柳枰柙柢柝柒歪殃殆段毒毗氟泉洋洲洪流津洌洱洞洗"],
    ["aca1", "活洽派洶洛泵洹洧洸洩洮洵洎洫炫為炳炬炯炭炸炮炤爰牲牯牴狩狠狡玷珊玻玲珍珀玳甚甭畏界畎畋疫疤疥疢疣癸皆皇皈盈盆盃盅省盹相眉看盾盼眇矜砂研砌砍祆祉祈祇禹禺科秒秋穿突竿竽籽紂紅紀紉紇約紆缸美羿耄"],
    ["ad40", "耐耍耑耶胖胥胚胃胄背胡胛胎胞胤胝致舢苧范茅苣苛苦茄若茂茉苒苗英茁苜苔苑苞苓苟苯茆虐虹虻虺衍衫要觔計訂訃貞負赴赳趴軍軌述迦迢迪迥"],
    ["ada1", "迭迫迤迨郊郎郁郃酋酊重閂限陋陌降面革韋韭音頁風飛食首香乘亳倌倍倣俯倦倥俸倩倖倆值借倚倒們俺倀倔倨俱倡個候倘俳修倭倪俾倫倉兼冤冥冢凍凌准凋剖剜剔剛剝匪卿原厝叟哨唐唁唷哼哥哲唆哺唔哩哭員唉哮哪"],
    ["ae40", "哦唧唇哽唏圃圄埂埔埋埃堉夏套奘奚娑娘娜娟娛娓姬娠娣娩娥娌娉孫屘宰害家宴宮宵容宸射屑展屐峭峽峻峪峨峰島崁峴差席師庫庭座弱徒徑徐恙"],
    ["aea1", "恣恥恐恕恭恩息悄悟悚悍悔悌悅悖扇拳挈拿捎挾振捕捂捆捏捉挺捐挽挪挫挨捍捌效敉料旁旅時晉晏晃晒晌晅晁書朔朕朗校核案框桓根桂桔栩梳栗桌桑栽柴桐桀格桃株桅栓栘桁殊殉殷氣氧氨氦氤泰浪涕消涇浦浸海浙涓"],
    ["af40", "浬涉浮浚浴浩涌涊浹涅浥涔烊烘烤烙烈烏爹特狼狹狽狸狷玆班琉珮珠珪珞畔畝畜畚留疾病症疲疳疽疼疹痂疸皋皰益盍盎眩真眠眨矩砰砧砸砝破砷"],
    ["afa1", "砥砭砠砟砲祕祐祠祟祖神祝祗祚秤秣秧租秦秩秘窄窈站笆笑粉紡紗紋紊素索純紐紕級紜納紙紛缺罟羔翅翁耆耘耕耙耗耽耿胱脂胰脅胭胴脆胸胳脈能脊胼胯臭臬舀舐航舫舨般芻茫荒荔荊茸荐草茵茴荏茲茹茶茗荀茱茨荃"],
    ["b040", "虔蚊蚪蚓蚤蚩蚌蚣蚜衰衷袁袂衽衹記訐討訌訕訊託訓訖訏訑豈豺豹財貢起躬軒軔軏辱送逆迷退迺迴逃追逅迸邕郡郝郢酒配酌釘針釗釜釙閃院陣陡"],
    ["b0a1", "陛陝除陘陞隻飢馬骨高鬥鬲鬼乾偺偽停假偃偌做偉健偶偎偕偵側偷偏倏偯偭兜冕凰剪副勒務勘動匐匏匙匿區匾參曼商啪啦啄啞啡啃啊唱啖問啕唯啤唸售啜唬啣唳啁啗圈國圉域堅堊堆埠埤基堂堵執培夠奢娶婁婉婦婪婀"],
    ["b140", "娼婢婚婆婊孰寇寅寄寂宿密尉專將屠屜屝崇崆崎崛崖崢崑崩崔崙崤崧崗巢常帶帳帷康庸庶庵庾張強彗彬彩彫得徙從徘御徠徜恿患悉悠您惋悴惦悽"],
    ["b1a1", "情悻悵惜悼惘惕惆惟悸惚惇戚戛扈掠控捲掖探接捷捧掘措捱掩掉掃掛捫推掄授掙採掬排掏掀捻捩捨捺敝敖救教敗啟敏敘敕敔斜斛斬族旋旌旎晝晚晤晨晦晞曹勗望梁梯梢梓梵桿桶梱梧梗械梃棄梭梆梅梔條梨梟梡梂欲殺"],
    ["b240", "毫毬氫涎涼淳淙液淡淌淤添淺清淇淋涯淑涮淞淹涸混淵淅淒渚涵淚淫淘淪深淮淨淆淄涪淬涿淦烹焉焊烽烯爽牽犁猜猛猖猓猙率琅琊球理現琍瓠瓶"],
    ["b2a1", "瓷甜產略畦畢異疏痔痕疵痊痍皎盔盒盛眷眾眼眶眸眺硫硃硎祥票祭移窒窕笠笨笛第符笙笞笮粒粗粕絆絃統紮紹紼絀細紳組累終紲紱缽羞羚翌翎習耜聊聆脯脖脣脫脩脰脤舂舵舷舶船莎莞莘荸莢莖莽莫莒莊莓莉莠荷荻荼"],
    ["b340", "莆莧處彪蛇蛀蚶蛄蚵蛆蛋蚱蚯蛉術袞袈被袒袖袍袋覓規訪訝訣訥許設訟訛訢豉豚販責貫貨貪貧赧赦趾趺軛軟這逍通逗連速逝逐逕逞造透逢逖逛途"],
    ["b3a1", "部郭都酗野釵釦釣釧釭釩閉陪陵陳陸陰陴陶陷陬雀雪雩章竟頂頃魚鳥鹵鹿麥麻傢傍傅備傑傀傖傘傚最凱割剴創剩勞勝勛博厥啻喀喧啼喊喝喘喂喜喪喔喇喋喃喳單喟唾喲喚喻喬喱啾喉喫喙圍堯堪場堤堰報堡堝堠壹壺奠"],
    ["b440", "婷媚婿媒媛媧孳孱寒富寓寐尊尋就嵌嵐崴嵇巽幅帽幀幃幾廊廁廂廄弼彭復循徨惑惡悲悶惠愜愣惺愕惰惻惴慨惱愎惶愉愀愒戟扉掣掌描揀揩揉揆揍"],
    ["b4a1", "插揣提握揖揭揮捶援揪換摒揚揹敞敦敢散斑斐斯普晰晴晶景暑智晾晷曾替期朝棺棕棠棘棗椅棟棵森棧棹棒棲棣棋棍植椒椎棉棚楮棻款欺欽殘殖殼毯氮氯氬港游湔渡渲湧湊渠渥渣減湛湘渤湖湮渭渦湯渴湍渺測湃渝渾滋"],
    ["b540", "溉渙湎湣湄湲湩湟焙焚焦焰無然煮焜牌犄犀猶猥猴猩琺琪琳琢琥琵琶琴琯琛琦琨甥甦畫番痢痛痣痙痘痞痠登發皖皓皴盜睏短硝硬硯稍稈程稅稀窘"],
    ["b5a1", "窗窖童竣等策筆筐筒答筍筋筏筑粟粥絞結絨絕紫絮絲絡給絢絰絳善翔翕耋聒肅腕腔腋腑腎脹腆脾腌腓腴舒舜菩萃菸萍菠菅萋菁華菱菴著萊菰萌菌菽菲菊萸萎萄菜萇菔菟虛蛟蛙蛭蛔蛛蛤蛐蛞街裁裂袱覃視註詠評詞証詁"],
    ["b640", "詔詛詐詆訴診訶詖象貂貯貼貳貽賁費賀貴買貶貿貸越超趁跎距跋跚跑跌跛跆軻軸軼辜逮逵週逸進逶鄂郵鄉郾酣酥量鈔鈕鈣鈉鈞鈍鈐鈇鈑閔閏開閑"],
    ["b6a1", "間閒閎隊階隋陽隅隆隍陲隄雁雅雄集雇雯雲韌項順須飧飪飯飩飲飭馮馭黃黍黑亂傭債傲傳僅傾催傷傻傯僇剿剷剽募勦勤勢勣匯嗟嗨嗓嗦嗎嗜嗇嗑嗣嗤嗯嗚嗡嗅嗆嗥嗉園圓塞塑塘塗塚塔填塌塭塊塢塒塋奧嫁嫉嫌媾媽媼"],
    ["b740", "媳嫂媲嵩嵯幌幹廉廈弒彙徬微愚意慈感想愛惹愁愈慎慌慄慍愾愴愧愍愆愷戡戢搓搾搞搪搭搽搬搏搜搔損搶搖搗搆敬斟新暗暉暇暈暖暄暘暍會榔業"],
    ["b7a1", "楚楷楠楔極椰概楊楨楫楞楓楹榆楝楣楛歇歲毀殿毓毽溢溯滓溶滂源溝滇滅溥溘溼溺溫滑準溜滄滔溪溧溴煎煙煩煤煉照煜煬煦煌煥煞煆煨煖爺牒猷獅猿猾瑯瑚瑕瑟瑞瑁琿瑙瑛瑜當畸瘀痰瘁痲痱痺痿痴痳盞盟睛睫睦睞督"],
    ["b840", "睹睪睬睜睥睨睢矮碎碰碗碘碌碉硼碑碓硿祺祿禁萬禽稜稚稠稔稟稞窟窠筷節筠筮筧粱粳粵經絹綑綁綏絛置罩罪署義羨群聖聘肆肄腱腰腸腥腮腳腫"],
    ["b8a1", "腹腺腦舅艇蒂葷落萱葵葦葫葉葬葛萼萵葡董葩葭葆虞虜號蛹蜓蜈蜇蜀蛾蛻蜂蜃蜆蜊衙裟裔裙補裘裝裡裊裕裒覜解詫該詳試詩詰誇詼詣誠話誅詭詢詮詬詹詻訾詨豢貊貉賊資賈賄貲賃賂賅跡跟跨路跳跺跪跤跦躲較載軾輊"],
    ["b940", "辟農運遊道遂達逼違遐遇遏過遍遑逾遁鄒鄗酬酪酩釉鈷鉗鈸鈽鉀鈾鉛鉋鉤鉑鈴鉉鉍鉅鈹鈿鉚閘隘隔隕雍雋雉雊雷電雹零靖靴靶預頑頓頊頒頌飼飴"],
    ["b9a1", "飽飾馳馱馴髡鳩麂鼎鼓鼠僧僮僥僖僭僚僕像僑僱僎僩兢凳劃劂匱厭嗾嘀嘛嘗嗽嘔嘆嘉嘍嘎嗷嘖嘟嘈嘐嗶團圖塵塾境墓墊塹墅塽壽夥夢夤奪奩嫡嫦嫩嫗嫖嫘嫣孵寞寧寡寥實寨寢寤察對屢嶄嶇幛幣幕幗幔廓廖弊彆彰徹慇"],
    ["ba40", "愿態慷慢慣慟慚慘慵截撇摘摔撤摸摟摺摑摧搴摭摻敲斡旗旖暢暨暝榜榨榕槁榮槓構榛榷榻榫榴槐槍榭槌榦槃榣歉歌氳漳演滾漓滴漩漾漠漬漏漂漢"],
    ["baa1", "滿滯漆漱漸漲漣漕漫漯澈漪滬漁滲滌滷熔熙煽熊熄熒爾犒犖獄獐瑤瑣瑪瑰瑭甄疑瘧瘍瘋瘉瘓盡監瞄睽睿睡磁碟碧碳碩碣禎福禍種稱窪窩竭端管箕箋筵算箝箔箏箸箇箄粹粽精綻綰綜綽綾綠緊綴網綱綺綢綿綵綸維緒緇綬"],
    ["bb40", "罰翠翡翟聞聚肇腐膀膏膈膊腿膂臧臺與舔舞艋蓉蒿蓆蓄蒙蒞蒲蒜蓋蒸蓀蓓蒐蒼蓑蓊蜿蜜蜻蜢蜥蜴蜘蝕蜷蜩裳褂裴裹裸製裨褚裯誦誌語誣認誡誓誤"],
    ["bba1", "說誥誨誘誑誚誧豪貍貌賓賑賒赫趙趕跼輔輒輕輓辣遠遘遜遣遙遞遢遝遛鄙鄘鄞酵酸酷酴鉸銀銅銘銖鉻銓銜銨鉼銑閡閨閩閣閥閤隙障際雌雒需靼鞅韶頗領颯颱餃餅餌餉駁骯骰髦魁魂鳴鳶鳳麼鼻齊億儀僻僵價儂儈儉儅凜"],
    ["bc40", "劇劈劉劍劊勰厲嘮嘻嘹嘲嘿嘴嘩噓噎噗噴嘶嘯嘰墀墟增墳墜墮墩墦奭嬉嫻嬋嫵嬌嬈寮寬審寫層履嶝嶔幢幟幡廢廚廟廝廣廠彈影德徵慶慧慮慝慕憂"],
    ["bca1", "慼慰慫慾憧憐憫憎憬憚憤憔憮戮摩摯摹撞撲撈撐撰撥撓撕撩撒撮播撫撚撬撙撢撳敵敷數暮暫暴暱樣樟槨樁樞標槽模樓樊槳樂樅槭樑歐歎殤毅毆漿潼澄潑潦潔澆潭潛潸潮澎潺潰潤澗潘滕潯潠潟熟熬熱熨牖犛獎獗瑩璋璃"],
    ["bd40", "瑾璀畿瘠瘩瘟瘤瘦瘡瘢皚皺盤瞎瞇瞌瞑瞋磋磅確磊碾磕碼磐稿稼穀稽稷稻窯窮箭箱範箴篆篇篁箠篌糊締練緯緻緘緬緝編緣線緞緩綞緙緲緹罵罷羯"],
    ["bda1", "翩耦膛膜膝膠膚膘蔗蔽蔚蓮蔬蔭蔓蔑蔣蔡蔔蓬蔥蓿蔆螂蝴蝶蝠蝦蝸蝨蝙蝗蝌蝓衛衝褐複褒褓褕褊誼諒談諄誕請諸課諉諂調誰論諍誶誹諛豌豎豬賠賞賦賤賬賭賢賣賜質賡赭趟趣踫踐踝踢踏踩踟踡踞躺輝輛輟輩輦輪輜輞"],
    ["be40", "輥適遮遨遭遷鄰鄭鄧鄱醇醉醋醃鋅銻銷鋪銬鋤鋁銳銼鋒鋇鋰銲閭閱霄霆震霉靠鞍鞋鞏頡頫頜颳養餓餒餘駝駐駟駛駑駕駒駙骷髮髯鬧魅魄魷魯鴆鴉"],
    ["bea1", "鴃麩麾黎墨齒儒儘儔儐儕冀冪凝劑劓勳噙噫噹噩噤噸噪器噥噱噯噬噢噶壁墾壇壅奮嬝嬴學寰導彊憲憑憩憊懍憶憾懊懈戰擅擁擋撻撼據擄擇擂操撿擒擔撾整曆曉暹曄曇暸樽樸樺橙橫橘樹橄橢橡橋橇樵機橈歙歷氅濂澱澡"],
    ["bf40", "濃澤濁澧澳激澹澶澦澠澴熾燉燐燒燈燕熹燎燙燜燃燄獨璜璣璘璟璞瓢甌甍瘴瘸瘺盧盥瞠瞞瞟瞥磨磚磬磧禦積穎穆穌穋窺篙簑築篤篛篡篩篦糕糖縊"],
    ["bfa1", "縑縈縛縣縞縝縉縐罹羲翰翱翮耨膳膩膨臻興艘艙蕊蕙蕈蕨蕩蕃蕉蕭蕪蕞螃螟螞螢融衡褪褲褥褫褡親覦諦諺諫諱謀諜諧諮諾謁謂諷諭諳諶諼豫豭貓賴蹄踱踴蹂踹踵輻輯輸輳辨辦遵遴選遲遼遺鄴醒錠錶鋸錳錯錢鋼錫錄錚"],
    ["c040", "錐錦錡錕錮錙閻隧隨險雕霎霑霖霍霓霏靛靜靦鞘頰頸頻頷頭頹頤餐館餞餛餡餚駭駢駱骸骼髻髭鬨鮑鴕鴣鴦鴨鴒鴛默黔龍龜優償儡儲勵嚎嚀嚐嚅嚇"],
    ["c0a1", "嚏壕壓壑壎嬰嬪嬤孺尷屨嶼嶺嶽嶸幫彌徽應懂懇懦懋戲戴擎擊擘擠擰擦擬擱擢擭斂斃曙曖檀檔檄檢檜櫛檣橾檗檐檠歜殮毚氈濘濱濟濠濛濤濫濯澀濬濡濩濕濮濰燧營燮燦燥燭燬燴燠爵牆獰獲璩環璦璨癆療癌盪瞳瞪瞰瞬"],
    ["c140", "瞧瞭矯磷磺磴磯礁禧禪穗窿簇簍篾篷簌篠糠糜糞糢糟糙糝縮績繆縷縲繃縫總縱繅繁縴縹繈縵縿縯罄翳翼聱聲聰聯聳臆臃膺臂臀膿膽臉膾臨舉艱薪"],
    ["c1a1", "薄蕾薜薑薔薯薛薇薨薊虧蟀蟑螳蟒蟆螫螻螺蟈蟋褻褶襄褸褽覬謎謗謙講謊謠謝謄謐豁谿豳賺賽購賸賻趨蹉蹋蹈蹊轄輾轂轅輿避遽還邁邂邀鄹醣醞醜鍍鎂錨鍵鍊鍥鍋錘鍾鍬鍛鍰鍚鍔闊闋闌闈闆隱隸雖霜霞鞠韓顆颶餵騁"],
    ["c240", "駿鮮鮫鮪鮭鴻鴿麋黏點黜黝黛鼾齋叢嚕嚮壙壘嬸彝懣戳擴擲擾攆擺擻擷斷曜朦檳檬櫃檻檸櫂檮檯歟歸殯瀉瀋濾瀆濺瀑瀏燻燼燾燸獷獵璧璿甕癖癘"],
    ["c2a1", "癒瞽瞿瞻瞼礎禮穡穢穠竄竅簫簧簪簞簣簡糧織繕繞繚繡繒繙罈翹翻職聶臍臏舊藏薩藍藐藉薰薺薹薦蟯蟬蟲蟠覆覲觴謨謹謬謫豐贅蹙蹣蹦蹤蹟蹕軀轉轍邇邃邈醫醬釐鎔鎊鎖鎢鎳鎮鎬鎰鎘鎚鎗闔闖闐闕離雜雙雛雞霤鞣鞦"],
    ["c340", "鞭韹額顏題顎顓颺餾餿餽餮馥騎髁鬃鬆魏魎魍鯊鯉鯽鯈鯀鵑鵝鵠黠鼕鼬儳嚥壞壟壢寵龐廬懲懷懶懵攀攏曠曝櫥櫝櫚櫓瀛瀟瀨瀚瀝瀕瀘爆爍牘犢獸"],
    ["c3a1", "獺璽瓊瓣疇疆癟癡矇礙禱穫穩簾簿簸簽簷籀繫繭繹繩繪羅繳羶羹羸臘藩藝藪藕藤藥藷蟻蠅蠍蟹蟾襠襟襖襞譁譜識證譚譎譏譆譙贈贊蹼蹲躇蹶蹬蹺蹴轔轎辭邊邋醱醮鏡鏑鏟鏃鏈鏜鏝鏖鏢鏍鏘鏤鏗鏨關隴難霪霧靡韜韻類"],
    ["c440", "願顛颼饅饉騖騙鬍鯨鯧鯖鯛鶉鵡鵲鵪鵬麒麗麓麴勸嚨嚷嚶嚴嚼壤孀孃孽寶巉懸懺攘攔攙曦朧櫬瀾瀰瀲爐獻瓏癢癥礦礪礬礫竇競籌籃籍糯糰辮繽繼"],
    ["c4a1", "纂罌耀臚艦藻藹蘑藺蘆蘋蘇蘊蠔蠕襤覺觸議譬警譯譟譫贏贍躉躁躅躂醴釋鐘鐃鏽闡霰飄饒饑馨騫騰騷騵鰓鰍鹹麵黨鼯齟齣齡儷儸囁囀囂夔屬巍懼懾攝攜斕曩櫻欄櫺殲灌爛犧瓖瓔癩矓籐纏續羼蘗蘭蘚蠣蠢蠡蠟襪襬覽譴"],
    ["c540", "護譽贓躊躍躋轟辯醺鐮鐳鐵鐺鐸鐲鐫闢霸霹露響顧顥饗驅驃驀騾髏魔魑鰭鰥鶯鶴鷂鶸麝黯鼙齜齦齧儼儻囈囊囉孿巔巒彎懿攤權歡灑灘玀瓤疊癮癬"],
    ["c5a1", "禳籠籟聾聽臟襲襯觼讀贖贗躑躓轡酈鑄鑑鑒霽霾韃韁顫饕驕驍髒鬚鱉鰱鰾鰻鷓鷗鼴齬齪龔囌巖戀攣攫攪曬欐瓚竊籤籣籥纓纖纔臢蘸蘿蠱變邐邏鑣鑠鑤靨顯饜驚驛驗髓體髑鱔鱗鱖鷥麟黴囑壩攬灞癱癲矗罐羈蠶蠹衢讓讒"],
    ["c640", "讖艷贛釀鑪靂靈靄韆顰驟鬢魘鱟鷹鷺鹼鹽鼇齷齲廳欖灣籬籮蠻觀躡釁鑲鑰顱饞髖鬣黌灤矚讚鑷韉驢驥纜讜躪釅鑽鑾鑼鱷鱸黷豔鑿鸚爨驪鬱鸛鸞籲"],
    ["c940", "乂乜凵匚厂万丌乇亍囗兀屮彳丏冇与丮亓仂仉仈冘勼卬厹圠夃夬尐巿旡殳毌气爿丱丼仨仜仩仡仝仚刌匜卌圢圣夗夯宁宄尒尻屴屳帄庀庂忉戉扐氕"],
    ["c9a1", "氶汃氿氻犮犰玊禸肊阞伎优伬仵伔仱伀价伈伝伂伅伢伓伄仴伒冱刓刉刐劦匢匟卍厊吇囡囟圮圪圴夼妀奼妅奻奾奷奿孖尕尥屼屺屻屾巟幵庄异弚彴忕忔忏扜扞扤扡扦扢扙扠扚扥旯旮朾朹朸朻机朿朼朳氘汆汒汜汏汊汔汋"],
    ["ca40", "汌灱牞犴犵玎甪癿穵网艸艼芀艽艿虍襾邙邗邘邛邔阢阤阠阣佖伻佢佉体佤伾佧佒佟佁佘伭伳伿佡冏冹刜刞刡劭劮匉卣卲厎厏吰吷吪呔呅吙吜吥吘"],
    ["caa1", "吽呏呁吨吤呇囮囧囥坁坅坌坉坋坒夆奀妦妘妠妗妎妢妐妏妧妡宎宒尨尪岍岏岈岋岉岒岊岆岓岕巠帊帎庋庉庌庈庍弅弝彸彶忒忑忐忭忨忮忳忡忤忣忺忯忷忻怀忴戺抃抌抎抏抔抇扱扻扺扰抁抈扷扽扲扴攷旰旴旳旲旵杅杇"],
    ["cb40", "杙杕杌杈杝杍杚杋毐氙氚汸汧汫沄沋沏汱汯汩沚汭沇沕沜汦汳汥汻沎灴灺牣犿犽狃狆狁犺狅玕玗玓玔玒町甹疔疕皁礽耴肕肙肐肒肜芐芏芅芎芑芓"],
    ["cba1", "芊芃芄豸迉辿邟邡邥邞邧邠阰阨阯阭丳侘佼侅佽侀侇佶佴侉侄佷佌侗佪侚佹侁佸侐侜侔侞侒侂侕佫佮冞冼冾刵刲刳剆刱劼匊匋匼厒厔咇呿咁咑咂咈呫呺呾呥呬呴呦咍呯呡呠咘呣呧呤囷囹坯坲坭坫坱坰坶垀坵坻坳坴坢"],
    ["cc40", "坨坽夌奅妵妺姏姎妲姌姁妶妼姃姖妱妽姀姈妴姇孢孥宓宕屄屇岮岤岠岵岯岨岬岟岣岭岢岪岧岝岥岶岰岦帗帔帙弨弢弣弤彔徂彾彽忞忥怭怦怙怲怋"],
    ["cca1", "怴怊怗怳怚怞怬怢怍怐怮怓怑怌怉怜戔戽抭抴拑抾抪抶拊抮抳抯抻抩抰抸攽斨斻昉旼昄昒昈旻昃昋昍昅旽昑昐曶朊枅杬枎枒杶杻枘枆构杴枍枌杺枟枑枙枃杽极杸杹枔欥殀歾毞氝沓泬泫泮泙沶泔沭泧沷泐泂沺泃泆泭泲"],
    ["cd40", "泒泝沴沊沝沀泞泀洰泍泇沰泹泏泩泑炔炘炅炓炆炄炑炖炂炚炃牪狖狋狘狉狜狒狔狚狌狑玤玡玭玦玢玠玬玝瓝瓨甿畀甾疌疘皯盳盱盰盵矸矼矹矻矺"],
    ["cda1", "矷祂礿秅穸穻竻籵糽耵肏肮肣肸肵肭舠芠苀芫芚芘芛芵芧芮芼芞芺芴芨芡芩苂芤苃芶芢虰虯虭虮豖迒迋迓迍迖迕迗邲邴邯邳邰阹阽阼阺陃俍俅俓侲俉俋俁俔俜俙侻侳俛俇俖侺俀侹俬剄剉勀勂匽卼厗厖厙厘咺咡咭咥哏"],
    ["ce40", "哃茍咷咮哖咶哅哆咠呰咼咢咾呲哞咰垵垞垟垤垌垗垝垛垔垘垏垙垥垚垕壴复奓姡姞姮娀姱姝姺姽姼姶姤姲姷姛姩姳姵姠姾姴姭宨屌峐峘峌峗峋峛"],
    ["cea1", "峞峚峉峇峊峖峓峔峏峈峆峎峟峸巹帡帢帣帠帤庰庤庢庛庣庥弇弮彖徆怷怹恔恲恞恅恓恇恉恛恌恀恂恟怤恄恘恦恮扂扃拏挍挋拵挎挃拫拹挏挌拸拶挀挓挔拺挕拻拰敁敃斪斿昶昡昲昵昜昦昢昳昫昺昝昴昹昮朏朐柁柲柈枺"],
    ["cf40", "柜枻柸柘柀枷柅柫柤柟枵柍枳柷柶柮柣柂枹柎柧柰枲柼柆柭柌枮柦柛柺柉柊柃柪柋欨殂殄殶毖毘毠氠氡洨洴洭洟洼洿洒洊泚洳洄洙洺洚洑洀洝浂"],
    ["cfa1", "洁洘洷洃洏浀洇洠洬洈洢洉洐炷炟炾炱炰炡炴炵炩牁牉牊牬牰牳牮狊狤狨狫狟狪狦狣玅珌珂珈珅玹玶玵玴珫玿珇玾珃珆玸珋瓬瓮甮畇畈疧疪癹盄眈眃眄眅眊盷盻盺矧矨砆砑砒砅砐砏砎砉砃砓祊祌祋祅祄秕种秏秖秎窀"],
    ["d040", "穾竑笀笁籺籸籹籿粀粁紃紈紁罘羑羍羾耇耎耏耔耷胘胇胠胑胈胂胐胅胣胙胜胊胕胉胏胗胦胍臿舡芔苙苾苹茇苨茀苕茺苫苖苴苬苡苲苵茌苻苶苰苪"],
    ["d0a1", "苤苠苺苳苭虷虴虼虳衁衎衧衪衩觓訄訇赲迣迡迮迠郱邽邿郕郅邾郇郋郈釔釓陔陏陑陓陊陎倞倅倇倓倢倰倛俵俴倳倷倬俶俷倗倜倠倧倵倯倱倎党冔冓凊凄凅凈凎剡剚剒剞剟剕剢勍匎厞唦哢唗唒哧哳哤唚哿唄唈哫唑唅哱"],
    ["d140", "唊哻哷哸哠唎唃唋圁圂埌堲埕埒垺埆垽垼垸垶垿埇埐垹埁夎奊娙娖娭娮娕娏娗娊娞娳孬宧宭宬尃屖屔峬峿峮峱峷崀峹帩帨庨庮庪庬弳弰彧恝恚恧"],
    ["d1a1", "恁悢悈悀悒悁悝悃悕悛悗悇悜悎戙扆拲挐捖挬捄捅挶捃揤挹捋捊挼挩捁挴捘捔捙挭捇挳捚捑挸捗捀捈敊敆旆旃旄旂晊晟晇晑朒朓栟栚桉栲栳栻桋桏栖栱栜栵栫栭栯桎桄栴栝栒栔栦栨栮桍栺栥栠欬欯欭欱欴歭肂殈毦毤"],
    ["d240", "毨毣毢毧氥浺浣浤浶洍浡涒浘浢浭浯涑涍淯浿涆浞浧浠涗浰浼浟涂涘洯浨涋浾涀涄洖涃浻浽浵涐烜烓烑烝烋缹烢烗烒烞烠烔烍烅烆烇烚烎烡牂牸"],
    ["d2a1", "牷牶猀狺狴狾狶狳狻猁珓珙珥珖玼珧珣珩珜珒珛珔珝珚珗珘珨瓞瓟瓴瓵甡畛畟疰痁疻痄痀疿疶疺皊盉眝眛眐眓眒眣眑眕眙眚眢眧砣砬砢砵砯砨砮砫砡砩砳砪砱祔祛祏祜祓祒祑秫秬秠秮秭秪秜秞秝窆窉窅窋窌窊窇竘笐"],
    ["d340", "笄笓笅笏笈笊笎笉笒粄粑粊粌粈粍粅紞紝紑紎紘紖紓紟紒紏紌罜罡罞罠罝罛羖羒翃翂翀耖耾耹胺胲胹胵脁胻脀舁舯舥茳茭荄茙荑茥荖茿荁茦茜茢"],
    ["d3a1", "荂荎茛茪茈茼荍茖茤茠茷茯茩荇荅荌荓茞茬荋茧荈虓虒蚢蚨蚖蚍蚑蚞蚇蚗蚆蚋蚚蚅蚥蚙蚡蚧蚕蚘蚎蚝蚐蚔衃衄衭衵衶衲袀衱衿衯袃衾衴衼訒豇豗豻貤貣赶赸趵趷趶軑軓迾迵适迿迻逄迼迶郖郠郙郚郣郟郥郘郛郗郜郤酐"],
    ["d440", "酎酏釕釢釚陜陟隼飣髟鬯乿偰偪偡偞偠偓偋偝偲偈偍偁偛偊偢倕偅偟偩偫偣偤偆偀偮偳偗偑凐剫剭剬剮勖勓匭厜啵啶唼啍啐唴唪啑啢唶唵唰啒啅"],
    ["d4a1", "唌唲啥啎唹啈唭唻啀啋圊圇埻堔埢埶埜埴堀埭埽堈埸堋埳埏堇埮埣埲埥埬埡堎埼堐埧堁堌埱埩埰堍堄奜婠婘婕婧婞娸娵婭婐婟婥婬婓婤婗婃婝婒婄婛婈媎娾婍娹婌婰婩婇婑婖婂婜孲孮寁寀屙崞崋崝崚崠崌崨崍崦崥崏"],
    ["d540", "崰崒崣崟崮帾帴庱庴庹庲庳弶弸徛徖徟悊悐悆悾悰悺惓惔惏惤惙惝惈悱惛悷惊悿惃惍惀挲捥掊掂捽掽掞掭掝掗掫掎捯掇掐据掯捵掜捭掮捼掤挻掟"],
    ["d5a1", "捸掅掁掑掍捰敓旍晥晡晛晙晜晢朘桹梇梐梜桭桮梮梫楖桯梣梬梩桵桴梲梏桷梒桼桫桲梪梀桱桾梛梖梋梠梉梤桸桻梑梌梊桽欶欳欷欸殑殏殍殎殌氪淀涫涴涳湴涬淩淢涷淶淔渀淈淠淟淖涾淥淜淝淛淴淊涽淭淰涺淕淂淏淉"],
    ["d640", "淐淲淓淽淗淍淣涻烺焍烷焗烴焌烰焄烳焐烼烿焆焓焀烸烶焋焂焎牾牻牼牿猝猗猇猑猘猊猈狿猏猞玈珶珸珵琄琁珽琇琀珺珼珿琌琋珴琈畤畣痎痒痏"],
    ["d6a1", "痋痌痑痐皏皉盓眹眯眭眱眲眴眳眽眥眻眵硈硒硉硍硊硌砦硅硐祤祧祩祪祣祫祡离秺秸秶秷窏窔窐笵筇笴笥笰笢笤笳笘笪笝笱笫笭笯笲笸笚笣粔粘粖粣紵紽紸紶紺絅紬紩絁絇紾紿絊紻紨罣羕羜羝羛翊翋翍翐翑翇翏翉耟"],
    ["d740", "耞耛聇聃聈脘脥脙脛脭脟脬脞脡脕脧脝脢舑舸舳舺舴舲艴莐莣莨莍荺荳莤荴莏莁莕莙荵莔莩荽莃莌莝莛莪莋荾莥莯莈莗莰荿莦莇莮荶莚虙虖蚿蚷"],
    ["d7a1", "蛂蛁蛅蚺蚰蛈蚹蚳蚸蛌蚴蚻蚼蛃蚽蚾衒袉袕袨袢袪袚袑袡袟袘袧袙袛袗袤袬袌袓袎覂觖觙觕訰訧訬訞谹谻豜豝豽貥赽赻赹趼跂趹趿跁軘軞軝軜軗軠軡逤逋逑逜逌逡郯郪郰郴郲郳郔郫郬郩酖酘酚酓酕釬釴釱釳釸釤釹釪"],
    ["d840", "釫釷釨釮镺閆閈陼陭陫陱陯隿靪頄飥馗傛傕傔傞傋傣傃傌傎傝偨傜傒傂傇兟凔匒匑厤厧喑喨喥喭啷噅喢喓喈喏喵喁喣喒喤啽喌喦啿喕喡喎圌堩堷"],
    ["d8a1", "堙堞堧堣堨埵塈堥堜堛堳堿堶堮堹堸堭堬堻奡媯媔媟婺媢媞婸媦婼媥媬媕媮娷媄媊媗媃媋媩婻婽媌媜媏媓媝寪寍寋寔寑寊寎尌尰崷嵃嵫嵁嵋崿崵嵑嵎嵕崳崺嵒崽崱嵙嵂崹嵉崸崼崲崶嵀嵅幄幁彘徦徥徫惉悹惌惢惎惄愔"],
    ["d940", "惲愊愖愅惵愓惸惼惾惁愃愘愝愐惿愄愋扊掔掱掰揎揥揨揯揃撝揳揊揠揶揕揲揵摡揟掾揝揜揄揘揓揂揇揌揋揈揰揗揙攲敧敪敤敜敨敥斌斝斞斮旐旒"],
    ["d9a1", "晼晬晻暀晱晹晪晲朁椌棓椄棜椪棬棪棱椏棖棷棫棤棶椓椐棳棡椇棌椈楰梴椑棯棆椔棸棐棽棼棨椋椊椗棎棈棝棞棦棴棑椆棔棩椕椥棇欹欻欿欼殔殗殙殕殽毰毲毳氰淼湆湇渟湉溈渼渽湅湢渫渿湁湝湳渜渳湋湀湑渻渃渮湞"],
    ["da40", "湨湜湡渱渨湠湱湫渹渢渰湓湥渧湸湤湷湕湹湒湦渵渶湚焠焞焯烻焮焱焣焥焢焲焟焨焺焛牋牚犈犉犆犅犋猒猋猰猢猱猳猧猲猭猦猣猵猌琮琬琰琫琖"],
    ["daa1", "琚琡琭琱琤琣琝琩琠琲瓻甯畯畬痧痚痡痦痝痟痤痗皕皒盚睆睇睄睍睅睊睎睋睌矞矬硠硤硥硜硭硱硪确硰硩硨硞硢祴祳祲祰稂稊稃稌稄窙竦竤筊笻筄筈筌筎筀筘筅粢粞粨粡絘絯絣絓絖絧絪絏絭絜絫絒絔絩絑絟絎缾缿罥"],
    ["db40", "罦羢羠羡翗聑聏聐胾胔腃腊腒腏腇脽腍脺臦臮臷臸臹舄舼舽舿艵茻菏菹萣菀菨萒菧菤菼菶萐菆菈菫菣莿萁菝菥菘菿菡菋菎菖菵菉萉萏菞萑萆菂菳"],
    ["dba1", "菕菺菇菑菪萓菃菬菮菄菻菗菢萛菛菾蛘蛢蛦蛓蛣蛚蛪蛝蛫蛜蛬蛩蛗蛨蛑衈衖衕袺裗袹袸裀袾袶袼袷袽袲褁裉覕覘覗觝觚觛詎詍訹詙詀詗詘詄詅詒詈詑詊詌詏豟貁貀貺貾貰貹貵趄趀趉跘跓跍跇跖跜跏跕跙跈跗跅軯軷軺"],
    ["dc40", "軹軦軮軥軵軧軨軶軫軱軬軴軩逭逴逯鄆鄬鄄郿郼鄈郹郻鄁鄀鄇鄅鄃酡酤酟酢酠鈁鈊鈥鈃鈚鈦鈏鈌鈀鈒釿釽鈆鈄鈧鈂鈜鈤鈙鈗鈅鈖镻閍閌閐隇陾隈"],
    ["dca1", "隉隃隀雂雈雃雱雰靬靰靮頇颩飫鳦黹亃亄亶傽傿僆傮僄僊傴僈僂傰僁傺傱僋僉傶傸凗剺剸剻剼嗃嗛嗌嗐嗋嗊嗝嗀嗔嗄嗩喿嗒喍嗏嗕嗢嗖嗈嗲嗍嗙嗂圔塓塨塤塏塍塉塯塕塎塝塙塥塛堽塣塱壼嫇嫄嫋媺媸媱媵媰媿嫈媻嫆"],
    ["dd40", "媷嫀嫊媴媶嫍媹媐寖寘寙尟尳嵱嵣嵊嵥嵲嵬嵞嵨嵧嵢巰幏幎幊幍幋廅廌廆廋廇彀徯徭惷慉慊愫慅愶愲愮慆愯慏愩慀戠酨戣戥戤揅揱揫搐搒搉搠搤"],
    ["dda1", "搳摃搟搕搘搹搷搢搣搌搦搰搨摁搵搯搊搚摀搥搧搋揧搛搮搡搎敯斒旓暆暌暕暐暋暊暙暔晸朠楦楟椸楎楢楱椿楅楪椹楂楗楙楺楈楉椵楬椳椽楥棰楸椴楩楀楯楄楶楘楁楴楌椻楋椷楜楏楑椲楒椯楻椼歆歅歃歂歈歁殛嗀毻毼"],
    ["de40", "毹毷毸溛滖滈溏滀溟溓溔溠溱溹滆滒溽滁溞滉溷溰滍溦滏溲溾滃滜滘溙溒溎溍溤溡溿溳滐滊溗溮溣煇煔煒煣煠煁煝煢煲煸煪煡煂煘煃煋煰煟煐煓"],
    ["dea1", "煄煍煚牏犍犌犑犐犎猼獂猻猺獀獊獉瑄瑊瑋瑒瑑瑗瑀瑏瑐瑎瑂瑆瑍瑔瓡瓿瓾瓽甝畹畷榃痯瘏瘃痷痾痼痹痸瘐痻痶痭痵痽皙皵盝睕睟睠睒睖睚睩睧睔睙睭矠碇碚碔碏碄碕碅碆碡碃硹碙碀碖硻祼禂祽祹稑稘稙稒稗稕稢稓"],
    ["df40", "稛稐窣窢窞竫筦筤筭筴筩筲筥筳筱筰筡筸筶筣粲粴粯綈綆綀綍絿綅絺綎絻綃絼綌綔綄絽綒罭罫罧罨罬羦羥羧翛翜耡腤腠腷腜腩腛腢腲朡腞腶腧腯"],
    ["dfa1", "腄腡舝艉艄艀艂艅蓱萿葖葶葹蒏蒍葥葑葀蒆葧萰葍葽葚葙葴葳葝蔇葞萷萺萴葺葃葸萲葅萩菙葋萯葂萭葟葰萹葎葌葒葯蓅蒎萻葇萶萳葨葾葄萫葠葔葮葐蜋蜄蛷蜌蛺蛖蛵蝍蛸蜎蜉蜁蛶蜍蜅裖裋裍裎裞裛裚裌裐覅覛觟觥觤"],
    ["e040", "觡觠觢觜触詶誆詿詡訿詷誂誄詵誃誁詴詺谼豋豊豥豤豦貆貄貅賌赨赩趑趌趎趏趍趓趔趐趒跰跠跬跱跮跐跩跣跢跧跲跫跴輆軿輁輀輅輇輈輂輋遒逿"],
    ["e0a1", "遄遉逽鄐鄍鄏鄑鄖鄔鄋鄎酮酯鉈鉒鈰鈺鉦鈳鉥鉞銃鈮鉊鉆鉭鉬鉏鉠鉧鉯鈶鉡鉰鈱鉔鉣鉐鉲鉎鉓鉌鉖鈲閟閜閞閛隒隓隑隗雎雺雽雸雵靳靷靸靲頏頍頎颬飶飹馯馲馰馵骭骫魛鳪鳭鳧麀黽僦僔僗僨僳僛僪僝僤僓僬僰僯僣僠"],
    ["e140", "凘劀劁勩勫匰厬嘧嘕嘌嘒嗼嘏嘜嘁嘓嘂嗺嘝嘄嗿嗹墉塼墐墘墆墁塿塴墋塺墇墑墎塶墂墈塻墔墏壾奫嫜嫮嫥嫕嫪嫚嫭嫫嫳嫢嫠嫛嫬嫞嫝嫙嫨嫟孷寠"],
    ["e1a1", "寣屣嶂嶀嵽嶆嵺嶁嵷嶊嶉嶈嵾嵼嶍嵹嵿幘幙幓廘廑廗廎廜廕廙廒廔彄彃彯徶愬愨慁慞慱慳慒慓慲慬憀慴慔慺慛慥愻慪慡慖戩戧戫搫摍摛摝摴摶摲摳摽摵摦撦摎撂摞摜摋摓摠摐摿搿摬摫摙摥摷敳斠暡暠暟朅朄朢榱榶槉"],
    ["e240", "榠槎榖榰榬榼榑榙榎榧榍榩榾榯榿槄榽榤槔榹槊榚槏榳榓榪榡榞槙榗榐槂榵榥槆歊歍歋殞殟殠毃毄毾滎滵滱漃漥滸漷滻漮漉潎漙漚漧漘漻漒滭漊"],
    ["e2a1", "漶潳滹滮漭潀漰漼漵滫漇漎潃漅滽滶漹漜滼漺漟漍漞漈漡熇熐熉熀熅熂熏煻熆熁熗牄牓犗犕犓獃獍獑獌瑢瑳瑱瑵瑲瑧瑮甀甂甃畽疐瘖瘈瘌瘕瘑瘊瘔皸瞁睼瞅瞂睮瞀睯睾瞃碲碪碴碭碨硾碫碞碥碠碬碢碤禘禊禋禖禕禔禓"],
    ["e340", "禗禈禒禐稫穊稰稯稨稦窨窫窬竮箈箜箊箑箐箖箍箌箛箎箅箘劄箙箤箂粻粿粼粺綧綷緂綣綪緁緀緅綝緎緄緆緋緌綯綹綖綼綟綦綮綩綡緉罳翢翣翥翞"],
    ["e3a1", "耤聝聜膉膆膃膇膍膌膋舕蒗蒤蒡蒟蒺蓎蓂蒬蒮蒫蒹蒴蓁蓍蒪蒚蒱蓐蒝蒧蒻蒢蒔蓇蓌蒛蒩蒯蒨蓖蒘蒶蓏蒠蓗蓔蓒蓛蒰蒑虡蜳蜣蜨蝫蝀蜮蜞蜡蜙蜛蝃蜬蝁蜾蝆蜠蜲蜪蜭蜼蜒蜺蜱蜵蝂蜦蜧蜸蜤蜚蜰蜑裷裧裱裲裺裾裮裼裶裻"],
    ["e440", "裰裬裫覝覡覟覞觩觫觨誫誙誋誒誏誖谽豨豩賕賏賗趖踉踂跿踍跽踊踃踇踆踅跾踀踄輐輑輎輍鄣鄜鄠鄢鄟鄝鄚鄤鄡鄛酺酲酹酳銥銤鉶銛鉺銠銔銪銍"],
    ["e4a1", "銦銚銫鉹銗鉿銣鋮銎銂銕銢鉽銈銡銊銆銌銙銧鉾銇銩銝銋鈭隞隡雿靘靽靺靾鞃鞀鞂靻鞄鞁靿韎韍頖颭颮餂餀餇馝馜駃馹馻馺駂馽駇骱髣髧鬾鬿魠魡魟鳱鳲鳵麧僿儃儰僸儆儇僶僾儋儌僽儊劋劌勱勯噈噂噌嘵噁噊噉噆噘"],
    ["e540", "噚噀嘳嘽嘬嘾嘸嘪嘺圚墫墝墱墠墣墯墬墥墡壿嫿嫴嫽嫷嫶嬃嫸嬂嫹嬁嬇嬅嬏屧嶙嶗嶟嶒嶢嶓嶕嶠嶜嶡嶚嶞幩幝幠幜緳廛廞廡彉徲憋憃慹憱憰憢憉"],
    ["e5a1", "憛憓憯憭憟憒憪憡憍慦憳戭摮摰撖撠撅撗撜撏撋撊撌撣撟摨撱撘敶敺敹敻斲斳暵暰暩暲暷暪暯樀樆樗槥槸樕槱槤樠槿槬槢樛樝槾樧槲槮樔槷槧橀樈槦槻樍槼槫樉樄樘樥樏槶樦樇槴樖歑殥殣殢殦氁氀毿氂潁漦潾澇濆澒"],
    ["e640", "澍澉澌潢潏澅潚澖潶潬澂潕潲潒潐潗澔澓潝漀潡潫潽潧澐潓澋潩潿澕潣潷潪潻熲熯熛熰熠熚熩熵熝熥熞熤熡熪熜熧熳犘犚獘獒獞獟獠獝獛獡獚獙"],
    ["e6a1", "獢璇璉璊璆璁瑽璅璈瑼瑹甈甇畾瘥瘞瘙瘝瘜瘣瘚瘨瘛皜皝皞皛瞍瞏瞉瞈磍碻磏磌磑磎磔磈磃磄磉禚禡禠禜禢禛歶稹窲窴窳箷篋箾箬篎箯箹篊箵糅糈糌糋緷緛緪緧緗緡縃緺緦緶緱緰緮緟罶羬羰羭翭翫翪翬翦翨聤聧膣膟"],
    ["e740", "膞膕膢膙膗舖艏艓艒艐艎艑蔤蔻蔏蔀蔩蔎蔉蔍蔟蔊蔧蔜蓻蔫蓺蔈蔌蓴蔪蓲蔕蓷蓫蓳蓼蔒蓪蓩蔖蓾蔨蔝蔮蔂蓽蔞蓶蔱蔦蓧蓨蓰蓯蓹蔘蔠蔰蔋蔙蔯虢"],
    ["e7a1", "蝖蝣蝤蝷蟡蝳蝘蝔蝛蝒蝡蝚蝑蝞蝭蝪蝐蝎蝟蝝蝯蝬蝺蝮蝜蝥蝏蝻蝵蝢蝧蝩衚褅褌褔褋褗褘褙褆褖褑褎褉覢覤覣觭觰觬諏諆誸諓諑諔諕誻諗誾諀諅諘諃誺誽諙谾豍貏賥賟賙賨賚賝賧趠趜趡趛踠踣踥踤踮踕踛踖踑踙踦踧"],
    ["e840", "踔踒踘踓踜踗踚輬輤輘輚輠輣輖輗遳遰遯遧遫鄯鄫鄩鄪鄲鄦鄮醅醆醊醁醂醄醀鋐鋃鋄鋀鋙銶鋏鋱鋟鋘鋩鋗鋝鋌鋯鋂鋨鋊鋈鋎鋦鋍鋕鋉鋠鋞鋧鋑鋓"],
    ["e8a1", "銵鋡鋆銴镼閬閫閮閰隤隢雓霅霈霂靚鞊鞎鞈韐韏頞頝頦頩頨頠頛頧颲餈飺餑餔餖餗餕駜駍駏駓駔駎駉駖駘駋駗駌骳髬髫髳髲髱魆魃魧魴魱魦魶魵魰魨魤魬鳼鳺鳽鳿鳷鴇鴀鳹鳻鴈鴅鴄麃黓鼏鼐儜儓儗儚儑凞匴叡噰噠噮"],
    ["e940", "噳噦噣噭噲噞噷圜圛壈墽壉墿墺壂墼壆嬗嬙嬛嬡嬔嬓嬐嬖嬨嬚嬠嬞寯嶬嶱嶩嶧嶵嶰嶮嶪嶨嶲嶭嶯嶴幧幨幦幯廩廧廦廨廥彋徼憝憨憖懅憴懆懁懌憺"],
    ["e9a1", "憿憸憌擗擖擐擏擉撽撉擃擛擳擙攳敿敼斢曈暾曀曊曋曏暽暻暺曌朣樴橦橉橧樲橨樾橝橭橶橛橑樨橚樻樿橁橪橤橐橏橔橯橩橠樼橞橖橕橍橎橆歕歔歖殧殪殫毈毇氄氃氆澭濋澣濇澼濎濈潞濄澽澞濊澨瀄澥澮澺澬澪濏澿澸"],
    ["ea40", "澢濉澫濍澯澲澰燅燂熿熸燖燀燁燋燔燊燇燏熽燘熼燆燚燛犝犞獩獦獧獬獥獫獪瑿璚璠璔璒璕璡甋疀瘯瘭瘱瘽瘳瘼瘵瘲瘰皻盦瞚瞝瞡瞜瞛瞢瞣瞕瞙"],
    ["eaa1", "瞗磝磩磥磪磞磣磛磡磢磭磟磠禤穄穈穇窶窸窵窱窷篞篣篧篝篕篥篚篨篹篔篪篢篜篫篘篟糒糔糗糐糑縒縡縗縌縟縠縓縎縜縕縚縢縋縏縖縍縔縥縤罃罻罼罺羱翯耪耩聬膱膦膮膹膵膫膰膬膴膲膷膧臲艕艖艗蕖蕅蕫蕍蕓蕡蕘"],
    ["eb40", "蕀蕆蕤蕁蕢蕄蕑蕇蕣蔾蕛蕱蕎蕮蕵蕕蕧蕠薌蕦蕝蕔蕥蕬虣虥虤螛螏螗螓螒螈螁螖螘蝹螇螣螅螐螑螝螄螔螜螚螉褞褦褰褭褮褧褱褢褩褣褯褬褟觱諠"],
    ["eba1", "諢諲諴諵諝謔諤諟諰諈諞諡諨諿諯諻貑貒貐賵賮賱賰賳赬赮趥趧踳踾踸蹀蹅踶踼踽蹁踰踿躽輶輮輵輲輹輷輴遶遹遻邆郺鄳鄵鄶醓醐醑醍醏錧錞錈錟錆錏鍺錸錼錛錣錒錁鍆錭錎錍鋋錝鋺錥錓鋹鋷錴錂錤鋿錩錹錵錪錔錌"],
    ["ec40", "錋鋾錉錀鋻錖閼闍閾閹閺閶閿閵閽隩雔霋霒霐鞙鞗鞔韰韸頵頯頲餤餟餧餩馞駮駬駥駤駰駣駪駩駧骹骿骴骻髶髺髹髷鬳鮀鮅鮇魼魾魻鮂鮓鮒鮐魺鮕"],
    ["eca1", "魽鮈鴥鴗鴠鴞鴔鴩鴝鴘鴢鴐鴙鴟麈麆麇麮麭黕黖黺鼒鼽儦儥儢儤儠儩勴嚓嚌嚍嚆嚄嚃噾嚂噿嚁壖壔壏壒嬭嬥嬲嬣嬬嬧嬦嬯嬮孻寱寲嶷幬幪徾徻懃憵憼懧懠懥懤懨懞擯擩擣擫擤擨斁斀斶旚曒檍檖檁檥檉檟檛檡檞檇檓檎"],
    ["ed40", "檕檃檨檤檑橿檦檚檅檌檒歛殭氉濌澩濴濔濣濜濭濧濦濞濲濝濢濨燡燱燨燲燤燰燢獳獮獯璗璲璫璐璪璭璱璥璯甐甑甒甏疄癃癈癉癇皤盩瞵瞫瞲瞷瞶"],
    ["eda1", "瞴瞱瞨矰磳磽礂磻磼磲礅磹磾礄禫禨穜穛穖穘穔穚窾竀竁簅簏篲簀篿篻簎篴簋篳簂簉簃簁篸篽簆篰篱簐簊糨縭縼繂縳顈縸縪繉繀繇縩繌縰縻縶繄縺罅罿罾罽翴翲耬膻臄臌臊臅臇膼臩艛艚艜薃薀薏薧薕薠薋薣蕻薤薚薞"],
    ["ee40", "蕷蕼薉薡蕺蕸蕗薎薖薆薍薙薝薁薢薂薈薅蕹蕶薘薐薟虨螾螪螭蟅螰螬螹螵螼螮蟉蟃蟂蟌螷螯蟄蟊螴螶螿螸螽蟞螲褵褳褼褾襁襒褷襂覭覯覮觲觳謞"],
    ["eea1", "謘謖謑謅謋謢謏謒謕謇謍謈謆謜謓謚豏豰豲豱豯貕貔賹赯蹎蹍蹓蹐蹌蹇轃轀邅遾鄸醚醢醛醙醟醡醝醠鎡鎃鎯鍤鍖鍇鍼鍘鍜鍶鍉鍐鍑鍠鍭鎏鍌鍪鍹鍗鍕鍒鍏鍱鍷鍻鍡鍞鍣鍧鎀鍎鍙闇闀闉闃闅閷隮隰隬霠霟霘霝霙鞚鞡鞜"],
    ["ef40", "鞞鞝韕韔韱顁顄顊顉顅顃餥餫餬餪餳餲餯餭餱餰馘馣馡騂駺駴駷駹駸駶駻駽駾駼騃骾髾髽鬁髼魈鮚鮨鮞鮛鮦鮡鮥鮤鮆鮢鮠鮯鴳鵁鵧鴶鴮鴯鴱鴸鴰"],
    ["efa1", "鵅鵂鵃鴾鴷鵀鴽翵鴭麊麉麍麰黈黚黻黿鼤鼣鼢齔龠儱儭儮嚘嚜嚗嚚嚝嚙奰嬼屩屪巀幭幮懘懟懭懮懱懪懰懫懖懩擿攄擽擸攁攃擼斔旛曚曛曘櫅檹檽櫡櫆檺檶檷櫇檴檭歞毉氋瀇瀌瀍瀁瀅瀔瀎濿瀀濻瀦濼濷瀊爁燿燹爃燽獶"],
    ["f040", "璸瓀璵瓁璾璶璻瓂甔甓癜癤癙癐癓癗癚皦皽盬矂瞺磿礌礓礔礉礐礒礑禭禬穟簜簩簙簠簟簭簝簦簨簢簥簰繜繐繖繣繘繢繟繑繠繗繓羵羳翷翸聵臑臒"],
    ["f0a1", "臐艟艞薴藆藀藃藂薳薵薽藇藄薿藋藎藈藅薱薶藒蘤薸薷薾虩蟧蟦蟢蟛蟫蟪蟥蟟蟳蟤蟔蟜蟓蟭蟘蟣螤蟗蟙蠁蟴蟨蟝襓襋襏襌襆襐襑襉謪謧謣謳謰謵譇謯謼謾謱謥謷謦謶謮謤謻謽謺豂豵貙貘貗賾贄贂贀蹜蹢蹠蹗蹖蹞蹥蹧"],
    ["f140", "蹛蹚蹡蹝蹩蹔轆轇轈轋鄨鄺鄻鄾醨醥醧醯醪鎵鎌鎒鎷鎛鎝鎉鎧鎎鎪鎞鎦鎕鎈鎙鎟鎍鎱鎑鎲鎤鎨鎴鎣鎥闒闓闑隳雗雚巂雟雘雝霣霢霥鞬鞮鞨鞫鞤鞪"],
    ["f1a1", "鞢鞥韗韙韖韘韺顐顑顒颸饁餼餺騏騋騉騍騄騑騊騅騇騆髀髜鬈鬄鬅鬩鬵魊魌魋鯇鯆鯃鮿鯁鮵鮸鯓鮶鯄鮹鮽鵜鵓鵏鵊鵛鵋鵙鵖鵌鵗鵒鵔鵟鵘鵚麎麌黟鼁鼀鼖鼥鼫鼪鼩鼨齌齕儴儵劖勷厴嚫嚭嚦嚧嚪嚬壚壝壛夒嬽嬾嬿巃幰"],
    ["f240", "徿懻攇攐攍攉攌攎斄旞旝曞櫧櫠櫌櫑櫙櫋櫟櫜櫐櫫櫏櫍櫞歠殰氌瀙瀧瀠瀖瀫瀡瀢瀣瀩瀗瀤瀜瀪爌爊爇爂爅犥犦犤犣犡瓋瓅璷瓃甖癠矉矊矄矱礝礛"],
    ["f2a1", "礡礜礗礞禰穧穨簳簼簹簬簻糬糪繶繵繸繰繷繯繺繲繴繨罋罊羃羆羷翽翾聸臗臕艤艡艣藫藱藭藙藡藨藚藗藬藲藸藘藟藣藜藑藰藦藯藞藢蠀蟺蠃蟶蟷蠉蠌蠋蠆蟼蠈蟿蠊蠂襢襚襛襗襡襜襘襝襙覈覷覶觶譐譈譊譀譓譖譔譋譕"],
    ["f340", "譑譂譒譗豃豷豶貚贆贇贉趬趪趭趫蹭蹸蹳蹪蹯蹻軂轒轑轏轐轓辴酀鄿醰醭鏞鏇鏏鏂鏚鏐鏹鏬鏌鏙鎩鏦鏊鏔鏮鏣鏕鏄鏎鏀鏒鏧镽闚闛雡霩霫霬霨霦"],
    ["f3a1", "鞳鞷鞶韝韞韟顜顙顝顗颿颽颻颾饈饇饃馦馧騚騕騥騝騤騛騢騠騧騣騞騜騔髂鬋鬊鬎鬌鬷鯪鯫鯠鯞鯤鯦鯢鯰鯔鯗鯬鯜鯙鯥鯕鯡鯚鵷鶁鶊鶄鶈鵱鶀鵸鶆鶋鶌鵽鵫鵴鵵鵰鵩鶅鵳鵻鶂鵯鵹鵿鶇鵨麔麑黀黼鼭齀齁齍齖齗齘匷嚲"],
    ["f440", "嚵嚳壣孅巆巇廮廯忀忁懹攗攖攕攓旟曨曣曤櫳櫰櫪櫨櫹櫱櫮櫯瀼瀵瀯瀷瀴瀱灂瀸瀿瀺瀹灀瀻瀳灁爓爔犨獽獼璺皫皪皾盭矌矎矏矍矲礥礣礧礨礤礩"],
    ["f4a1", "禲穮穬穭竷籉籈籊籇籅糮繻繾纁纀羺翿聹臛臙舋艨艩蘢藿蘁藾蘛蘀藶蘄蘉蘅蘌藽蠙蠐蠑蠗蠓蠖襣襦覹觷譠譪譝譨譣譥譧譭趮躆躈躄轙轖轗轕轘轚邍酃酁醷醵醲醳鐋鐓鏻鐠鐏鐔鏾鐕鐐鐨鐙鐍鏵鐀鏷鐇鐎鐖鐒鏺鐉鏸鐊鏿"],
    ["f540", "鏼鐌鏶鐑鐆闞闠闟霮霯鞹鞻韽韾顠顢顣顟飁飂饐饎饙饌饋饓騲騴騱騬騪騶騩騮騸騭髇髊髆鬐鬒鬑鰋鰈鯷鰅鰒鯸鱀鰇鰎鰆鰗鰔鰉鶟鶙鶤鶝鶒鶘鶐鶛"],
    ["f5a1", "鶠鶔鶜鶪鶗鶡鶚鶢鶨鶞鶣鶿鶩鶖鶦鶧麙麛麚黥黤黧黦鼰鼮齛齠齞齝齙龑儺儹劘劗囃嚽嚾孈孇巋巏廱懽攛欂櫼欃櫸欀灃灄灊灈灉灅灆爝爚爙獾甗癪矐礭礱礯籔籓糲纊纇纈纋纆纍罍羻耰臝蘘蘪蘦蘟蘣蘜蘙蘧蘮蘡蘠蘩蘞蘥"],
    ["f640", "蠩蠝蠛蠠蠤蠜蠫衊襭襩襮襫觺譹譸譅譺譻贐贔趯躎躌轞轛轝酆酄酅醹鐿鐻鐶鐩鐽鐼鐰鐹鐪鐷鐬鑀鐱闥闤闣霵霺鞿韡顤飉飆飀饘饖騹騽驆驄驂驁騺"],
    ["f6a1", "騿髍鬕鬗鬘鬖鬺魒鰫鰝鰜鰬鰣鰨鰩鰤鰡鶷鶶鶼鷁鷇鷊鷏鶾鷅鷃鶻鶵鷎鶹鶺鶬鷈鶱鶭鷌鶳鷍鶲鹺麜黫黮黭鼛鼘鼚鼱齎齥齤龒亹囆囅囋奱孋孌巕巑廲攡攠攦攢欋欈欉氍灕灖灗灒爞爟犩獿瓘瓕瓙瓗癭皭礵禴穰穱籗籜籙籛籚"],
    ["f740", "糴糱纑罏羇臞艫蘴蘵蘳蘬蘲蘶蠬蠨蠦蠪蠥襱覿覾觻譾讄讂讆讅譿贕躕躔躚躒躐躖躗轠轢酇鑌鑐鑊鑋鑏鑇鑅鑈鑉鑆霿韣顪顩飋饔饛驎驓驔驌驏驈驊"],
    ["f7a1", "驉驒驐髐鬙鬫鬻魖魕鱆鱈鰿鱄鰹鰳鱁鰼鰷鰴鰲鰽鰶鷛鷒鷞鷚鷋鷐鷜鷑鷟鷩鷙鷘鷖鷵鷕鷝麶黰鼵鼳鼲齂齫龕龢儽劙壨壧奲孍巘蠯彏戁戃戄攩攥斖曫欑欒欏毊灛灚爢玂玁玃癰矔籧籦纕艬蘺虀蘹蘼蘱蘻蘾蠰蠲蠮蠳襶襴襳觾"],
    ["f840", "讌讎讋讈豅贙躘轤轣醼鑢鑕鑝鑗鑞韄韅頀驖驙鬞鬟鬠鱒鱘鱐鱊鱍鱋鱕鱙鱌鱎鷻鷷鷯鷣鷫鷸鷤鷶鷡鷮鷦鷲鷰鷢鷬鷴鷳鷨鷭黂黐黲黳鼆鼜鼸鼷鼶齃齏"],
    ["f8a1", "齱齰齮齯囓囍孎屭攭曭曮欓灟灡灝灠爣瓛瓥矕礸禷禶籪纗羉艭虃蠸蠷蠵衋讔讕躞躟躠躝醾醽釂鑫鑨鑩雥靆靃靇韇韥驞髕魙鱣鱧鱦鱢鱞鱠鸂鷾鸇鸃鸆鸅鸀鸁鸉鷿鷽鸄麠鼞齆齴齵齶囔攮斸欘欙欗欚灢爦犪矘矙礹籩籫糶纚"],
    ["f940", "纘纛纙臠臡虆虇虈襹襺襼襻觿讘讙躥躤躣鑮鑭鑯鑱鑳靉顲饟鱨鱮鱭鸋鸍鸐鸏鸒鸑麡黵鼉齇齸齻齺齹圞灦籯蠼趲躦釃鑴鑸鑶鑵驠鱴鱳鱱鱵鸔鸓黶鼊"],
    ["f9a1", "龤灨灥糷虪蠾蠽蠿讞貜躩軉靋顳顴飌饡馫驤驦驧鬤鸕鸗齈戇欞爧虌躨钂钀钁驩驨鬮鸙爩虋讟钃鱹麷癵驫鱺鸝灩灪麤齾齉龘碁銹裏墻恒粧嫺╔╦╗╠╬╣╚╩╝╒╤╕╞╪╡╘╧╛╓╥╖╟╫╢╙╨╜║═╭╮╰╯▓"]
  ];
});

// node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = __commonJS((exports, module) => {
  module.exports = [
    ["8740", "䏰䰲䘃䖦䕸𧉧䵷䖳𧲱䳢𧳅㮕䜶䝄䱇䱀𤊿𣘗𧍒𦺋𧃒䱗𪍑䝏䗚䲅𧱬䴇䪤䚡𦬣爥𥩔𡩣𣸆𣽡晍囻"],
    ["8767", "綕夝𨮹㷴霴𧯯寛𡵞媤㘥𩺰嫑宷峼杮薓𩥅瑡璝㡵𡵓𣚞𦀡㻬"],
    ["87a1", "𥣞㫵竼龗𤅡𨤍𣇪𠪊𣉞䌊蒄龖鐯䤰蘓墖靊鈘秐稲晠権袝瑌篅枂稬剏遆㓦珄𥶹瓆鿇垳䤯呌䄱𣚎堘穲𧭥讏䚮𦺈䆁𥶙箮𢒼鿈𢓁𢓉𢓌鿉蔄𣖻䂴鿊䓡𪷿拁灮鿋"],
    ["8840", "㇀", 4, "𠄌㇅𠃑𠃍㇆㇇𠃋𡿨㇈𠃊㇉㇊㇋㇌𠄎㇍㇎ĀÁǍÀĒÉĚÈŌÓǑÒ࿿Ê̄Ế࿿Ê̌ỀÊāáǎàɑēéěèīíǐìōóǒòūúǔùǖǘǚ"],
    ["88a1", "ǜü࿿ê̄ế࿿ê̌ềêɡ⏚⏛"],
    ["8940", "𪎩𡅅"],
    ["8943", "攊"],
    ["8946", "丽滝鵎釟"],
    ["894c", "𧜵撑会伨侨兖兴农凤务动医华发变团声处备夲头学实実岚庆总斉柾栄桥济炼电纤纬纺织经统缆缷艺苏药视设询车轧轮"],
    ["89a1", "琑糼緍楆竉刧"],
    ["89ab", "醌碸酞肼"],
    ["89b0", "贋胶𠧧"],
    ["89b5", "肟黇䳍鷉鸌䰾𩷶𧀎鸊𪄳㗁"],
    ["89c1", "溚舾甙"],
    ["89c5", "䤑马骏龙禇𨑬𡷊𠗐𢫦两亁亀亇亿仫伷㑌侽㹈倃傈㑽㒓㒥円夅凛凼刅争剹劐匧㗇厩㕑厰㕓参吣㕭㕲㚁咓咣咴咹哐哯唘唣唨㖘唿㖥㖿嗗㗅"],
    ["8a40", "𧶄唥"],
    ["8a43", "𠱂𠴕𥄫喐𢳆㧬𠍁蹆𤶸𩓥䁓𨂾睺𢰸㨴䟕𨅝𦧲𤷪擝𠵼𠾴𠳕𡃴撍蹾𠺖𠰋𠽤𢲩𨉖𤓓"],
    ["8a64", "𠵆𩩍𨃩䟴𤺧𢳂骲㩧𩗴㿭㔆𥋇𩟔𧣈𢵄鵮頕"],
    ["8a76", "䏙𦂥撴哣𢵌𢯊𡁷㧻𡁯"],
    ["8aa1", "𦛚𦜖𧦠擪𥁒𠱃蹨𢆡𨭌𠜱"],
    ["8aac", "䠋𠆩㿺塳𢶍"],
    ["8ab2", "𤗈𠓼𦂗𠽌𠶖啹䂻䎺"],
    ["8abb", "䪴𢩦𡂝膪飵𠶜捹㧾𢝵跀嚡摼㹃"],
    ["8ac9", "𪘁𠸉𢫏𢳉"],
    ["8ace", "𡃈𣧂㦒㨆𨊛㕸𥹉𢃇噒𠼱𢲲𩜠㒼氽𤸻"],
    ["8adf", "𧕴𢺋𢈈𪙛𨳍𠹺𠰴𦠜羓𡃏𢠃𢤹㗻𥇣𠺌𠾍𠺪㾓𠼰𠵇𡅏𠹌"],
    ["8af6", "𠺫𠮩𠵈𡃀𡄽㿹𢚖搲𠾭"],
    ["8b40", "𣏴𧘹𢯎𠵾𠵿𢱑𢱕㨘𠺘𡃇𠼮𪘲𦭐𨳒𨶙𨳊閪哌苄喹"],
    ["8b55", "𩻃鰦骶𧝞𢷮煀腭胬尜𦕲脴㞗卟𨂽醶𠻺𠸏𠹷𠻻㗝𤷫㘉𠳖嚯𢞵𡃉𠸐𠹸𡁸𡅈𨈇𡑕𠹹𤹐𢶤婔𡀝𡀞𡃵𡃶垜𠸑"],
    ["8ba1", "𧚔𨋍𠾵𠹻𥅾㜃𠾶𡆀𥋘𪊽𤧚𡠺𤅷𨉼墙剨㘚𥜽箲孨䠀䬬鼧䧧鰟鮍𥭴𣄽嗻㗲嚉丨夂𡯁屮靑𠂆乛亻㔾尣彑忄㣺扌攵歺氵氺灬爫丬犭𤣩罒礻糹罓𦉪㓁"],
    ["8bde", "𦍋耂肀𦘒𦥑卝衤见𧢲讠贝钅镸长门𨸏韦页风飞饣𩠐鱼鸟黄歯龜丷𠂇阝户钢"],
    ["8c40", "倻淾𩱳龦㷉袏𤅎灷峵䬠𥇍㕙𥴰愢𨨲辧釶熑朙玺𣊁𪄇㲋𡦀䬐磤琂冮𨜏䀉橣𪊺䈣蘏𠩯稪𩥇𨫪靕灍匤𢁾鏴盙𨧣龧矝亣俰傼丯众龨吴綋墒壐𡶶庒庙忂𢜒斋"],
    ["8ca1", "𣏹椙橃𣱣泿"],
    ["8ca7", "爀𤔅玌㻛𤨓嬕璹讃𥲤𥚕窓篬糃繬苸薗龩袐龪躹龫迏蕟駠鈡龬𨶹𡐿䁱䊢娚"],
    ["8cc9", "顨杫䉶圽"],
    ["8cce", "藖𤥻芿𧄍䲁𦵴嵻𦬕𦾾龭龮宖龯曧繛湗秊㶈䓃𣉖𢞖䎚䔶"],
    ["8ce6", "峕𣬚諹屸㴒𣕑嵸龲煗䕘𤃬𡸣䱷㥸㑊𠆤𦱁諌侴𠈹妿腬顖𩣺弻"],
    ["8d40", "𠮟"],
    ["8d42", "𢇁𨥭䄂䚻𩁹㼇龳𪆵䃸㟖䛷𦱆䅼𨚲𧏿䕭㣔𥒚䕡䔛䶉䱻䵶䗪㿈𤬏㙡䓞䒽䇭崾嵈嵖㷼㠏嶤嶹㠠㠸幂庽弥徃㤈㤔㤿㥍惗愽峥㦉憷憹懏㦸戬抐拥挘㧸嚱"],
    ["8da1", "㨃揢揻搇摚㩋擀崕嘡龟㪗斆㪽旿晓㫲暒㬢朖㭂枤栀㭘桊梄㭲㭱㭻椉楃牜楤榟榅㮼槖㯝橥橴橱檂㯬檙㯲檫檵櫔櫶殁毁毪汵沪㳋洂洆洦涁㳯涤涱渕渘温溆𨧀溻滢滚齿滨滩漤漴㵆𣽁澁澾㵪㵵熷岙㶊瀬㶑灐灔灯灿炉𠌥䏁㗱𠻘"],
    ["8e40", "𣻗垾𦻓焾𥟠㙎榢𨯩孴穉𥣡𩓙穥穽𥦬窻窰竂竃燑𦒍䇊竚竝竪䇯咲𥰁笋筕笩𥌎𥳾箢筯莜𥮴𦱿篐萡箒箸𥴠㶭𥱥蒒篺簆簵𥳁籄粃𤢂粦晽𤕸糉糇糦籴糳糵糎"],
    ["8ea1", "繧䔝𦹄絝𦻖璍綉綫焵綳緒𤁗𦀩緤㴓緵𡟹緥𨍭縝𦄡𦅚繮纒䌫鑬縧罀罁罇礶𦋐駡羗𦍑羣𡙡𠁨䕜𣝦䔃𨌺翺𦒉者耈耝耨耯𪂇𦳃耻耼聡𢜔䦉𦘦𣷣𦛨朥肧𨩈脇脚墰𢛶汿𦒘𤾸擧𡒊舘𡡞橓𤩥𤪕䑺舩𠬍𦩒𣵾俹𡓽蓢荢𦬊𤦧𣔰𡝳𣷸芪椛芳䇛"],
    ["8f40", "蕋苐茚𠸖𡞴㛁𣅽𣕚艻苢茘𣺋𦶣𦬅𦮗𣗎㶿茝嗬莅䔋𦶥莬菁菓㑾𦻔橗蕚㒖𦹂𢻯葘𥯤葱㷓䓤檧葊𣲵祘蒨𦮖𦹷𦹃蓞萏莑䒠蒓蓤𥲑䉀𥳀䕃蔴嫲𦺙䔧蕳䔖枿蘖"],
    ["8fa1", "𨘥𨘻藁𧂈蘂𡖂𧃍䕫䕪蘨㙈𡢢号𧎚虾蝱𪃸蟮𢰧螱蟚蠏噡虬桖䘏衅衆𧗠𣶹𧗤衞袜䙛袴袵揁装睷𧜏覇覊覦覩覧覼𨨥觧𧤤𧪽誜瞓釾誐𧩙竩𧬺𣾏䜓𧬸煼謌謟𥐰𥕥謿譌譍誩𤩺讐讛誯𡛟䘕衏貛𧵔𧶏貫㜥𧵓賖𧶘𧶽贒贃𡤐賛灜贑𤳉㻐起"],
    ["9040", "趩𨀂𡀔𤦊㭼𨆼𧄌竧躭躶軃鋔輙輭𨍥𨐒辥錃𪊟𠩐辳䤪𨧞𨔽𣶻廸𣉢迹𪀔𨚼𨔁𢌥㦀𦻗逷𨔼𧪾遡𨕬𨘋邨𨜓郄𨛦邮都酧㫰醩釄粬𨤳𡺉鈎沟鉁鉢𥖹銹𨫆𣲛𨬌𥗛"],
    ["90a1", "𠴱錬鍫𨫡𨯫炏嫃𨫢𨫥䥥鉄𨯬𨰹𨯿鍳鑛躼閅閦鐦閠濶䊹𢙺𨛘𡉼𣸮䧟氜陻隖䅬隣𦻕懚隶磵𨫠隽双䦡𦲸𠉴𦐐𩂯𩃥𤫑𡤕𣌊霱虂霶䨏䔽䖅𤫩灵孁霛靜𩇕靗孊𩇫靟鐥僐𣂷𣂼鞉鞟鞱鞾韀韒韠𥑬韮琜𩐳響韵𩐝𧥺䫑頴頳顋顦㬎𧅵㵑𠘰𤅜"],
    ["9140", "𥜆飊颷飈飇䫿𦴧𡛓喰飡飦飬鍸餹𤨩䭲𩡗𩤅駵騌騻騐驘𥜥㛄𩂱𩯕髠髢𩬅髴䰎鬔鬭𨘀倴鬴𦦨㣃𣁽魐魀𩴾婅𡡣鮎𤉋鰂鯿鰌𩹨鷔𩾷𪆒𪆫𪃡𪄣𪇟鵾鶃𪄴鸎梈"],
    ["91a1", "鷄𢅛𪆓𪈠𡤻𪈳鴹𪂹𪊴麐麕麞麢䴴麪麯𤍤黁㭠㧥㴝伲㞾𨰫鼂鼈䮖鐤𦶢鼗鼖鼹嚟嚊齅馸𩂋韲葿齢齩竜龎爖䮾𤥵𤦻煷𤧸𤍈𤩑玞𨯚𡣺禟𨥾𨸶鍩鏳𨩄鋬鎁鏋𨥬𤒹爗㻫睲穃烐𤑳𤏸煾𡟯炣𡢾𣖙㻇𡢅𥐯𡟸㜢𡛻𡠹㛡𡝴𡣑𥽋㜣𡛀坛𤨥𡏾𡊨"],
    ["9240", "𡏆𡒶蔃𣚦蔃葕𤦔𧅥𣸱𥕜𣻻𧁒䓴𣛮𩦝𦼦柹㜳㰕㷧塬𡤢栐䁗𣜿𤃡𤂋𤄏𦰡哋嚞𦚱嚒𠿟𠮨𠸍鏆𨬓鎜仸儫㠙𤐶亼𠑥𠍿佋侊𥙑婨𠆫𠏋㦙𠌊𠐔㐵伩𠋀𨺳𠉵諚𠈌亘"],
    ["92a1", "働儍侢伃𤨎𣺊佂倮偬傁俌俥偘僼兙兛兝兞湶𣖕𣸹𣺿浲𡢄𣺉冨凃𠗠䓝𠒣𠒒𠒑赺𨪜𠜎剙劤𠡳勡鍮䙺熌𤎌𠰠𤦬𡃤槑𠸝瑹㻞璙琔瑖玘䮎𤪼𤂍叐㖄爏𤃉喴𠍅响𠯆圝鉝雴鍦埝垍坿㘾壋媙𨩆𡛺𡝯𡜐娬妸銏婾嫏娒𥥆𡧳𡡡𤊕㛵洅瑃娡𥺃"],
    ["9340", "媁𨯗𠐓鏠璌𡌃焅䥲鐈𨧻鎽㞠尞岞幞幈𡦖𡥼𣫮廍孏𡤃𡤄㜁𡢠㛝𡛾㛓脪𨩇𡶺𣑲𨦨弌弎𡤧𡞫婫𡜻孄蘔𧗽衠恾𢡠𢘫忛㺸𢖯𢖾𩂈𦽳懀𠀾𠁆𢘛憙憘恵𢲛𢴇𤛔𩅍"],
    ["93a1", "摱𤙥𢭪㨩𢬢𣑐𩣪𢹸挷𪑛撶挱揑𤧣𢵧护𢲡搻敫楲㯴𣂎𣊭𤦉𣊫唍𣋠𡣙𩐿曎𣊉𣆳㫠䆐𥖄𨬢𥖏𡛼𥕛𥐥磮𣄃𡠪𣈴㑤𣈏𣆂𤋉暎𦴤晫䮓昰𧡰𡷫晣𣋒𣋡昞𥡲㣑𣠺𣞼㮙𣞢𣏾瓐㮖枏𤘪梶栞㯄檾㡣𣟕𤒇樳橒櫉欅𡤒攑梘橌㯗橺歗𣿀𣲚鎠鋲𨯪𨫋"],
    ["9440", "銉𨀞𨧜鑧涥漋𤧬浧𣽿㶏渄𤀼娽渊塇洤硂焻𤌚𤉶烱牐犇犔𤞏𤜥兹𤪤𠗫瑺𣻸𣙟𤩊𤤗𥿡㼆㺱𤫟𨰣𣼵悧㻳瓌琼鎇琷䒟𦷪䕑疃㽣𤳙𤴆㽘畕癳𪗆㬙瑨𨫌𤦫𤦎㫻"],
    ["94a1", "㷍𤩎㻿𤧅𤣳釺圲鍂𨫣𡡤僟𥈡𥇧睸𣈲眎眏睻𤚗𣞁㩞𤣰琸璛㺿𤪺𤫇䃈𤪖𦆮錇𥖁砞碍碈磒珐祙𧝁𥛣䄎禛蒖禥樭𣻺稺秴䅮𡛦䄲鈵秱𠵌𤦌𠊙𣶺𡝮㖗啫㕰㚪𠇔𠰍竢婙𢛵𥪯𥪜娍𠉛磰娪𥯆竾䇹籝籭䈑𥮳𥺼𥺦糍𤧹𡞰粎籼粮檲緜縇緓罎𦉡"],
    ["9540", "𦅜𧭈綗𥺂䉪𦭵𠤖柖𠁎𣗏埄𦐒𦏸𤥢翝笧𠠬𥫩𥵃笌𥸎駦虅驣樜𣐿㧢𤧷𦖭騟𦖠蒀𧄧𦳑䓪脷䐂胆脉腂𦞴飃𦩂艢艥𦩑葓𦶧蘐𧈛媆䅿𡡀嬫𡢡嫤𡣘蚠蜨𣶏蠭𧐢娂"],
    ["95a1", "衮佅袇袿裦襥襍𥚃襔𧞅𧞄𨯵𨯙𨮜𨧹㺭蒣䛵䛏㟲訽訜𩑈彍鈫𤊄旔焩烄𡡅鵭貟賩𧷜妚矃姰䍮㛔踪躧𤰉輰轊䋴汘澻𢌡䢛潹溋𡟚鯩㚵𤤯邻邗啱䤆醻鐄𨩋䁢𨫼鐧𨰝𨰻蓥訫閙閧閗閖𨴴瑅㻂𤣿𤩂𤏪㻧𣈥随𨻧𨹦𨹥㻌𤧭𤩸𣿮琒瑫㻼靁𩂰"],
    ["9640", "桇䨝𩂓𥟟靝鍨𨦉𨰦𨬯𦎾銺嬑譩䤼珹𤈛鞛靱餸𠼦巁𨯅𤪲頟𩓚鋶𩗗釥䓀𨭐𤩧𨭤飜𨩅㼀鈪䤥萔餻饍𧬆㷽馛䭯馪驜𨭥𥣈檏騡嫾騯𩣱䮐𩥈馼䮽䮗鍽塲𡌂堢𤦸"],
    ["96a1", "𡓨硄𢜟𣶸棅㵽鑘㤧慐𢞁𢥫愇鱏鱓鱻鰵鰐魿鯏𩸭鮟𪇵𪃾鴡䲮𤄄鸘䲰鴌𪆴𪃭𪃳𩤯鶥蒽𦸒𦿟𦮂藼䔳𦶤𦺄𦷰萠藮𦸀𣟗𦁤秢𣖜𣙀䤭𤧞㵢鏛銾鍈𠊿碹鉷鑍俤㑀遤𥕝砽硔碶硋𡝗𣇉𤥁㚚佲濚濙瀞瀞吔𤆵垻壳垊鴖埗焴㒯𤆬燫𦱀𤾗嬨𡞵𨩉"],
    ["9740", "愌嫎娋䊼𤒈㜬䭻𨧼鎻鎸𡣖𠼝葲𦳀𡐓𤋺𢰦𤏁妔𣶷𦝁綨𦅛𦂤𤦹𤦋𨧺鋥珢㻩璴𨭣𡢟㻡𤪳櫘珳珻㻖𤨾𤪔𡟙𤩦𠎧𡐤𤧥瑈𤤖炥𤥶銄珦鍟𠓾錱𨫎𨨖鎆𨯧𥗕䤵𨪂煫"],
    ["97a1", "𤥃𠳿嚤𠘚𠯫𠲸唂秄𡟺緾𡛂𤩐𡡒䔮鐁㜊𨫀𤦭妰𡢿𡢃𧒄媡㛢𣵛㚰鉟婹𨪁𡡢鍴㳍𠪴䪖㦊僴㵩㵌𡎜煵䋻𨈘渏𩃤䓫浗𧹏灧沯㳖𣿭𣸭渂漌㵯𠏵畑㚼㓈䚀㻚䡱姄鉮䤾轁𨰜𦯀堒埈㛖𡑒烾𤍢𤩱𢿣𡊰𢎽梹楧𡎘𣓥𧯴𣛟𨪃𣟖𣏺𤲟樚𣚭𦲷萾䓟䓎"],
    ["9840", "𦴦𦵑𦲂𦿞漗𧄉茽𡜺菭𦲀𧁓𡟛妉媂𡞳婡婱𡤅𤇼㜭姯𡜼㛇熎鎐暚𤊥婮娫𤊓樫𣻹𧜶𤑛𤋊焝𤉙𨧡侰𦴨峂𤓎𧹍𤎽樌𤉖𡌄炦焳𤏩㶥泟勇𤩏繥姫崯㷳彜𤩝𡟟綤萦"],
    ["98a1", "咅𣫺𣌀𠈔坾𠣕𠘙㿥𡾞𪊶瀃𩅛嵰玏糓𨩙𩐠俈翧狍猐𧫴猸猹𥛶獁獈㺩𧬘遬燵𤣲珡臶㻊県㻑沢国琙琞琟㻢㻰㻴㻺瓓㼎㽓畂畭畲疍㽼痈痜㿀癍㿗癴㿜発𤽜熈嘣覀塩䀝睃䀹条䁅㗛瞘䁪䁯属瞾矋売砘点砜䂨砹硇硑硦葈𥔵礳栃礲䄃"],
    ["9940", "䄉禑禙辻稆込䅧窑䆲窼艹䇄竏竛䇏両筢筬筻簒簛䉠䉺类粜䊌粸䊔糭输烀𠳏総緔緐緽羮羴犟䎗耠耥笹耮耱联㷌垴炠肷胩䏭脌猪脎脒畠脔䐁㬹腖腙腚"],
    ["99a1", "䐓堺腼膄䐥膓䐭膥埯臁臤艔䒏芦艶苊苘苿䒰荗险榊萅烵葤惣蒈䔄蒾蓡蓸蔐蔸蕒䔻蕯蕰藠䕷虲蚒蚲蛯际螋䘆䘗袮裿褤襇覑𧥧訩訸誔誴豑賔賲贜䞘塟跃䟭仮踺嗘坔蹱嗵躰䠷軎転軤軭軲辷迁迊迌逳駄䢭飠鈓䤞鈨鉘鉫銱銮銿"],
    ["9a40", "鋣鋫鋳鋴鋽鍃鎄鎭䥅䥑麿鐗匁鐝鐭鐾䥪鑔鑹锭関䦧间阳䧥枠䨤靀䨵鞲韂噔䫤惨颹䬙飱塄餎餙冴餜餷饂饝饢䭰駅䮝騼鬏窃魩鮁鯝鯱鯴䱭鰠㝯𡯂鵉鰺"],
    ["9aa1", "黾噐鶓鶽鷀鷼银辶鹻麬麱麽黆铜黢黱黸竈齄𠂔𠊷𠎠椚铃妬𠓗塀铁㞹𠗕𠘕𠙶𡚺块煳𠫂𠫍𠮿呪吆𠯋咞𠯻𠰻𠱓𠱥𠱼惧𠲍噺𠲵𠳝𠳭𠵯𠶲𠷈楕鰯螥𠸄𠸎𠻗𠾐𠼭𠹳尠𠾼帋𡁜𡁏𡁶朞𡁻𡂈𡂖㙇𡂿𡃓𡄯𡄻卤蒭𡋣𡍵𡌶讁𡕷𡘙𡟃𡟇乸炻𡠭𡥪"],
    ["9b40", "𡨭𡩅𡰪𡱰𡲬𡻈拃𡻕𡼕熘桕𢁅槩㛈𢉼𢏗𢏺𢜪𢡱𢥏苽𢥧𢦓𢫕覥𢫨辠𢬎鞸𢬿顇骽𢱌"],
    ["9b62", "𢲈𢲷𥯨𢴈𢴒𢶷𢶕𢹂𢽴𢿌𣀳𣁦𣌟𣏞徱晈暿𧩹𣕧𣗳爁𤦺矗𣘚𣜖纇𠍆墵朎"],
    ["9ba1", "椘𣪧𧙗𥿢𣸑𣺹𧗾𢂚䣐䪸𤄙𨪚𤋮𤌍𤀻𤌴𤎖𤩅𠗊凒𠘑妟𡺨㮾𣳿𤐄𤓖垈𤙴㦛𤜯𨗨𩧉㝢𢇃譞𨭎駖𤠒𤣻𤨕爉𤫀𠱸奥𤺥𤾆𠝹軚𥀬劏圿煱𥊙𥐙𣽊𤪧喼𥑆𥑮𦭒釔㑳𥔿𧘲𥕞䜘𥕢𥕦𥟇𤤿𥡝偦㓻𣏌惞𥤃䝼𨥈𥪮𥮉𥰆𡶐垡煑澶𦄂𧰒遖𦆲𤾚譢𦐂𦑊"],
    ["9c40", "嵛𦯷輶𦒄𡤜諪𤧶𦒈𣿯𦔒䯀𦖿𦚵𢜛鑥𥟡憕娧晉侻嚹𤔡𦛼乪𤤴陖涏𦲽㘘襷𦞙𦡮𦐑𦡞營𦣇筂𩃀𠨑𦤦鄄𦤹穅鷰𦧺騦𦨭㙟𦑩𠀡禃𦨴𦭛崬𣔙菏𦮝䛐𦲤画补𦶮墶"],
    ["9ca1", "㜜𢖍𧁋𧇍㱔𧊀𧊅銁𢅺𧊋錰𧋦𤧐氹钟𧑐𠻸蠧裵𢤦𨑳𡞱溸𤨪𡠠㦤㚹尐秣䔿暶𩲭𩢤襃𧟌𧡘囖䃟𡘊㦡𣜯𨃨𡏅熭荦𧧝𩆨婧䲷𧂯𨦫𧧽𧨊𧬋𧵦𤅺筃祾𨀉澵𪋟樃𨌘厢𦸇鎿栶靝𨅯𨀣𦦵𡏭𣈯𨁈嶅𨰰𨂃圕頣𨥉嶫𤦈斾槕叒𤪥𣾁㰑朶𨂐𨃴𨄮𡾡𨅏"],
    ["9d40", "𨆉𨆯𨈚𨌆𨌯𨎊㗊𨑨𨚪䣺揦𨥖砈鉕𨦸䏲𨧧䏟𨧨𨭆𨯔姸𨰉輋𨿅𩃬筑𩄐𩄼㷷𩅞𤫊运犏嚋𩓧𩗩𩖰𩖸𩜲𩣑𩥉𩥪𩧃𩨨𩬎𩵚𩶛纟𩻸𩼣䲤镇𪊓熢𪋿䶑递𪗋䶜𠲜达嗁"],
    ["9da1", "辺𢒰边𤪓䔉繿潖檱仪㓤𨬬𧢝㜺躀𡟵𨀤𨭬𨮙𧨾𦚯㷫𧙕𣲷𥘵𥥖亚𥺁𦉘嚿𠹭踎孭𣺈𤲞揞拐𡟶𡡻攰嘭𥱊吚𥌑㷆𩶘䱽嘢嘞罉𥻘奵𣵀蝰东𠿪𠵉𣚺脗鵞贘瘻鱅癎瞹鍅吲腈苷嘥脲萘肽嗪祢噃吖𠺝㗎嘅嗱曱𨋢㘭甴嗰喺咗啲𠱁𠲖廐𥅈𠹶𢱢"],
    ["9e40", "𠺢麫絚嗞𡁵抝靭咔賍燶酶揼掹揾啩𢭃鱲𢺳冚㓟𠶧冧呍唞唓癦踭𦢊疱肶蠄螆裇膶萜𡃁䓬猄𤜆宐茋𦢓噻𢛴𧴯𤆣𧵳𦻐𧊶酰𡇙鈈𣳼𪚩𠺬𠻹牦𡲢䝎𤿂𧿹𠿫䃺"],
    ["9ea1", "鱝攟𢶠䣳𤟠𩵼𠿬𠸊恢𧖣𠿭"],
    ["9ead", "𦁈𡆇熣纎鵐业丄㕷嬍沲卧㚬㧜卽㚥𤘘墚𤭮舭呋垪𥪕𠥹"],
    ["9ec5", "㩒𢑥獴𩺬䴉鯭𣳾𩼰䱛𤾩𩖞𩿞葜𣶶𧊲𦞳𣜠挮紥𣻷𣸬㨪逈勌㹴㙺䗩𠒎癀嫰𠺶硺𧼮墧䂿噼鮋嵴癔𪐴麅䳡痹㟻愙𣃚𤏲"],
    ["9ef5", "噝𡊩垧𤥣𩸆刴𧂮㖭汊鵼"],
    ["9f40", "籖鬹埞𡝬屓擓𩓐𦌵𧅤蚭𠴨𦴢𤫢𠵱"],
    ["9f4f", "凾𡼏嶎霃𡷑麁遌笟鬂峑箣扨挵髿篏鬪籾鬮籂粆鰕篼鬉鼗鰛𤤾齚啳寃俽麘俲剠㸆勑坧偖妷帒韈鶫轜呩鞴饀鞺匬愰"],
    ["9fa1", "椬叚鰊鴂䰻陁榀傦畆𡝭駚剳"],
    ["9fae", "酙隁酜"],
    ["9fb2", "酑𨺗捿𦴣櫊嘑醎畺抅𠏼獏籰𥰡𣳽"],
    ["9fc1", "𤤙盖鮝个𠳔莾衂"],
    ["9fc9", "届槀僭坺刟巵从氱𠇲伹咜哚劚趂㗾弌㗳"],
    ["9fdb", "歒酼龥鮗頮颴骺麨麄煺笔"],
    ["9fe7", "毺蠘罸"],
    ["9feb", "嘠𪙊蹷齓"],
    ["9ff0", "跔蹏鸜踁抂𨍽踨蹵竓𤩷稾磘泪詧瘇"],
    ["a040", "𨩚鼦泎蟖痃𪊲硓咢贌狢獱謭猂瓱賫𤪻蘯徺袠䒷"],
    ["a055", "𡠻𦸅"],
    ["a058", "詾𢔛"],
    ["a05b", "惽癧髗鵄鍮鮏蟵"],
    ["a063", "蠏賷猬霡鮰㗖犲䰇籑饊𦅙慙䰄麖慽"],
    ["a073", "坟慯抦戹拎㩜懢厪𣏵捤栂㗒"],
    ["a0a1", "嵗𨯂迚𨸹"],
    ["a0a6", "僙𡵆礆匲阸𠼻䁥"],
    ["a0ae", "矾"],
    ["a0b0", "糂𥼚糚稭聦聣絍甅瓲覔舚朌聢𧒆聛瓰脃眤覉𦟌畓𦻑螩蟎臈螌詉貭譃眫瓸蓚㘵榲趦"],
    ["a0d4", "覩瑨涹蟁𤀑瓧㷛煶悤憜㳑煢恷"],
    ["a0e2", "罱𨬭牐惩䭾删㰘𣳇𥻗𧙖𥔱𡥄𡋾𩤃𦷜𧂭峁𦆭𨨏𣙷𠃮𦡆𤼎䕢嬟𦍌齐麦𦉫"],
    ["a3c0", "␀", 31, "␡"],
    ["c6a1", "①", 9, "⑴", 9, "ⅰ", 9, "丶丿亅亠冂冖冫勹匸卩厶夊宀巛⼳广廴彐彡攴无疒癶辵隶¨ˆヽヾゝゞ〃仝々〆〇ー［］✽ぁ", 23],
    ["c740", "す", 58, "ァアィイ"],
    ["c7a1", "ゥ", 81, "А", 5, "ЁЖ", 4],
    ["c840", "Л", 26, "ёж", 25, "⇧↸↹㇏𠃌乚𠂊刂䒑"],
    ["c8a1", "龰冈龱𧘇"],
    ["c8cd", "￢￤＇＂㈱№℡゛゜⺀⺄⺆⺇⺈⺊⺌⺍⺕⺜⺝⺥⺧⺪⺬⺮⺶⺼⺾⻆⻊⻌⻍⻏⻖⻗⻞⻣"],
    ["c8f5", "ʃɐɛɔɵœøŋʊɪ"],
    ["f9fe", "￭"],
    ["fa40", "𠕇鋛𠗟𣿅蕌䊵珯况㙉𤥂𨧤鍄𡧛苮𣳈砼杄拟𤤳𨦪𠊠𦮳𡌅侫𢓭倈𦴩𧪄𣘀𤪱𢔓倩𠍾徤𠎀𠍇滛𠐟偽儁㑺儎顬㝃萖𤦤𠒇兠𣎴兪𠯿𢃼𠋥𢔰𠖎𣈳𡦃宂蝽𠖳𣲙冲冸"],
    ["faa1", "鴴凉减凑㳜凓𤪦决凢卂凭菍椾𣜭彻刋刦刼劵剗劔効勅簕蕂勠蘍𦬓包𨫞啉滙𣾀𠥔𣿬匳卄𠯢泋𡜦栛珕恊㺪㣌𡛨燝䒢卭却𨚫卾卿𡖖𡘓矦厓𨪛厠厫厮玧𥝲㽙玜叁叅汉义埾叙㪫𠮏叠𣿫𢶣叶𠱷吓灹唫晗浛呭𦭓𠵴啝咏咤䞦𡜍𠻝㶴𠵍"],
    ["fb40", "𨦼𢚘啇䳭启琗喆喩嘅𡣗𤀺䕒𤐵暳𡂴嘷曍𣊊暤暭噍噏磱囱鞇叾圀囯园𨭦㘣𡉏坆𤆥汮炋坂㚱𦱾埦𡐖堃𡑔𤍣堦𤯵塜墪㕡壠壜𡈼壻寿坃𪅐𤉸鏓㖡够梦㛃湙"],
    ["fba1", "𡘾娤啓𡚒蔅姉𠵎𦲁𦴪𡟜姙𡟻𡞲𦶦浱𡠨𡛕姹𦹅媫婣㛦𤦩婷㜈媖瑥嫓𦾡𢕔㶅𡤑㜲𡚸広勐孶斈孼𧨎䀄䡝𠈄寕慠𡨴𥧌𠖥寳宝䴐尅𡭄尓珎尔𡲥𦬨屉䣝岅峩峯嶋𡷹𡸷崐崘嵆𡺤岺巗苼㠭𤤁𢁉𢅳芇㠶㯂帮檊幵幺𤒼𠳓厦亷廐厨𡝱帉廴𨒂"],
    ["fc40", "廹廻㢠廼栾鐛弍𠇁弢㫞䢮𡌺强𦢈𢏐彘𢑱彣鞽𦹮彲鍀𨨶徧嶶㵟𥉐𡽪𧃸𢙨釖𠊞𨨩怱暅𡡷㥣㷇㘹垐𢞴祱㹀悞悤悳𤦂𤦏𧩓璤僡媠慤萤慂慈𦻒憁凴𠙖憇宪𣾷"],
    ["fca1", "𢡟懓𨮝𩥝懐㤲𢦀𢣁怣慜攞掋𠄘担𡝰拕𢸍捬𤧟㨗搸揸𡎎𡟼撐澊𢸶頔𤂌𥜝擡擥鑻㩦携㩗敍漖𤨨𤨣斅敭敟𣁾斵𤥀䬷旑䃘𡠩无旣忟𣐀昘𣇷𣇸晄𣆤𣆥晋𠹵晧𥇦晳晴𡸽𣈱𨗴𣇈𥌓矅𢣷馤朂𤎜𤨡㬫槺𣟂杞杧杢𤇍𩃭柗䓩栢湐鈼栁𣏦𦶠桝"],
    ["fd40", "𣑯槡樋𨫟楳棃𣗍椁椀㴲㨁𣘼㮀枬楡𨩊䋼椶榘㮡𠏉荣傐槹𣙙𢄪橅𣜃檝㯳枱櫈𩆜㰍欝𠤣惞欵歴𢟍溵𣫛𠎵𡥘㝀吡𣭚毡𣻼毜氷𢒋𤣱𦭑汚舦汹𣶼䓅𣶽𤆤𤤌𤤀"],
    ["fda1", "𣳉㛥㳫𠴲鮃𣇹𢒑羏样𦴥𦶡𦷫涖浜湼漄𤥿𤂅𦹲蔳𦽴凇沜渝萮𨬡港𣸯瑓𣾂秌湏媑𣁋濸㜍澝𣸰滺𡒗𤀽䕕鏰潄潜㵎潴𩅰㴻澟𤅄濓𤂑𤅕𤀹𣿰𣾴𤄿凟𤅖𤅗𤅀𦇝灋灾炧炁烌烕烖烟䄄㷨熴熖𤉷焫煅媈煊煮岜𤍥煏鍢𤋁焬𤑚𤨧𤨢熺𨯨炽爎"],
    ["fe40", "鑂爕夑鑃爤鍁𥘅爮牀𤥴梽牕牗㹕𣁄栍漽犂猪猫𤠣𨠫䣭𨠄猨献珏玪𠰺𦨮珉瑉𤇢𡛧𤨤昣㛅𤦷𤦍𤧻珷琕椃𤨦琹𠗃㻗瑜𢢭瑠𨺲瑇珤瑶莹瑬㜰瑴鏱樬璂䥓𤪌"],
    ["fea1", "𤅟𤩹𨮏孆𨰃𡢞瓈𡦈甎瓩甞𨻙𡩋寗𨺬鎅畍畊畧畮𤾂㼄𤴓疎瑝疞疴瘂瘬癑癏癯癶𦏵皐臯㟸𦤑𦤎皡皥皷盌𦾟葢𥂝𥅽𡸜眞眦着撯𥈠睘𣊬瞯𨥤𨥨𡛁矴砉𡍶𤨒棊碯磇磓隥礮𥗠磗礴碱𧘌辸袄𨬫𦂃𢘜禆褀椂禀𥡗禝𧬹礼禩渪𧄦㺨秆𩄍秔"]
  ];
});

// node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = __commonJS((exports, module) => {
  "use strict";
  module.exports = {
    shiftjis: {
      type: "_dbcs",
      table: function() {
        return require_shiftjis();
      },
      encodeAdd: {"¥": 92, "‾": 126},
      encodeSkipVals: [{from: 60736, to: 63808}]
    },
    csshiftjis: "shiftjis",
    mskanji: "shiftjis",
    sjis: "shiftjis",
    windows31j: "shiftjis",
    ms31j: "shiftjis",
    xsjis: "shiftjis",
    windows932: "shiftjis",
    ms932: "shiftjis",
    "932": "shiftjis",
    cp932: "shiftjis",
    eucjp: {
      type: "_dbcs",
      table: function() {
        return require_eucjp();
      },
      encodeAdd: {"¥": 92, "‾": 126}
    },
    gb2312: "cp936",
    gb231280: "cp936",
    gb23121980: "cp936",
    csgb2312: "cp936",
    csiso58gb231280: "cp936",
    euccn: "cp936",
    windows936: "cp936",
    ms936: "cp936",
    "936": "cp936",
    cp936: {
      type: "_dbcs",
      table: function() {
        return require_cp936();
      }
    },
    gbk: {
      type: "_dbcs",
      table: function() {
        return require_cp936().concat(require_gbk_added());
      }
    },
    xgbk: "gbk",
    isoir58: "gbk",
    gb18030: {
      type: "_dbcs",
      table: function() {
        return require_cp936().concat(require_gbk_added());
      },
      gb18030: function() {
        return require_gb18030_ranges();
      },
      encodeSkipVals: [128],
      encodeAdd: {"€": 41699}
    },
    chinese: "gb18030",
    windows949: "cp949",
    ms949: "cp949",
    "949": "cp949",
    cp949: {
      type: "_dbcs",
      table: function() {
        return require_cp949();
      }
    },
    cseuckr: "cp949",
    csksc56011987: "cp949",
    euckr: "cp949",
    isoir149: "cp949",
    korean: "cp949",
    ksc56011987: "cp949",
    ksc56011989: "cp949",
    ksc5601: "cp949",
    windows950: "cp950",
    ms950: "cp950",
    "950": "cp950",
    cp950: {
      type: "_dbcs",
      table: function() {
        return require_cp950();
      }
    },
    big5: "big5hkscs",
    big5hkscs: {
      type: "_dbcs",
      table: function() {
        return require_cp950().concat(require_big5_added());
      },
      encodeSkipVals: [41676]
    },
    cnbig5: "big5hkscs",
    csbig5: "big5hkscs",
    xxbig5: "big5hkscs"
  };
});

// node_modules/iconv-lite/encodings/index.js
var require_encodings = __commonJS((exports, module) => {
  "use strict";
  var modules = [
    require_internal(),
    require_utf32(),
    require_utf16(),
    require_utf7(),
    require_sbcs_codec(),
    require_sbcs_data(),
    require_sbcs_data_generated(),
    require_dbcs_codec(),
    require_dbcs_data()
  ];
  for (var i2 = 0; i2 < modules.length; i2++) {
    var module = modules[i2];
    for (var enc in module)
      if (Object.prototype.hasOwnProperty.call(module, enc))
        exports[enc] = module[enc];
  }
});

// node_modules/iconv-lite/lib/streams.js
var require_streams = __commonJS((exports, module) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  module.exports = function(stream_module) {
    var Transform = stream_module.Transform;
    function IconvLiteEncoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.decodeStrings = false;
      Transform.call(this, options);
    }
    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
      constructor: {value: IconvLiteEncoderStream}
    });
    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
      if (typeof chunk != "string")
        return done(new Error("Iconv encoding stream needs strings as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length)
          this.push(res);
        done();
      } catch (e2) {
        done(e2);
      }
    };
    IconvLiteEncoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length)
          this.push(res);
        done();
      } catch (e2) {
        done(e2);
      }
    };
    IconvLiteEncoderStream.prototype.collect = function(cb) {
      var chunks = [];
      this.on("error", cb);
      this.on("data", function(chunk) {
        chunks.push(chunk);
      });
      this.on("end", function() {
        cb(null, Buffer2.concat(chunks));
      });
      return this;
    };
    function IconvLiteDecoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.encoding = this.encoding = "utf8";
      Transform.call(this, options);
    }
    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
      constructor: {value: IconvLiteDecoderStream}
    });
    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
      if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array))
        return done(new Error("Iconv decoding stream needs buffers as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length)
          this.push(res, this.encoding);
        done();
      } catch (e2) {
        done(e2);
      }
    };
    IconvLiteDecoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length)
          this.push(res, this.encoding);
        done();
      } catch (e2) {
        done(e2);
      }
    };
    IconvLiteDecoderStream.prototype.collect = function(cb) {
      var res = "";
      this.on("error", cb);
      this.on("data", function(chunk) {
        res += chunk;
      });
      this.on("end", function() {
        cb(null, res);
      });
      return this;
    };
    return {
      IconvLiteEncoderStream,
      IconvLiteDecoderStream
    };
  };
});

// node_modules/iconv-lite/lib/index.js
var require_lib = __commonJS((exports, module) => {
  "use strict";
  var Buffer2 = require_safer().Buffer;
  var bomHandling = require_bom_handling();
  var iconv = module.exports;
  iconv.encodings = null;
  iconv.defaultCharUnicode = "�";
  iconv.defaultCharSingleByte = "?";
  iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || "");
    var encoder = iconv.getEncoder(encoding, options);
    var res = encoder.write(str);
    var trail = encoder.end();
    return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
  };
  iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === "string") {
      if (!iconv.skipDecodeWarning) {
        console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
        iconv.skipDecodeWarning = true;
      }
      buf = Buffer2.from("" + (buf || ""), "binary");
    }
    var decoder = iconv.getDecoder(encoding, options);
    var res = decoder.write(buf);
    var trail = decoder.end();
    return trail ? res + trail : res;
  };
  iconv.encodingExists = function encodingExists(enc) {
    try {
      iconv.getCodec(enc);
      return true;
    } catch (e2) {
      return false;
    }
  };
  iconv.toEncoding = iconv.encode;
  iconv.fromEncoding = iconv.decode;
  iconv._codecDataCache = {};
  iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
      iconv.encodings = require_encodings();
    var enc = iconv._canonicalizeEncoding(encoding);
    var codecOptions = {};
    while (true) {
      var codec = iconv._codecDataCache[enc];
      if (codec)
        return codec;
      var codecDef = iconv.encodings[enc];
      switch (typeof codecDef) {
        case "string":
          enc = codecDef;
          break;
        case "object":
          for (var key in codecDef)
            codecOptions[key] = codecDef[key];
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          enc = codecDef.type;
          break;
        case "function":
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          codec = new codecDef(codecOptions, iconv);
          iconv._codecDataCache[codecOptions.encodingName] = codec;
          return codec;
        default:
          throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
      }
    }
  };
  iconv._canonicalizeEncoding = function(encoding) {
    return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
  };
  iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
    if (codec.bomAware && options && options.addBOM)
      encoder = new bomHandling.PrependBOM(encoder, options);
    return encoder;
  };
  iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
    if (codec.bomAware && !(options && options.stripBOM === false))
      decoder = new bomHandling.StripBOM(decoder, options);
    return decoder;
  };
  iconv.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
    if (iconv.supportsStreams)
      return;
    var streams = require_streams()(stream_module2);
    iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
    iconv.encodeStream = function encodeStream(encoding, options) {
      return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    };
    iconv.decodeStream = function decodeStream(encoding, options) {
      return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    };
    iconv.supportsStreams = true;
  };
  var stream_module;
  try {
    stream_module = require("stream");
  } catch (e2) {
  }
  if (stream_module && stream_module.Transform) {
    iconv.enableStreamingAPI(stream_module);
  } else {
    iconv.encodeStream = iconv.decodeStream = function() {
      throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
    };
  }
  if (false) {
    console.error("iconv-lite warning: js files use non-utf8 encoding. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.");
  }
});

// node_modules/encoding/lib/encoding.js
var require_encoding = __commonJS((exports, module) => {
  "use strict";
  var iconvLite = require_lib();
  module.exports.convert = convert;
  function convert(str, to2, from) {
    from = checkEncoding(from || "UTF-8");
    to2 = checkEncoding(to2 || "UTF-8");
    str = str || "";
    var result;
    if (from !== "UTF-8" && typeof str === "string") {
      str = Buffer.from(str, "binary");
    }
    if (from === to2) {
      if (typeof str === "string") {
        result = Buffer.from(str);
      } else {
        result = str;
      }
    } else {
      try {
        result = convertIconvLite(str, to2, from);
      } catch (E2) {
        console.error(E2);
        result = str;
      }
    }
    if (typeof result === "string") {
      result = Buffer.from(result, "utf-8");
    }
    return result;
  }
  function convertIconvLite(str, to2, from) {
    if (to2 === "UTF-8") {
      return iconvLite.decode(str, from);
    } else if (from === "UTF-8") {
      return iconvLite.encode(str, to2);
    } else {
      return iconvLite.encode(iconvLite.decode(str, from), to2);
    }
  }
  function checkEncoding(name) {
    return (name || "").toString().trim().replace(/^latin[\-_]?(\d+)$/i, "ISO-8859-$1").replace(/^win(?:dows)?[\-_]?(\d+)$/i, "WINDOWS-$1").replace(/^utf[\-_]?(\d+)$/i, "UTF-$1").replace(/^ks_c_5601\-1987$/i, "CP949").replace(/^us[\-_]?ascii$/i, "ASCII").toUpperCase();
  }
});

// node_modules/node-fetch/lib/index.es.js
var require_index_es = __commonJS((exports) => {
  __export(exports, {
    FetchError: () => FetchError,
    Headers: () => Headers,
    Request: () => Request,
    Response: () => Response,
    default: () => index_es_default
  });
  const BUFFER = Symbol("buffer");
  const TYPE = Symbol("type");
  class Blob2 {
    constructor() {
      this[TYPE] = "";
      const blobParts = arguments[0];
      const options = arguments[1];
      const buffers = [];
      if (blobParts) {
        const a2 = blobParts;
        const length = Number(a2.length);
        for (let i2 = 0; i2 < length; i2++) {
          const element = a2[i2];
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob2) {
            buffer = element[BUFFER];
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          buffers.push(buffer);
        }
      }
      this[BUFFER] = Buffer.concat(buffers);
      let type = options && options.type !== void 0 && String(options.type).toLowerCase();
      if (type && !/[^\u0020-\u007E]/.test(type)) {
        this[TYPE] = type;
      }
    }
    get size() {
      return this[BUFFER].length;
    }
    get type() {
      return this[TYPE];
    }
    slice() {
      const size = this.size;
      const start = arguments[0];
      const end = arguments[1];
      let relativeStart, relativeEnd;
      if (start === void 0) {
        relativeStart = 0;
      } else if (start < 0) {
        relativeStart = Math.max(size + start, 0);
      } else {
        relativeStart = Math.min(start, size);
      }
      if (end === void 0) {
        relativeEnd = size;
      } else if (end < 0) {
        relativeEnd = Math.max(size + end, 0);
      } else {
        relativeEnd = Math.min(end, size);
      }
      const span = Math.max(relativeEnd - relativeStart, 0);
      const buffer = this[BUFFER];
      const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
      const blob = new Blob2([], {type: arguments[2]});
      blob[BUFFER] = slicedBuffer;
      return blob;
    }
  }
  Object.defineProperties(Blob2.prototype, {
    size: {enumerable: true},
    type: {enumerable: true},
    slice: {enumerable: true}
  });
  Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
    value: "Blob",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function FetchError(message, type, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type;
    if (systemError) {
      this.code = this.errno = systemError.code;
    }
    Error.captureStackTrace(this, this.constructor);
  }
  FetchError.prototype = Object.create(Error.prototype);
  FetchError.prototype.constructor = FetchError;
  FetchError.prototype.name = "FetchError";
  const Stream = require("stream");
  var _require = require("stream");
  const PassThrough = _require.PassThrough;
  let convert;
  try {
    convert = require_encoding().convert;
  } catch (e2) {
  }
  const INTERNALS = Symbol("Body internals");
  function Body(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === void 0 ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
    if (body == null) {
      body = null;
    } else if (typeof body === "string") {
    } else if (isURLSearchParams(body)) {
    } else if (body instanceof Blob2) {
    } else if (Buffer.isBuffer(body)) {
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    } else if (body instanceof Stream) {
    } else {
      body = String(body);
    }
    this[INTERNALS] = {
      body,
      disturbed: false,
      error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof Stream) {
      body.on("error", function(err) {
        _this[INTERNALS].error = new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
      });
    }
  }
  Body.prototype = {
    get body() {
      return this[INTERNALS].body;
    },
    get bodyUsed() {
      return this[INTERNALS].disturbed;
    },
    arrayBuffer() {
      return consumeBody.call(this).then(function(buf) {
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      });
    },
    blob() {
      let ct2 = this.headers && this.headers.get("content-type") || "";
      return consumeBody.call(this).then(function(buf) {
        return Object.assign(new Blob2([], {
          type: ct2.toLowerCase()
        }), {
          [BUFFER]: buf
        });
      });
    },
    json() {
      var _this2 = this;
      return consumeBody.call(this).then(function(buffer) {
        try {
          return JSON.parse(buffer.toString());
        } catch (err) {
          return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
        }
      });
    },
    text() {
      return consumeBody.call(this).then(function(buffer) {
        return buffer.toString();
      });
    },
    buffer() {
      return consumeBody.call(this);
    },
    textConverted() {
      var _this3 = this;
      return consumeBody.call(this).then(function(buffer) {
        return convertBody(buffer, _this3.headers);
      });
    }
  };
  Object.defineProperties(Body.prototype, {
    body: {enumerable: true},
    bodyUsed: {enumerable: true},
    arrayBuffer: {enumerable: true},
    blob: {enumerable: true},
    json: {enumerable: true},
    text: {enumerable: true}
  });
  Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)) {
      if (!(name in proto)) {
        const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
        Object.defineProperty(proto, name, desc);
      }
    }
  };
  function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
      return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
      return Body.Promise.reject(this[INTERNALS].error);
    }
    if (this.body === null) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    if (typeof this.body === "string") {
      return Body.Promise.resolve(Buffer.from(this.body));
    }
    if (this.body instanceof Blob2) {
      return Body.Promise.resolve(this.body[BUFFER]);
    }
    if (Buffer.isBuffer(this.body)) {
      return Body.Promise.resolve(this.body);
    }
    if (Object.prototype.toString.call(this.body) === "[object ArrayBuffer]") {
      return Body.Promise.resolve(Buffer.from(this.body));
    }
    if (!(this.body instanceof Stream)) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve, reject) {
      let resTimeout;
      if (_this4.timeout) {
        resTimeout = setTimeout(function() {
          abort = true;
          reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
        }, _this4.timeout);
      }
      _this4.body.on("error", function(err) {
        reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
      });
      _this4.body.on("data", function(chunk) {
        if (abort || chunk === null) {
          return;
        }
        if (_this4.size && accumBytes + chunk.length > _this4.size) {
          abort = true;
          reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
          return;
        }
        accumBytes += chunk.length;
        accum.push(chunk);
      });
      _this4.body.on("end", function() {
        if (abort) {
          return;
        }
        clearTimeout(resTimeout);
        try {
          resolve(Buffer.concat(accum));
        } catch (err) {
          reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
        }
      });
    });
  }
  function convertBody(buffer, headers) {
    if (typeof convert !== "function") {
      throw new Error("The package `encoding` must be installed to use the textConverted() function");
    }
    const ct2 = headers.get("content-type");
    let charset = "utf-8";
    let res, str;
    if (ct2) {
      res = /charset=([^;]*)/i.exec(ct2);
    }
    str = buffer.slice(0, 1024).toString();
    if (!res && str) {
      res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    if (!res && str) {
      res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
      if (res) {
        res = /charset=(.*)/i.exec(res.pop());
      }
    }
    if (!res && str) {
      res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    if (res) {
      charset = res.pop();
      if (charset === "gb2312" || charset === "gbk") {
        charset = "gb18030";
      }
    }
    return convert(buffer, "UTF-8", charset).toString();
  }
  function isURLSearchParams(obj) {
    if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
      return false;
    }
    return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
  }
  function clone(instance) {
    let p1, p2;
    let body = instance.body;
    if (instance.bodyUsed) {
      throw new Error("cannot clone body after it is used");
    }
    if (body instanceof Stream && typeof body.getBoundary !== "function") {
      p1 = new PassThrough();
      p2 = new PassThrough();
      body.pipe(p1);
      body.pipe(p2);
      instance[INTERNALS].body = p1;
      body = p2;
    }
    return body;
  }
  function extractContentType(instance) {
    const body = instance.body;
    if (body === null) {
      return null;
    } else if (typeof body === "string") {
      return "text/plain;charset=UTF-8";
    } else if (isURLSearchParams(body)) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (body instanceof Blob2) {
      return body.type || null;
    } else if (Buffer.isBuffer(body)) {
      return null;
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      return null;
    } else if (typeof body.getBoundary === "function") {
      return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else {
      return null;
    }
  }
  function getTotalBytes(instance) {
    const body = instance.body;
    if (body === null) {
      return 0;
    } else if (typeof body === "string") {
      return Buffer.byteLength(body);
    } else if (isURLSearchParams(body)) {
      return Buffer.byteLength(String(body));
    } else if (body instanceof Blob2) {
      return body.size;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      return body.byteLength;
    } else if (body && typeof body.getLengthSync === "function") {
      if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
        return body.getLengthSync();
      }
      return null;
    } else {
      return null;
    }
  }
  function writeToStream(dest, instance) {
    const body = instance.body;
    if (body === null) {
      dest.end();
    } else if (typeof body === "string") {
      dest.write(body);
      dest.end();
    } else if (isURLSearchParams(body)) {
      dest.write(Buffer.from(String(body)));
      dest.end();
    } else if (body instanceof Blob2) {
      dest.write(body[BUFFER]);
      dest.end();
    } else if (Buffer.isBuffer(body)) {
      dest.write(body);
      dest.end();
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      dest.write(Buffer.from(body));
      dest.end();
    } else {
      body.pipe(dest);
    }
  }
  Body.Promise = global.Promise;
  const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
  const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  function validateName(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name)) {
      throw new TypeError(`${name} is not a legal HTTP header name`);
    }
  }
  function validateValue(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
      throw new TypeError(`${value} is not a legal HTTP header value`);
    }
  }
  function find(map, name) {
    name = name.toLowerCase();
    for (const key in map) {
      if (key.toLowerCase() === name) {
        return key;
      }
    }
    return void 0;
  }
  const MAP = Symbol("map");
  class Headers {
    constructor() {
      let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      this[MAP] = Object.create(null);
      if (init instanceof Headers) {
        const rawHeaders = init.raw();
        const headerNames = Object.keys(rawHeaders);
        for (const headerName of headerNames) {
          for (const value of rawHeaders[headerName]) {
            this.append(headerName, value);
          }
        }
        return;
      }
      if (init == null) {
      } else if (typeof init === "object") {
        const method = init[Symbol.iterator];
        if (method != null) {
          if (typeof method !== "function") {
            throw new TypeError("Header pairs must be iterable");
          }
          const pairs = [];
          for (const pair of init) {
            if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
              throw new TypeError("Each header pair must be iterable");
            }
            pairs.push(Array.from(pair));
          }
          for (const pair of pairs) {
            if (pair.length !== 2) {
              throw new TypeError("Each header pair must be a name/value tuple");
            }
            this.append(pair[0], pair[1]);
          }
        } else {
          for (const key of Object.keys(init)) {
            const value = init[key];
            this.append(key, value);
          }
        }
      } else {
        throw new TypeError("Provided initializer must be an object");
      }
    }
    get(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key === void 0) {
        return null;
      }
      return this[MAP][key].join(", ");
    }
    forEach(callback) {
      let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
      let pairs = getHeaders(this);
      let i2 = 0;
      while (i2 < pairs.length) {
        var _pairs$i = pairs[i2];
        const name = _pairs$i[0], value = _pairs$i[1];
        callback.call(thisArg, value, name, this);
        pairs = getHeaders(this);
        i2++;
      }
    }
    set(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      this[MAP][key !== void 0 ? key : name] = [value];
    }
    append(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      if (key !== void 0) {
        this[MAP][key].push(value);
      } else {
        this[MAP][name] = [value];
      }
    }
    has(name) {
      name = `${name}`;
      validateName(name);
      return find(this[MAP], name) !== void 0;
    }
    delete(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key !== void 0) {
        delete this[MAP][key];
      }
    }
    raw() {
      return this[MAP];
    }
    keys() {
      return createHeadersIterator(this, "key");
    }
    values() {
      return createHeadersIterator(this, "value");
    }
    [Symbol.iterator]() {
      return createHeadersIterator(this, "key+value");
    }
  }
  Headers.prototype.entries = Headers.prototype[Symbol.iterator];
  Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
    value: "Headers",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Headers.prototype, {
    get: {enumerable: true},
    forEach: {enumerable: true},
    set: {enumerable: true},
    append: {enumerable: true},
    has: {enumerable: true},
    delete: {enumerable: true},
    keys: {enumerable: true},
    values: {enumerable: true},
    entries: {enumerable: true}
  });
  function getHeaders(headers) {
    let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
    const keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind === "key" ? function(k2) {
      return k2.toLowerCase();
    } : kind === "value" ? function(k2) {
      return headers[MAP][k2].join(", ");
    } : function(k2) {
      return [k2.toLowerCase(), headers[MAP][k2].join(", ")];
    });
  }
  const INTERNAL = Symbol("internal");
  function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
      target,
      kind,
      index: 0
    };
    return iterator;
  }
  const HeadersIteratorPrototype = Object.setPrototypeOf({
    next() {
      if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
        throw new TypeError("Value of `this` is not a HeadersIterator");
      }
      var _INTERNAL = this[INTERNAL];
      const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
      const values = getHeaders(target, kind);
      const len = values.length;
      if (index >= len) {
        return {
          value: void 0,
          done: true
        };
      }
      this[INTERNAL].index = index + 1;
      return {
        value: values[index],
        done: false
      };
    }
  }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
  Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: "HeadersIterator",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function exportNodeCompatibleHeaders(headers) {
    const obj = Object.assign({__proto__: null}, headers[MAP]);
    const hostHeaderKey = find(headers[MAP], "Host");
    if (hostHeaderKey !== void 0) {
      obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
  }
  function createHeadersLenient(obj) {
    const headers = new Headers();
    for (const name of Object.keys(obj)) {
      if (invalidTokenRegex.test(name)) {
        continue;
      }
      if (Array.isArray(obj[name])) {
        for (const val of obj[name]) {
          if (invalidHeaderCharRegex.test(val)) {
            continue;
          }
          if (headers[MAP][name] === void 0) {
            headers[MAP][name] = [val];
          } else {
            headers[MAP][name].push(val);
          }
        }
      } else if (!invalidHeaderCharRegex.test(obj[name])) {
        headers[MAP][name] = [obj[name]];
      }
    }
    return headers;
  }
  var _require$1 = require("http");
  const STATUS_CODES = _require$1.STATUS_CODES;
  const INTERNALS$1 = Symbol("Response internals");
  class Response {
    constructor() {
      let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      Body.call(this, body, opts);
      const status = opts.status || 200;
      this[INTERNALS$1] = {
        url: opts.url,
        status,
        statusText: opts.statusText || STATUS_CODES[status],
        headers: new Headers(opts.headers)
      };
    }
    get url() {
      return this[INTERNALS$1].url;
    }
    get status() {
      return this[INTERNALS$1].status;
    }
    get ok() {
      return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get statusText() {
      return this[INTERNALS$1].statusText;
    }
    get headers() {
      return this[INTERNALS$1].headers;
    }
    clone() {
      return new Response(clone(this), {
        url: this.url,
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        ok: this.ok
      });
    }
  }
  Body.mixIn(Response.prototype);
  Object.defineProperties(Response.prototype, {
    url: {enumerable: true},
    status: {enumerable: true},
    ok: {enumerable: true},
    statusText: {enumerable: true},
    headers: {enumerable: true},
    clone: {enumerable: true}
  });
  Object.defineProperty(Response.prototype, Symbol.toStringTag, {
    value: "Response",
    writable: false,
    enumerable: false,
    configurable: true
  });
  var _require$2 = require("url");
  const format_url = _require$2.format;
  const parse_url = _require$2.parse;
  const INTERNALS$2 = Symbol("Request internals");
  function isRequest(input) {
    return typeof input === "object" && typeof input[INTERNALS$2] === "object";
  }
  class Request {
    constructor(input) {
      let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let parsedURL;
      if (!isRequest(input)) {
        if (input && input.href) {
          parsedURL = parse_url(input.href);
        } else {
          parsedURL = parse_url(`${input}`);
        }
        input = {};
      } else {
        parsedURL = parse_url(input.url);
      }
      let method = init.method || input.method || "GET";
      method = method.toUpperCase();
      if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body");
      }
      let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
      Body.call(this, inputBody, {
        timeout: init.timeout || input.timeout || 0,
        size: init.size || input.size || 0
      });
      const headers = new Headers(init.headers || input.headers || {});
      if (init.body != null) {
        const contentType = extractContentType(this);
        if (contentType !== null && !headers.has("Content-Type")) {
          headers.append("Content-Type", contentType);
        }
      }
      this[INTERNALS$2] = {
        method,
        redirect: init.redirect || input.redirect || "follow",
        headers,
        parsedURL
      };
      this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
      this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
      this.counter = init.counter || input.counter || 0;
      this.agent = init.agent || input.agent;
    }
    get method() {
      return this[INTERNALS$2].method;
    }
    get url() {
      return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
      return this[INTERNALS$2].headers;
    }
    get redirect() {
      return this[INTERNALS$2].redirect;
    }
    clone() {
      return new Request(this);
    }
  }
  Body.mixIn(Request.prototype);
  Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: "Request",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Request.prototype, {
    method: {enumerable: true},
    url: {enumerable: true},
    headers: {enumerable: true},
    redirect: {enumerable: true},
    clone: {enumerable: true}
  });
  function getNodeRequestOptions(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers(request[INTERNALS$2].headers);
    if (!headers.has("Accept")) {
      headers.set("Accept", "*/*");
    }
    if (!parsedURL.protocol || !parsedURL.hostname) {
      throw new TypeError("Only absolute URLs are supported");
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
      throw new TypeError("Only HTTP(S) protocols are supported");
    }
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
      contentLengthValue = "0";
    }
    if (request.body != null) {
      const totalBytes = getTotalBytes(request);
      if (typeof totalBytes === "number") {
        contentLengthValue = String(totalBytes);
      }
    }
    if (contentLengthValue) {
      headers.set("Content-Length", contentLengthValue);
    }
    if (!headers.has("User-Agent")) {
      headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
    }
    if (request.compress) {
      headers.set("Accept-Encoding", "gzip,deflate");
    }
    if (!headers.has("Connection") && !request.agent) {
      headers.set("Connection", "close");
    }
    return Object.assign({}, parsedURL, {
      method: request.method,
      headers: exportNodeCompatibleHeaders(headers),
      agent: request.agent
    });
  }
  const http = require("http");
  const https = require("https");
  var _require$3 = require("stream");
  const PassThrough$1 = _require$3.PassThrough;
  var _require2 = require("url");
  const resolve_url = _require2.resolve;
  const zlib = require("zlib");
  function fetch2(url, opts) {
    if (!fetch2.Promise) {
      throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
    }
    Body.Promise = fetch2.Promise;
    return new fetch2.Promise(function(resolve, reject) {
      const request = new Request(url, opts);
      const options = getNodeRequestOptions(request);
      const send = (options.protocol === "https:" ? https : http).request;
      const req = send(options);
      let reqTimeout;
      function finalize() {
        req.abort();
        clearTimeout(reqTimeout);
      }
      if (request.timeout) {
        req.once("socket", function(socket) {
          reqTimeout = setTimeout(function() {
            reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
            finalize();
          }, request.timeout);
        });
      }
      req.on("error", function(err) {
        reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
        finalize();
      });
      req.on("response", function(res) {
        clearTimeout(reqTimeout);
        const headers = createHeadersLenient(res.headers);
        if (fetch2.isRedirect(res.statusCode)) {
          const location = headers.get("Location");
          const locationURL = location === null ? null : resolve_url(request.url, location);
          switch (request.redirect) {
            case "error":
              reject(new FetchError(`redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              if (locationURL !== null) {
                headers.set("Location", locationURL);
              }
              break;
            case "follow":
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOpts = {
                headers: new Headers(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: request.body
              };
              if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                requestOpts.method = "GET";
                requestOpts.body = void 0;
                requestOpts.headers.delete("content-length");
              }
              resolve(fetch2(new Request(locationURL, requestOpts)));
              finalize();
              return;
          }
        }
        let body = res.pipe(new PassThrough$1());
        const response_options = {
          url: request.url,
          status: res.statusCode,
          statusText: res.statusMessage,
          headers,
          size: request.size,
          timeout: request.timeout
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
          resolve(new Response(body, response_options));
          return;
        }
        const zlibOptions = {
          flush: zlib.Z_SYNC_FLUSH,
          finishFlush: zlib.Z_SYNC_FLUSH
        };
        if (codings == "gzip" || codings == "x-gzip") {
          body = body.pipe(zlib.createGunzip(zlibOptions));
          resolve(new Response(body, response_options));
          return;
        }
        if (codings == "deflate" || codings == "x-deflate") {
          const raw = res.pipe(new PassThrough$1());
          raw.once("data", function(chunk) {
            if ((chunk[0] & 15) === 8) {
              body = body.pipe(zlib.createInflate());
            } else {
              body = body.pipe(zlib.createInflateRaw());
            }
            resolve(new Response(body, response_options));
          });
          return;
        }
        resolve(new Response(body, response_options));
      });
      writeToStream(req, request);
    });
  }
  fetch2.isRedirect = function(code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
  };
  fetch2.default = fetch2;
  fetch2.Promise = global.Promise;
  const index_es_default = fetch2;
});

// node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js
const tf_core_esm_exports = {};
__export(tf_core_esm_exports, {
  AdadeltaOptimizer: () => Kf,
  AdagradOptimizer: () => jf,
  AdamOptimizer: () => Xf,
  AdamaxOptimizer: () => $f,
  DataStorage: () => so,
  ENV: () => i,
  Environment: () => o,
  KernelBackend: () => co,
  MomentumOptimizer: () => Qf,
  Optimizer: () => qf,
  RMSPropOptimizer: () => Jf,
  Rank: () => vt,
  Reduction: () => Xl,
  SGDOptimizer: () => Yf,
  Tensor: () => dt,
  TensorBuffer: () => lt,
  Variable: () => bt,
  abs: () => Vu,
  acos: () => zu,
  acosh: () => Gu,
  add: () => Vs,
  addN: () => zs,
  addStrict: () => Gs,
  all: () => ul,
  any: () => sl,
  argMax: () => cl,
  argMin: () => ll,
  asin: () => Hu,
  asinh: () => qu,
  atan: () => Ku,
  atan2: () => Hs,
  atanh: () => ju,
  avgPool: () => Qc,
  avgPool3d: () => tl,
  backend: () => on,
  backend_util: () => To,
  basicLSTMCell: () => Sl,
  batchNorm: () => Ns,
  batchNorm2d: () => Fs,
  batchNorm3d: () => Os,
  batchNorm4d: () => _s,
  batchNormalization: () => Ts,
  batchNormalization2d: () => Ss,
  batchNormalization3d: () => As,
  batchNormalization4d: () => Ds,
  batchToSpaceND: () => cr,
  booleanMaskAsync: () => Ic,
  browser: () => Ff,
  buffer: () => ur,
  cast: () => lr,
  ceil: () => Xu,
  clipByValue: () => $u,
  clone: () => hr,
  complex: () => En,
  concat: () => Gn,
  concat1d: () => Hn,
  concat2d: () => qn,
  concat3d: () => Kn,
  concat4d: () => jn,
  conv1d: () => Dc,
  conv2d: () => Tc,
  conv2dTranspose: () => Lc,
  conv3d: () => Nc,
  conv3dTranspose: () => Wc,
  cos: () => Yu,
  cosh: () => Qu,
  cumsum: () => fr,
  customGrad: () => oo,
  deprecationWarn: () => ze,
  depthToSpace: () => pr,
  depthwiseConv2d: () => _c,
  diag: () => Ul,
  disableDeprecationWarnings: () => Ve,
  dispose: () => Xe,
  disposeVariables: () => Ge,
  div: () => qs,
  divNoNan: () => Ks,
  divStrict: () => js,
  dot: () => Vc,
  dropout: () => Vl,
  elu: () => yl,
  enableDebugMode: () => Ue,
  enableProdMode: () => We,
  engine: () => He,
  env: () => a,
  equal: () => cc,
  equalStrict: () => lc,
  erf: () => Ju,
  exp: () => Zu,
  expandDims: () => dr,
  expm1: () => ts,
  eye: () => vr,
  fft: () => Ol,
  fill: () => Ln,
  findBackend: () => en,
  findBackendFactory: () => nn,
  floor: () => es,
  floorDiv: () => Xs,
  frame: () => ql,
  fused: () => Rh,
  gather: () => Ec,
  gatherND: () => Wl,
  getBackend: () => Ze,
  getKernel: () => s,
  getKernelsForBackend: () => c,
  grad: () => Zr,
  grads: () => to,
  greater: () => hc,
  greaterEqual: () => fc,
  greaterEqualStrict: () => pc,
  greaterStrict: () => dc,
  hammingWindow: () => Hl,
  hannWindow: () => Gl,
  ifft: () => _l,
  imag: () => In,
  image: () => mh,
  inTopKAsync: () => $l,
  io: () => Af,
  irfft: () => Bl,
  isFinite: () => ps,
  isInf: () => fs,
  isNaN: () => hs,
  keep: () => $e,
  leakyRelu: () => xl,
  less: () => vc,
  lessEqual: () => mc,
  lessEqualStrict: () => gc,
  lessStrict: () => yc,
  linalg: () => ch,
  linspace: () => Wn,
  localResponseNormalization: () => Il,
  log: () => ns,
  log1p: () => rs,
  logSigmoid: () => os,
  logSoftmax: () => uo,
  logSumExp: () => hl,
  logicalAnd: () => Ms,
  logicalNot: () => Bs,
  logicalOr: () => Ps,
  logicalXor: () => Ls,
  losses: () => ah,
  matMul: () => Uc,
  math: () => Tf,
  max: () => fl,
  maxPool: () => Yc,
  maxPool3d: () => Zc,
  maximum: () => $s,
  maximumStrict: () => Ys,
  mean: () => pl,
  memory: () => qe,
  min: () => dl,
  minimum: () => Qs,
  minimumStrict: () => Js,
  mod: () => Zs,
  modStrict: () => tc,
  moments: () => vl,
  movingAverage: () => Dl,
  mul: () => ec,
  mulStrict: () => nc,
  multiRNNCell: () => Al,
  multinomial: () => mr,
  neg: () => as,
  nextFrame: () => np,
  norm: () => kl,
  notEqual: () => xc,
  notEqualStrict: () => bc,
  oneHot: () => gr,
  ones: () => Bn,
  onesLike: () => Vn,
  op: () => Cn,
  outerProduct: () => zc,
  pad: () => yr,
  pad1d: () => xr,
  pad2d: () => br,
  pad3d: () => wr,
  pad4d: () => Cr,
  pool: () => Jc,
  pow: () => rc,
  powStrict: () => oc,
  prelu: () => bl,
  print: () => sr,
  prod: () => gl,
  profile: () => Ke,
  rand: () => Er,
  randomGamma: () => Ir,
  randomNormal: () => Rr,
  randomUniform: () => kr,
  range: () => Un,
  ready: () => Je,
  real: () => Rn,
  reciprocal: () => is,
  registerBackend: () => rn,
  registerKernel: () => l,
  relu: () => wl,
  relu6: () => Cl,
  removeBackend: () => tn,
  reshape: () => Sr,
  reverse: () => Gc,
  reverse1d: () => Hc,
  reverse2d: () => qc,
  reverse3d: () => Kc,
  reverse4d: () => jc,
  rfft: () => Ml,
  round: () => us,
  rsqrt: () => ss,
  scalar: () => An,
  scatterND: () => Fl,
  selu: () => El,
  separableConv2d: () => Pc,
  serialization: () => Bf,
  setBackend: () => Qe,
  setPlatform: () => an,
  setdiff1dAsync: () => _r,
  sigmoid: () => cs,
  sign: () => ls,
  signal: () => jl,
  sin: () => ds,
  sinh: () => vs,
  slice: () => el,
  slice1d: () => nl,
  slice2d: () => rl,
  slice3d: () => ol,
  slice4d: () => al,
  slice_util: () => Jr,
  softmax: () => io,
  softplus: () => ms,
  spaceToBatchND: () => Ar,
  sparseToDense: () => Ll,
  spectral: () => Pl,
  split: () => Xn,
  sqrt: () => gs,
  square: () => Uu,
  squaredDifference: () => ac,
  squaredDifferenceStrict: () => ic,
  squeeze: () => Dr,
  stack: () => Tr,
  step: () => ys,
  stft: () => Kl,
  stridedSlice: () => Tl,
  sub: () => uc,
  subStrict: () => sc,
  sum: () => ml,
  tan: () => xs,
  tanh: () => bs,
  tensor: () => kn,
  tensor1d: () => Dn,
  tensor2d: () => Tn,
  tensor3d: () => Nn,
  tensor4d: () => Fn,
  tensor5d: () => On,
  tensor6d: () => _n,
  tensor_util: () => At,
  test_util: () => zf,
  tidy: () => je,
  tile: () => Nr,
  time: () => Ye,
  topk: () => Nl,
  train: () => tp,
  transpose: () => Rl,
  truncatedNormal: () => Fr,
  unregisterKernel: () => h,
  unsortedSegmentSum: () => Rc,
  unstack: () => Or,
  util: () => tt,
  valueAndGrad: () => eo,
  valueAndGrads: () => no,
  variable: () => Mn,
  variableGrads: () => ro,
  version_core: () => Gf,
  webgl: () => Hf,
  where: () => Ws,
  whereAsync: () => Us,
  zeros: () => Pn,
  zerosLike: () => zn
});
var t = function(e2, n2) {
  return (t = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(t2, e3) {
    t2.__proto__ = e3;
  } || function(t2, e3) {
    for (var n3 in e3)
      e3.hasOwnProperty(n3) && (t2[n3] = e3[n3]);
  })(e2, n2);
};
function e(e2, n2) {
  function r2() {
    this.constructor = e2;
  }
  t(e2, n2), e2.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
}
function n(t2, e2, n2, r2) {
  return new (n2 || (n2 = Promise))(function(o2, a2) {
    function i2(t3) {
      try {
        s2(r2.next(t3));
      } catch (t4) {
        a2(t4);
      }
    }
    function u2(t3) {
      try {
        s2(r2.throw(t3));
      } catch (t4) {
        a2(t4);
      }
    }
    function s2(t3) {
      t3.done ? o2(t3.value) : new n2(function(e3) {
        e3(t3.value);
      }).then(i2, u2);
    }
    s2((r2 = r2.apply(t2, e2 || [])).next());
  });
}
function r(t2, e2) {
  var n2, r2, o2, a2, i2 = {label: 0, sent: function() {
    if (1 & o2[0])
      throw o2[1];
    return o2[1];
  }, trys: [], ops: []};
  return a2 = {next: u2(0), throw: u2(1), return: u2(2)}, "function" == typeof Symbol && (a2[Symbol.iterator] = function() {
    return this;
  }), a2;
  function u2(a3) {
    return function(u3) {
      return function(a4) {
        if (n2)
          throw new TypeError("Generator is already executing.");
        for (; i2; )
          try {
            if (n2 = 1, r2 && (o2 = 2 & a4[0] ? r2.return : a4[0] ? r2.throw || ((o2 = r2.return) && o2.call(r2), 0) : r2.next) && !(o2 = o2.call(r2, a4[1])).done)
              return o2;
            switch (r2 = 0, o2 && (a4 = [2 & a4[0], o2.value]), a4[0]) {
              case 0:
              case 1:
                o2 = a4;
                break;
              case 4:
                return i2.label++, {value: a4[1], done: false};
              case 5:
                i2.label++, r2 = a4[1], a4 = [0];
                continue;
              case 7:
                a4 = i2.ops.pop(), i2.trys.pop();
                continue;
              default:
                if (!(o2 = (o2 = i2.trys).length > 0 && o2[o2.length - 1]) && (6 === a4[0] || 2 === a4[0])) {
                  i2 = 0;
                  continue;
                }
                if (3 === a4[0] && (!o2 || a4[1] > o2[0] && a4[1] < o2[3])) {
                  i2.label = a4[1];
                  break;
                }
                if (6 === a4[0] && i2.label < o2[1]) {
                  i2.label = o2[1], o2 = a4;
                  break;
                }
                if (o2 && i2.label < o2[2]) {
                  i2.label = o2[2], i2.ops.push(a4);
                  break;
                }
                o2[2] && i2.ops.pop(), i2.trys.pop();
                continue;
            }
            a4 = e2.call(t2, i2);
          } catch (t3) {
            a4 = [6, t3], r2 = 0;
          } finally {
            n2 = o2 = 0;
          }
        if (5 & a4[0])
          throw a4[1];
        return {value: a4[0] ? a4[1] : void 0, done: true};
      }([a3, u3]);
    };
  }
}
var o = function() {
  function t2(t3) {
    this.global = t3, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.populateURLFlags();
  }
  return t2.prototype.setPlatform = function(t3, e2) {
    null != this.platform && console.warn("Platform " + this.platformName + " has already been set. Overwriting the platform with " + e2 + "."), this.platformName = t3, this.platform = e2;
  }, t2.prototype.registerFlag = function(t3, e2, n2) {
    if (this.flagRegistry[t3] = {evaluationFn: e2, setHook: n2}, null != this.urlFlags[t3]) {
      var r2 = this.urlFlags[t3];
      console.warn("Setting feature override from URL " + t3 + ": " + r2 + "."), this.set(t3, r2);
    }
  }, t2.prototype.get = function(t3) {
    return t3 in this.flags ? this.flags[t3] : (this.flags[t3] = this.evaluateFlag(t3), this.flags[t3]);
  }, t2.prototype.getNumber = function(t3) {
    return this.get(t3);
  }, t2.prototype.getBool = function(t3) {
    return this.get(t3);
  }, t2.prototype.getFlags = function() {
    return this.flags;
  }, Object.defineProperty(t2.prototype, "features", {get: function() {
    return this.flags;
  }, enumerable: true, configurable: true}), t2.prototype.set = function(t3, e2) {
    if (null == this.flagRegistry[t3])
      throw new Error("Cannot set flag " + t3 + " as it has not been registered.");
    this.flags[t3] = e2, null != this.flagRegistry[t3].setHook && this.flagRegistry[t3].setHook(e2);
  }, t2.prototype.evaluateFlag = function(t3) {
    if (null == this.flagRegistry[t3])
      throw new Error("Cannot evaluate flag '" + t3 + "': no evaluation function found.");
    return this.flagRegistry[t3].evaluationFn();
  }, t2.prototype.setFlags = function(t3) {
    this.flags = Object.assign({}, t3);
  }, t2.prototype.reset = function() {
    this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
  }, t2.prototype.populateURLFlags = function() {
    var t3 = this;
    if (void 0 !== this.global && void 0 !== this.global.location && void 0 !== this.global.location.search) {
      var e2, n2, r2 = (e2 = this.global.location.search, n2 = {}, e2.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function(t4) {
        for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
          e3[r3 - 1] = arguments[r3];
        return function(t5, e4, n3) {
          t5[decodeURIComponent(e4)] = decodeURIComponent(n3 || "");
        }(n2, e3[0], e3[1]), e3.join("=");
      }), n2);
      if ("tfjsflags" in r2)
        r2.tfjsflags.split(",").forEach(function(e3) {
          var n3 = e3.split(":"), r3 = n3[0], o2 = n3[1];
          t3.urlFlags[r3] = function(t4, e4) {
            if ("true" === (e4 = e4.toLowerCase()) || "false" === e4)
              return "true" === e4;
            if ("" + +e4 === e4)
              return +e4;
            throw new Error("Could not parse value flag value " + e4 + " for flag " + t4 + ".");
          }(r3, o2);
        });
    }
  }, t2;
}();
function a() {
  return i;
}
var i = null;
var u = new Map();
function s(t2, e2) {
  var n2 = f(t2, e2);
  return u.get(n2);
}
function c(t2) {
  for (var e2 = u.entries(), n2 = []; ; ) {
    var r2 = e2.next(), o2 = r2.done, a2 = r2.value;
    if (o2)
      break;
    var i2 = a2[0], s2 = a2[1];
    i2.split("_")[0] === t2 && n2.push(s2);
  }
  return n2;
}
function l(t2) {
  var e2 = t2.kernelName, n2 = t2.backendName, r2 = f(e2, n2);
  if (u.has(r2))
    throw new Error("The kernel '" + e2 + "' for backend '" + n2 + "' is already registered");
  u.set(r2, t2);
}
function h(t2, e2) {
  var n2 = f(t2, e2);
  if (!u.has(n2))
    throw new Error("The kernel '" + t2 + "' for backend '" + e2 + "' is not registered");
  u.delete(n2);
}
function f(t2, e2) {
  return e2 + "_" + t2;
}
function p(t2) {
  for (var e2 = t2.length, n2 = 0, r2 = 0; e2 > 0; )
    r2 = Math.random() * e2 | 0, n2 = t2[--e2], t2[e2] = t2[r2], t2[r2] = n2;
}
function d(t2, e2, n2) {
  return Math.max(t2, Math.min(e2, n2));
}
function v(t2) {
  return t2 % 2 == 0 ? t2 : t2 + 1;
}
function m(t2) {
  for (var e2 = 0, n2 = 0; n2 < t2.length; n2++)
    e2 += t2[n2];
  return e2;
}
function g(t2, e2) {
  if (!t2)
    throw new Error("string" == typeof e2 ? e2 : e2());
}
function y(t2, e2, n2) {
  void 0 === n2 && (n2 = ""), g(C(t2, e2), function() {
    return n2 + " Shapes " + t2 + " and " + e2 + " must match";
  });
}
function x(t2) {
  g(null != t2, function() {
    return "The input to the tensor constructor must be a non-null value.";
  });
}
function b(t2, e2, n2) {
  if (void 0 === e2 && (e2 = []), void 0 === n2 && (n2 = false), null == e2 && (e2 = []), Array.isArray(t2) || B(t2) && !n2)
    for (var r2 = 0; r2 < t2.length; ++r2)
      b(t2[r2], e2, n2);
  else
    e2.push(t2);
  return e2;
}
function w(t2) {
  if (0 === t2.length)
    return 1;
  for (var e2 = t2[0], n2 = 1; n2 < t2.length; n2++)
    e2 *= t2[n2];
  return e2;
}
function C(t2, e2) {
  if (t2 === e2)
    return true;
  if (null == t2 || null == e2)
    return false;
  if (t2.length !== e2.length)
    return false;
  for (var n2 = 0; n2 < t2.length; n2++)
    if (t2[n2] !== e2[n2])
      return false;
  return true;
}
function E(t2) {
  return t2 % 1 == 0;
}
function R(t2) {
  if (null != Math.tanh)
    return Math.tanh(t2);
  if (t2 === 1 / 0)
    return 1;
  if (t2 === -1 / 0)
    return -1;
  var e2 = Math.exp(2 * t2);
  return (e2 - 1) / (e2 + 1);
}
function I(t2) {
  var e2 = Math.ceil(Math.sqrt(t2));
  return [e2, Math.ceil(t2 / e2)];
}
function k(t2, e2) {
  return e2 <= t2.length ? t2 : t2 + " ".repeat(e2 - t2.length);
}
function S(t2, e2, n2) {
  return void 0 === e2 && (e2 = function(t3) {
    return 0;
  }), new Promise(function(r2, o2) {
    var a2 = 0, i2 = function() {
      if (t2())
        r2();
      else {
        var u2 = e2(++a2);
        null != n2 && a2 >= n2 ? o2() : setTimeout(i2, u2);
      }
    };
    i2();
  });
}
function A(t2, e2) {
  for (var n2 = 1, r2 = -1, o2 = 0; o2 < t2.length; ++o2)
    if (t2[o2] >= 0)
      n2 *= t2[o2];
    else if (-1 === t2[o2]) {
      if (-1 !== r2)
        throw Error("Shapes can only have 1 implicit size. Found -1 at dim " + r2 + " and dim " + o2);
      r2 = o2;
    } else if (t2[o2] < 0)
      throw Error("Shapes can not be < 0. Found " + t2[o2] + " at dim " + o2);
  if (-1 === r2) {
    if (e2 > 0 && e2 !== n2)
      throw Error("Size(" + e2 + ") must match the product of shape " + t2);
    return t2;
  }
  if (0 === n2)
    throw Error("Cannot infer the missing size in [" + t2 + "] when there are 0 elements");
  if (e2 % n2 != 0)
    throw Error("The implicit shape can't be a fractional number. Got " + e2 + " / " + n2);
  var a2 = t2.slice();
  return a2[r2] = e2 / n2, a2;
}
function D(t2, e2) {
  var n2 = e2.length;
  return g((t2 = null == t2 ? e2.map(function(t3, e3) {
    return e3;
  }) : [].concat(t2)).every(function(t3) {
    return t3 >= -n2 && t3 < n2;
  }), function() {
    return "All values in axis param must be in range [-" + n2 + ", " + n2 + ") but got axis " + t2;
  }), g(t2.every(function(t3) {
    return E(t3);
  }), function() {
    return "All values in axis param must be integers but got axis " + t2;
  }), t2.map(function(t3) {
    return t3 < 0 ? n2 + t3 : t3;
  });
}
function T(t2, e2) {
  for (var n2 = [], r2 = [], o2 = null != e2 && Array.isArray(e2) && 0 === e2.length, a2 = null == e2 || o2 ? null : D(e2, t2).sort(), i2 = 0, u2 = 0; u2 < t2.length; ++u2) {
    if (null != a2) {
      if (a2[i2] === u2 && 1 !== t2[u2])
        throw new Error("Can't squeeze axis " + u2 + " since its dim '" + t2[u2] + "' is not 1");
      (null == a2[i2] || a2[i2] > u2) && 1 === t2[u2] && (n2.push(t2[u2]), r2.push(u2)), a2[i2] <= u2 && i2++;
    }
    1 !== t2[u2] && (n2.push(t2[u2]), r2.push(u2));
  }
  return {newShape: n2, keptDims: r2};
}
function N(t2, e2) {
  var n2 = null;
  if (null == t2 || "float32" === t2)
    n2 = new Float32Array(e2);
  else if ("int32" === t2)
    n2 = new Int32Array(e2);
  else {
    if ("bool" !== t2)
      throw new Error("Unknown data type " + t2);
    n2 = new Uint8Array(e2);
  }
  return n2;
}
function F(t2, e2) {
  var n2 = null;
  if (null == t2 || "float32" === t2)
    n2 = new Float32Array(e2);
  else if ("int32" === t2)
    n2 = new Int32Array(e2);
  else if ("bool" === t2)
    n2 = new Uint8Array(e2);
  else {
    if ("string" !== t2)
      throw new Error("Unknown data type " + t2);
    n2 = new Array(e2);
  }
  return n2;
}
function O(t2, e2) {
  for (var n2 = 0; n2 < t2.length; n2++) {
    var r2 = t2[n2];
    if (isNaN(r2) || !isFinite(r2))
      throw Error("A tensor of type " + e2 + " being uploaded contains " + r2 + ".");
  }
}
function _(t2) {
  return "bool" === t2 || "complex64" === t2 || "float32" === t2 || "int32" === t2 || "string" === t2;
}
function M(t2, e2) {
  return "complex64" !== e2 && (("float32" !== e2 || "complex64" === t2) && (("int32" !== e2 || "float32" === t2 || "complex64" === t2) && ("bool" !== e2 || "bool" !== t2)));
}
function B(t2) {
  return t2 instanceof Float32Array || t2 instanceof Int32Array || t2 instanceof Uint8Array;
}
function P(t2) {
  if ("float32" === t2 || "int32" === t2)
    return 4;
  if ("complex64" === t2)
    return 8;
  if ("bool" === t2)
    return 1;
  throw new Error("Unknown dtype " + t2);
}
function L(t2) {
  if (null == t2)
    return 0;
  var e2 = 0;
  return t2.forEach(function(t3) {
    return e2 += t3.length;
  }), e2;
}
function W(t2) {
  return "string" == typeof t2 || t2 instanceof String;
}
function U(t2) {
  return "boolean" == typeof t2;
}
function V(t2) {
  return "number" == typeof t2;
}
function z(t2) {
  return Array.isArray(t2) ? z(t2[0]) : t2 instanceof Float32Array ? "float32" : t2 instanceof Int32Array || t2 instanceof Uint8Array ? "int32" : V(t2) ? "float32" : W(t2) ? "string" : U(t2) ? "bool" : "float32";
}
function G(t2) {
  return !!(t2 && t2.constructor && t2.call && t2.apply);
}
function H(t2, e2) {
  for (var n2 = e2; n2 < t2; ++n2)
    if (t2 % n2 == 0)
      return n2;
  return t2;
}
function q(t2) {
  var e2 = t2.length;
  if (e2 < 2)
    return [];
  var n2 = new Array(e2 - 1);
  n2[e2 - 2] = t2[e2 - 1];
  for (var r2 = e2 - 3; r2 >= 0; --r2)
    n2[r2] = n2[r2 + 1] * t2[r2 + 1];
  return n2;
}
function K(t2, e2, n2) {
  if ("string" === e2)
    throw new Error("Cannot convert a string[] to a TypedArray");
  if (Array.isArray(t2) && (t2 = b(t2)), n2 && O(t2, e2), function(t3, e3) {
    return t3 instanceof Float32Array && "float32" === e3 || t3 instanceof Int32Array && "int32" === e3 || t3 instanceof Uint8Array && "bool" === e3;
  }(t2, e2))
    return t2;
  if (null == e2 || "float32" === e2 || "complex64" === e2)
    return new Float32Array(t2);
  if ("int32" === e2)
    return new Int32Array(t2);
  if ("bool" === e2) {
    for (var r2 = new Uint8Array(t2.length), o2 = 0; o2 < r2.length; ++o2)
      0 !== Math.round(t2[o2]) && (r2[o2] = 1);
    return r2;
  }
  throw new Error("Unknown data type " + e2);
}
function j(t2, e2) {
  if (0 === t2.length)
    return e2[0];
  var n2 = t2.reduce(function(t3, e3) {
    return t3 * e3;
  });
  if (0 === n2)
    return [];
  if (n2 !== e2.length)
    throw new Error("[" + t2 + "] does not match the input size.");
  return function t3(e3, n3, r2) {
    var o2 = new Array();
    if (1 === n3.length)
      for (var a2 = n3[0], i2 = 0; i2 < a2; i2++)
        o2[i2] = r2[e3 + i2];
    else {
      a2 = n3[0];
      var u2 = n3.slice(1), s2 = u2.reduce(function(t4, e4) {
        return t4 * e4;
      });
      for (i2 = 0; i2 < a2; i2++)
        o2[i2] = t3(e3 + i2 * s2, u2, r2);
    }
    return o2;
  }(0, t2, e2);
}
function X(t2, e2) {
  for (var n2 = $(t2, e2), r2 = 0; r2 < n2.length; r2++)
    n2[r2] = 1;
  return n2;
}
function $(t2, e2) {
  if (null == e2 || "float32" === e2 || "complex64" === e2)
    return new Float32Array(t2);
  if ("int32" === e2)
    return new Int32Array(t2);
  if ("bool" === e2)
    return new Uint8Array(t2);
  throw new Error("Unknown data type " + e2);
}
function Y() {
  return a().platform.now();
}
function Q(t2) {
  t2.forEach(function(e2) {
    g(Number.isInteger(e2) && e2 >= 0, function() {
      return "Tensor must have a shape comprised of positive integers but got shape [" + t2 + "].";
    });
  });
}
function J(t2, e2) {
  return void 0 === e2 && (e2 = "utf-8"), e2 = e2 || "utf-8", a().platform.encode(t2, e2);
}
function Z(t2, e2) {
  return void 0 === e2 && (e2 = "utf-8"), e2 = e2 || "utf-8", a().platform.decode(t2, e2);
}
var tt = Object.freeze({shuffle: p, clamp: d, nearestLargerEven: v, sum: m, randUniform: function(t2, e2) {
  var n2 = Math.random();
  return e2 * n2 + (1 - n2) * t2;
}, distSquared: function(t2, e2) {
  for (var n2 = 0, r2 = 0; r2 < t2.length; r2++) {
    var o2 = Number(t2[r2]) - Number(e2[r2]);
    n2 += o2 * o2;
  }
  return n2;
}, assert: g, assertShapesMatch: y, assertNonNull: x, flatten: b, sizeFromShape: w, isScalarShape: function(t2) {
  return 0 === t2.length;
}, arraysEqual: C, isInt: E, tanh: R, sizeToSquarishShape: I, createShuffledIndices: function(t2) {
  for (var e2 = new Uint32Array(t2), n2 = 0; n2 < t2; ++n2)
    e2[n2] = n2;
  return p(e2), e2;
}, rightPad: k, repeatedTry: S, inferFromImplicitShape: A, parseAxisParam: D, squeezeShape: T, getTypedArrayFromDType: N, getArrayFromDType: F, checkConversionForErrors: O, isValidDtype: _, hasEncodingLoss: M, isTypedArray: B, bytesPerElement: P, bytesFromStringArray: L, isString: W, isBoolean: U, isNumber: V, inferDtype: z, isFunction: G, nearestDivisor: H, computeStrides: q, toTypedArray: K, toNestedArray: j, makeOnesTypedArray: X, makeZerosTypedArray: $, now: Y, assertNonNegativeIntegerDimensions: Q, fetch: function(t2, e2) {
  return a().platform.fetch(t2, e2);
}, encodeString: J, decodeString: Z});
var et = function() {
  function t2(t3, e2) {
    this.backendTimer = t3, this.logger = e2, null == e2 && (this.logger = new nt());
  }
  return t2.prototype.profileKernel = function(t3, e2, n2) {
    var r2, o2 = this, a2 = this.backendTimer.time(function() {
      r2 = n2();
    });
    return r2.forEach(function(n3) {
      n3.data().then(function(r3) {
        !function(t4, e3, n4) {
          if ("float32" !== e3)
            return false;
          for (var r4 = 0; r4 < t4.length; r4++) {
            var o3 = t4[r4];
            if (isNaN(o3) || !isFinite(o3))
              return console.warn("Found " + o3 + " in the result of '" + n4 + "'"), true;
          }
        }(r3, n3.dtype, t3), a2.then(function(a3) {
          var i2 = "";
          null != a3.getExtraProfileInfo && (i2 = a3.getExtraProfileInfo()), o2.logger.logKernelProfile(t3, n3, r3, a3.kernelMs, e2, i2);
        });
      });
    }), r2;
  }, t2;
}();
var nt = function() {
  function t2() {
  }
  return t2.prototype.logKernelProfile = function(t3, e2, n2, r2, o2, a2) {
    var i2 = k(r2 + "ms", 9), u2 = k(t3, 25), s2 = e2.rank, c2 = e2.size, l2 = k(e2.shape.toString(), 14), h2 = "";
    for (var f2 in o2) {
      var p2 = o2[f2].shape, d2 = p2.length;
      h2 += f2 + ": " + d2 + "D " + (d2 > 0 ? p2 : "") + " ";
    }
    console.log("%c" + u2 + "	%c" + i2 + "	%c" + s2 + "D " + l2 + "	%c" + c2 + "	%c" + h2 + "	%c" + a2, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
  }, t2;
}();
var rt = 20;
var ot = 3;
var at = 7;
function it(t2, e2, n2, r2) {
  var o2 = q(e2), a2 = function(t3, e3, n3, r3) {
    var o3 = w(e3), a3 = r3[r3.length - 1], i3 = new Array(a3).fill(0), u3 = e3.length, s3 = "complex64" === n3 ? ct(t3) : t3;
    if (u3 > 1)
      for (var c2 = 0; c2 < o3 / a3; c2++)
        for (var l2 = c2 * a3, h2 = 0; h2 < a3; h2++)
          i3[h2] = Math.max(i3[h2], ut(s3[l2 + h2], 0, n3).length);
    return i3;
  }(t2, e2, n2, o2), i2 = e2.length, u2 = function t3(e3, n3, r3, o3, a3, i3) {
    void 0 === i3 && (i3 = true);
    var u3 = "complex64" === r3 ? 2 : 1;
    var s3 = n3[0];
    var c2 = n3.length;
    if (0 === c2) {
      if ("complex64" === r3) {
        var l2 = ct(e3);
        return [ut(l2[0], 0, r3)];
      }
      return "bool" === r3 ? [st(e3[0])] : [e3[0].toString()];
    }
    if (1 === c2) {
      if (s3 > rt) {
        var h2 = ot * u3, f2 = Array.from(e3.slice(0, h2)), p2 = Array.from(e3.slice((s3 - ot) * u3, s3 * u3));
        return "complex64" === r3 && (f2 = ct(f2), p2 = ct(p2)), ["[" + f2.map(function(t4, e4) {
          return ut(t4, a3[e4], r3);
        }).join(", ") + ", ..., " + p2.map(function(t4, e4) {
          return ut(t4, a3[s3 - ot + e4], r3);
        }).join(", ") + "]"];
      }
      var d2 = "complex64" === r3 ? ct(e3) : Array.from(e3);
      return ["[" + d2.map(function(t4, e4) {
        return ut(t4, a3[e4], r3);
      }).join(", ") + "]"];
    }
    var v2 = n3.slice(1);
    var m2 = o3.slice(1);
    var g2 = o3[0] * u3;
    var y2 = [];
    if (s3 > rt) {
      for (var x2 = 0; x2 < ot; x2++) {
        var b2 = x2 * g2, w2 = b2 + g2;
        y2.push.apply(y2, t3(e3.slice(b2, w2), v2, r3, m2, a3, false));
      }
      y2.push("...");
      for (var x2 = s3 - ot; x2 < s3; x2++) {
        var b2 = x2 * g2, w2 = b2 + g2;
        y2.push.apply(y2, t3(e3.slice(b2, w2), v2, r3, m2, a3, x2 === s3 - 1));
      }
    } else
      for (var x2 = 0; x2 < s3; x2++) {
        var b2 = x2 * g2, w2 = b2 + g2;
        y2.push.apply(y2, t3(e3.slice(b2, w2), v2, r3, m2, a3, x2 === s3 - 1));
      }
    var C2 = 2 === c2 ? "," : "";
    y2[0] = "[" + y2[0] + C2;
    for (var x2 = 1; x2 < y2.length - 1; x2++)
      y2[x2] = " " + y2[x2] + C2;
    var E2 = ",\n";
    for (var x2 = 2; x2 < c2; x2++)
      E2 += "\n";
    y2[y2.length - 1] = " " + y2[y2.length - 1] + "]" + (i3 ? "" : E2);
    return y2;
  }(t2, e2, n2, o2, a2), s2 = ["Tensor"];
  return r2 && (s2.push("  dtype: " + n2), s2.push("  rank: " + i2), s2.push("  shape: [" + e2 + "]"), s2.push("  values:")), s2.push(u2.map(function(t3) {
    return "    " + t3;
  }).join("\n")), s2.join("\n");
}
function ut(t2, e2, n2) {
  return k(Array.isArray(t2) ? parseFloat(t2[0].toFixed(at)) + " + " + parseFloat(t2[1].toFixed(at)) + "j" : W(t2) ? "'" + t2 + "'" : "bool" === n2 ? st(t2) : parseFloat(t2.toFixed(at)).toString(), e2);
}
function st(t2) {
  return 0 === t2 ? "false" : "true";
}
function ct(t2) {
  for (var e2 = [], n2 = 0; n2 < t2.length; n2 += 2)
    e2.push([t2[n2], t2[n2 + 1]]);
  return e2;
}
var lt = function() {
  function t2(t3, e2, n2) {
    var r2 = this;
    if (this.dtype = e2, this.shape = t3.slice(), this.size = w(t3), null != n2) {
      var o2 = n2.length;
      g(o2 === this.size, function() {
        return "Length of values '" + o2 + "' does not match the size inferred by the shape '" + r2.size + "'.";
      });
    }
    if ("complex64" === e2)
      throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
    this.values = n2 || F(e2, this.size), this.strides = q(t3);
  }
  return t2.prototype.set = function(t3) {
    for (var e2 = this, n2 = [], r2 = 1; r2 < arguments.length; r2++)
      n2[r2 - 1] = arguments[r2];
    0 === n2.length && (n2 = [0]), g(n2.length === this.rank, function() {
      return "The number of provided coordinates (" + n2.length + ") must match the rank (" + e2.rank + ")";
    });
    var o2 = this.locToIndex(n2);
    this.values[o2] = t3;
  }, t2.prototype.get = function() {
    for (var t3 = [], e2 = 0; e2 < arguments.length; e2++)
      t3[e2] = arguments[e2];
    0 === t3.length && (t3 = [0]);
    for (var n2 = 0, r2 = 0, o2 = t3; r2 < o2.length; r2++) {
      var a2 = o2[r2];
      if (a2 < 0 || a2 >= this.shape[n2]) {
        var i2 = "Requested out of range element at " + t3 + ".   Buffer shape=" + this.shape;
        throw new Error(i2);
      }
      n2++;
    }
    for (var u2 = t3[t3.length - 1], s2 = 0; s2 < t3.length - 1; ++s2)
      u2 += this.strides[s2] * t3[s2];
    return this.values[u2];
  }, t2.prototype.locToIndex = function(t3) {
    if (0 === this.rank)
      return 0;
    if (1 === this.rank)
      return t3[0];
    for (var e2 = t3[t3.length - 1], n2 = 0; n2 < t3.length - 1; ++n2)
      e2 += this.strides[n2] * t3[n2];
    return e2;
  }, t2.prototype.indexToLoc = function(t3) {
    if (0 === this.rank)
      return [];
    if (1 === this.rank)
      return [t3];
    for (var e2 = new Array(this.shape.length), n2 = 0; n2 < e2.length - 1; ++n2)
      e2[n2] = Math.floor(t3 / this.strides[n2]), t3 -= e2[n2] * this.strides[n2];
    return e2[e2.length - 1] = t3, e2;
  }, Object.defineProperty(t2.prototype, "rank", {get: function() {
    return this.shape.length;
  }, enumerable: true, configurable: true}), t2.prototype.toTensor = function() {
    return ht().makeTensor(this.values, this.shape, this.dtype);
  }, t2;
}();
var ht = null;
var ft = null;
var pt = null;
var dt = function() {
  function t2(t3, e2, n2, r2) {
    this.kept = false, this.isDisposedInternal = false, this.shape = t3.slice(), this.dtype = e2 || "float32", this.size = w(t3), this.strides = q(t3), this.dataId = n2, this.id = r2, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
  }
  return t2.prototype.flatten = function() {
    return this.throwIfDisposed(), this.as1D();
  }, t2.prototype.asScalar = function() {
    return this.throwIfDisposed(), g(1 === this.size, function() {
      return "The array must have only 1 element.";
    }), this.reshape([]);
  }, t2.prototype.as1D = function() {
    return this.throwIfDisposed(), this.reshape([this.size]);
  }, t2.prototype.as2D = function(t3, e2) {
    return this.throwIfDisposed(), this.reshape([t3, e2]);
  }, t2.prototype.as3D = function(t3, e2, n2) {
    return this.throwIfDisposed(), this.reshape([t3, e2, n2]);
  }, t2.prototype.as4D = function(t3, e2, n2, r2) {
    return this.throwIfDisposed(), this.reshape([t3, e2, n2, r2]);
  }, t2.prototype.as5D = function(t3, e2, n2, r2, o2) {
    return this.throwIfDisposed(), this.reshape([t3, e2, n2, r2, o2]);
  }, t2.prototype.asType = function(t3) {
    return this.throwIfDisposed(), ft.cast(this, t3);
  }, Object.defineProperty(t2.prototype, "rank", {get: function() {
    return this.shape.length;
  }, enumerable: true, configurable: true}), t2.prototype.buffer = function() {
    return n(this, void 0, void 0, function() {
      var t3;
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return [4, this.data()];
          case 1:
            return t3 = e2.sent(), [2, ft.buffer(this.shape, this.dtype, t3)];
        }
      });
    });
  }, t2.prototype.bufferSync = function() {
    return ft.buffer(this.shape, this.dtype, this.dataSync());
  }, t2.prototype.array = function() {
    return n(this, void 0, void 0, function() {
      var t3;
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return [4, this.data()];
          case 1:
            return t3 = e2.sent(), [2, j(this.shape, t3)];
        }
      });
    });
  }, t2.prototype.arraySync = function() {
    return j(this.shape, this.dataSync());
  }, t2.prototype.data = function() {
    return n(this, void 0, void 0, function() {
      var t3, e2;
      return r(this, function(n2) {
        switch (n2.label) {
          case 0:
            return this.throwIfDisposed(), t3 = ht().read(this.dataId), "string" !== this.dtype ? [3, 2] : [4, t3];
          case 1:
            e2 = n2.sent();
            try {
              return [2, e2.map(function(t4) {
                return Z(t4);
              })];
            } catch (t4) {
              throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
            }
            n2.label = 2;
          case 2:
            return [2, t3];
        }
      });
    });
  }, t2.prototype.dataSync = function() {
    this.throwIfDisposed();
    var t3 = ht().readSync(this.dataId);
    if ("string" === this.dtype)
      try {
        return t3.map(function(t4) {
          return Z(t4);
        });
      } catch (t4) {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
    return t3;
  }, t2.prototype.bytes = function() {
    return n(this, void 0, void 0, function() {
      var t3;
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return this.throwIfDisposed(), [4, ht().read(this.dataId)];
          case 1:
            return t3 = e2.sent(), "string" === this.dtype ? [2, t3] : [2, new Uint8Array(t3.buffer)];
        }
      });
    });
  }, t2.prototype.dispose = function() {
    this.isDisposed || (ht().disposeTensor(this), this.isDisposedInternal = true);
  }, Object.defineProperty(t2.prototype, "isDisposed", {get: function() {
    return this.isDisposedInternal;
  }, enumerable: true, configurable: true}), t2.prototype.throwIfDisposed = function() {
    if (this.isDisposed)
      throw new Error("Tensor is disposed.");
  }, t2.prototype.toFloat = function() {
    return this.asType("float32");
  }, t2.prototype.toInt = function() {
    return this.asType("int32");
  }, t2.prototype.toBool = function() {
    return this.asType("bool");
  }, t2.prototype.print = function(t3) {
    return void 0 === t3 && (t3 = false), ft.print(this, t3);
  }, t2.prototype.reshape = function(t3) {
    return this.throwIfDisposed(), ft.reshape(this, t3);
  }, t2.prototype.reshapeAs = function(t3) {
    return this.throwIfDisposed(), this.reshape(t3.shape);
  }, t2.prototype.expandDims = function(t3) {
    return void 0 === t3 && (t3 = 0), ft.expandDims(this, t3);
  }, t2.prototype.cumsum = function(t3, e2, n2) {
    return void 0 === t3 && (t3 = 0), void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = false), ft.cumsum(this, t3, e2, n2);
  }, t2.prototype.squeeze = function(t3) {
    return this.throwIfDisposed(), ft.squeeze(this, t3);
  }, t2.prototype.clone = function() {
    return this.throwIfDisposed(), ft.clone(this);
  }, t2.prototype.oneHot = function(t3, e2, n2) {
    return this.throwIfDisposed(), ft.oneHot(this, t3, e2, n2);
  }, t2.prototype.toString = function(t3) {
    return void 0 === t3 && (t3 = false), it(this.dataSync(), this.shape, this.dtype, t3);
  }, t2.prototype.tile = function(t3) {
    return this.throwIfDisposed(), ft.tile(this, t3);
  }, t2.prototype.gather = function(t3, e2) {
    return void 0 === e2 && (e2 = 0), this.throwIfDisposed(), ft.gather(this, t3, e2);
  }, t2.prototype.matMul = function(t3, e2, n2) {
    return void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = false), this.throwIfDisposed(), ft.matMul(this, t3, e2, n2);
  }, t2.prototype.dot = function(t3) {
    return this.throwIfDisposed(), ft.dot(this, t3);
  }, t2.prototype.norm = function(t3, e2, n2) {
    return void 0 === t3 && (t3 = "euclidean"), void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false), this.throwIfDisposed(), ft.norm(this, t3, e2, n2);
  }, t2.prototype.slice = function(t3, e2) {
    return this.throwIfDisposed(), ft.slice(this, t3, e2);
  }, t2.prototype.reverse = function(t3) {
    return this.throwIfDisposed(), ft.reverse(this, t3);
  }, t2.prototype.concat = function(e2, n2) {
    return void 0 === n2 && (n2 = 0), this.throwIfDisposed(), e2 instanceof t2 && (e2 = [e2]), ft.concat([this].concat(e2), n2);
  }, t2.prototype.split = function(t3, e2) {
    return void 0 === e2 && (e2 = 0), this.throwIfDisposed(), ft.split(this, t3, e2);
  }, t2.prototype.stack = function(t3, e2) {
    return void 0 === e2 && (e2 = 0), ft.stack([this, t3], e2);
  }, t2.prototype.unstack = function(t3) {
    return void 0 === t3 && (t3 = 0), ft.unstack(this, t3);
  }, t2.prototype.pad = function(t3, e2) {
    return void 0 === e2 && (e2 = 0), ft.pad(this, t3, e2);
  }, t2.prototype.batchNormalization = function(t3, e2, n2, r2, o2) {
    return void 0 === n2 && (n2 = 1e-3), pt("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"), this.batchNorm(t3, e2, o2, r2, n2);
  }, t2.prototype.batchNorm = function(t3, e2, n2, r2, o2) {
    return void 0 === o2 && (o2 = 1e-3), this.throwIfDisposed(), ft.batchNorm(this, t3, e2, n2, r2, o2);
  }, t2.prototype.all = function(t3, e2) {
    return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.all(this, t3, e2);
  }, t2.prototype.any = function(t3, e2) {
    return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.any(this, t3, e2);
  }, t2.prototype.logSumExp = function(t3, e2) {
    return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.logSumExp(this, t3, e2);
  }, t2.prototype.sum = function(t3, e2) {
    return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.sum(this, t3, e2);
  }, t2.prototype.prod = function(t3, e2) {
    return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.prod(this, t3, e2);
  }, t2.prototype.mean = function(t3, e2) {
    return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.mean(this, t3, e2);
  }, t2.prototype.min = function(t3, e2) {
    return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.min(this, t3, e2);
  }, t2.prototype.max = function(t3, e2) {
    return void 0 === t3 && (t3 = null), void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.max(this, t3, e2);
  }, t2.prototype.argMin = function(t3) {
    return void 0 === t3 && (t3 = null), this.throwIfDisposed(), ft.argMin(this, t3);
  }, t2.prototype.argMax = function(t3) {
    return void 0 === t3 && (t3 = null), this.throwIfDisposed(), ft.argMax(this, t3);
  }, t2.prototype.cast = function(t3) {
    return this.throwIfDisposed(), ft.cast(this, t3);
  }, t2.prototype.add = function(t3) {
    return this.throwIfDisposed(), ft.add(this, t3);
  }, t2.prototype.addStrict = function(t3) {
    return this.throwIfDisposed(), ft.addStrict(this, t3);
  }, t2.prototype.atan2 = function(t3) {
    return this.throwIfDisposed(), ft.atan2(this, t3);
  }, t2.prototype.sub = function(t3) {
    return this.throwIfDisposed(), ft.sub(this, t3);
  }, t2.prototype.subStrict = function(t3) {
    return this.throwIfDisposed(), ft.subStrict(this, t3);
  }, t2.prototype.pow = function(t3) {
    return this.throwIfDisposed(), ft.pow(this, t3);
  }, t2.prototype.powStrict = function(t3) {
    return this.throwIfDisposed(), ft.powStrict(this, t3);
  }, t2.prototype.mul = function(t3) {
    return this.throwIfDisposed(), ft.mul(this, t3);
  }, t2.prototype.mulStrict = function(t3) {
    return this.throwIfDisposed(), ft.mulStrict(this, t3);
  }, t2.prototype.div = function(t3) {
    return this.throwIfDisposed(), ft.div(this, t3);
  }, t2.prototype.divNoNan = function(t3) {
    return this.throwIfDisposed(), ft.divNoNan(this, t3);
  }, t2.prototype.floorDiv = function(t3) {
    return this.throwIfDisposed(), ft.floorDiv(this, t3);
  }, t2.prototype.divStrict = function(t3) {
    return this.throwIfDisposed(), ft.divStrict(this, t3);
  }, t2.prototype.minimum = function(t3) {
    return this.throwIfDisposed(), ft.minimum(this, t3);
  }, t2.prototype.minimumStrict = function(t3) {
    return this.throwIfDisposed(), ft.minimumStrict(this, t3);
  }, t2.prototype.maximum = function(t3) {
    return this.throwIfDisposed(), ft.maximum(this, t3);
  }, t2.prototype.maximumStrict = function(t3) {
    return this.throwIfDisposed(), ft.maximumStrict(this, t3);
  }, t2.prototype.mod = function(t3) {
    return this.throwIfDisposed(), ft.mod(this, t3);
  }, t2.prototype.modStrict = function(t3) {
    return this.throwIfDisposed(), ft.modStrict(this, t3);
  }, t2.prototype.squaredDifference = function(t3) {
    return this.throwIfDisposed(), ft.squaredDifference(this, t3);
  }, t2.prototype.squaredDifferenceStrict = function(t3) {
    return this.throwIfDisposed(), ft.squaredDifferenceStrict(this, t3);
  }, t2.prototype.transpose = function(t3) {
    return this.throwIfDisposed(), ft.transpose(this, t3);
  }, t2.prototype.notEqual = function(t3) {
    return this.throwIfDisposed(), ft.notEqual(this, t3);
  }, t2.prototype.notEqualStrict = function(t3) {
    return this.throwIfDisposed(), ft.notEqualStrict(this, t3);
  }, t2.prototype.less = function(t3) {
    return this.throwIfDisposed(), ft.less(this, t3);
  }, t2.prototype.lessStrict = function(t3) {
    return this.throwIfDisposed(), ft.lessStrict(this, t3);
  }, t2.prototype.equal = function(t3) {
    return this.throwIfDisposed(), ft.equal(this, t3);
  }, t2.prototype.equalStrict = function(t3) {
    return this.throwIfDisposed(), ft.equalStrict(this, t3);
  }, t2.prototype.lessEqual = function(t3) {
    return this.throwIfDisposed(), ft.lessEqual(this, t3);
  }, t2.prototype.lessEqualStrict = function(t3) {
    return this.throwIfDisposed(), ft.lessEqualStrict(this, t3);
  }, t2.prototype.greater = function(t3) {
    return this.throwIfDisposed(), ft.greater(this, t3);
  }, t2.prototype.greaterStrict = function(t3) {
    return this.throwIfDisposed(), ft.greaterStrict(this, t3);
  }, t2.prototype.greaterEqual = function(t3) {
    return this.throwIfDisposed(), ft.greaterEqual(this, t3);
  }, t2.prototype.greaterEqualStrict = function(t3) {
    return this.throwIfDisposed(), ft.greaterEqualStrict(this, t3);
  }, t2.prototype.logicalAnd = function(t3) {
    return this.throwIfDisposed(), ft.logicalAnd(this, t3);
  }, t2.prototype.logicalOr = function(t3) {
    return this.throwIfDisposed(), ft.logicalOr(this, t3);
  }, t2.prototype.logicalNot = function() {
    return this.throwIfDisposed(), ft.logicalNot(this);
  }, t2.prototype.logicalXor = function(t3) {
    return this.throwIfDisposed(), ft.logicalXor(this, t3);
  }, t2.prototype.where = function(t3, e2) {
    return this.throwIfDisposed(), ft.where(t3, this, e2);
  }, t2.prototype.neg = function() {
    return this.throwIfDisposed(), ft.neg(this);
  }, t2.prototype.ceil = function() {
    return this.throwIfDisposed(), ft.ceil(this);
  }, t2.prototype.floor = function() {
    return this.throwIfDisposed(), ft.floor(this);
  }, t2.prototype.sign = function() {
    return this.throwIfDisposed(), ft.sign(this);
  }, t2.prototype.isNaN = function() {
    return this.throwIfDisposed(), ft.isNaN(this);
  }, t2.prototype.isInf = function() {
    return this.throwIfDisposed(), ft.isInf(this);
  }, t2.prototype.isFinite = function() {
    return this.throwIfDisposed(), ft.isFinite(this);
  }, t2.prototype.exp = function() {
    return this.throwIfDisposed(), ft.exp(this);
  }, t2.prototype.expm1 = function() {
    return this.throwIfDisposed(), ft.expm1(this);
  }, t2.prototype.log = function() {
    return this.throwIfDisposed(), ft.log(this);
  }, t2.prototype.log1p = function() {
    return this.throwIfDisposed(), ft.log1p(this);
  }, t2.prototype.sqrt = function() {
    return this.throwIfDisposed(), ft.sqrt(this);
  }, t2.prototype.rsqrt = function() {
    return this.throwIfDisposed(), ft.rsqrt(this);
  }, t2.prototype.square = function() {
    return this.throwIfDisposed(), ft.square(this);
  }, t2.prototype.reciprocal = function() {
    return this.throwIfDisposed(), ft.reciprocal(this);
  }, t2.prototype.abs = function() {
    return this.throwIfDisposed(), ft.abs(this);
  }, t2.prototype.clipByValue = function(t3, e2) {
    return this.throwIfDisposed(), ft.clipByValue(this, t3, e2);
  }, t2.prototype.relu = function() {
    return this.throwIfDisposed(), ft.relu(this);
  }, t2.prototype.relu6 = function() {
    return this.throwIfDisposed(), ft.relu6(this);
  }, t2.prototype.elu = function() {
    return this.throwIfDisposed(), ft.elu(this);
  }, t2.prototype.selu = function() {
    return this.throwIfDisposed(), ft.selu(this);
  }, t2.prototype.leakyRelu = function(t3) {
    return void 0 === t3 && (t3 = 0.2), this.throwIfDisposed(), ft.leakyRelu(this, t3);
  }, t2.prototype.prelu = function(t3) {
    return this.throwIfDisposed(), ft.prelu(this, t3);
  }, t2.prototype.sigmoid = function() {
    return this.throwIfDisposed(), ft.sigmoid(this);
  }, t2.prototype.logSigmoid = function() {
    return this.throwIfDisposed(), ft.logSigmoid(this);
  }, t2.prototype.softplus = function() {
    return this.throwIfDisposed(), ft.softplus(this);
  }, t2.prototype.zerosLike = function() {
    return this.throwIfDisposed(), ft.zerosLike(this);
  }, t2.prototype.onesLike = function() {
    return this.throwIfDisposed(), ft.onesLike(this);
  }, t2.prototype.sin = function() {
    return this.throwIfDisposed(), ft.sin(this);
  }, t2.prototype.cos = function() {
    return this.throwIfDisposed(), ft.cos(this);
  }, t2.prototype.tan = function() {
    return this.throwIfDisposed(), ft.tan(this);
  }, t2.prototype.asin = function() {
    return this.throwIfDisposed(), ft.asin(this);
  }, t2.prototype.acos = function() {
    return this.throwIfDisposed(), ft.acos(this);
  }, t2.prototype.atan = function() {
    return this.throwIfDisposed(), ft.atan(this);
  }, t2.prototype.sinh = function() {
    return this.throwIfDisposed(), ft.sinh(this);
  }, t2.prototype.cosh = function() {
    return this.throwIfDisposed(), ft.cosh(this);
  }, t2.prototype.tanh = function() {
    return this.throwIfDisposed(), ft.tanh(this);
  }, t2.prototype.asinh = function() {
    return this.throwIfDisposed(), ft.asinh(this);
  }, t2.prototype.acosh = function() {
    return this.throwIfDisposed(), ft.acosh(this);
  }, t2.prototype.atanh = function() {
    return this.throwIfDisposed(), ft.atanh(this);
  }, t2.prototype.erf = function() {
    return this.throwIfDisposed(), ft.erf(this);
  }, t2.prototype.round = function() {
    return this.throwIfDisposed(), ft.round(this);
  }, t2.prototype.step = function(t3) {
    return void 0 === t3 && (t3 = 0), this.throwIfDisposed(), ft.step(this, t3);
  }, t2.prototype.softmax = function(t3) {
    return void 0 === t3 && (t3 = -1), this.throwIfDisposed(), ft.softmax(this, t3);
  }, t2.prototype.logSoftmax = function(t3) {
    return void 0 === t3 && (t3 = -1), this.throwIfDisposed(), ft.logSoftmax(this, t3);
  }, t2.prototype.resizeBilinear = function(t3, e2) {
    return void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.image.resizeBilinear(this, t3, e2);
  }, t2.prototype.resizeNearestNeighbor = function(t3, e2) {
    return void 0 === e2 && (e2 = false), this.throwIfDisposed(), ft.image.resizeNearestNeighbor(this, t3, e2);
  }, t2.prototype.conv1d = function(t3, e2, n2, r2, o2, a2) {
    return void 0 === r2 && (r2 = "NWC"), void 0 === o2 && (o2 = 1), this.throwIfDisposed(), ft.conv1d(this, t3, e2, n2, r2, o2, a2);
  }, t2.prototype.conv2d = function(t3, e2, n2, r2, o2, a2) {
    return void 0 === r2 && (r2 = "NHWC"), void 0 === o2 && (o2 = [1, 1]), this.throwIfDisposed(), ft.conv2d(this, t3, e2, n2, r2, o2, a2);
  }, t2.prototype.conv2dTranspose = function(t3, e2, n2, r2, o2) {
    return this.throwIfDisposed(), ft.conv2dTranspose(this, t3, e2, n2, r2, o2);
  }, t2.prototype.depthwiseConv2D = function(t3, e2, n2, r2, o2, a2) {
    return void 0 === r2 && (r2 = "NHWC"), void 0 === o2 && (o2 = [1, 1]), this.throwIfDisposed(), ft.depthwiseConv2d(this, t3, e2, n2, r2, o2, a2);
  }, t2.prototype.separableConv2d = function(t3, e2, n2, r2, o2, a2) {
    return void 0 === o2 && (o2 = [1, 1]), void 0 === a2 && (a2 = "NHWC"), this.throwIfDisposed(), ft.separableConv2d(this, t3, e2, n2, r2, o2, a2);
  }, t2.prototype.avgPool = function(t3, e2, n2, r2) {
    return this.throwIfDisposed(), ft.avgPool(this, t3, e2, n2, r2);
  }, t2.prototype.maxPool = function(t3, e2, n2, r2) {
    return this.throwIfDisposed(), ft.maxPool(this, t3, e2, n2, r2);
  }, t2.prototype.localResponseNormalization = function(t3, e2, n2, r2) {
    return void 0 === t3 && (t3 = 5), void 0 === e2 && (e2 = 1), void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = 0.5), ft.localResponseNormalization(this, t3, e2, n2, r2);
  }, t2.prototype.pool = function(t3, e2, n2, r2, o2) {
    return this.throwIfDisposed(), ft.pool(this, t3, e2, n2, r2, o2);
  }, t2.prototype.variable = function(t3, e2, n2) {
    return void 0 === t3 && (t3 = true), this.throwIfDisposed(), ht().makeVariable(this, t3, e2, n2);
  }, t2.prototype.unsortedSegmentSum = function(t3, e2) {
    return this.throwIfDisposed(), ft.unsortedSegmentSum(this, t3, e2);
  }, t2.prototype.batchToSpaceND = function(t3, e2) {
    return this.throwIfDisposed(), ft.batchToSpaceND(this, t3, e2);
  }, t2.prototype.spaceToBatchND = function(t3, e2) {
    return this.throwIfDisposed(), ft.spaceToBatchND(this, t3, e2);
  }, t2.prototype.topk = function(t3, e2) {
    return void 0 === t3 && (t3 = 1), void 0 === e2 && (e2 = true), this.throwIfDisposed(), ft.topk(this, t3, e2);
  }, t2.prototype.stridedSlice = function(t3, e2, n2, r2, o2, a2, i2, u2) {
    return void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = 0), void 0 === a2 && (a2 = 0), void 0 === i2 && (i2 = 0), void 0 === u2 && (u2 = 0), this.throwIfDisposed(), ft.stridedSlice(this, t3, e2, n2, r2, o2, a2, i2, u2);
  }, t2.prototype.depthToSpace = function(t3, e2) {
    return this.throwIfDisposed(), ft.depthToSpace(this, t3, e2);
  }, t2.prototype.fft = function() {
    return this.throwIfDisposed(), ft.spectral.fft(this);
  }, t2.prototype.ifft = function() {
    return this.throwIfDisposed(), ft.spectral.ifft(this);
  }, t2.prototype.rfft = function() {
    return this.throwIfDisposed(), ft.spectral.rfft(this);
  }, t2.prototype.irfft = function() {
    return this.throwIfDisposed(), ft.spectral.irfft(this);
  }, t2;
}();
Object.defineProperty(dt, Symbol.hasInstance, {value: function(t2) {
  return !!t2 && null != t2.dataId && null != t2.shape && null != t2.dtype;
}});
var vt;
var mt;
var gt;
var yt;
var xt;
var bt = function(t2) {
  function n2(e2, n3, r2, o2) {
    var a2 = t2.call(this, e2.shape, e2.dtype, e2.dataId, o2) || this;
    return a2.trainable = n3, a2.name = r2, a2;
  }
  return e(n2, t2), n2.prototype.assign = function(t3) {
    if (t3.dtype !== this.dtype)
      throw new Error("dtype of the new value (" + t3.dtype + ") and previous value (" + this.dtype + ") must match");
    if (!C(t3.shape, this.shape))
      throw new Error("shape of the new value (" + t3.shape + ") and previous value (" + this.shape + ") must match");
    ht().disposeTensor(this), this.dataId = t3.dataId, ht().incRef(this, null);
  }, n2.prototype.dispose = function() {
    ht().disposeVariable(this), this.isDisposedInternal = true;
  }, n2;
}(dt);
Object.defineProperty(bt, Symbol.hasInstance, {value: function(t2) {
  return t2 instanceof dt && null != t2.assign && t2.assign instanceof Function;
}}), function(t2) {
  t2.R0 = "R0", t2.R1 = "R1", t2.R2 = "R2", t2.R3 = "R3", t2.R4 = "R4", t2.R5 = "R5", t2.R6 = "R6";
}(vt || (vt = {})), function(t2) {
  t2.float32 = "float32", t2.int32 = "int32", t2.bool = "int32", t2.complex64 = "complex64";
}(mt || (mt = {})), function(t2) {
  t2.float32 = "float32", t2.int32 = "int32", t2.bool = "bool", t2.complex64 = "complex64";
}(gt || (gt = {})), function(t2) {
  t2.float32 = "float32", t2.int32 = "float32", t2.bool = "float32", t2.complex64 = "complex64";
}(yt || (yt = {})), function(t2) {
  t2.float32 = "complex64", t2.int32 = "complex64", t2.bool = "complex64", t2.complex64 = "complex64";
}(xt || (xt = {}));
var wt = {float32: yt, int32: mt, bool: gt, complex64: xt};
function Ct(t2, e2) {
  if ("string" === t2 || "string" === e2) {
    if ("string" === t2 && "string" === e2)
      return "string";
    throw new Error("Can not upcast " + t2 + " with " + e2);
  }
  return wt[t2][e2];
}
function Et(t2) {
  return Ct(t2, "int32");
}
function Rt(t2, e2) {
  if (t2.dtype === e2.dtype)
    return [t2, e2];
  var n2 = Ct(t2.dtype, e2.dtype);
  return [t2.cast(n2), e2.cast(n2)];
}
function It(t2, e2) {
  g(t2.dtype === e2.dtype, function() {
    return "The dtypes of the first(" + t2.dtype + ") and second(" + e2.dtype + ") input must match";
  });
}
function kt(t2) {
  var e2 = [];
  return function t3(e3, n2, r2) {
    if (null == e3)
      return;
    if (e3 instanceof dt)
      return void n2.push(e3);
    if (o2 = e3, !Array.isArray(o2) && "object" != typeof o2)
      return;
    var o2;
    var a2 = e3;
    for (var i2 in a2) {
      var u2 = a2[i2];
      r2.has(u2) || (r2.add(u2), t3(u2, n2, r2));
    }
  }(t2, e2, new Set()), e2;
}
var St;
var At = Object.freeze({makeTypesMatch: Rt, assertTypesMatch: It, isTensorInList: function(t2, e2) {
  for (var n2 = 0; n2 < e2.length; n2++)
    if (e2[n2].id === t2.id)
      return true;
  return false;
}, getTensorsInContainer: kt});
var Dt = function() {
  function t2() {
    this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap(), this.profiling = false, this.activeProfile = {newBytes: 0, newTensors: 0, peakBytes: 0, kernels: [], result: null};
  }
  return t2.prototype.dispose = function() {
    for (var t3 in this.registeredVariables)
      this.registeredVariables[t3].dispose();
  }, t2;
}();
var Tt = function() {
  function t2(t3) {
    this.ENV = t3, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new Dt();
  }
  return t2.prototype.ready = function() {
    return n(this, void 0, void 0, function() {
      var t3, e2, n2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (null != this.pendingBackendInit)
              return [2, this.pendingBackendInit.then(function() {
              })];
            if (null != this.backendInstance)
              return [2];
            t3 = this.getSortedBackends(), e2 = 0, r2.label = 1;
          case 1:
            return e2 < t3.length ? (n2 = t3[e2], [4, this.initializeBackend(n2).success]) : [3, 5];
          case 2:
            return r2.sent() ? [4, this.setBackend(n2)] : [3, 4];
          case 3:
            return r2.sent(), [2];
          case 4:
            return e2++, [3, 1];
          case 5:
            throw new Error("Could not initialize any backends, all backend initializations failed.");
        }
      });
    });
  }, Object.defineProperty(t2.prototype, "backend", {get: function() {
    if (null != this.pendingBackendInit)
      throw new Error("Backend '" + this.backendName + "' has not yet been initialized. Make sure to await tf.ready() before calling other methods");
    if (null == this.backendInstance) {
      var t3 = this.initializeBackendsAndReturnBest(), e2 = t3.name;
      if (t3.asyncInit)
        throw new Error("The highest priority backend '" + e2 + "' has not yet been initialized. Make sure to await tf.ready() before calling other methods");
      this.setBackend(e2);
    }
    return this.backendInstance;
  }, enumerable: true, configurable: true}), t2.prototype.backendNames = function() {
    return Object.keys(this.registryFactory);
  }, t2.prototype.findBackend = function(t3) {
    if (!(t3 in this.registry)) {
      if (!(t3 in this.registryFactory))
        return null;
      if (this.initializeBackend(t3).asyncInit)
        return null;
    }
    return this.registry[t3];
  }, t2.prototype.findBackendFactory = function(t3) {
    return t3 in this.registryFactory ? this.registryFactory[t3].factory : null;
  }, t2.prototype.registerBackend = function(t3, e2, n2) {
    return void 0 === n2 && (n2 = 1), t3 in this.registryFactory ? (console.warn(t3 + " backend was already registered. Reusing existing backend factory."), false) : (this.registryFactory[t3] = {factory: e2, priority: n2}, true);
  }, t2.prototype.setBackend = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2, o2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (null == this.registryFactory[t3])
              throw new Error("Backend name '" + t3 + "' not found in registry");
            return this.backendName = t3, null != this.registry[t3] ? [3, 4] : (this.backendInstance = null, e2 = this.initializeBackend(t3), n2 = e2.success, e2.asyncInit ? [4, n2] : [3, 2]);
          case 1:
            return o2 = r2.sent(), [3, 3];
          case 2:
            o2 = n2, r2.label = 3;
          case 3:
            if (!o2)
              return [2, false];
            r2.label = 4;
          case 4:
            return this.backendInstance = this.registry[t3], this.setupRegisteredKernels(), this.profiler = new et(this.backendInstance), [2, true];
        }
      });
    });
  }, t2.prototype.setupRegisteredKernels = function() {
    var t3 = this;
    c(this.backendName).forEach(function(e2) {
      null != e2.setupFunc && e2.setupFunc(t3.backendInstance);
    });
  }, t2.prototype.disposeRegisteredKernels = function(t3) {
    var e2 = this;
    c(t3).forEach(function(n2) {
      null != n2.disposeFunc && n2.disposeFunc(e2.registry[t3]);
    });
  }, t2.prototype.initializeBackend = function(t3) {
    var e2 = this, n2 = this.registryFactory[t3];
    if (null == n2)
      throw new Error("Cannot initialize backend " + t3 + ", no registration found.");
    try {
      var r2 = n2.factory();
      if (Promise.resolve(r2) === r2) {
        var o2 = ++this.pendingBackendInitId, a2 = r2.then(function(n3) {
          return !(o2 < e2.pendingBackendInitId) && (e2.registry[t3] = n3, e2.pendingBackendInit = null, true);
        }).catch(function(n3) {
          return !(o2 < e2.pendingBackendInitId) && (e2.pendingBackendInit = null, console.warn("Initialization of backend " + t3 + " failed"), console.warn(n3.stack || n3.message), false);
        });
        return this.pendingBackendInit = a2, {success: a2, asyncInit: true};
      }
      return this.registry[t3] = r2, {success: true, asyncInit: false};
    } catch (e3) {
      return console.warn("Initialization of backend " + t3 + " failed"), console.warn(e3.stack || e3.message), {success: false, asyncInit: false};
    }
  }, t2.prototype.removeBackend = function(t3) {
    if (!(t3 in this.registryFactory))
      throw new Error(t3 + " backend not found in registry");
    this.backendName === t3 && null != this.pendingBackendInit && this.pendingBackendInitId++, t3 in this.registry && (this.disposeRegisteredKernels(t3), this.registry[t3].dispose(), delete this.registry[t3]), delete this.registryFactory[t3], this.backendName === t3 && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
  }, t2.prototype.getSortedBackends = function() {
    var t3 = this;
    if (0 === Object.keys(this.registryFactory).length)
      throw new Error("No backend found in registry.");
    return Object.keys(this.registryFactory).sort(function(e2, n2) {
      return t3.registryFactory[n2].priority - t3.registryFactory[e2].priority;
    });
  }, t2.prototype.initializeBackendsAndReturnBest = function() {
    for (var t3 = this.getSortedBackends(), e2 = 0; e2 < t3.length; e2++) {
      var n2 = t3[e2], r2 = this.initializeBackend(n2), o2 = r2.success, a2 = r2.asyncInit;
      if (a2 || o2)
        return {name: n2, asyncInit: a2};
    }
    throw new Error("Could not initialize any backends, all backend initializations failed.");
  }, t2.prototype.moveData = function(t3, e2) {
    var n2 = this.state.tensorInfo.get(e2), r2 = n2.backend, o2 = this.readSync(e2);
    r2.disposeData(e2), n2.backend = t3, t3.move(e2, o2, n2.shape, n2.dtype), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
  }, t2.prototype.tidy = function(t3, e2) {
    var n2, r2 = this, o2 = null;
    if (null == e2) {
      if ("function" != typeof t3)
        throw new Error("Please provide a function to tidy()");
      e2 = t3;
    } else {
      if ("string" != typeof t3 && !(t3 instanceof String))
        throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
      if ("function" != typeof e2)
        throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
      o2 = t3;
    }
    return this.scopedRun(function() {
      return r2.startScope(o2);
    }, function() {
      return r2.endScope(n2);
    }, function() {
      return (n2 = e2()) instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n2;
    });
  }, t2.prototype.scopedRun = function(t3, e2, n2) {
    t3();
    try {
      var r2 = n2();
      return e2(), r2;
    } catch (t4) {
      throw e2(), t4;
    }
  }, t2.prototype.nextTensorId = function() {
    return t2.nextTensorId++;
  }, t2.prototype.nextVariableId = function() {
    return t2.nextVariableId++;
  }, t2.prototype.clone = function(t3) {
    var e2 = this.makeTensorFromDataId(t3.dataId, t3.shape, t3.dtype), n2 = {x: t3};
    return this.addTapeNode(this.state.activeScope.name, n2, [e2], function(t4) {
      return {x: function() {
        return t4.toFloat();
      }};
    }, []), e2;
  }, t2.prototype.runKernel = function(t3, e2, n2, r2, o2) {
    return this.runKernelFunc(null, e2, null, t3, n2, r2, o2);
  }, t2.prototype.shouldCheckForMemLeaks = function() {
    return this.ENV.getBool("IS_TEST");
  }, t2.prototype.checkKernelForMemLeak = function(t3, e2, n2) {
    var r2 = this.backend.numDataIds(), o2 = 0;
    n2.forEach(function(t4) {
      o2 += "complex64" === t4.dtype ? 3 : 1;
    });
    var a2 = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], i2 = r2 - e2 - o2 - a2;
    if (i2 > 0)
      throw new Error("Backend '" + this.backendName + "' has an internal memory leak (" + i2 + " data ids) after running '" + t3 + "'");
  }, t2.prototype.runKernelFunc = function(t3, e2, n2, r2, o2, a2, i2) {
    var u2, c2 = this;
    void 0 === a2 && (a2 = []), void 0 === i2 && (i2 = []);
    var l2, h2 = [], f2 = this.isTapeOn(), p2 = null != this.state.activeScope ? this.state.activeScope.name : "", d2 = function(t4) {
      f2 && (h2 = t4.map(function(t5) {
        return c2.keep(c2.clone(t5));
      }));
    }, v2 = this.state.numBytes, m2 = this.state.numTensors;
    this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
    var g2, y2 = s(r2, this.backendName);
    return l2 = null != y2 ? function() {
      var t4 = c2.backend.numDataIds();
      g2 = y2.kernelFunc({inputs: e2, attrs: o2, backend: c2.backend});
      var n3 = Array.isArray(g2) ? g2 : [g2];
      c2.shouldCheckForMemLeaks() && c2.checkKernelForMemLeak(p2, t4, n3);
      var r3 = n3.map(function(t5) {
        var e3 = t5.dataId, n4 = t5.shape, r4 = t5.dtype;
        return c2.makeTensorFromDataId(e3, n4, r4);
      }), u3 = r3.filter(function(t5, e3) {
        return i2[e3];
      });
      return d2(a2.slice().concat(u3)), r3;
    } : function() {
      var e3 = c2.backend.numDataIds();
      g2 = c2.tidy(function() {
        return t3(c2.backend, d2);
      });
      var n3 = Array.isArray(g2) ? g2 : [g2];
      return c2.shouldCheckForMemLeaks() && c2.checkKernelForMemLeak(p2, e3, n3), n3;
    }, this.scopedRun(function() {
      return c2.state.kernelDepth++;
    }, function() {
      return c2.state.kernelDepth--;
    }, function() {
      u2 = c2.ENV.getBool("DEBUG") ? c2.profiler.profileKernel(p2, e2, function() {
        return l2();
      }) : l2();
    }), f2 && this.addTapeNode(p2, e2, u2, n2, h2), this.state.profiling && this.state.activeProfile.kernels.push({name: p2, bytesAdded: this.state.numBytes - v2, totalBytesSnapshot: this.state.numBytes, tensorsAdded: this.state.numTensors - m2, totalTensorsSnapshot: this.state.numTensors, inputShapes: Object.keys(e2).map(function(t4) {
      return e2[t4].shape;
    }), outputShapes: u2.map(function(t4) {
      return t4.shape;
    })}), Array.isArray(g2) ? u2 : u2[0];
  }, t2.prototype.makeTensor = function(t3, e2, n2, r2) {
    if (null == t3)
      throw new Error("Values passed to engine.makeTensor() are null");
    n2 = n2 || "float32", r2 = r2 || this.backend;
    var o2 = t3;
    "string" === n2 && W(t3[0]) && (o2 = t3.map(function(t4) {
      return J(t4);
    }));
    var a2 = r2.write(o2, e2, n2), i2 = new dt(e2, n2, a2, this.nextTensorId());
    if (this.incRef(i2, r2), "string" === n2) {
      var u2 = this.state.tensorInfo.get(a2), s2 = L(o2);
      this.state.numBytes += s2 - u2.bytes, u2.bytes = s2;
    }
    return i2;
  }, t2.prototype.makeTensorFromDataId = function(t3, e2, n2, r2) {
    var o2 = new dt(e2, n2 = n2 || "float32", t3, this.nextTensorId());
    return this.incRef(o2, r2), o2;
  }, t2.prototype.makeVariable = function(t3, e2, n2, r2) {
    void 0 === e2 && (e2 = true), n2 = n2 || this.nextVariableId().toString(), null != r2 && r2 !== t3.dtype && (t3 = t3.asType(r2));
    var o2 = new bt(t3, e2, n2, this.nextTensorId());
    if (null != this.state.registeredVariables[o2.name])
      throw new Error("Variable with name " + o2.name + " was already registered");
    return this.state.registeredVariables[o2.name] = o2, this.incRef(o2, this.backend), o2;
  }, t2.prototype.incRef = function(t3, e2) {
    var n2 = this.state.tensorInfo.has(t3.dataId) ? this.state.tensorInfo.get(t3.dataId).refCount : 0;
    if (this.state.numTensors++, "string" === t3.dtype && this.state.numStringTensors++, 0 === n2) {
      this.state.numDataBuffers++;
      var r2 = 0;
      "complex64" !== t3.dtype && "string" !== t3.dtype && (r2 = t3.size * P(t3.dtype)), this.state.tensorInfo.set(t3.dataId, {backend: e2 || this.backend, dtype: t3.dtype, shape: t3.shape, bytes: r2, refCount: 0}), this.state.numBytes += r2;
    }
    this.state.tensorInfo.get(t3.dataId).refCount++, t3 instanceof bt || this.track(t3);
  }, t2.prototype.disposeTensor = function(t3) {
    if (this.state.tensorInfo.has(t3.dataId)) {
      this.state.numTensors--, "string" === t3.dtype && this.state.numStringTensors--;
      var e2 = this.state.tensorInfo.get(t3.dataId);
      e2.refCount <= 1 ? ("complex64" !== t3.dtype && (this.state.numBytes -= e2.bytes), this.state.numDataBuffers--, e2.backend.disposeData(t3.dataId), this.state.tensorInfo.delete(t3.dataId)) : this.state.tensorInfo.get(t3.dataId).refCount--;
    }
  }, t2.prototype.disposeVariables = function() {
    for (var t3 in this.state.registeredVariables) {
      var e2 = this.state.registeredVariables[t3];
      this.disposeVariable(e2);
    }
  }, t2.prototype.disposeVariable = function(t3) {
    this.disposeTensor(t3), null != this.state.registeredVariables[t3.name] && delete this.state.registeredVariables[t3.name];
  }, t2.prototype.memory = function() {
    var t3 = this.backend.memory();
    return t3.numTensors = this.state.numTensors, t3.numDataBuffers = this.state.numDataBuffers, t3.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (t3.unreliable = true, null == t3.reasons && (t3.reasons = []), t3.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), t3;
  }, t2.prototype.profile = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2;
      return r(this, function(r2) {
        return this.state.profiling = true, e2 = this.state.numBytes, n2 = this.state.numTensors, this.state.activeProfile.kernels = [], this.state.activeProfile.result = t3(), this.state.profiling = false, this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map(function(t4) {
          return t4.totalBytesSnapshot;
        })), this.state.activeProfile.newBytes = this.state.numBytes - e2, this.state.activeProfile.newTensors = this.state.numTensors - n2, [2, this.state.activeProfile];
      });
    });
  }, t2.prototype.isTapeOn = function() {
    return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth;
  }, t2.prototype.addTapeNode = function(t3, e2, n2, r2, o2) {
    var a2 = this, i2 = {id: this.state.nextTapeNodeId++, name: t3, inputs: e2, outputs: n2, saved: o2};
    null != r2 && (i2.gradient = function(t4) {
      return t4 = t4.map(function(t5, e3) {
        if (null == t5) {
          var r3 = n2[e3], o3 = $(r3.size, r3.dtype);
          return a2.makeTensor(o3, r3.shape, r3.dtype);
        }
        return t5;
      }), r2(t4.length > 1 ? t4 : t4[0], o2);
    }), this.state.activeTape.push(i2);
  }, t2.prototype.keep = function(t3) {
    return t3.kept = true, t3;
  }, t2.prototype.startTape = function() {
    0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++;
  }, t2.prototype.endTape = function() {
    this.state.gradientDepth--;
  }, t2.prototype.startScope = function(t3) {
    var e2 = {track: [], name: "unnamed scope", id: this.state.nextScopeId++};
    t3 && (e2.name = t3), this.state.scopeStack.push(e2), this.state.activeScope = e2;
  }, t2.prototype.endScope = function(t3) {
    for (var e2 = this, n2 = kt(t3), r2 = new Set(n2.map(function(t4) {
      return t4.id;
    })), o2 = 0; o2 < this.state.activeScope.track.length; o2++) {
      var a2 = this.state.activeScope.track[o2];
      a2.kept || r2.has(a2.id) || a2.dispose();
    }
    var i2 = this.state.scopeStack.pop();
    this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n2.forEach(function(t4) {
      t4.kept || t4.scopeId !== i2.id || e2.track(t4);
    });
  }, t2.prototype.gradients = function(t3, e2, n2, r2) {
    var o2 = this;
    if (void 0 === r2 && (r2 = false), g(e2.length > 0, function() {
      return "gradients() received an empty list of xs.";
    }), null != n2 && "float32" !== n2.dtype)
      throw new Error("dy must have 'float32' dtype, but has '" + n2.dtype + "'");
    var a2 = this.scopedRun(function() {
      return o2.startTape();
    }, function() {
      return o2.endTape();
    }, function() {
      return o2.tidy("forward", t3);
    });
    g(a2 instanceof dt, function() {
      return "The result y returned by f() must be a tensor.";
    });
    var i2 = function(t4, e3, n3) {
      for (var r3 = {}, o3 = {}, a3 = 0; a3 < e3.length; a3++)
        r3[e3[a3].id] = true;
      for (a3 = 0; a3 < t4.length; a3++) {
        var i3 = (d2 = t4[a3]).inputs;
        for (var u2 in i3) {
          for (var s2 = i3[u2], c2 = false, l2 = 0; l2 < e3.length; l2++)
            if (r3[s2.id]) {
              d2.outputs.forEach(function(t5) {
                return r3[t5.id] = true;
              }), c2 = true, o3[d2.id] = true;
              break;
            }
          if (c2)
            break;
        }
      }
      var h2 = {};
      h2[n3.id] = true;
      var f2 = {};
      for (a3 = t4.length - 1; a3 >= 0; a3--)
        for (i3 = (d2 = t4[a3]).inputs, l2 = 0; l2 < d2.outputs.length; l2++)
          if (h2[d2.outputs[l2].id]) {
            for (var u2 in i3)
              h2[i3[u2].id] = true, f2[d2.id] = true;
            break;
          }
      var p2 = [];
      for (a3 = 0; a3 < t4.length; a3++) {
        var d2;
        if (o3[(d2 = t4[a3]).id] && f2[d2.id]) {
          var v2 = {};
          for (var u2 in d2.inputs) {
            var m2 = d2.inputs[u2];
            r3[m2.id] && (v2[u2] = m2);
          }
          var g2 = Object.assign({}, d2);
          g2.inputs = v2, g2.outputs = d2.outputs, p2.push(g2);
        }
      }
      return p2;
    }(this.state.activeTape, e2, a2);
    if (!r2 && 0 === i2.length && e2.length > 0)
      throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
    return this.tidy("backward", function() {
      var t4, r3, u2 = {};
      u2[a2.id] = null == n2 ? (t4 = a2.shape, r3 = X(w(t4), "float32"), Nt.makeTensor(r3, t4, "float32")) : n2, function(t5, e3, n3) {
        for (var r4 = function(r5) {
          var o4 = e3[r5], a3 = [];
          if (o4.outputs.forEach(function(e4) {
            var n4 = t5[e4.id];
            null != n4 ? a3.push(n4) : a3.push(null);
          }), null == o4.gradient)
            throw new Error("Cannot compute gradient: gradient function not found for " + o4.name + ".");
          var i3 = o4.gradient(a3), u3 = function(e4) {
            if (!(e4 in i3))
              throw new Error("Cannot backprop through input " + e4 + ". Available gradients found: " + Object.keys(i3) + ".");
            var r6 = n3(function() {
              return i3[e4]();
            });
            if ("float32" !== r6.dtype)
              throw new Error("Error in gradient for op " + o4.name + ". The gradient of input " + e4 + " must have 'float32' dtype, but has '" + r6.dtype + "'");
            var a4 = o4.inputs[e4];
            if (!C(r6.shape, a4.shape))
              throw new Error("Error in gradient for op " + o4.name + ". The gradient of input '" + e4 + "' has shape '" + r6.shape + "', which does not match the shape of the input '" + a4.shape + "'");
            if (null == t5[a4.id])
              t5[a4.id] = r6;
            else {
              var u4 = t5[a4.id];
              t5[a4.id] = u4.add(r6), u4.dispose();
            }
          };
          for (var s3 in o4.inputs)
            u3(s3);
        }, o3 = e3.length - 1; o3 >= 0; o3--)
          r4(o3);
      }(u2, i2, function(t5) {
        return o2.tidy(t5);
      });
      var s2 = e2.map(function(t5) {
        return u2[t5.id];
      });
      return 0 === o2.state.gradientDepth && (o2.state.activeTape.forEach(function(t5) {
        for (var e3 in t5.saved)
          t5.saved[e3].dispose();
      }), o2.state.activeTape = null), {value: a2, grads: s2};
    });
  }, t2.prototype.customGrad = function(t3) {
    var e2 = this;
    return g(G(t3), function() {
      return "The f passed in customGrad(f) must be a function.";
    }), function() {
      for (var n2, r2 = [], o2 = 0; o2 < arguments.length; o2++)
        r2[o2] = arguments[o2];
      g(r2.every(function(t4) {
        return t4 instanceof dt;
      }), function() {
        return "The args passed in customGrad(f)(x1, x2,...) must all be tensors";
      });
      var a2 = {};
      return r2.forEach(function(t4, e3) {
        a2[e3] = t4;
      }), e2.runKernelFunc(function(e3, o3) {
        return g((n2 = t3.apply(void 0, r2.concat([o3]))).value instanceof dt, function() {
          return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor";
        }), g(G(n2.gradFunc), function() {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.";
        }), n2.value;
      }, a2, function(t4, e3) {
        var o3 = n2.gradFunc(t4, e3), a3 = Array.isArray(o3) ? o3 : [o3];
        g(a3.length === r2.length, function() {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).";
        }), g(a3.every(function(t5) {
          return t5 instanceof dt;
        }), function() {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.";
        });
        var i2 = {};
        return a3.forEach(function(t5, e4) {
          i2[e4] = function() {
            return t5;
          };
        }), i2;
      });
    };
  }, t2.prototype.readSync = function(t3) {
    return this.state.tensorInfo.get(t3).backend.readSync(t3);
  }, t2.prototype.read = function(t3) {
    return this.state.tensorInfo.get(t3).backend.read(t3);
  }, t2.prototype.fromPixels = function(t3, e2) {
    return this.backend.fromPixels(t3, e2);
  }, t2.prototype.time = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            return e2 = Y(), [4, this.backend.time(t3)];
          case 1:
            return (n2 = r2.sent()).wallMs = Y() - e2, [2, n2];
        }
      });
    });
  }, t2.prototype.track = function(t3) {
    return null != this.state.activeScope && (t3.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(t3)), t3;
  }, Object.defineProperty(t2.prototype, "registeredVariables", {get: function() {
    return this.state.registeredVariables;
  }, enumerable: true, configurable: true}), t2.prototype.reset = function() {
    for (var t3 in (this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new Dt(), this.registry))
      this.disposeRegisteredKernels(t3), this.registry[t3].dispose(), delete this.registry[t3];
    this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
  }, t2.nextTensorId = 0, t2.nextVariableId = 0, t2;
}();
var Nt = function() {
  var t2 = function() {
    if (null == St) {
      var t3 = void 0;
      if ("undefined" != typeof window)
        t3 = window;
      else if ("undefined" != typeof global)
        t3 = global;
      else if ("undefined" != typeof process)
        t3 = process;
      else {
        if ("undefined" == typeof self)
          throw new Error("Could not find a global object");
        t3 = self;
      }
      St = t3;
    }
    return St;
  }();
  if (null == t2._tfengine) {
    var e2 = new o(t2);
    t2._tfengine = new Tt(e2);
  }
  return function(t3) {
    i = t3;
  }(t2._tfengine.ENV), ht = function() {
    return t2._tfengine;
  }, t2._tfengine;
}();
function Ft() {
  return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope;
}
var Ot = a();
Ot.registerFlag("DEBUG", function() {
  return false;
}, function(t2) {
  t2 && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
}), Ot.registerFlag("IS_BROWSER", function() {
  return Ft();
}), Ot.registerFlag("IS_NODE", function() {
  return "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node;
}), Ot.registerFlag("IS_CHROME", function() {
  return "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
}), Ot.registerFlag("PROD", function() {
  return false;
}), Ot.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", function() {
  return Ot.getBool("DEBUG");
}), Ot.registerFlag("DEPRECATION_WARNINGS_ENABLED", function() {
  return true;
}), Ot.registerFlag("IS_TEST", function() {
  return false;
});
var _t;
var Mt;
var Bt;
var Pt = {};
var Lt = {alpha: false, antialias: false, premultipliedAlpha: false, preserveDrawingBuffer: false, depth: false, stencil: false, failIfMajorPerformanceCaveat: true};
function Wt(t2, e2) {
  Pt[t2] = e2;
}
function Ut(t2) {
  t2 in Pt || (Pt[t2] = function(t3) {
    if (1 !== t3 && 2 !== t3)
      throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
    var e3 = Vt(t3);
    if (e3.addEventListener("webglcontextlost", function(e4) {
      e4.preventDefault(), delete Pt[t3];
    }, false), 1 === t3)
      return e3.getContext("webgl", Lt) || e3.getContext("experimental-webgl", Lt);
    return e3.getContext("webgl2", Lt);
  }(t2));
  var e2 = Pt[t2];
  return e2.isContextLost() ? (delete Pt[t2], Ut(t2)) : (e2.disable(e2.DEPTH_TEST), e2.disable(e2.STENCIL_TEST), e2.disable(e2.BLEND), e2.disable(e2.DITHER), e2.disable(e2.POLYGON_OFFSET_FILL), e2.disable(e2.SAMPLE_COVERAGE), e2.enable(e2.SCISSOR_TEST), e2.enable(e2.CULL_FACE), e2.cullFace(e2.BACK), Pt[t2]);
}
function Vt(t2) {
  if ("undefined" != typeof OffscreenCanvas && 2 === t2)
    return new OffscreenCanvas(300, 150);
  if ("undefined" != typeof document)
    return document.createElement("canvas");
  throw new Error("Cannot create a canvas in this context");
}
function zt(t2, e2) {
  return [e2, t2];
}
function Gt(t2) {
  var e2 = w(t2);
  return I(Math.ceil(e2 / 4));
}
function Ht(t2, e2) {
  return [Math.max(1, Math.ceil(e2 / 2)), Math.max(1, Math.ceil(t2 / 2))];
}
function qt(t2, e2) {
  var n2, r2, o2, i2, u2, s2, c2, l2, h2, f2 = t2;
  return 2 === a().getNumber("WEBGL_VERSION") ? (n2 = f2.R32F, r2 = f2.R16F, o2 = f2.RGBA16F, i2 = f2.RGBA32F, u2 = f2.RED, s2 = 4, c2 = 1, l2 = f2.HALF_FLOAT, h2 = f2.FLOAT) : (n2 = t2.RGBA, r2 = t2.RGBA, o2 = t2.RGBA, i2 = f2.RGBA, u2 = t2.RGBA, s2 = 4, c2 = 4, l2 = null != e2 ? e2.HALF_FLOAT_OES : null, h2 = t2.FLOAT), {internalFormatFloat: n2, internalFormatHalfFloat: r2, internalFormatPackedHalfFloat: o2, internalFormatPackedFloat: i2, textureFormatFloat: u2, downloadTextureFormat: t2.RGBA, downloadUnpackNumChannels: s2, defaultNumChannels: c2, textureTypeHalfFloat: l2, textureTypeFloat: h2};
}
function Kt(t2, e2, n2) {
  var r2 = n2();
  return e2 && function(t3) {
    var e3 = t3.getError();
    if (e3 !== t3.NO_ERROR)
      throw new Error("WebGL Error: " + Yt(t3, e3));
  }(t2), r2;
}
!function(t2) {
  t2[t2.DENSE = 0] = "DENSE", t2[t2.SHARED_BATCH = 1] = "SHARED_BATCH";
}(_t || (_t = {})), function(t2) {
  t2[t2.RENDER = 0] = "RENDER", t2[t2.UPLOAD = 1] = "UPLOAD", t2[t2.PIXELS = 2] = "PIXELS", t2[t2.DOWNLOAD = 3] = "DOWNLOAD";
}(Mt || (Mt = {})), function(t2) {
  t2[t2.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", t2[t2.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", t2[t2.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", t2[t2.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", t2[t2.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
}(Bt || (Bt = {}));
var jt = 596e-10;
var Xt = 65504;
function $t(t2) {
  return !!(a().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === t2 || jt < Math.abs(t2) && Math.abs(t2) < Xt);
}
function Yt(t2, e2) {
  switch (e2) {
    case t2.NO_ERROR:
      return "NO_ERROR";
    case t2.INVALID_ENUM:
      return "INVALID_ENUM";
    case t2.INVALID_VALUE:
      return "INVALID_VALUE";
    case t2.INVALID_OPERATION:
      return "INVALID_OPERATION";
    case t2.INVALID_FRAMEBUFFER_OPERATION:
      return "INVALID_FRAMEBUFFER_OPERATION";
    case t2.OUT_OF_MEMORY:
      return "OUT_OF_MEMORY";
    case t2.CONTEXT_LOST_WEBGL:
      return "CONTEXT_LOST_WEBGL";
    default:
      return "Unknown error code " + e2;
  }
}
function Qt(t2, e2, n2) {
  return be(t2, e2, function() {
    return t2.getExtension(n2);
  }, 'Extension "' + n2 + '" not supported on this browser.');
}
function Jt(t2, e2, n2) {
  var r2 = be(t2, e2, function() {
    return t2.createShader(t2.VERTEX_SHADER);
  }, "Unable to create vertex WebGLShader.");
  if (Kt(t2, e2, function() {
    return t2.shaderSource(r2, n2);
  }), Kt(t2, e2, function() {
    return t2.compileShader(r2);
  }), false === t2.getShaderParameter(r2, t2.COMPILE_STATUS))
    throw console.log(t2.getShaderInfoLog(r2)), new Error("Failed to compile vertex shader.");
  return r2;
}
function Zt(t2, e2, n2) {
  var r2 = be(t2, e2, function() {
    return t2.createShader(t2.FRAGMENT_SHADER);
  }, "Unable to create fragment WebGLShader.");
  if (Kt(t2, e2, function() {
    return t2.shaderSource(r2, n2);
  }), Kt(t2, e2, function() {
    return t2.compileShader(r2);
  }), false === t2.getShaderParameter(r2, t2.COMPILE_STATUS))
    throw function(t3, e3) {
      var n3 = ne.exec(e3);
      if (null == n3)
        return console.log("Couldn't parse line number in error: " + e3), void console.log(t3);
      for (var r3 = +n3[1], o2 = t3.split("\n"), a2 = o2.length.toString().length + 2, i2 = o2.map(function(t4, e4) {
        return k((e4 + 1).toString(), a2) + t4;
      }), u2 = 0, s2 = 0; s2 < i2.length; s2++)
        u2 = Math.max(i2[s2].length, u2);
      var c2 = i2.slice(0, r3 - 1), l2 = i2.slice(r3 - 1, r3), h2 = i2.slice(r3);
      console.log(c2.join("\n")), console.log(e3.split("\n")[0]), console.log("%c " + k(l2[0], u2), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(h2.join("\n"));
    }(n2, t2.getShaderInfoLog(r2)), new Error("Failed to compile fragment shader.");
  return r2;
}
var te;
var ee;
var ne = /ERROR: [0-9]+:([0-9]+):/g;
function re(t2, e2) {
  return be(t2, e2, function() {
    return t2.createProgram();
  }, "Unable to create WebGLProgram.");
}
function oe(t2, e2, n2) {
  if (Kt(t2, e2, function() {
    return t2.linkProgram(n2);
  }), false === t2.getProgramParameter(n2, t2.LINK_STATUS))
    throw console.log(t2.getProgramInfoLog(n2)), new Error("Failed to link vertex and fragment shaders.");
}
function ae(t2, e2, n2) {
  if (Kt(t2, e2, function() {
    return t2.validateProgram(n2);
  }), false === t2.getProgramParameter(n2, t2.VALIDATE_STATUS))
    throw console.log(t2.getProgramInfoLog(n2)), new Error("Shader program validation failed.");
}
function ie(t2, e2, n2) {
  var r2 = be(t2, e2, function() {
    return t2.createBuffer();
  }, "Unable to create WebGLBuffer");
  return Kt(t2, e2, function() {
    return t2.bindBuffer(t2.ARRAY_BUFFER, r2);
  }), Kt(t2, e2, function() {
    return t2.bufferData(t2.ARRAY_BUFFER, n2, t2.STATIC_DRAW);
  }), r2;
}
function ue(t2, e2, n2) {
  var r2 = be(t2, e2, function() {
    return t2.createBuffer();
  }, "Unable to create WebGLBuffer");
  return Kt(t2, e2, function() {
    return t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, r2);
  }), Kt(t2, e2, function() {
    return t2.bufferData(t2.ELEMENT_ARRAY_BUFFER, n2, t2.STATIC_DRAW);
  }), r2;
}
function se(t2, e2) {
  return be(t2, e2, function() {
    return t2.createTexture();
  }, "Unable to create WebGLTexture.");
}
function ce(t2, e2) {
  var n2 = a().getNumber("WEBGL_MAX_TEXTURE_SIZE");
  if (t2 <= 0 || e2 <= 0) {
    var r2 = "[" + t2 + "x" + e2 + "]";
    throw new Error("Requested texture size " + r2 + " is invalid.");
  }
  if (t2 > n2 || e2 > n2) {
    r2 = "[" + t2 + "x" + e2 + "]";
    throw new Error("Requested texture size " + r2 + " greater than WebGL maximum on this browser / GPU " + ("[" + n2 + "x" + n2 + "]") + ".");
  }
}
function le(t2, e2) {
  return be(t2, e2, function() {
    return t2.createFramebuffer();
  }, "Unable to create WebGLFramebuffer.");
}
function he(t2, e2, n2, r2, o2, a2, i2, u2) {
  var s2 = t2.getAttribLocation(n2, r2);
  return -1 !== s2 && (Kt(t2, e2, function() {
    return t2.bindBuffer(t2.ARRAY_BUFFER, o2);
  }), Kt(t2, e2, function() {
    return t2.vertexAttribPointer(s2, a2, t2.FLOAT, false, i2, u2);
  }), Kt(t2, e2, function() {
    return t2.enableVertexAttribArray(s2);
  }), true);
}
function fe(t2, e2, n2, r2) {
  we(t2, r2), Kt(t2, e2, function() {
    return t2.activeTexture(t2.TEXTURE0 + r2);
  }), Kt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, n2);
  });
}
function pe(t2, e2, n2, r2) {
  return be(t2, e2, function() {
    return t2.getUniformLocation(n2, r2);
  }, 'uniform "' + r2 + '" not present in program.');
}
function de(t2, e2, n2) {
  return t2.getUniformLocation(e2, n2);
}
function ve(t2, e2, n2, r2, o2, a2) {
  Kt(t2, e2, function() {
    return fe(t2, e2, r2, a2);
  }), Kt(t2, e2, function() {
    return t2.uniform1i(o2, a2);
  });
}
function me(t2, e2, n2, r2) {
  Kt(t2, e2, function() {
    return t2.bindFramebuffer(t2.FRAMEBUFFER, r2);
  }), Kt(t2, e2, function() {
    return t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, n2, 0);
  });
}
function ge(t2, e2, n2) {
  Kt(t2, e2, function() {
    return t2.bindFramebuffer(t2.FRAMEBUFFER, n2);
  }), Kt(t2, e2, function() {
    return t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, null, 0);
  });
}
function ye(t2) {
  var e2 = t2.checkFramebufferStatus(t2.FRAMEBUFFER);
  if (e2 !== t2.FRAMEBUFFER_COMPLETE)
    throw new Error("Error binding framebuffer: " + xe(t2, e2));
}
function xe(t2, e2) {
  switch (e2) {
    case t2.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    case t2.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    case t2.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
      return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    case t2.FRAMEBUFFER_UNSUPPORTED:
      return "FRAMEBUFFER_UNSUPPORTED";
    default:
      return "unknown error " + e2;
  }
}
function be(t2, e2, n2, r2) {
  var o2 = Kt(t2, e2, function() {
    return n2();
  });
  if (null == o2)
    throw new Error(r2);
  return o2;
}
function we(t2, e2) {
  var n2 = t2.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, r2 = e2 + t2.TEXTURE0;
  if (r2 < t2.TEXTURE0 || r2 > n2)
    throw new Error("textureUnit must be in " + ("[gl.TEXTURE0, gl.TEXTURE" + n2 + "]") + ".");
}
function Ce(t2, e2) {
  return void 0 === e2 && (e2 = 2), w(t2.slice(0, t2.length - e2));
}
function Ee(t2) {
  if (0 === t2.length)
    throw Error("Cannot get rows and columns of an empty shape array.");
  return [t2.length > 1 ? t2[t2.length - 2] : 1, t2[t2.length - 1]];
}
function Re(t2) {
  var e2 = [1, 1, 1];
  return 0 === t2.length || 1 === t2.length && 1 === t2[0] || (e2 = [Ce(t2)].concat(Ee(t2))), e2;
}
function Ie(t2, e2) {
  var n2;
  void 0 === e2 && (e2 = false);
  var r2 = a().getNumber("WEBGL_MAX_TEXTURE_SIZE");
  if (e2 && (r2 *= 2, 1 === (t2 = t2.map(function(e3, n3) {
    return n3 >= t2.length - 2 ? v(t2[n3]) : t2[n3];
  })).length && (t2 = [2, t2[0]])), 2 !== t2.length) {
    var o2 = T(t2);
    t2 = o2.newShape;
  }
  var i2 = w(t2);
  if (t2.length <= 1 && i2 <= r2)
    return [1, i2];
  if (2 === t2.length && t2[0] <= r2 && t2[1] <= r2)
    return t2;
  if (3 === t2.length && t2[0] * t2[1] <= r2 && t2[2] <= r2)
    return [t2[0] * t2[1], t2[2]];
  if (3 === t2.length && t2[0] <= r2 && t2[1] * t2[2] <= r2)
    return [t2[0], t2[1] * t2[2]];
  if (4 === t2.length && t2[0] * t2[1] * t2[2] <= r2 && t2[3] <= r2)
    return [t2[0] * t2[1] * t2[2], t2[3]];
  if (4 === t2.length && t2[0] <= r2 && t2[1] * t2[2] * t2[3] <= r2)
    return [t2[0], t2[1] * t2[2] * t2[3]];
  if (e2) {
    var u2 = Ce(t2), s2 = 2, c2 = 2;
    return t2.length && (s2 = (n2 = Ee(t2))[0], c2 = n2[1]), I(i2 = u2 * (s2 / 2) * (c2 / 2)).map(function(t3) {
      return 2 * t3;
    });
  }
  return I(i2);
}
function ke(t2) {
  return t2 % 2 == 0;
}
function Se(t2, e2) {
  if (C(t2 = t2.slice(-2), e2 = e2.slice(-2)))
    return true;
  if (!t2.length || !e2.length)
    return true;
  if (0 === t2[0] || 0 === t2[1] || 0 === e2[0] || 0 === e2[1])
    return true;
  if (t2.length !== e2.length) {
    var n2 = t2.slice(-1)[0], r2 = e2.slice(-1)[0];
    if (n2 === r2)
      return true;
    if (ke(n2) && ke(r2) && (1 === t2[0] || 1 === e2[0]))
      return true;
  }
  return t2[1] === e2[1] && ke(t2[0]) && ke(e2[0]);
}
function Ae(t2) {
  if (null == te) {
    var e2 = Ut(t2);
    te = e2.getParameter(e2.MAX_TEXTURE_SIZE);
  }
  return te;
}
function De(t2) {
  if (null == ee) {
    var e2 = Ut(t2);
    ee = e2.getParameter(e2.MAX_TEXTURE_IMAGE_UNITS);
  }
  return Math.min(16, ee);
}
function Te(t2) {
  if (0 === t2)
    return 0;
  var e2 = Ut(t2);
  return Ne(e2, "EXT_disjoint_timer_query_webgl2") && 2 === t2 ? 2 : Ne(e2, "EXT_disjoint_timer_query") ? 1 : 0;
}
function Ne(t2, e2) {
  return null != t2.getExtension(e2);
}
function Fe(t2) {
  try {
    if (null != Ut(t2))
      return true;
  } catch (t3) {
    return false;
  }
  return false;
}
function Oe(t2) {
  if (0 === t2)
    return false;
  var e2 = Ut(t2);
  if (1 === t2) {
    if (!Ne(e2, "OES_texture_float"))
      return false;
  } else if (!Ne(e2, "EXT_color_buffer_float"))
    return false;
  return Me(e2);
}
function _e(t2) {
  if (0 === t2)
    return false;
  var e2 = Ut(t2);
  if (1 !== t2) {
    if (Ne(e2, "EXT_color_buffer_float"))
      return Me(e2);
    if (Ne(e2, "EXT_color_buffer_half_float")) {
      var n2 = e2.getExtension("EXT_color_buffer_half_float");
      return function(t3, e3) {
        var n3 = qt(t3, e3), r2 = t3.createTexture();
        t3.bindTexture(t3.TEXTURE_2D, r2);
        t3.texImage2D(t3.TEXTURE_2D, 0, n3.internalFormatHalfFloat, 1, 1, 0, n3.textureFormatFloat, n3.textureTypeHalfFloat, null);
        var o2 = t3.createFramebuffer();
        t3.bindFramebuffer(t3.FRAMEBUFFER, o2), t3.framebufferTexture2D(t3.FRAMEBUFFER, t3.COLOR_ATTACHMENT0, t3.TEXTURE_2D, r2, 0);
        var a2 = t3.checkFramebufferStatus(t3.FRAMEBUFFER) === t3.FRAMEBUFFER_COMPLETE;
        return t3.bindTexture(t3.TEXTURE_2D, null), t3.bindFramebuffer(t3.FRAMEBUFFER, null), t3.deleteTexture(r2), t3.deleteFramebuffer(o2), a2;
      }(e2, n2);
    }
    return false;
  }
  return !!Ne(e2, "OES_texture_float") && (!!Ne(e2, "WEBGL_color_buffer_float") && Me(e2));
}
function Me(t2) {
  var e2 = qt(t2), n2 = t2.createTexture();
  t2.bindTexture(t2.TEXTURE_2D, n2);
  t2.texImage2D(t2.TEXTURE_2D, 0, e2.internalFormatFloat, 1, 1, 0, e2.textureFormatFloat, e2.textureTypeFloat, null);
  var r2 = t2.createFramebuffer();
  t2.bindFramebuffer(t2.FRAMEBUFFER, r2), t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, n2, 0);
  var o2 = t2.checkFramebufferStatus(t2.FRAMEBUFFER) === t2.FRAMEBUFFER_COMPLETE;
  return t2.bindTexture(t2.TEXTURE_2D, null), t2.bindFramebuffer(t2.FRAMEBUFFER, null), t2.deleteTexture(n2), t2.deleteFramebuffer(r2), o2;
}
function Be(t2) {
  return 2 === t2 && null != Ut(t2).fenceSync;
}
var Pe = Object.freeze({callAndCheck: Kt, canBeRepresented: $t, getWebGLErrorMessage: Yt, getExtensionOrThrow: Qt, createVertexShader: Jt, createFragmentShader: Zt, createProgram: re, linkProgram: oe, validateProgram: ae, createStaticVertexBuffer: ie, createStaticIndexBuffer: ue, getNumChannels: function() {
  return 2 === a().getNumber("WEBGL_VERSION") ? 1 : 4;
}, createTexture: se, validateTextureSize: ce, createFramebuffer: le, bindVertexBufferToProgramAttribute: he, bindTextureUnit: fe, unbindTextureUnit: function(t2, e2, n2) {
  we(t2, n2), Kt(t2, e2, function() {
    return t2.activeTexture(t2.TEXTURE0 + n2);
  }), Kt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, null);
  });
}, getProgramUniformLocationOrThrow: pe, getProgramUniformLocation: de, bindTextureToProgramUniformSampler: ve, bindCanvasToFramebuffer: function(t2, e2) {
  Kt(t2, e2, function() {
    return t2.bindFramebuffer(t2.FRAMEBUFFER, null);
  }), Kt(t2, e2, function() {
    return t2.viewport(0, 0, t2.canvas.width, t2.canvas.height);
  }), Kt(t2, e2, function() {
    return t2.scissor(0, 0, t2.canvas.width, t2.canvas.height);
  });
}, bindColorTextureToFramebuffer: me, unbindColorTextureFromFramebuffer: ge, validateFramebuffer: ye, getFramebufferErrorMessage: xe, getBatchDim: Ce, getRowsCols: Ee, getShapeAs3D: Re, getTextureShapeFromLogicalShape: Ie, isReshapeFree: Se, getWebGLMaxTextureSize: Ae, resetMaxTextureSize: function() {
  te = null;
}, resetMaxTexturesInShader: function() {
  ee = null;
}, getMaxTexturesInShader: De, getWebGLDisjointQueryTimerVersion: Te, hasExtension: Ne, isWebGLVersionEnabled: Fe, isCapableOfRenderingToFloatTexture: Oe, isDownloadFloatTextureEnabled: _e, isWebGLFenceEnabled: Be});
var Le = a();
function We() {
  a().set("PROD", true);
}
function Ue() {
  a().set("DEBUG", true);
}
function Ve() {
  a().set("DEPRECATION_WARNINGS_ENABLED", false), console.warn("TensorFlow.js deprecation warnings have been disabled.");
}
function ze(t2) {
  a().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(t2 + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
}
function Ge() {
  Nt.disposeVariables();
}
function He() {
  return Nt;
}
function qe() {
  return Nt.memory();
}
function Ke(t2) {
  return Nt.profile(t2);
}
function je(t2, e2) {
  return Nt.tidy(t2, e2);
}
function Xe(t2) {
  kt(t2).forEach(function(t3) {
    return t3.dispose();
  });
}
function $e(t2) {
  return Nt.keep(t2);
}
function Ye(t2) {
  return Nt.time(t2);
}
function Qe(t2) {
  return Nt.setBackend(t2);
}
function Je() {
  return Nt.ready();
}
function Ze() {
  return Nt.backendName;
}
function tn(t2) {
  Nt.removeBackend(t2);
}
function en(t2) {
  return Nt.findBackend(t2);
}
function nn(t2) {
  return Nt.findBackendFactory(t2);
}
function rn(t2, e2, n2) {
  return void 0 === n2 && (n2 = 1), Nt.registerBackend(t2, e2, n2);
}
function on() {
  return Nt.backend;
}
function an(t2, e2) {
  a().setPlatform(t2, e2);
}
function un() {
  for (var t2 = [], e2 = 0; e2 < arguments.length; e2++)
    t2[e2] = arguments[e2];
  a().getBool("IS_TEST") || console.warn.apply(console, t2);
}
function sn(t2, e2) {
  var n2 = t2;
  if (B(t2))
    return "string" === e2 ? [] : [t2.length];
  if (!Array.isArray(t2))
    return [];
  for (var r2 = []; Array.isArray(n2) || B(n2) && "string" !== e2; )
    r2.push(n2.length), n2 = n2[0];
  return Array.isArray(t2) && a().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && function t3(e3, n3, r3) {
    r3 = r3 || [];
    if (!Array.isArray(e3) && !B(e3))
      return void g(0 === n3.length, function() {
        return "Element arr[" + r3.join("][") + "] is a primitive, but should be an array/TypedArray of " + n3[0] + " elements";
      });
    g(n3.length > 0, function() {
      return "Element arr[" + r3.join("][") + "] should be a primitive, but is an array of " + e3.length + " elements";
    });
    g(e3.length === n3[0], function() {
      return "Element arr[" + r3.join("][") + "] should have " + n3[0] + " elements, but has " + e3.length + " elements";
    });
    var o2 = n3.slice(1);
    for (var a2 = 0; a2 < e3.length; ++a2)
      t3(e3[a2], o2, r3.concat(a2));
  }(t2, r2, []), r2;
}
function cn(t2, e2, n2, r2) {
  if (null != t2 && ("numeric" !== t2 && t2 !== e2 || "numeric" === t2 && "string" === e2))
    throw new Error("Argument '" + n2 + "' passed to '" + r2 + "' must be " + t2 + " tensor, but got " + e2 + " tensor");
}
function ln(t2, e2, n2, r2) {
  if (void 0 === r2 && (r2 = "numeric"), t2 instanceof dt)
    return cn(r2, t2.dtype, e2, n2), t2;
  var o2 = z(t2);
  if ("string" !== o2 && ["bool", "int32", "float32"].indexOf(r2) >= 0 && (o2 = r2), cn(r2, o2, e2, n2), null == t2 || !B(t2) && !Array.isArray(t2) && "number" != typeof t2 && "boolean" != typeof t2 && "string" != typeof t2) {
    var i2 = null == t2 ? "null" : t2.constructor.name;
    throw new Error("Argument '" + e2 + "' passed to '" + n2 + "' must be a Tensor or TensorLike, but got '" + i2 + "'");
  }
  var u2 = sn(t2, o2);
  B(t2) || Array.isArray(t2) || (t2 = [t2]);
  var s2 = "string" !== o2 ? K(t2, o2, a().getBool("DEBUG")) : b(t2, [], true);
  return Nt.makeTensor(s2, u2, o2);
}
function hn(t2, e2, n2, r2) {
  if (void 0 === r2 && (r2 = "numeric"), !Array.isArray(t2))
    throw new Error("Argument " + e2 + " passed to " + n2 + " must be a `Tensor[]` or `TensorLike[]`");
  return t2.map(function(t3, r3) {
    return ln(t3, e2 + "[" + r3 + "]", n2);
  }, r2);
}
function fn(t2, e2) {
  for (var n2 = 0; n2 < t2.length; ++n2)
    if (t2[t2.length - n2 - 1] !== e2 - 1 - n2)
      return false;
  return true;
}
function pn(t2, e2, n2) {
  for (var r2 = t2.length + e2.length, o2 = [], a2 = 0, i2 = 0, u2 = 0; u2 < r2; u2++)
    -1 === n2.indexOf(u2) ? o2.push(t2[a2++]) : o2.push(e2[i2++]);
  return o2;
}
function dn(t2, e2) {
  for (var n2 = [], r2 = t2.length, o2 = 0; o2 < r2; o2++)
    -1 === e2.indexOf(o2) && n2.push(t2[o2]);
  return [n2, e2.map(function(e3) {
    return t2[e3];
  })];
}
function vn(t2, e2) {
  return pn(t2, e2.map(function(t3) {
    return 1;
  }), e2);
}
function mn(t2, e2, n2) {
  g(fn(e2, n2), function() {
    return t2 + " supports only inner-most axes for now. Got axes " + e2 + " and rank-" + n2 + " input.";
  });
}
function gn(t2, e2) {
  if (fn(t2, e2))
    return null;
  for (var n2 = [], r2 = 0; r2 < e2; ++r2)
    -1 === t2.indexOf(r2) && n2.push(r2);
  return t2.forEach(function(t3) {
    return n2.push(t3);
  }), n2;
}
function yn(t2) {
  return t2.map(function(t3, e2) {
    return [e2, t3];
  }).sort(function(t3, e2) {
    return t3[1] - e2[1];
  }).map(function(t3) {
    return t3[0];
  });
}
function xn(t2, e2) {
  for (var n2 = [], r2 = e2 - t2; r2 < e2; ++r2)
    n2.push(r2);
  return n2;
}
function bn(t2, e2) {
  var n2 = t2[0].length;
  t2.forEach(function(t3, e3) {
    g(t3.length === n2, function() {
      return "Error in concat" + n2 + "D: rank of tensors[" + e3 + "] must be the same as the rank of the rest (" + n2 + ")";
    });
  }), g(e2 >= 0 && e2 < n2, function() {
    return "Error in concat" + n2 + "D: axis must be between 0 and " + (n2 - 1) + ".";
  });
  var r2 = t2[0];
  t2.forEach(function(t3, o2) {
    for (var a2 = 0; a2 < n2; a2++)
      g(a2 === e2 || t3[a2] === r2[a2], function() {
        return "Error in concat" + n2 + "D: Shape of tensors[" + o2 + "] (" + t3 + ") does not match the shape of the rest (" + r2 + ") along the non-concatenated axis " + o2 + ".";
      });
  });
}
function wn(t2, e2) {
  for (var n2 = t2[0].slice(), r2 = 1; r2 < t2.length; r2++)
    n2[e2] += t2[r2][e2];
  return n2;
}
function Cn(t2) {
  var e2 = Object.keys(t2);
  if (1 !== e2.length)
    throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + e2.length + " keys.");
  var n2 = e2[0], r2 = t2[n2];
  n2.endsWith("_") && (n2 = n2.substring(0, n2.length - 1));
  var o2 = function() {
    for (var t3 = [], e3 = 0; e3 < arguments.length; e3++)
      t3[e3] = arguments[e3];
    Nt.startScope(n2);
    try {
      var o3 = r2.apply(void 0, t3);
      return o3 instanceof Promise && console.error("Cannot return a Promise inside of tidy."), Nt.endScope(o3), o3;
    } catch (t4) {
      throw Nt.endScope(null), t4;
    }
  };
  return Object.defineProperty(o2, "name", {value: n2, configurable: true}), o2;
}
Le.registerFlag("HAS_WEBGL", function() {
  return Le.getNumber("WEBGL_VERSION") > 0;
}), Le.registerFlag("WEBGL_VERSION", function() {
  return Fe(2) ? 2 : Fe(1) ? 1 : 0;
}), Le.registerFlag("WEBGL_BUFFER_SUPPORTED", function() {
  return 2 === Le.get("WEBGL_VERSION");
}), Le.registerFlag("WEBGL_CPU_FORWARD", function() {
  return true;
}), Le.registerFlag("WEBGL_FORCE_F16_TEXTURES", function() {
  return false;
}), Le.registerFlag("WEBGL_PACK", function() {
  return Le.getBool("HAS_WEBGL");
}), Le.registerFlag("WEBGL_PACK_NORMALIZATION", function() {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_PACK_CLIP", function() {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_PACK_DEPTHWISECONV", function() {
  return false;
}), Le.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", function() {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", function() {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", function() {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", function() {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_PACK_REDUCE", function() {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_LAZILY_UNPACK", function() {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_CONV_IM2COL", function() {
  return Le.getBool("WEBGL_PACK");
}), Le.registerFlag("WEBGL_MAX_TEXTURE_SIZE", function() {
  return Ae(Le.getNumber("WEBGL_VERSION"));
}), Le.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", function() {
  return De(Le.getNumber("WEBGL_VERSION"));
}), Le.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", function() {
  var t2 = Le.getNumber("WEBGL_VERSION");
  return 0 === t2 ? 0 : Te(t2);
}), Le.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", function() {
  return Le.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && (t2 = navigator.userAgent || navigator.vendor || window.opera, !(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t2) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t2.substr(0, 4))));
  var t2;
}), Le.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", function() {
  return Oe(Le.getNumber("WEBGL_VERSION"));
}), Le.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", function() {
  return !Le.getBool("WEBGL_FORCE_F16_TEXTURES") && Le.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
}), Le.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", function() {
  return _e(Le.getNumber("WEBGL_VERSION"));
}), Le.registerFlag("WEBGL_FENCE_API_ENABLED", function() {
  return Be(Le.getNumber("WEBGL_VERSION"));
}), Le.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", function() {
  return Le.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0;
}), pt = ze;
var En = Cn({complex_: function(t2, e2) {
  var n2 = ln(t2, "real", "complex"), r2 = ln(e2, "imag", "complex");
  return y(n2.shape, r2.shape, "real and imag shapes, " + n2.shape + " and " + r2.shape + ", must match in call to tf.complex()."), Nt.runKernelFunc(function(t3) {
    return t3.complex(n2, r2);
  }, {$real: n2, $imag: r2});
}});
var Rn = Cn({real_: function(t2) {
  var e2 = ln(t2, "input", "real");
  return Nt.runKernelFunc(function(t3) {
    return t3.real(e2);
  }, {$input: e2});
}});
var In = Cn({imag_: function(t2) {
  var e2 = ln(t2, "input", "imag");
  return Nt.runKernelFunc(function(t3) {
    return t3.imag(e2);
  }, {$input: e2});
}});
function kn(t2, e2, n2) {
  return Sn(t2, e2, sn(t2, n2), n2);
}
function Sn(t2, e2, n2, r2) {
  if (null == r2 && (r2 = z(t2)), "complex64" === r2)
    throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
  if (!B(t2) && !Array.isArray(t2) && "number" != typeof t2 && "boolean" != typeof t2 && "string" != typeof t2)
    throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
  if (null != e2) {
    Q(e2);
    var o2 = w(e2), i2 = w(n2);
    g(o2 === i2, function() {
      return "Based on the provided shape, [" + e2 + "], the tensor should have " + o2 + " values but has " + i2;
    });
    for (var u2 = 0; u2 < n2.length; ++u2) {
      var s2 = n2[u2], c2 = u2 !== n2.length - 1 || s2 !== w(e2.slice(u2));
      g(n2[u2] === e2[u2] || !c2, function() {
        return "Error creating a new Tensor. Inferred shape (" + n2 + ") does not match the provided shape (" + e2 + "). ";
      });
    }
  }
  return B(t2) || Array.isArray(t2) || (t2 = [t2]), e2 = e2 || n2, t2 = "string" !== r2 ? K(t2, r2, a().getBool("DEBUG")) : b(t2, [], true), Nt.makeTensor(t2, e2, r2);
}
function An(t2, e2) {
  if ((B(t2) && "string" !== e2 || Array.isArray(t2)) && "complex64" !== e2)
    throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  if ("string" === e2 && B(t2) && !(t2 instanceof Uint8Array))
    throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  return Sn(t2, [], [], e2);
}
function Dn(t2, e2) {
  x(t2);
  var n2 = sn(t2, e2);
  if (1 !== n2.length)
    throw new Error("tensor1d() requires values to be a flat/TypedArray");
  return Sn(t2, null, n2, e2);
}
function Tn(t2, e2, n2) {
  if (x(t2), null != e2 && 2 !== e2.length)
    throw new Error("tensor2d() requires shape to have two numbers");
  var r2 = sn(t2, n2);
  if (2 !== r2.length && 1 !== r2.length)
    throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  if (1 === r2.length && null == e2)
    throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
  return Sn(t2, e2, r2, n2);
}
function Nn(t2, e2, n2) {
  if (x(t2), null != e2 && 3 !== e2.length)
    throw new Error("tensor3d() requires shape to have three numbers");
  var r2 = sn(t2, n2);
  if (3 !== r2.length && 1 !== r2.length)
    throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
  if (1 === r2.length && null == e2)
    throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
  return Sn(t2, e2, r2, n2);
}
function Fn(t2, e2, n2) {
  if (x(t2), null != e2 && 4 !== e2.length)
    throw new Error("tensor4d() requires shape to have four numbers");
  var r2 = sn(t2, n2);
  if (4 !== r2.length && 1 !== r2.length)
    throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
  if (1 === r2.length && null == e2)
    throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
  return Sn(t2, e2, r2, n2);
}
function On(t2, e2, n2) {
  if (x(t2), null != e2 && 5 !== e2.length)
    throw new Error("tensor5d() requires shape to have five numbers");
  var r2 = sn(t2, n2);
  if (5 !== r2.length && 1 !== r2.length)
    throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
  if (1 === r2.length && null == e2)
    throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
  return Sn(t2, e2, r2, n2);
}
function _n(t2, e2, n2) {
  if (x(t2), null != e2 && 6 !== e2.length)
    throw new Error("tensor6d() requires shape to have six numbers");
  var r2 = sn(t2, n2);
  if (6 !== r2.length && 1 !== r2.length)
    throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
  if (1 === r2.length && null == e2)
    throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
  return Sn(t2, e2 = e2 || r2, r2, n2);
}
function Mn(t2, e2, n2, r2) {
  return void 0 === e2 && (e2 = true), Nt.makeVariable(t2, e2, n2, r2);
}
function Bn(t2, e2) {
  if (void 0 === e2 && (e2 = "float32"), "complex64" === e2) {
    var n2 = Bn(t2, "float32"), r2 = Pn(t2, "float32");
    return En(n2, r2);
  }
  var o2 = X(w(t2), e2);
  return Nt.makeTensor(o2, t2, e2);
}
function Pn(t2, e2) {
  if (void 0 === e2 && (e2 = "float32"), "complex64" === e2) {
    var n2 = Pn(t2, "float32"), r2 = Pn(t2, "float32");
    return En(n2, r2);
  }
  var o2 = $(w(t2), e2);
  return Nt.makeTensor(o2, t2, e2);
}
function Ln(t2, e2, n2) {
  return Nt.runKernelFunc(function(r2) {
    return r2.fill(t2, e2, n2);
  }, {});
}
function Wn(t2, e2, n2) {
  if (n2 <= 0)
    throw new Error("The number of values should be positive.");
  return Nt.runKernelFunc(function(r2) {
    return r2.linspace(t2, e2, n2);
  }, {});
}
function Un(t2, e2, n2, r2) {
  if (void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = "float32"), 0 === n2)
    throw new Error("Cannot have a step of zero");
  if (t2 === e2 || t2 < e2 && n2 < 0 || e2 < t2 && n2 > 1)
    return Pn([0], r2);
  var o2 = $(Math.abs(Math.ceil((e2 - t2) / n2)), r2);
  e2 < t2 && 1 === n2 && (n2 = -1), o2[0] = t2;
  for (var a2 = 1; a2 < o2.length; a2++)
    o2[a2] = o2[a2 - 1] + n2;
  return Dn(o2, r2);
}
var Vn = Cn({onesLike_: function(t2) {
  var e2 = ln(t2, "x", "onesLike");
  if ("complex64" === e2.dtype) {
    var n2 = Vn(Rn(e2)), r2 = zn(In(e2));
    return En(n2, r2);
  }
  return Nt.runKernelFunc(function(t3) {
    return t3.onesLike(e2);
  }, {$x: e2}, function(t3, e3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var zn = Cn({zerosLike_: function(t2) {
  var e2 = ln(t2, "x", "zerosLike");
  return Nt.runKernelFunc(function(t3) {
    return t3.zerosLike(e2);
  }, {$x: e2}, function(t3, e3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var Gn = Cn({concat_: function(t2, e2) {
  void 0 === e2 && (e2 = 0), g(t2.length >= 1, function() {
    return "Pass at least one tensor to concat";
  });
  var n2 = hn(t2, "tensors", "concat");
  "complex64" === n2[0].dtype && n2.forEach(function(t3) {
    if ("complex64" !== t3.dtype)
      throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype " + t3.dtype + ". ");
  }), e2 = D(e2, n2[0].shape)[0];
  var r2 = wn(n2.map(function(t3) {
    return t3.shape;
  }), e2);
  if (0 === w(r2))
    return kn([], r2);
  if (1 === (n2 = n2.filter(function(t3) {
    return t3.size > 0;
  })).length)
    return n2[0];
  var o2 = n2.map(function(t3) {
    return t3.shape;
  });
  bn(o2, e2);
  var a2 = n2, i2 = {axis: e2};
  return Nt.runKernelFunc(function(t3) {
    return t3.concat(n2, e2);
  }, a2, function(t3) {
    var n3 = o2.map(function(t4) {
      return t4[e2];
    });
    return Xn(t3, n3, e2).map(function(t4) {
      return function() {
        return t4;
      };
    });
  }, "Concat", i2);
}});
var Hn = Cn({concat1d_: function(t2) {
  return Gn(t2, 0);
}});
var qn = Cn({concat2d_: function(t2, e2) {
  return Gn(t2, e2);
}});
var Kn = Cn({concat3d_: function(t2, e2) {
  return Gn(t2, e2);
}});
var jn = Cn({concat4d_: function(t2, e2) {
  return Gn(t2, e2);
}});
var Xn = Cn({split_: function(t2, e2, n2) {
  void 0 === n2 && (n2 = 0);
  var r2, o2 = ln(t2, "x", "split");
  return n2 = D(n2, o2.shape)[0], "number" == typeof e2 ? (g(o2.shape[n2] % e2 == 0, function() {
    return "Number of splits must evenly divide the axis.";
  }), r2 = new Array(e2).fill(o2.shape[n2] / e2)) : (g(o2.shape[n2] === e2.reduce(function(t3, e3) {
    return t3 + e3;
  }), function() {
    return "The sum of sizes must match the size of the axis dimension.";
  }), r2 = e2), Nt.runKernelFunc(function(t3) {
    return t3.split(o2, r2, n2);
  }, {$x: o2}, function(t3) {
    return {$x: function() {
      return Gn(t3, n2);
    }};
  });
}});
"undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self;
function $n(t2, e2) {
  return t2(e2 = {exports: {}}, e2.exports), e2.exports;
}
var Yn = $n(function(t2) {
  !function(t3, e2, n2) {
    function r2(t4) {
      var e3, n3 = this, r3 = (e3 = 4022871197, function(t5) {
        t5 = t5.toString();
        for (var n4 = 0; n4 < t5.length; n4++) {
          var r4 = 0.02519603282416938 * (e3 += t5.charCodeAt(n4));
          r4 -= e3 = r4 >>> 0, e3 = (r4 *= e3) >>> 0, e3 += 4294967296 * (r4 -= e3);
        }
        return 23283064365386963e-26 * (e3 >>> 0);
      });
      n3.next = function() {
        var t5 = 2091639 * n3.s0 + 23283064365386963e-26 * n3.c;
        return n3.s0 = n3.s1, n3.s1 = n3.s2, n3.s2 = t5 - (n3.c = 0 | t5);
      }, n3.c = 1, n3.s0 = r3(" "), n3.s1 = r3(" "), n3.s2 = r3(" "), n3.s0 -= r3(t4), n3.s0 < 0 && (n3.s0 += 1), n3.s1 -= r3(t4), n3.s1 < 0 && (n3.s1 += 1), n3.s2 -= r3(t4), n3.s2 < 0 && (n3.s2 += 1), r3 = null;
    }
    function o2(t4, e3) {
      return e3.c = t4.c, e3.s0 = t4.s0, e3.s1 = t4.s1, e3.s2 = t4.s2, e3;
    }
    function a2(t4, e3) {
      var n3 = new r2(t4), a3 = e3 && e3.state, i2 = n3.next;
      return i2.int32 = function() {
        return 4294967296 * n3.next() | 0;
      }, i2.double = function() {
        return i2() + 11102230246251565e-32 * (2097152 * i2() | 0);
      }, i2.quick = i2, a3 && ("object" == typeof a3 && o2(a3, n3), i2.state = function() {
        return o2(n3, {});
      }), i2;
    }
    e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
      return a2;
    }) : this.alea = a2;
  }(0, t2, false);
});
var Qn = $n(function(t2) {
  !function(t3, e2, n2) {
    function r2(t4) {
      var e3 = this, n3 = "";
      e3.x = 0, e3.y = 0, e3.z = 0, e3.w = 0, e3.next = function() {
        var t5 = e3.x ^ e3.x << 11;
        return e3.x = e3.y, e3.y = e3.z, e3.z = e3.w, e3.w ^= e3.w >>> 19 ^ t5 ^ t5 >>> 8;
      }, t4 === (0 | t4) ? e3.x = t4 : n3 += t4;
      for (var r3 = 0; r3 < n3.length + 64; r3++)
        e3.x ^= 0 | n3.charCodeAt(r3), e3.next();
    }
    function o2(t4, e3) {
      return e3.x = t4.x, e3.y = t4.y, e3.z = t4.z, e3.w = t4.w, e3;
    }
    function a2(t4, e3) {
      var n3 = new r2(t4), a3 = e3 && e3.state, i2 = function() {
        return (n3.next() >>> 0) / 4294967296;
      };
      return i2.double = function() {
        do {
          var t5 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t5);
        return t5;
      }, i2.int32 = n3.next, i2.quick = i2, a3 && ("object" == typeof a3 && o2(a3, n3), i2.state = function() {
        return o2(n3, {});
      }), i2;
    }
    e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
      return a2;
    }) : this.xor128 = a2;
  }(0, t2, false);
});
var Jn = $n(function(t2) {
  !function(t3, e2, n2) {
    function r2(t4) {
      var e3 = this, n3 = "";
      e3.next = function() {
        var t5 = e3.x ^ e3.x >>> 2;
        return e3.x = e3.y, e3.y = e3.z, e3.z = e3.w, e3.w = e3.v, (e3.d = e3.d + 362437 | 0) + (e3.v = e3.v ^ e3.v << 4 ^ t5 ^ t5 << 1) | 0;
      }, e3.x = 0, e3.y = 0, e3.z = 0, e3.w = 0, e3.v = 0, t4 === (0 | t4) ? e3.x = t4 : n3 += t4;
      for (var r3 = 0; r3 < n3.length + 64; r3++)
        e3.x ^= 0 | n3.charCodeAt(r3), r3 == n3.length && (e3.d = e3.x << 10 ^ e3.x >>> 4), e3.next();
    }
    function o2(t4, e3) {
      return e3.x = t4.x, e3.y = t4.y, e3.z = t4.z, e3.w = t4.w, e3.v = t4.v, e3.d = t4.d, e3;
    }
    function a2(t4, e3) {
      var n3 = new r2(t4), a3 = e3 && e3.state, i2 = function() {
        return (n3.next() >>> 0) / 4294967296;
      };
      return i2.double = function() {
        do {
          var t5 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t5);
        return t5;
      }, i2.int32 = n3.next, i2.quick = i2, a3 && ("object" == typeof a3 && o2(a3, n3), i2.state = function() {
        return o2(n3, {});
      }), i2;
    }
    e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
      return a2;
    }) : this.xorwow = a2;
  }(0, t2, false);
});
var Zn = $n(function(t2) {
  !function(t3, e2, n2) {
    function r2(t4) {
      var e3 = this;
      e3.next = function() {
        var t5, n3, r3 = e3.x, o3 = e3.i;
        return t5 = r3[o3], n3 = (t5 ^= t5 >>> 7) ^ t5 << 24, n3 ^= (t5 = r3[o3 + 1 & 7]) ^ t5 >>> 10, n3 ^= (t5 = r3[o3 + 3 & 7]) ^ t5 >>> 3, n3 ^= (t5 = r3[o3 + 4 & 7]) ^ t5 << 7, t5 = r3[o3 + 7 & 7], n3 ^= (t5 ^= t5 << 13) ^ t5 << 9, r3[o3] = n3, e3.i = o3 + 1 & 7, n3;
      }, function(t5, e4) {
        var n3, r3 = [];
        if (e4 === (0 | e4))
          r3[0] = e4;
        else
          for (e4 = "" + e4, n3 = 0; n3 < e4.length; ++n3)
            r3[7 & n3] = r3[7 & n3] << 15 ^ e4.charCodeAt(n3) + r3[n3 + 1 & 7] << 13;
        for (; r3.length < 8; )
          r3.push(0);
        for (n3 = 0; n3 < 8 && 0 === r3[n3]; ++n3)
          ;
        for (8 == n3 ? r3[7] = -1 : r3[n3], t5.x = r3, t5.i = 0, n3 = 256; n3 > 0; --n3)
          t5.next();
      }(e3, t4);
    }
    function o2(t4, e3) {
      return e3.x = t4.x.slice(), e3.i = t4.i, e3;
    }
    function a2(t4, e3) {
      null == t4 && (t4 = +new Date());
      var n3 = new r2(t4), a3 = e3 && e3.state, i2 = function() {
        return (n3.next() >>> 0) / 4294967296;
      };
      return i2.double = function() {
        do {
          var t5 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t5);
        return t5;
      }, i2.int32 = n3.next, i2.quick = i2, a3 && (a3.x && o2(a3, n3), i2.state = function() {
        return o2(n3, {});
      }), i2;
    }
    e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
      return a2;
    }) : this.xorshift7 = a2;
  }(0, t2, false);
});
var tr = $n(function(t2) {
  !function(t3, e2, n2) {
    function r2(t4) {
      var e3 = this;
      e3.next = function() {
        var t5, n3, r3 = e3.w, o3 = e3.X, a3 = e3.i;
        return e3.w = r3 = r3 + 1640531527 | 0, n3 = o3[a3 + 34 & 127], t5 = o3[a3 = a3 + 1 & 127], n3 ^= n3 << 13, t5 ^= t5 << 17, n3 ^= n3 >>> 15, t5 ^= t5 >>> 12, n3 = o3[a3] = n3 ^ t5, e3.i = a3, n3 + (r3 ^ r3 >>> 16) | 0;
      }, function(t5, e4) {
        var n3, r3, o3, a3, i2, u2 = [], s2 = 128;
        for (e4 === (0 | e4) ? (r3 = e4, e4 = null) : (e4 += "\0", r3 = 0, s2 = Math.max(s2, e4.length)), o3 = 0, a3 = -32; a3 < s2; ++a3)
          e4 && (r3 ^= e4.charCodeAt((a3 + 32) % e4.length)), 0 === a3 && (i2 = r3), r3 ^= r3 << 10, r3 ^= r3 >>> 15, r3 ^= r3 << 4, r3 ^= r3 >>> 13, a3 >= 0 && (i2 = i2 + 1640531527 | 0, o3 = 0 == (n3 = u2[127 & a3] ^= r3 + i2) ? o3 + 1 : 0);
        for (o3 >= 128 && (u2[127 & (e4 && e4.length || 0)] = -1), o3 = 127, a3 = 512; a3 > 0; --a3)
          r3 = u2[o3 + 34 & 127], n3 = u2[o3 = o3 + 1 & 127], r3 ^= r3 << 13, n3 ^= n3 << 17, r3 ^= r3 >>> 15, n3 ^= n3 >>> 12, u2[o3] = r3 ^ n3;
        t5.w = i2, t5.X = u2, t5.i = o3;
      }(e3, t4);
    }
    function o2(t4, e3) {
      return e3.i = t4.i, e3.w = t4.w, e3.X = t4.X.slice(), e3;
    }
    function a2(t4, e3) {
      null == t4 && (t4 = +new Date());
      var n3 = new r2(t4), a3 = e3 && e3.state, i2 = function() {
        return (n3.next() >>> 0) / 4294967296;
      };
      return i2.double = function() {
        do {
          var t5 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t5);
        return t5;
      }, i2.int32 = n3.next, i2.quick = i2, a3 && (a3.X && o2(a3, n3), i2.state = function() {
        return o2(n3, {});
      }), i2;
    }
    e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
      return a2;
    }) : this.xor4096 = a2;
  }(0, t2, false);
});
var er = $n(function(t2) {
  !function(t3, e2, n2) {
    function r2(t4) {
      var e3 = this, n3 = "";
      e3.next = function() {
        var t5 = e3.b, n4 = e3.c, r4 = e3.d, o3 = e3.a;
        return t5 = t5 << 25 ^ t5 >>> 7 ^ n4, n4 = n4 - r4 | 0, r4 = r4 << 24 ^ r4 >>> 8 ^ o3, o3 = o3 - t5 | 0, e3.b = t5 = t5 << 20 ^ t5 >>> 12 ^ n4, e3.c = n4 = n4 - r4 | 0, e3.d = r4 << 16 ^ n4 >>> 16 ^ o3, e3.a = o3 - t5 | 0;
      }, e3.a = 0, e3.b = 0, e3.c = -1640531527, e3.d = 1367130551, t4 === Math.floor(t4) ? (e3.a = t4 / 4294967296 | 0, e3.b = 0 | t4) : n3 += t4;
      for (var r3 = 0; r3 < n3.length + 20; r3++)
        e3.b ^= 0 | n3.charCodeAt(r3), e3.next();
    }
    function o2(t4, e3) {
      return e3.a = t4.a, e3.b = t4.b, e3.c = t4.c, e3.d = t4.d, e3;
    }
    function a2(t4, e3) {
      var n3 = new r2(t4), a3 = e3 && e3.state, i2 = function() {
        return (n3.next() >>> 0) / 4294967296;
      };
      return i2.double = function() {
        do {
          var t5 = ((n3.next() >>> 11) + (n3.next() >>> 0) / 4294967296) / (1 << 21);
        } while (0 === t5);
        return t5;
      }, i2.int32 = n3.next, i2.quick = i2, a3 && ("object" == typeof a3 && o2(a3, n3), i2.state = function() {
        return o2(n3, {});
      }), i2;
    }
    e2 && e2.exports ? e2.exports = a2 : n2 && n2.amd ? n2(function() {
      return a2;
    }) : this.tychei = a2;
  }(0, t2, false);
});
var nr = $n(function(t2) {
  !function(e2, n2) {
    var r2, o2 = this, a2 = 256, i2 = 6, u2 = "random", s2 = n2.pow(a2, i2), c2 = n2.pow(2, 52), l2 = 2 * c2, h2 = a2 - 1;
    function f2(t3, h3, f3) {
      var g2 = [], y2 = v2(function t4(e3, n3) {
        var r3, o3 = [], a3 = typeof e3;
        if (n3 && "object" == a3)
          for (r3 in e3)
            try {
              o3.push(t4(e3[r3], n3 - 1));
            } catch (t5) {
            }
        return o3.length ? o3 : "string" == a3 ? e3 : e3 + "\0";
      }((h3 = 1 == h3 ? {entropy: true} : h3 || {}).entropy ? [t3, m2(e2)] : null == t3 ? function() {
        try {
          var t4;
          return r2 && (t4 = r2.randomBytes) ? t4 = t4(a2) : (t4 = new Uint8Array(a2), (o2.crypto || o2.msCrypto).getRandomValues(t4)), m2(t4);
        } catch (t5) {
          var n3 = o2.navigator, i3 = n3 && n3.plugins;
          return [+new Date(), o2, i3, o2.screen, m2(e2)];
        }
      }() : t3, 3), g2), x2 = new p2(g2), b2 = function() {
        for (var t4 = x2.g(i2), e3 = s2, n3 = 0; t4 < c2; )
          t4 = (t4 + n3) * a2, e3 *= a2, n3 = x2.g(1);
        for (; t4 >= l2; )
          t4 /= 2, e3 /= 2, n3 >>>= 1;
        return (t4 + n3) / e3;
      };
      return b2.int32 = function() {
        return 0 | x2.g(4);
      }, b2.quick = function() {
        return x2.g(4) / 4294967296;
      }, b2.double = b2, v2(m2(x2.S), e2), (h3.pass || f3 || function(t4, e3, r3, o3) {
        return o3 && (o3.S && d2(o3, x2), t4.state = function() {
          return d2(x2, {});
        }), r3 ? (n2[u2] = t4, e3) : t4;
      })(b2, y2, "global" in h3 ? h3.global : this == n2, h3.state);
    }
    function p2(t3) {
      var e3, n3 = t3.length, r3 = this, o3 = 0, i3 = r3.i = r3.j = 0, u3 = r3.S = [];
      for (n3 || (t3 = [n3++]); o3 < a2; )
        u3[o3] = o3++;
      for (o3 = 0; o3 < a2; o3++)
        u3[o3] = u3[i3 = h2 & i3 + t3[o3 % n3] + (e3 = u3[o3])], u3[i3] = e3;
      (r3.g = function(t4) {
        for (var e4, n4 = 0, o4 = r3.i, i4 = r3.j, u4 = r3.S; t4--; )
          e4 = u4[o4 = h2 & o4 + 1], n4 = n4 * a2 + u4[h2 & (u4[o4] = u4[i4 = h2 & i4 + e4]) + (u4[i4] = e4)];
        return r3.i = o4, r3.j = i4, n4;
      })(a2);
    }
    function d2(t3, e3) {
      return e3.i = t3.i, e3.j = t3.j, e3.S = t3.S.slice(), e3;
    }
    function v2(t3, e3) {
      for (var n3, r3 = t3 + "", o3 = 0; o3 < r3.length; )
        e3[h2 & o3] = h2 & (n3 ^= 19 * e3[h2 & o3]) + r3.charCodeAt(o3++);
      return m2(e3);
    }
    function m2(t3) {
      return String.fromCharCode.apply(0, t3);
    }
    if (n2["seed" + u2] = f2, v2(n2.random(), e2), t2.exports) {
      t2.exports = f2;
      try {
        r2 = require("crypto");
      } catch (t3) {
      }
    }
  }([], Math);
});
nr.alea = Yn, nr.xor128 = Qn, nr.xorwow = Jn, nr.xorshift7 = Zn, nr.xor4096 = tr, nr.tychei = er;
var rr = nr.alea;
var or = function() {
  function t2(t3, e2, n2, r2, o2) {
    this.mean = t3, this.stdDev = e2, this.dtype = n2, this.nextVal = NaN, this.truncated = r2, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
    var a2 = o2 || Math.random();
    this.random = rr(a2.toString());
  }
  return t2.prototype.nextValue = function() {
    if (!isNaN(this.nextVal)) {
      var t3 = this.nextVal;
      return this.nextVal = NaN, t3;
    }
    for (var e2, n2, r2 = false; !r2; ) {
      var o2 = void 0, a2 = void 0, i2 = void 0;
      do {
        i2 = (o2 = 2 * this.random() - 1) * o2 + (a2 = 2 * this.random() - 1) * a2;
      } while (i2 >= 1 || 0 === i2);
      var u2 = Math.sqrt(-2 * Math.log(i2) / i2);
      e2 = this.mean + this.stdDev * o2 * u2, n2 = this.mean + this.stdDev * a2 * u2, this.truncated && !this.isValidTruncated(e2) || (r2 = true);
    }
    return this.truncated && !this.isValidTruncated(n2) || (this.nextVal = this.convertValue(n2)), this.convertValue(e2);
  }, t2.prototype.convertValue = function(t3) {
    return null == this.dtype || "float32" === this.dtype ? t3 : Math.round(t3);
  }, t2.prototype.isValidTruncated = function(t3) {
    return t3 <= this.upper && t3 >= this.lower;
  }, t2;
}();
var ar = function() {
  function t2(t3, e2, n2, r2) {
    this.alpha = t3, this.beta = 1 / e2, this.dtype = n2;
    var o2 = r2 || Math.random();
    this.randu = rr(o2.toString()), this.randn = new or(0, 1, n2, false, this.randu()), this.d = t3 < 1 ? t3 + 2 / 3 : t3 - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);
  }
  return t2.prototype.nextValue = function() {
    for (var t3, e2, n2, r2, o2, a2; ; ) {
      do {
        r2 = this.randn.nextValue(), a2 = 1 + this.c * r2;
      } while (a2 <= 0);
      if (a2 *= a2 * a2, e2 = 1 - 0.331 * (t3 = r2 * r2) * t3, n2 = 0.5 * t3 + this.d * (1 - a2 + Math.log(a2)), (o2 = this.randu()) < e2 || Math.log(o2) < n2)
        break;
    }
    return a2 = 1 / this.beta * this.d * a2, this.alpha < 1 && (a2 *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(a2);
  }, t2.prototype.convertValue = function(t3) {
    return "float32" === this.dtype ? t3 : Math.round(t3);
  }, t2;
}();
var ir = function() {
  function t2(t3, e2, n2, r2) {
    var o2 = this;
    if (void 0 === t3 && (t3 = 0), void 0 === e2 && (e2 = 1), this.canReturnFloat = function() {
      return null == o2.dtype || "float32" === o2.dtype;
    }, this.min = t3, this.range = e2 - t3, this.dtype = n2, null == r2 && (r2 = Math.random()), "number" == typeof r2 && (r2 = r2.toString()), !this.canReturnFloat() && this.range <= 1)
      throw new Error("The difference between " + t3 + " - " + e2 + " <= 1 and dtype is not float");
    this.random = rr(r2);
  }
  return t2.prototype.convertValue = function(t3) {
    return this.canReturnFloat() ? t3 : Math.round(t3);
  }, t2.prototype.nextValue = function() {
    return this.convertValue(this.min + this.range * this.random());
  }, t2;
}();
function ur(t2, e2, n2) {
  return void 0 === e2 && (e2 = "float32"), e2 = e2 || "float32", Q(t2), new lt(t2, e2, n2);
}
function sr(t2, e2) {
  void 0 === e2 && (e2 = false), console.log(t2.toString(e2));
}
var cr = Cn({batchToSpaceND_: function(t2, e2, n2) {
  var r2 = ln(t2, "x", "batchToSpaceND"), o2 = e2.reduce(function(t3, e3) {
    return t3 * e3;
  });
  return g(r2.rank >= 1 + e2.length, function() {
    return "input rank is " + r2.rank + " but should be > than blockShape.length " + e2.length;
  }), g(n2.length === e2.length, function() {
    return "crops.length is " + n2.length + " but should be equal to blockShape.length  " + e2.length;
  }), g(r2.shape[0] % o2 == 0, function() {
    return "input tensor batch is " + r2.shape[0] + " but is not divisible by the product of the elements of blockShape " + e2.join(" * ") + " === " + o2;
  }), Nt.runKernelFunc(function(t3) {
    return t3.batchToSpaceND(r2, e2, n2);
  }, {$x: r2}, function(t3) {
    return {$x: function() {
      return t3.spaceToBatchND(e2, n2);
    }};
  });
}});
var lr = Cn({cast_: function(t2, e2) {
  var n2 = ln(t2, "x", "cast");
  if (!_(e2))
    throw new Error("Failed to cast to unknown dtype " + e2);
  if ("string" === e2 && "string" !== n2.dtype || "string" !== e2 && "string" === n2.dtype)
    throw new Error("Only strings can be casted to strings");
  var r2 = {dtype: e2};
  return Nt.runKernelFunc(function(t3) {
    return t3.cast(n2, e2);
  }, {x: n2}, function(t3) {
    return {x: function() {
      return t3.clone();
    }};
  }, "Cast", r2);
}});
var hr = Cn({clone_: function(t2) {
  var e2 = ln(t2, "x", "clone", null);
  return Nt.runKernelFunc(function() {
    return Nt.makeTensorFromDataId(e2.dataId, e2.shape, e2.dtype);
  }, {$x: e2}, function(t3) {
    return {$x: function() {
      return t3.toFloat();
    }};
  });
}});
var fr = Cn({cumsum_: function(t2, e2, n2, r2) {
  void 0 === e2 && (e2 = 0), void 0 === n2 && (n2 = false), void 0 === r2 && (r2 = false);
  var o2 = ln(t2, "x", "cumsum"), a2 = gn([e2 |= 0], o2.rank), i2 = o2;
  null != a2 && (i2 = o2.transpose(a2));
  var u2 = xn(1, o2.rank)[0], s2 = Nt.runKernelFunc(function(t3) {
    return t3.cumsum(i2, u2, n2, r2);
  }, {permutedX: i2}, function(t3) {
    return {permutedX: function() {
      return t3.cumsum(e2, n2, !r2);
    }};
  });
  return null != a2 && (s2 = s2.transpose(a2)), s2;
}});
var pr = Cn({depthToSpace_: function(t2, e2, n2) {
  void 0 === n2 && (n2 = "NHWC");
  var r2 = ln(t2, "x", "depthToSpace"), o2 = "NHWC" === n2 ? r2.shape[1] : r2.shape[2], a2 = "NHWC" === n2 ? r2.shape[2] : r2.shape[3], i2 = "NHWC" === n2 ? r2.shape[3] : r2.shape[1];
  return g(o2 * e2 >= 0, function() {
    return "Negative dimension size caused by overflow when multiplying\n      " + o2 + " and " + e2 + "  for depthToSpace with input shape\n      " + r2.shape;
  }), g(a2 * e2 >= 0, function() {
    return "Negative dimension size caused by overflow when multiplying\n      " + a2 + " and " + e2 + " for depthToSpace with input shape\n          " + r2.shape;
  }), g(i2 % (e2 * e2) == 0, function() {
    return "Dimension size must be evenly divisible by " + e2 * e2 + " but is " + i2 + " for depthToSpace with input shape " + r2.shape;
  }), Nt.runKernelFunc(function(t3) {
    return t3.depthToSpace(r2, e2, n2);
  }, {$x: r2});
}});
var dr = Cn({expandDims_: function(t2, e2) {
  void 0 === e2 && (e2 = 0);
  var n2 = ln(t2, "x", "expandDims", null);
  g(e2 <= n2.rank, function() {
    return "Axis must be <= rank of the tensor";
  });
  var r2 = n2.shape.slice();
  return e2 < 0 && (g(-(n2.rank + 1) <= e2, function() {
    return "Axis must be in the interval [" + -(n2.rank + 1) + ", " + n2.rank + "]";
  }), e2 = n2.rank + e2 + 1), r2.splice(e2, 0, 1), Sr(n2, r2);
}});
var vr = Cn({eye_: function(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = "float32"), null == e2 && (e2 = t2);
  for (var o2 = ur([t2, e2], r2), a2 = t2 <= e2 ? t2 : e2, i2 = 0; i2 < a2; ++i2)
    o2.set(1, i2, i2);
  var u2 = o2.toTensor().as2D(t2, e2);
  if (null == n2)
    return u2;
  if (1 === n2.length)
    return Nr(dr(u2, 0), [n2[0], 1, 1]);
  if (2 === n2.length)
    return Nr(dr(dr(u2, 0), 0), [n2[0], n2[1], 1, 1]);
  if (3 === n2.length)
    return Nr(dr(dr(dr(u2, 0), 0), 0), [n2[0], n2[1], n2[2], 1, 1]);
  throw new Error("eye() currently supports only 1D and 2D batchShapes, but received " + n2.length + "D.");
}});
var mr = Cn({multinomial_: function(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = false);
  var o2 = ln(t2, "logits", "multinomial"), a2 = o2.size, i2 = o2.rank;
  if (a2 < 2)
    throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + a2 + ".");
  if (i2 > 2)
    throw new Error("Rank of probabilities must be 1 or 2, but is " + i2);
  n2 = n2 || Math.random();
  var u2 = 1 === i2 ? o2.as2D(1, -1) : o2, s2 = Nt.runKernelFunc(function(t3) {
    return t3.multinomial(u2, r2, e2, n2);
  }, {logits2D: u2});
  return 1 === i2 ? s2.as1D() : s2;
}});
var gr = Cn({oneHot_: function(t2, e2, n2, r2) {
  if (void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = 0), e2 < 2)
    throw new Error("Error in oneHot: depth must be >=2, but it is " + e2);
  var o2 = ln(t2, "indices", "oneHot", "int32"), a2 = o2.shape.concat([e2]);
  return o2 = o2.flatten(), Nt.runKernelFunc(function(t3) {
    return t3.oneHot(o2, e2, n2, r2);
  }, {$indices: o2}, function(t3) {
    return {$indices: function() {
      return Pn(o2.shape, "float32");
    }};
  }).reshape(a2);
}});
var yr = Cn({pad_: function(t2, e2, n2) {
  void 0 === n2 && (n2 = 0);
  var r2 = ln(t2, "x", "pad");
  if (0 === r2.rank)
    throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
  var o2 = e2.map(function(t3) {
    return t3[0];
  });
  return Nt.runKernelFunc(function(t3) {
    return t3.pad(r2, e2, n2);
  }, {$x: r2}, function(t3) {
    return {$x: function() {
      return t3.slice(o2, r2.shape);
    }};
  });
}});
var xr = Cn({pad1d_: function(t2, e2, n2) {
  return void 0 === n2 && (n2 = 0), g(2 === e2.length, function() {
    return "Invalid number of paddings. Must be length of 2.";
  }), yr(t2, [e2], n2);
}});
var br = Cn({pad2d_: function(t2, e2, n2) {
  return void 0 === n2 && (n2 = 0), g(2 === e2.length && 2 === e2[0].length && 2 === e2[1].length, function() {
    return "Invalid number of paddings. Must be length of 2 each.";
  }), yr(t2, e2, n2);
}});
var wr = Cn({pad3d_: function(t2, e2, n2) {
  return void 0 === n2 && (n2 = 0), g(3 === e2.length && 2 === e2[0].length && 2 === e2[1].length && 2 === e2[2].length, function() {
    return "Invalid number of paddings. Must be length of 2 each.";
  }), yr(t2, e2, n2);
}});
var Cr = Cn({pad4d_: function(t2, e2, n2) {
  return void 0 === n2 && (n2 = 0), g(4 === e2.length && 2 === e2[0].length && 2 === e2[1].length && 2 === e2[2].length && 2 === e2[3].length, function() {
    return "Invalid number of paddings. Must be length of 2 each.";
  }), yr(t2, e2, n2);
}});
var Er = Cn({rand_: function(t2, e2, n2) {
  var r2 = w(t2), o2 = null;
  if (null == n2 || "float32" === n2)
    o2 = new Float32Array(r2);
  else if ("int32" === n2)
    o2 = new Int32Array(r2);
  else {
    if ("bool" !== n2)
      throw new Error("Unknown data type " + n2);
    o2 = new Uint8Array(r2);
  }
  for (var a2 = 0; a2 < r2; a2++)
    o2[a2] = e2();
  return Nt.makeTensor(o2, t2, n2);
}});
var Rr = Cn({randomNormal_: function(t2, e2, n2, r2, o2) {
  if (void 0 === e2 && (e2 = 0), void 0 === n2 && (n2 = 1), null != r2 && "bool" === r2)
    throw new Error("Unsupported data type " + r2);
  for (var a2 = new or(e2, n2, r2, false, o2), i2 = ur(t2, r2), u2 = 0; u2 < i2.values.length; u2++)
    i2.values[u2] = a2.nextValue();
  return i2.toTensor();
}});
var Ir = Cn({randomGamma_: function(t2, e2, n2, r2, o2) {
  if (void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = "float32"), null == n2 && (n2 = 1), null == r2 && (r2 = "float32"), "float32" !== r2 && "int32" !== r2)
    throw new Error("Unsupported data type " + r2);
  for (var a2 = new ar(e2, n2, r2, o2), i2 = ur(t2, r2), u2 = 0; u2 < i2.values.length; u2++)
    i2.values[u2] = a2.nextValue();
  return i2.toTensor();
}});
var kr = Cn({randomUniform_: function(t2, e2, n2, r2, o2) {
  void 0 === e2 && (e2 = 0), void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = "float32");
  for (var a2 = ur(t2, r2), i2 = new ir(e2, n2, null, o2), u2 = 0; u2 < a2.values.length; u2++)
    a2.values[u2] = i2.nextValue();
  return a2.toTensor();
}});
var Sr = Cn({reshape_: function(t2, e2) {
  var n2 = ln(t2, "x", "reshape", null);
  e2 = A(e2, n2.size), g(n2.size === w(e2), function() {
    return "new shape and old shape must have the same number of elements.";
  });
  var r2 = {shape: e2};
  return Nt.runKernelFunc(function(t3) {
    return t3.reshape(n2, e2);
  }, {x: n2}, function(t3) {
    return {x: function() {
      return t3.reshape(n2.shape);
    }};
  }, "Reshape", r2);
}});
var Ar = Cn({spaceToBatchND_: function(t2, e2, n2) {
  var r2 = ln(t2, "x", "spaceToBatchND");
  return g(r2.rank >= 1 + e2.length, function() {
    return "input rank " + r2.rank + " should be > than [blockShape] " + e2.length;
  }), g(n2.length === e2.length, function() {
    return "paddings.shape[0] " + n2.length + " must be equal to [blockShape] " + e2.length;
  }), g(r2.shape.reduce(function(t3, r3, o2) {
    return o2 > 0 && o2 <= e2.length ? t3 && (r3 + n2[o2 - 1][0] + n2[o2 - 1][1]) % e2[o2 - 1] == 0 : t3;
  }, true), function() {
    return "input spatial dimensions " + r2.shape.slice(1) + " with paddings " + n2.toString() + " must be divisible by blockShapes " + e2.toString();
  }), Nt.runKernelFunc(function(t3) {
    return t3.spaceToBatchND(r2, e2, n2);
  }, {$x: r2}, function(t3) {
    return {$x: function() {
      return t3.batchToSpaceND(e2, n2);
    }};
  });
}});
var Dr = Cn({squeeze_: function(t2, e2) {
  var n2 = ln(t2, "x", "squeeze");
  return Sr(n2, T(n2.shape, e2).newShape);
}});
var Tr = Cn({stack_: function(t2, e2) {
  void 0 === e2 && (e2 = 0);
  var n2 = hn(t2, "tensors", "stack");
  if (g(n2.length >= 1, function() {
    return "Pass at least one tensor to tf.stack";
  }), 1 === n2.length)
    return n2[0].expandDims(e2);
  var r2 = n2[0].rank, o2 = n2[0].shape, a2 = n2[0].dtype;
  g(e2 <= r2, function() {
    return "Axis must be <= rank of the tensor";
  }), n2.forEach(function(t3) {
    y(o2, t3.shape, "All tensors passed to stack must have matching shapes");
  }), n2.forEach(function(t3) {
    g(a2 === t3.dtype, function() {
      return "All tensors passed to stack must have matching dtypes";
    });
  });
  var i2 = n2.map(function(t3) {
    return t3.expandDims(e2);
  });
  return Gn(i2, e2);
}});
var Nr = Cn({tile_: function(t2, e2) {
  var n2 = ln(t2, "x", "tile", null);
  return g(n2.rank === e2.length, function() {
    return "Error in transpose: rank of input " + n2.rank + " must match length of reps " + e2 + ".";
  }), Nt.runKernelFunc(function(t3, r2) {
    var o2 = t3.tile(n2, e2);
    return r2([n2]), o2;
  }, {$x: n2}, function(t3, n3) {
    var r2 = n3[0];
    return {$x: function() {
      var n4 = zn(r2);
      if (1 === r2.rank)
        for (var o2 = 0; o2 < e2[0]; ++o2)
          n4 = n4.add(t3.slice([o2 * r2.shape[0]], [r2.shape[0]]));
      else if (2 === r2.rank)
        for (o2 = 0; o2 < e2[0]; ++o2)
          for (var a2 = 0; a2 < e2[1]; ++a2)
            n4 = n4.add(t3.slice([o2 * r2.shape[0], a2 * r2.shape[1]], [r2.shape[0], r2.shape[1]]));
      else if (3 === r2.rank)
        for (o2 = 0; o2 < e2[0]; ++o2)
          for (a2 = 0; a2 < e2[1]; ++a2)
            for (var i2 = 0; i2 < e2[2]; ++i2)
              n4 = n4.add(t3.slice([o2 * r2.shape[0], a2 * r2.shape[1], i2 * r2.shape[2]], [r2.shape[0], r2.shape[1], r2.shape[2]]));
      else {
        if (4 !== r2.rank)
          throw new Error("Gradient for tile operation is not implemented for rank-" + r2.rank + " tensors yet.");
        for (o2 = 0; o2 < e2[0]; ++o2)
          for (a2 = 0; a2 < e2[1]; ++a2)
            for (i2 = 0; i2 < e2[2]; ++i2)
              for (var u2 = 0; u2 < e2[3]; ++u2)
                n4 = n4.add(t3.slice([o2 * r2.shape[0], a2 * r2.shape[1], i2 * r2.shape[2], u2 * r2.shape[3]], [r2.shape[0], r2.shape[1], r2.shape[2], r2.shape[3]]));
      }
      return n4;
    }};
  });
}});
var Fr = Cn({truncatedNormal_: function(t2, e2, n2, r2, o2) {
  if (void 0 === e2 && (e2 = 0), void 0 === n2 && (n2 = 1), null != r2 && "bool" === r2)
    throw new Error("Unsupported data type " + r2);
  for (var a2 = new or(e2, n2, r2, true, o2), i2 = ur(t2, r2), u2 = 0; u2 < i2.values.length; u2++)
    i2.values[u2] = a2.nextValue();
  return i2.toTensor();
}});
var Or = Cn({unstack_: function(t2, e2) {
  void 0 === e2 && (e2 = 0), e2 = e2 || 0;
  var n2 = ln(t2, "x", "unstack");
  return g(e2 >= -n2.shape.length && e2 < n2.shape.length, function() {
    return "Axis = " + e2 + " is not in [-" + n2.shape.length + ", " + n2.shape.length + ")";
  }), e2 < 0 && (e2 += n2.shape.length), Nt.runKernelFunc(function(t3) {
    return t3.unstack(n2, e2);
  }, {$x: n2}, function(t3) {
    return {$x: function() {
      return Tr(t3, e2);
    }};
  });
}});
var _r = function(t2, e2) {
  return n(this, void 0, void 0, function() {
    var n2, o2, a2, i2, u2, s2, c2, l2, h2, f2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          return n2 = ln(t2, "x", "setdiff1d"), o2 = ln(e2, "y", "setdiff1d"), g(n2.dtype === o2.dtype, function() {
            return "x and y should have the same dtype, but got x (" + n2.dtype + ") and y (" + o2.dtype + ").";
          }), g(1 === n2.rank, function() {
            return "x should be 1D tensor, but got x (" + n2.shape + ").";
          }), g(1 === o2.rank, function() {
            return "y should be 1D tensor, but got y (" + o2.shape + ").";
          }), [4, n2.data()];
        case 1:
          return a2 = r2.sent(), [4, o2.data()];
        case 2:
          for (i2 = r2.sent(), u2 = new Set(i2), s2 = 0, h2 = 0; h2 < a2.length; h2++)
            u2.has(a2[h2]) || s2++;
          for (c2 = new lt([s2], n2.dtype), l2 = new lt([s2], "int32"), h2 = 0, f2 = 0; h2 < a2.length; h2++)
            u2.has(a2[h2]) || (c2.values[f2] = a2[h2], l2.values[f2] = h2, f2++);
          return [2, [c2.toTensor(), l2.toTensor()]];
      }
    });
  });
};
function Mr(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = true);
  var o2 = [];
  if (r2)
    (o2 = o2.concat(e2.slice(0))).push(t2[0] / n2), o2 = o2.concat(t2.slice(1));
  else {
    o2 = o2.concat(t2[0]);
    for (var a2 = e2.length, i2 = 0; i2 < a2; ++i2)
      o2 = o2.concat([t2[i2 + 1] / e2[i2], e2[i2]]);
    o2 = o2.concat(t2.slice(a2 + 1));
  }
  return o2;
}
function Br(t2, e2, n2) {
  void 0 === n2 && (n2 = true);
  var r2 = [];
  if (n2) {
    r2.push(e2);
    for (var o2 = e2 + 1; o2 < t2; ++o2)
      o2 <= 2 * e2 ? (r2.push(o2), r2.push(o2 - (e2 + 1))) : r2.push(o2);
  } else {
    var a2 = [], i2 = [];
    for (o2 = 1; o2 < t2; ++o2)
      o2 >= 2 * e2 + 1 || o2 % 2 == 1 ? i2.push(o2) : a2.push(o2);
    r2.push.apply(r2, a2), r2.push(0), r2.push.apply(r2, i2);
  }
  return r2;
}
function Pr(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = true);
  var o2 = [];
  r2 ? o2.push(t2[0] / n2) : o2.push(t2[0] * n2);
  for (var a2 = 1; a2 < t2.length; ++a2)
    a2 <= e2.length ? r2 ? o2.push(e2[a2 - 1] * t2[a2]) : o2.push(t2[a2] / e2[a2 - 1]) : o2.push(t2[a2]);
  return o2;
}
function Lr(t2, e2) {
  for (var n2 = [0], r2 = 0; r2 < e2; ++r2)
    n2.push(t2[r2][0]);
  return n2;
}
function Wr(t2, e2, n2) {
  for (var r2 = t2.slice(0, 1), o2 = 0; o2 < n2; ++o2)
    r2.push(t2[o2 + 1] - e2[o2][0] - e2[o2][1]);
  return r2;
}
function Ur(t2, e2) {
  if (t2.rank < 1)
    throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was " + t2.rank + ".");
  if (e2.rank < 1)
    throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was " + e2.rank + ".");
  if ("int32" !== e2.dtype)
    throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was " + e2.dtype + ".");
  if (e2.shape[e2.rank - 1] > t2.rank)
    throw new Error("index innermost dimension length must be <= tensor rank; saw: " + e2.shape[e2.rank - 1] + " vs. " + t2.rank);
  if (0 === t2.size)
    throw new Error("Requested more than 0 entries, but input is empty. Input shape: " + t2.shape + ".");
  for (var n2 = e2.shape, r2 = n2[n2.length - 1], o2 = 1, a2 = 0; a2 < n2.length - 1; ++a2)
    o2 *= n2[a2];
  var i2 = t2.shape, u2 = n2.slice();
  u2.pop();
  var s2 = 1;
  for (a2 = r2; a2 < t2.rank; ++a2)
    s2 *= i2[a2], u2.push(i2[a2]);
  var c2 = q(t2.shape).map(function(t3) {
    return t3 / s2;
  }).concat([1]).slice(0, r2);
  return [u2, o2, s2, c2];
}
var Vr = 30;
function zr(t2) {
  return t2 <= Vr ? t2 : H(t2, Math.floor(Math.sqrt(t2)));
}
function Gr(t2, e2, n2) {
  if (e2.rank < 1)
    throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was " + e2.rank + ".");
  if (t2.rank < 1)
    throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was " + t2.rank + ".");
  if ("int32" !== e2.dtype)
    throw new Error("The dtype of 'indices' should be int32, but got dtype: " + e2.dtype);
  if (n2.length < 1)
    throw new Error("Output rank must be greater or equal to 1, but got shape: " + n2);
  if (0 === n2.length) {
    if (0 === e2.size)
      throw new Error("Indices specified for empty output. indices shape: " + e2.shape);
    if (0 === t2.size)
      throw new Error("Updates specified for empty output. updates shape: " + t2.shape);
  }
  !function(t3, e3, n3) {
    var r2 = e3.rank > 1 ? e3.shape[e3.rank - 1] : 1, o2 = e3.rank > 1 ? e3.rank - 1 : 1, a2 = "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: " + n3.shape + ", indices.shape: " + e3.shape + ", shape: " + t3 + ", sliceDim: " + r2 + ", and batchDim: " + o2 + ".";
    if (n3.rank < o2)
      throw new Error(a2 + " update.rank < " + o2 + ". ");
    if (t3.length < r2 + (n3.rank - o2))
      throw new Error(a2 + " Output shape length < " + (r2 + (n3.rank - o2)));
    if (n3.rank !== o2 + t3.length - r2)
      throw new Error(a2 + " update.rank != " + (o2 + t3.length - r2));
    for (var i2 = 0; i2 < o2; ++i2)
      if (n3.shape[i2] !== e3.shape[i2])
        throw new Error(a2 + " updates.shape[" + i2 + "] (" + n3.shape[i2] + ") != indices.shape[" + i2 + "] (" + e3.shape[i2] + ").");
    for (i2 = 0; i2 < n3.rank - o2; ++i2)
      if (n3.shape[i2 + o2] !== t3[i2 + r2])
        throw new Error(a2 + " updates.shape[" + (i2 + o2) + "] (" + n3.shape[i2 + o2] + ") != shape[" + (i2 + o2) + "] (" + t3[i2 + o2] + ")");
  }(n2, e2, t2);
}
function Hr(t2, e2, n2) {
  for (var r2 = e2.rank > 1 ? e2.shape[e2.rank - 1] : 1, o2 = n2.length, a2 = 1, i2 = r2; i2 < o2; ++i2)
    a2 *= n2[i2];
  var u2 = r2 < 1 ? 1 : r2;
  return {sliceRank: r2, numUpdates: e2.size / u2, sliceSize: a2, strides: q(n2.slice(0, r2)).concat([1]), outputSize: w(n2)};
}
function qr(t2, e2, n2) {
  g(t2.rank === e2.length, function() {
    return "Error in slice" + t2.rank + "D: Length of begin " + e2 + " must match the rank of the array (" + t2.rank + ").";
  }), g(t2.rank === n2.length, function() {
    return "Error in slice" + t2.rank + "D: Length of size " + n2 + " must match the rank of the array (" + t2.rank + ").";
  });
  for (var r2 = function(r3) {
    g(e2[r3] + n2[r3] <= t2.shape[r3], function() {
      return "Error in slice" + t2.rank + "D: begin[" + r3 + "] + size[" + r3 + "] (" + (e2[r3] + n2[r3]) + ") would overflow input.shape[" + r3 + "] (" + t2.shape[r3] + ")";
    });
  }, o2 = 0; o2 < t2.rank; ++o2)
    r2(o2);
}
function Kr(t2) {
  for (var e2 = [], n2 = 0; t2 > 0; )
    1 & t2 && e2.push(n2), t2 /= 2, n2++;
  return e2;
}
function jr(t2, e2, n2) {
  for (var r2 = [], o2 = 0; o2 < t2.length; o2++)
    r2[o2] = Math.ceil((e2[o2] - t2[o2]) / n2[o2]);
  return r2;
}
function Xr(t2, e2, n2, r2, o2) {
  var a2 = e2[o2], i2 = n2[o2] || 1;
  (t2 & 1 << o2 || null == a2) && (a2 = i2 > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
  var u2 = r2[o2];
  return a2 < 0 && (a2 += u2), a2 = d(0, a2, u2 - 1);
}
function $r(t2, e2, n2, r2, o2) {
  var a2 = e2[o2], i2 = n2[o2] || 1;
  (t2 & 1 << o2 || null == a2) && (a2 = i2 > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
  var u2 = r2[o2];
  return a2 < 0 && (a2 += u2), a2 = i2 > 0 ? d(0, a2, u2) : d(-1, a2, u2 - 1);
}
function Yr(t2, e2, n2) {
  for (var r2 = n2.length, o2 = 0; o2 < n2.length; o2++)
    if (n2[o2] > 1) {
      r2 = o2;
      break;
    }
  for (o2 = r2 + 1; o2 < n2.length; o2++)
    if (e2[o2] > 0 || n2[o2] !== t2[o2])
      return false;
  return true;
}
function Qr(t2, e2) {
  for (var n2 = t2.length > 0 ? t2[t2.length - 1] : 1, r2 = 0; r2 < t2.length - 1; r2++)
    n2 += t2[r2] * e2[r2];
  return n2;
}
var Jr = Object.freeze({assertParamsValid: qr, maskToAxes: Kr, computeOutShape: jr, startForAxis: Xr, stopForAxis: $r, isSliceContinous: Yr, computeFlatOffset: Qr});
function Zr(t2) {
  return g(G(t2), function() {
    return "The f passed in grad(f) must be a function";
  }), function(e2, n2) {
    var r2 = ln(e2, "x", "tf.grad", null), o2 = null != n2 ? ln(n2, "dy", "tf.grad") : null;
    return Nt.tidy(function() {
      var e3 = Nt.gradients(function() {
        return t2(r2);
      }, [r2], o2), n3 = e3.value, a2 = e3.grads;
      return null != o2 && y(n3.shape, o2.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"), ao(a2), a2[0];
    });
  };
}
function to(t2) {
  return g(G(t2), function() {
    return "The f passed in grads(f) must be a function";
  }), function(e2, n2) {
    g(Array.isArray(e2), function() {
      return "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s";
    });
    var r2 = hn(e2, "args", "tf.grads", null), o2 = null != n2 ? ln(n2, "dy", "tf.grads") : null;
    return Nt.tidy(function() {
      var e3 = Nt.gradients(function() {
        return t2.apply(void 0, r2);
      }, r2, o2), n3 = e3.value, a2 = e3.grads;
      return null != o2 && y(n3.shape, o2.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), ao(a2), a2;
    });
  };
}
function eo(t2) {
  return g(G(t2), function() {
    return "The f passed in valueAndGrad(f) must be a function";
  }), function(e2, n2) {
    g(e2 instanceof dt, function() {
      return "The x passed in valueAndGrad(f)(x) must be a tensor";
    }), g(null == n2 || n2 instanceof dt, function() {
      return "The dy passed in valueAndGrad(f)(x, dy) must be a tensor";
    });
    var r2 = Nt.gradients(function() {
      return t2(e2);
    }, [e2], n2), o2 = r2.grads, a2 = r2.value;
    return ao(o2), {grad: o2[0], value: a2};
  };
}
function no(t2) {
  return g(G(t2), function() {
    return "The f passed in valueAndGrads(f) must be a function";
  }), function(e2, n2) {
    g(Array.isArray(e2) && e2.every(function(t3) {
      return t3 instanceof dt;
    }), function() {
      return "The args passed in valueAndGrads(f)(args) must be array of tensors";
    }), g(null == n2 || n2 instanceof dt, function() {
      return "The dy passed in valueAndGrads(f)(args, dy) must be a tensor";
    });
    var r2 = Nt.gradients(function() {
      return t2.apply(void 0, e2);
    }, e2, n2);
    return null != n2 && y(r2.value.shape, n2.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), ao(r2.grads), r2;
  };
}
function ro(t2, e2) {
  g(G(t2), function() {
    return "The f passed in variableGrads(f) must be a function";
  }), g(null == e2 || Array.isArray(e2) && e2.every(function(t3) {
    return t3 instanceof bt;
  }), function() {
    return "The varList passed in variableGrads(f, varList) must be an array of variables";
  });
  var n2 = null != e2;
  if (!n2)
    for (var r2 in (e2 = [], Nt.registeredVariables))
      e2.push(Nt.registeredVariables[r2]);
  var o2 = n2 ? e2.filter(function(t3) {
    return !t3.trainable;
  }) : null, a2 = e2.length;
  g((e2 = e2.filter(function(t3) {
    return t3.trainable;
  })).length > 0, function() {
    return "variableGrads() expects at least one of the input variables to be trainable, but none of the " + a2 + " variables is trainable.";
  });
  var i2 = Nt.gradients(t2, e2, null, true), u2 = i2.value, s2 = i2.grads;
  g(s2.some(function(t3) {
    return null != t3;
  }), function() {
    return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().";
  }), g(0 === u2.rank, function() {
    return "The f passed in variableGrads(f) must return a scalar, but it returned a rank-" + u2.rank + " tensor";
  });
  var c2 = {};
  return e2.forEach(function(t3, e3) {
    null != s2[e3] && (c2[t3.name] = s2[e3]);
  }), null != o2 && o2.forEach(function(t3) {
    return c2[t3.name] = null;
  }), {value: u2, grads: c2};
}
function oo(t2) {
  return Nt.customGrad(t2);
}
function ao(t2) {
  if (t2.filter(function(t3) {
    return null == t3;
  }).length > 0)
    throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.");
}
var io = Cn({softmax_: function(t2, e2) {
  void 0 === e2 && (e2 = -1);
  var n2 = ln(t2, "logits", "softmax");
  if (-1 === e2 && (e2 = n2.rank - 1), e2 !== n2.rank - 1)
    throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank " + n2.rank + " and dim was " + e2);
  return oo(function(t3, n3) {
    var r2 = t3.logSumExp([e2], true), o2 = t3.toFloat().sub(r2).exp();
    return n3([o2]), {value: o2, gradFunc: function(t4, n4) {
      var r3 = n4[0], o3 = t4.mul(r3);
      return o3.sub(o3.sum([e2], true).mul(r3));
    }};
  })(n2);
}});
var uo = Cn({logSoftmax_: function(t2, e2) {
  void 0 === e2 && (e2 = -1);
  var n2 = ln(t2, "logits", "logSoftmax");
  if (-1 === e2 && (e2 = n2.rank - 1), e2 !== n2.rank - 1)
    throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank " + n2.rank + " and axis was " + e2);
  return oo(function(t3, n3) {
    var r2 = t3.max(e2, true), o2 = t3.sub(r2), a2 = o2.toFloat().sub(o2.exp().sum(e2, true).log());
    return n3([a2]), {value: a2, gradFunc: function(t4, n4) {
      var r3 = n4[0].exp();
      return t4.sub(t4.sum(e2, true).mul(r3));
    }};
  })(n2);
}});
var so = function() {
  function t2(t3, e2) {
    this.backend = t3, this.dataMover = e2, this.data = new WeakMap(), this.dataIdsCount = 0;
  }
  return t2.prototype.get = function(t3) {
    return this.data.has(t3) || this.dataMover.moveData(this.backend, t3), this.data.get(t3);
  }, t2.prototype.set = function(t3, e2) {
    this.dataIdsCount++, this.data.set(t3, e2);
  }, t2.prototype.has = function(t3) {
    return this.data.has(t3);
  }, t2.prototype.delete = function(t3) {
    return this.dataIdsCount--, this.data.delete(t3);
  }, t2.prototype.numDataIds = function() {
    return this.dataIdsCount;
  }, t2;
}();
var co = function() {
  function t2() {
  }
  return t2.prototype.time = function(t3) {
    return lo("time");
  }, t2.prototype.read = function(t3) {
    return lo("read");
  }, t2.prototype.readSync = function(t3) {
    return lo("readSync");
  }, t2.prototype.numDataIds = function() {
    return lo("numDataIds");
  }, t2.prototype.disposeData = function(t3) {
    return lo("disposeData");
  }, t2.prototype.fromPixels = function(t3, e2) {
    return lo("fromPixels");
  }, t2.prototype.write = function(t3, e2, n2) {
    return lo("write");
  }, t2.prototype.move = function(t3, e2, n2, r2) {
    return lo("move");
  }, t2.prototype.memory = function() {
    return lo("memory");
  }, t2.prototype.floatPrecision = function() {
    return lo("floatPrecision");
  }, t2.prototype.epsilon = function() {
    return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
  }, t2.prototype.batchMatMul = function(t3, e2, n2, r2) {
    return lo("batchMatMul");
  }, t2.prototype.fusedBatchMatMul = function(t3) {
    t3.a, t3.b, t3.transposeA, t3.transposeB, t3.bias, t3.activation, t3.preluActivationWeights;
    return lo("fusedBatchMatMul");
  }, t2.prototype.slice = function(t3, e2, n2) {
    return lo("slice");
  }, t2.prototype.stridedSlice = function(t3, e2, n2, r2) {
    return lo("stridedSlice");
  }, t2.prototype.unstack = function(t3, e2) {
    return lo("unstack");
  }, t2.prototype.reverse = function(t3, e2) {
    return lo("reverse");
  }, t2.prototype.concat = function(t3, e2) {
    return lo("concat");
  }, t2.prototype.neg = function(t3) {
    return lo("neg");
  }, t2.prototype.add = function(t3, e2) {
    return lo("add");
  }, t2.prototype.addN = function(t3) {
    return lo("addN");
  }, t2.prototype.subtract = function(t3, e2) {
    return lo("subtract");
  }, t2.prototype.multiply = function(t3, e2) {
    return lo("multiply");
  }, t2.prototype.realDivide = function(t3, e2) {
    return lo("realDivide");
  }, t2.prototype.floorDiv = function(t3, e2) {
    return lo("floorDiv");
  }, t2.prototype.sum = function(t3, e2) {
    return lo("sum");
  }, t2.prototype.prod = function(t3, e2) {
    return lo("prod");
  }, t2.prototype.unsortedSegmentSum = function(t3, e2, n2) {
    return lo("unsortedSegmentSum");
  }, t2.prototype.argMin = function(t3, e2) {
    return lo("argMin");
  }, t2.prototype.argMax = function(t3, e2) {
    return lo("argMax");
  }, t2.prototype.equal = function(t3, e2) {
    return lo("equal");
  }, t2.prototype.notEqual = function(t3, e2) {
    return lo("notEqual");
  }, t2.prototype.less = function(t3, e2) {
    return lo("less");
  }, t2.prototype.lessEqual = function(t3, e2) {
    return lo("lessEqual");
  }, t2.prototype.greater = function(t3, e2) {
    return lo("greater");
  }, t2.prototype.greaterEqual = function(t3, e2) {
    return lo("greaterEqual");
  }, t2.prototype.logicalNot = function(t3) {
    return lo("logicalNot");
  }, t2.prototype.logicalAnd = function(t3, e2) {
    return lo("logicalAnd");
  }, t2.prototype.logicalOr = function(t3, e2) {
    return lo("logicalOr");
  }, t2.prototype.where = function(t3) {
    return lo("where");
  }, t2.prototype.select = function(t3, e2, n2) {
    return lo("select");
  }, t2.prototype.topk = function(t3, e2, n2) {
    return lo("topk");
  }, t2.prototype.min = function(t3, e2) {
    return lo("min");
  }, t2.prototype.minimum = function(t3, e2) {
    return lo("minimum");
  }, t2.prototype.mod = function(t3, e2) {
    return lo("mod");
  }, t2.prototype.max = function(t3, e2) {
    return lo("max");
  }, t2.prototype.maximum = function(t3, e2) {
    return lo("maximum");
  }, t2.prototype.all = function(t3, e2) {
    return lo("all");
  }, t2.prototype.any = function(t3, e2) {
    return lo("any");
  }, t2.prototype.squaredDifference = function(t3, e2) {
    return lo("squaredDifference");
  }, t2.prototype.ceil = function(t3) {
    return lo("ceil");
  }, t2.prototype.floor = function(t3) {
    return lo("floor");
  }, t2.prototype.round = function(t3) {
    return lo("round");
  }, t2.prototype.sign = function(t3) {
    return lo("sign");
  }, t2.prototype.isNaN = function(t3) {
    return lo("isNaN");
  }, t2.prototype.isInf = function(t3) {
    return lo("isInf");
  }, t2.prototype.isFinite = function(t3) {
    return lo("isFinite");
  }, t2.prototype.pow = function(t3, e2) {
    return lo("pow");
  }, t2.prototype.exp = function(t3) {
    return lo("exp");
  }, t2.prototype.expm1 = function(t3) {
    return lo("expm1");
  }, t2.prototype.log = function(t3) {
    return lo("log");
  }, t2.prototype.log1p = function(t3) {
    return lo("log1p");
  }, t2.prototype.sqrt = function(t3) {
    return lo("sqrt");
  }, t2.prototype.rsqrt = function(t3) {
    return lo("rsqrt");
  }, t2.prototype.square = function(t3) {
    return lo("square");
  }, t2.prototype.reciprocal = function(t3) {
    return lo("reciprocal");
  }, t2.prototype.relu = function(t3) {
    return lo("relu");
  }, t2.prototype.relu6 = function(t3) {
    return lo("relu6");
  }, t2.prototype.prelu = function(t3, e2) {
    return lo("prelu");
  }, t2.prototype.elu = function(t3) {
    return lo("elu");
  }, t2.prototype.eluDer = function(t3, e2) {
    return lo("eluDer");
  }, t2.prototype.selu = function(t3) {
    return lo("selu");
  }, t2.prototype.int = function(t3) {
    return lo("int");
  }, t2.prototype.clip = function(t3, e2, n2) {
    return lo("clip");
  }, t2.prototype.abs = function(t3) {
    return lo("abs");
  }, t2.prototype.complexAbs = function(t3) {
    return lo("complexAbs");
  }, t2.prototype.sigmoid = function(t3) {
    return lo("sigmoid");
  }, t2.prototype.softplus = function(t3) {
    return lo("softplus");
  }, t2.prototype.sin = function(t3) {
    return lo("sin");
  }, t2.prototype.cos = function(t3) {
    return lo("cos");
  }, t2.prototype.tan = function(t3) {
    return lo("tan");
  }, t2.prototype.asin = function(t3) {
    return lo("asin");
  }, t2.prototype.acos = function(t3) {
    return lo("acos");
  }, t2.prototype.atan = function(t3) {
    return lo("atan");
  }, t2.prototype.atan2 = function(t3, e2) {
    return lo("atan2");
  }, t2.prototype.sinh = function(t3) {
    return lo("sinh");
  }, t2.prototype.cosh = function(t3) {
    return lo("cosh");
  }, t2.prototype.tanh = function(t3) {
    return lo("tanh");
  }, t2.prototype.asinh = function(t3) {
    return lo("asinh");
  }, t2.prototype.acosh = function(t3) {
    return lo("acosh");
  }, t2.prototype.atanh = function(t3) {
    return lo("atanh");
  }, t2.prototype.erf = function(t3) {
    return lo("erf");
  }, t2.prototype.step = function(t3, e2) {
    return lo("step");
  }, t2.prototype.fusedConv2d = function(t3) {
    t3.input, t3.filter, t3.convInfo, t3.bias, t3.activation, t3.preluActivationWeights;
    return lo("fusedConv2d");
  }, t2.prototype.conv2d = function(t3, e2, n2) {
    return lo("conv2d");
  }, t2.prototype.conv2dDerInput = function(t3, e2, n2) {
    return lo("conv2dDerInput");
  }, t2.prototype.conv2dDerFilter = function(t3, e2, n2) {
    return lo("conv2dDerFilter");
  }, t2.prototype.fusedDepthwiseConv2D = function(t3) {
    t3.input, t3.filter, t3.convInfo, t3.bias, t3.activation, t3.preluActivationWeights;
    return lo("fusedDepthwiseConv2D");
  }, t2.prototype.depthwiseConv2D = function(t3, e2, n2) {
    return lo("depthwiseConv2D");
  }, t2.prototype.depthwiseConv2DDerInput = function(t3, e2, n2) {
    return lo("depthwiseConv2DDerInput");
  }, t2.prototype.depthwiseConv2DDerFilter = function(t3, e2, n2) {
    return lo("depthwiseConv2DDerFilter");
  }, t2.prototype.conv3d = function(t3, e2, n2) {
    return lo("conv3d");
  }, t2.prototype.conv3dDerInput = function(t3, e2, n2) {
    return lo("conv3dDerInput");
  }, t2.prototype.conv3dDerFilter = function(t3, e2, n2) {
    return lo("conv3dDerFilter");
  }, t2.prototype.maxPool = function(t3, e2) {
    return lo("maxPool");
  }, t2.prototype.maxPoolBackprop = function(t3, e2, n2, r2) {
    return lo("maxPoolBackprop");
  }, t2.prototype.avgPool = function(t3, e2) {
    return lo("avgPool");
  }, t2.prototype.avgPoolBackprop = function(t3, e2, n2) {
    return lo("avgPoolBackprop");
  }, t2.prototype.avgPool3d = function(t3, e2) {
    return lo("avgPool3d");
  }, t2.prototype.avgPool3dBackprop = function(t3, e2, n2) {
    return lo("avgPool3dBackprop");
  }, t2.prototype.maxPool3d = function(t3, e2) {
    return lo("maxPool3d");
  }, t2.prototype.maxPool3dBackprop = function(t3, e2, n2, r2) {
    return lo("maxPool3dBackprop");
  }, t2.prototype.reshape = function(t3, e2) {
    return lo("reshape");
  }, t2.prototype.cast = function(t3, e2) {
    return lo("cast");
  }, t2.prototype.tile = function(t3, e2) {
    return lo("tile");
  }, t2.prototype.pad = function(t3, e2, n2) {
    return lo("pad");
  }, t2.prototype.transpose = function(t3, e2) {
    return lo("transpose");
  }, t2.prototype.gather = function(t3, e2, n2) {
    return lo("gather");
  }, t2.prototype.gatherND = function(t3, e2) {
    return lo("gatherND");
  }, t2.prototype.scatterND = function(t3, e2, n2) {
    return lo("scatterND");
  }, t2.prototype.batchToSpaceND = function(t3, e2, n2) {
    return lo("batchToSpaceND");
  }, t2.prototype.spaceToBatchND = function(t3, e2, n2) {
    return lo("spaceToBatchND");
  }, t2.prototype.resizeBilinear = function(t3, e2, n2, r2) {
    return lo("resizeBilinear");
  }, t2.prototype.resizeBilinearBackprop = function(t3, e2, n2) {
    return lo("resizeBilinearBackprop");
  }, t2.prototype.resizeNearestNeighbor = function(t3, e2, n2, r2) {
    return lo("resizeNearestNeighbor");
  }, t2.prototype.resizeNearestNeighborBackprop = function(t3, e2, n2) {
    return lo("resizeNearestNeighborBackprop");
  }, t2.prototype.batchNormalization = function(t3, e2, n2, r2, o2, a2) {
    return lo("batchNormalization");
  }, t2.prototype.localResponseNormalization4D = function(t3, e2, n2, r2, o2) {
    return lo("localResponseNormalization4D");
  }, t2.prototype.LRNGrad = function(t3, e2, n2, r2, o2, a2, i2) {
    return lo("LRNGrad");
  }, t2.prototype.multinomial = function(t3, e2, n2, r2) {
    return lo("multinomial");
  }, t2.prototype.oneHot = function(t3, e2, n2, r2) {
    return lo("oneHot");
  }, t2.prototype.cumsum = function(t3, e2, n2, r2) {
    return lo("cumsum");
  }, t2.prototype.nonMaxSuppression = function(t3, e2, n2, r2, o2) {
    return lo("nonMaxSuppression");
  }, t2.prototype.fft = function(t3) {
    return lo("fft");
  }, t2.prototype.ifft = function(t3) {
    return lo("ifft");
  }, t2.prototype.complex = function(t3, e2) {
    return lo("complex");
  }, t2.prototype.real = function(t3) {
    return lo("real");
  }, t2.prototype.imag = function(t3) {
    return lo("imag");
  }, t2.prototype.cropAndResize = function(t3, e2, n2, r2, o2, a2) {
    return lo("cropAndResize");
  }, t2.prototype.depthToSpace = function(t3, e2, n2) {
    return lo("depthToSpace");
  }, t2.prototype.split = function(t3, e2, n2) {
    return lo("split");
  }, t2.prototype.sparseToDense = function(t3, e2, n2, r2) {
    return lo("sparseToDense");
  }, t2.prototype.diag = function(t3) {
    return lo("diag");
  }, t2.prototype.fill = function(t3, e2, n2) {
    return lo("fill");
  }, t2.prototype.onesLike = function(t3) {
    return lo("onesLike");
  }, t2.prototype.zerosLike = function(t3) {
    return lo("zerosLike");
  }, t2.prototype.linspace = function(t3, e2, n2) {
    return lo("linspace");
  }, t2.prototype.dispose = function() {
    return lo("dispose");
  }, t2;
}();
function lo(t2) {
  throw new Error("'" + t2 + "' not yet implemented or not found in the registry. Did you forget to import the kernel?");
}
function ho(t2, e2) {
  for (var n2 = t2.length, r2 = [], o2 = 0; o2 < n2; o2++) {
    var a2 = n2 - 1 - o2, i2 = t2[a2] || 1;
    (e2[e2.length - 1 - o2] || 1) > 1 && 1 === i2 && r2.unshift(a2);
  }
  return r2;
}
function fo(t2, e2) {
  for (var n2 = [], r2 = 0; r2 < e2.length; r2++) {
    var o2 = t2[t2.length - r2 - 1], a2 = e2.length - r2 - 1, i2 = e2[a2];
    (null == o2 || 1 === o2 && i2 > 1) && n2.unshift(a2);
  }
  return n2;
}
function po(t2, e2) {
  for (var n2 = [], r2 = Math.max(t2.length, e2.length), o2 = 0; o2 < r2; o2++) {
    var a2 = t2[t2.length - o2 - 1];
    null == a2 && (a2 = 1);
    var i2 = e2[e2.length - o2 - 1];
    if (null == i2 && (i2 = 1), 1 === a2)
      n2.unshift(i2);
    else if (1 === i2)
      n2.unshift(a2);
    else {
      if (a2 !== i2)
        throw Error("Operands could not be broadcast together with shapes " + t2 + " and " + e2 + ".");
      n2.unshift(a2);
    }
  }
  return n2;
}
function vo(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === i2 && (i2 = "channelsLast");
  var u2, s2 = bo(e2), c2 = s2[0], l2 = s2[1];
  if ("channelsLast" === i2)
    u2 = [c2, l2, t2[3], t2[3]];
  else {
    if ("channelsFirst" !== i2)
      throw new Error("Unknown dataFormat " + i2);
    u2 = [c2, l2, t2[1], t2[1]];
  }
  return go(t2, u2, n2, r2, o2, a2, false, i2);
}
function mo(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === i2 && (i2 = "NDHWC");
  var u2, s2, c2 = wo(e2), l2 = c2[0], h2 = c2[1], f2 = c2[2];
  if ("NDHWC" === i2)
    s2 = "channelsLast", u2 = [l2, h2, f2, t2[4], t2[4]];
  else {
    if ("NCDHW" !== i2)
      throw new Error("Unknown dataFormat " + i2);
    s2 = "channelsFirst", u2 = [l2, h2, f2, t2[1], t2[1]];
  }
  return yo(t2, u2, n2, r2, o2, false, s2, a2);
}
function go(t2, e2, n2, r2, o2, a2, i2, u2) {
  void 0 === i2 && (i2 = false), void 0 === u2 && (u2 = "channelsLast");
  var s2 = [-1, -1, -1, -1], c2 = s2[0], l2 = s2[1], h2 = s2[2], f2 = s2[3];
  if ("channelsLast" === u2)
    c2 = t2[0], l2 = t2[1], h2 = t2[2], f2 = t2[3];
  else {
    if ("channelsFirst" !== u2)
      throw new Error("Unknown dataFormat " + u2);
    c2 = t2[0], f2 = t2[1], l2 = t2[2], h2 = t2[3];
  }
  var p2, d2 = e2[0], v2 = e2[1], m2 = e2[3], y2 = bo(n2), x2 = y2[0], b2 = y2[1], w2 = bo(r2), C2 = w2[0], R2 = w2[1], I2 = Co(d2, C2), k2 = Co(v2, R2), S2 = function(t3, e3, n3, r3, o3, a3, i3, u3) {
    var s3, c3, l3;
    if ("number" == typeof t3) {
      var h3 = 0 === t3 ? "VALID" : "NUMBER";
      s3 = {top: t3, bottom: t3, left: t3, right: t3, type: h3};
      var f3 = function(t4, e4, n4, r4, o4) {
        null == r4 && (r4 = xo(t4, e4, n4));
        var a4 = t4[0], i4 = t4[1], u4 = Eo((a4 - e4 + 2 * r4) / n4 + 1, o4);
        g(E(u4), function() {
          return "The output # of rows (" + u4 + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var s4 = Eo((i4 - e4 + 2 * r4) / n4 + 1, o4);
        return g(E(s4), function() {
          return "The output # of columns (" + s4 + ") must be an integer. Change the stride and/or zero pad parameters";
        }), [u4, s4];
      }([e3, n3], a3, r3, t3, u3);
      c3 = f3[0], l3 = f3[1];
    } else if ("same" === t3) {
      c3 = Math.ceil(e3 / r3), l3 = Math.ceil(n3 / o3);
      var p3 = Math.max(0, (c3 - 1) * r3 + a3 - e3), d3 = Math.max(0, (l3 - 1) * o3 + i3 - n3), v3 = Math.floor(p3 / 2), m3 = p3 - v3, y3 = Math.floor(d3 / 2), x3 = d3 - y3;
      s3 = {top: v3, bottom: m3, left: y3, right: x3, type: "SAME"};
    } else {
      if ("valid" !== t3)
        throw Error("Unknown padding parameter: " + t3);
      s3 = {top: 0, bottom: 0, left: 0, right: 0, type: "VALID"}, c3 = Math.ceil((e3 - a3 + 1) / r3), l3 = Math.ceil((n3 - i3 + 1) / o3);
    }
    return {padInfo: s3, outHeight: c3, outWidth: l3};
  }(o2, l2, h2, x2, b2, I2, k2, a2), A2 = S2.padInfo, D2 = S2.outHeight, T2 = S2.outWidth, N2 = i2 ? m2 * f2 : m2;
  return "channelsFirst" === u2 ? p2 = [c2, N2, D2, T2] : "channelsLast" === u2 && (p2 = [c2, D2, T2, N2]), {batchSize: c2, dataFormat: u2, inHeight: l2, inWidth: h2, inChannels: f2, outHeight: D2, outWidth: T2, outChannels: N2, padInfo: A2, strideHeight: x2, strideWidth: b2, filterHeight: d2, filterWidth: v2, effectiveFilterHeight: I2, effectiveFilterWidth: k2, dilationHeight: C2, dilationWidth: R2, inShape: t2, outShape: p2, filterShape: e2};
}
function yo(t2, e2, n2, r2, o2, a2, i2, u2) {
  void 0 === a2 && (a2 = false), void 0 === i2 && (i2 = "channelsLast");
  var s2 = [-1, -1, -1, -1, -1], c2 = s2[0], l2 = s2[1], h2 = s2[2], f2 = s2[3], p2 = s2[4];
  if ("channelsLast" === i2)
    c2 = t2[0], l2 = t2[1], h2 = t2[2], f2 = t2[3], p2 = t2[4];
  else {
    if ("channelsFirst" !== i2)
      throw new Error("Unknown dataFormat " + i2);
    c2 = t2[0], p2 = t2[1], l2 = t2[2], h2 = t2[3], f2 = t2[4];
  }
  var d2, v2 = e2[0], m2 = e2[1], y2 = e2[2], x2 = e2[4], b2 = wo(n2), w2 = b2[0], C2 = b2[1], R2 = b2[2], I2 = wo(r2), k2 = I2[0], S2 = I2[1], A2 = I2[2], D2 = Co(v2, k2), T2 = Co(m2, S2), N2 = Co(y2, A2), F2 = function(t3, e3, n3, r3, o3, a3, i3, u3, s3, c3, l3) {
    var h3, f3, p3, d3;
    if ("number" == typeof t3) {
      var v3 = 0 === t3 ? "VALID" : "NUMBER";
      h3 = {top: t3, bottom: t3, left: t3, right: t3, front: t3, back: t3, type: v3};
      var m3 = function(t4, e4, n4, r4, o4, a4) {
        null == o4 && (o4 = xo(t4, e4, r4));
        var i4 = t4[0], u4 = t4[1], s4 = t4[2], c4 = Eo((i4 - e4 + 2 * o4) / r4 + 1, a4);
        g(E(c4), function() {
          return "The output # of depths (" + c4 + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var l4 = Eo((u4 - e4 + 2 * o4) / r4 + 1, a4);
        g(E(l4), function() {
          return "The output # of rows (" + l4 + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var h4 = Eo((s4 - e4 + 2 * o4) / r4 + 1, a4);
        return g(E(h4), function() {
          return "The output # of columns (" + h4 + ") must be an integer. Change the stride and/or zero pad parameters";
        }), [c4, l4, h4, n4];
      }([e3, n3, r3, 1], u3, 1, o3, t3, l3);
      f3 = m3[0], p3 = m3[1], d3 = m3[2];
    } else if ("same" === t3) {
      f3 = Math.ceil(e3 / o3), p3 = Math.ceil(n3 / a3), d3 = Math.ceil(r3 / i3);
      var y3 = (f3 - 1) * o3 + u3 - e3, x3 = (p3 - 1) * a3 + s3 - n3, b3 = (d3 - 1) * i3 + c3 - r3, w3 = Math.floor(y3 / 2), C3 = y3 - w3, R3 = Math.floor(x3 / 2), I3 = x3 - R3, k3 = Math.floor(b3 / 2), S3 = b3 - k3;
      h3 = {top: R3, bottom: I3, left: k3, right: S3, front: w3, back: C3, type: "SAME"};
    } else {
      if ("valid" !== t3)
        throw Error("Unknown padding parameter: " + t3);
      h3 = {top: 0, bottom: 0, left: 0, right: 0, front: 0, back: 0, type: "VALID"}, f3 = Math.ceil((e3 - u3 + 1) / o3), p3 = Math.ceil((n3 - s3 + 1) / a3), d3 = Math.ceil((r3 - c3 + 1) / i3);
    }
    return {padInfo: h3, outDepth: f3, outHeight: p3, outWidth: d3};
  }(o2, l2, h2, f2, w2, C2, R2, D2, T2, N2, u2), O2 = F2.padInfo, _2 = F2.outDepth, M2 = F2.outHeight, B2 = F2.outWidth, P2 = a2 ? x2 * p2 : x2;
  return "channelsFirst" === i2 ? d2 = [c2, P2, _2, M2, B2] : "channelsLast" === i2 && (d2 = [c2, _2, M2, B2, P2]), {batchSize: c2, dataFormat: i2, inDepth: l2, inHeight: h2, inWidth: f2, inChannels: p2, outDepth: _2, outHeight: M2, outWidth: B2, outChannels: P2, padInfo: O2, strideDepth: w2, strideHeight: C2, strideWidth: R2, filterDepth: v2, filterHeight: m2, filterWidth: y2, effectiveFilterDepth: D2, effectiveFilterHeight: T2, effectiveFilterWidth: N2, dilationDepth: k2, dilationHeight: S2, dilationWidth: A2, inShape: t2, outShape: d2, filterShape: e2};
}
function xo(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = 1);
  var o2 = Co(e2, r2);
  return Math.floor((t2[0] * (n2 - 1) - n2 + o2) / 2);
}
function bo(t2) {
  return "number" == typeof t2 ? [t2, t2, t2] : 2 === t2.length ? [t2[0], t2[1], 1] : t2;
}
function wo(t2) {
  return "number" == typeof t2 ? [t2, t2, t2] : t2;
}
function Co(t2, e2) {
  return e2 <= 1 ? t2 : t2 + (t2 - 1) * (e2 - 1);
}
function Eo(t2, e2) {
  if (!e2)
    return t2;
  switch (e2) {
    case "round":
      return Math.round(t2);
    case "ceil":
      return Math.ceil(t2);
    case "floor":
      return Math.floor(t2);
    default:
      throw new Error("Unknown roundingMode " + e2);
  }
}
function Ro(t2) {
  var e2 = bo(t2), n2 = e2[0], r2 = e2[1], o2 = e2[2];
  return 1 === n2 && 1 === r2 && 1 === o2;
}
function Io(t2, e2) {
  return Ro(t2) || Ro(e2);
}
function ko(t2) {
  if ("NHWC" === t2)
    return "channelsLast";
  if ("NCHW" === t2)
    return "channelsFirst";
  throw new Error("Unknown dataFormat " + t2);
}
function So(t2, e2, n2) {
  if ("complex64" === e2) {
    if ("complex64" === t2.dtype)
      return t2.clone();
    var r2 = Pn(t2.shape), o2 = t2.toFloat(), a2 = n2.complex(o2, r2);
    return r2.dispose(), o2.dispose(), a2;
  }
  if (!M(t2.dtype, e2))
    return Nt.makeTensorFromDataId(t2.dataId, t2.shape, e2);
  if ("complex64" === t2.dtype) {
    var i2 = n2.real(t2);
    a2 = i2.cast(e2);
    return i2.dispose(), a2;
  }
  if ("int32" === e2)
    return n2.int(t2);
  if ("bool" === e2) {
    var u2 = An(0, t2.dtype);
    a2 = n2.notEqual(t2, u2);
    return u2.dispose(), a2;
  }
  throw new Error("Error in Cast: failed to cast " + t2.dtype + " to " + e2);
}
function Ao(t2, e2) {
  return Nt.makeTensorFromDataId(t2.dataId, e2, t2.dtype);
}
function Do(t2, e2, n2) {
  var r2 = (e2 - t2) / (n2 - 1), o2 = $(n2, "float32");
  o2[0] = t2;
  for (var a2 = 1; a2 < o2.length; a2++)
    o2[a2] = o2[a2 - 1] + r2;
  return Dn(o2, "float32");
}
var To = Object.freeze({castTensor: So, reshapeTensor: Ao, linspaceImpl: Do, upcastType: Ct, axesAreInnerMostDims: fn, combineLocations: pn, computeOutAndReduceShapes: dn, expandShapeToKeepDim: vn, assertAxesAreInnerMostDims: mn, getAxesPermutation: gn, getUndoAxesPermutation: yn, getInnerMostAxes: xn, getBroadcastDims: ho, getReductionAxes: fo, assertAndGetBroadcastShape: po, assertParamsConsistent: bn, computeOutShape: wn, computePool2DInfo: vo, computePool3DInfo: mo, computeConv2DInfo: go, computeConv3DInfo: yo, computeDefaultPad: xo, tupleValuesAreOne: Ro, eitherStridesOrDilationsAreOne: Io, convertConv2DDataFormat: ko});
function No(t2, e2) {
  if (t2.length !== e2.length)
    throw new Error("Cannot merge real and imag arrays of different lengths. real:" + t2.length + ", imag: " + e2.length + ".");
  for (var n2 = new Float32Array(2 * t2.length), r2 = 0; r2 < n2.length; r2 += 2)
    n2[r2] = t2[r2 / 2], n2[r2 + 1] = e2[r2 / 2];
  return n2;
}
function Fo(t2, e2) {
  return {real: t2[2 * e2], imag: t2[2 * e2 + 1]};
}
function Oo(t2, e2, n2, r2) {
  t2[2 * r2] = e2, t2[2 * r2 + 1] = n2;
}
function _o(t2, e2, n2) {
  var r2 = (n2 ? 2 : -2) * Math.PI * (t2 / e2);
  return {real: Math.cos(r2), imag: Math.sin(r2)};
}
function Mo(t2, e2, n2, r2, o2) {
  for (var a2 = Array.from(e2).map(function(t3, e3) {
    return {score: t3, boxIndex: e3};
  }).filter(function(t3) {
    return t3.score > o2;
  }).sort(function(t3, e3) {
    return e3.score - t3.score;
  }), i2 = [], u2 = 0; u2 < a2.length; u2++) {
    var s2 = a2[u2], c2 = s2.score, l2 = s2.boxIndex;
    if (c2 < o2)
      break;
    for (var h2 = false, f2 = i2.length - 1; f2 >= 0; --f2) {
      if (Bo(t2, l2, i2[f2]) >= r2) {
        h2 = true;
        break;
      }
    }
    if (!h2 && (i2.push(l2), i2.length >= n2))
      break;
  }
  return Dn(i2, "int32");
}
function Bo(t2, e2, n2) {
  var r2 = t2.subarray(4 * e2, 4 * e2 + 4), o2 = t2.subarray(4 * n2, 4 * n2 + 4), a2 = Math.min(r2[0], r2[2]), i2 = Math.min(r2[1], r2[3]), u2 = Math.max(r2[0], r2[2]), s2 = Math.max(r2[1], r2[3]), c2 = Math.min(o2[0], o2[2]), l2 = Math.min(o2[1], o2[3]), h2 = Math.max(o2[0], o2[2]), f2 = Math.max(o2[1], o2[3]), p2 = (u2 - a2) * (s2 - i2), d2 = (h2 - c2) * (f2 - l2);
  if (p2 <= 0 || d2 <= 0)
    return 0;
  var v2 = Math.max(a2, c2), m2 = Math.max(i2, l2), g2 = Math.min(u2, h2), y2 = Math.min(s2, f2), x2 = Math.max(g2 - v2, 0) * Math.max(y2 - m2, 0);
  return x2 / (p2 + d2 - x2);
}
function Po(t2, e2, n2) {
  var r2 = new Array(t2.rank).fill(0), o2 = t2.shape.slice();
  return e2.map(function(e3) {
    o2[n2] = e3;
    var a2 = t2.slice(r2, o2);
    return r2[n2] += e3, a2;
  });
}
function Lo(t2, e2) {
  for (var n2 = new Array(t2.rank), r2 = 0; r2 < n2.length; r2++)
    n2[r2] = t2.shape[r2] * e2[r2];
  var o2 = ur(n2, t2.dtype);
  for (r2 = 0; r2 < o2.values.length; ++r2) {
    for (var a2 = o2.indexToLoc(r2), i2 = new Array(t2.rank), u2 = 0; u2 < i2.length; u2++)
      i2[u2] = a2[u2] % t2.shape[u2];
    var s2 = t2.locToIndex(i2);
    o2.values[r2] = t2.values[s2];
  }
  return o2.toTensor();
}
function Wo(t2, e2, n2, r2, o2) {
  for (var a2 = e2[e2.length - 1], i2 = [t2.length / a2, a2], u2 = i2[0], s2 = i2[1], c2 = N(n2, u2 * r2), l2 = N("int32", u2 * r2), h2 = 0; h2 < u2; h2++) {
    for (var f2 = h2 * s2, p2 = t2.subarray(f2, f2 + s2), d2 = [], v2 = 0; v2 < p2.length; v2++)
      d2.push({value: p2[v2], index: v2});
    d2.sort(function(t3, e3) {
      return e3.value - t3.value;
    });
    var m2 = h2 * r2, g2 = c2.subarray(m2, m2 + r2), y2 = l2.subarray(m2, m2 + r2);
    for (v2 = 0; v2 < r2; v2++)
      g2[v2] = d2[v2].value, y2[v2] = d2[v2].index;
  }
  var x2 = e2.slice();
  return x2[x2.length - 1] = r2, [kn(c2, x2, n2), kn(l2, x2, "int32")];
}
function Uo(t2, e2) {
  for (var n2 = [], r2 = 0; r2 < e2.length; r2++)
    e2[r2] && n2.push(r2);
  var o2 = ur(t2, "int32"), a2 = ur([n2.length, t2.length], "int32");
  for (r2 = 0; r2 < n2.length; r2++) {
    var i2 = o2.indexToLoc(n2[r2]), u2 = r2 * t2.length;
    a2.values.set(i2, u2);
  }
  return a2.toTensor();
}
var Vo = function() {
  return function(t2, e2) {
    this.outputShape = [], this.outputShape = t2, this.variableNames = e2.map(function(t3, e3) {
      return "T" + e3;
    });
    var n2 = [];
    this.variableNames.forEach(function(t3) {
      n2.push("float v" + t3 + " = get" + t3 + "AtOutCoords();");
    });
    var r2 = this.variableNames.map(function(t3) {
      return "v" + t3;
    }).join(" + ");
    this.userCode = "\n      void main() {\n        " + n2.join("\n        ") + "\n\n        float result = " + r2 + ";\n        setOutput(result);\n      }\n    ";
  };
}();
var zo = function() {
  return function(t2, e2) {
    this.outputShape = [], this.packedInputs = true, this.packedOutput = true, this.outputShape = t2, this.variableNames = e2.map(function(t3, e3) {
      return "T" + e3;
    });
    var n2 = [];
    this.variableNames.forEach(function(t3) {
      n2.push("vec4 v" + t3 + " = get" + t3 + "AtOutCoords();");
    });
    var r2 = this.variableNames.map(function(t3) {
      return "v" + t3;
    }).join(" + ");
    this.userCode = "\n      void main() {\n        " + n2.join("\n        ") + "\n\n        vec4 result = " + r2 + ";\n        setOutput(result);\n      }\n    ";
  };
}();
var Go = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["A"];
    var r2 = t2.windowSize, o2 = t2.batchSize, a2 = t2.inSize, i2 = Math.ceil(a2 / r2);
    n2 || this.variableNames.push("bestIndicesA"), this.outputShape = [o2, i2];
    var u2 = "max" === e2 ? ">" : "<", s2 = n2 ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
    this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + r2 + ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < " + r2 + "; i++) {\n          int inIdx = " + s2 + ";\n          float candidate = getA(batch, inIdx);\n          if (candidate " + u2 + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
  };
}();
function Ho(t2, e2) {
  return ["x", "y", "z", "w", "u", "v"].slice(0, e2).map(function(e3) {
    return t2 + "." + e3;
  });
}
function qo(t2, e2) {
  return 1 === e2 ? [t2] : Ho(t2, e2);
}
function Ko() {
  var t2, e2, n2, r2, o2, i2, u2, s2, c2, l2;
  return 2 === a().getNumber("WEBGL_VERSION") ? (t2 = "#version 300 es", e2 = "in", n2 = "out", r2 = "in", o2 = "texture", i2 = "outputColor", u2 = "out vec4 outputColor;", s2 = "\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ", c2 = "", l2 = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (t2 = "", e2 = "attribute", n2 = "varying", r2 = "varying", o2 = "texture2D", i2 = "gl_FragColor", u2 = "", s2 = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", c2 = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", l2 = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), {version: t2, attribute: e2, varyingVs: n2, varyingFs: r2, texture2D: o2, output: i2, defineOutput: u2, defineSpecialNaN: s2, defineSpecialInf: c2, defineRound: l2};
}
function jo(t2, e2, n2) {
  void 0 === n2 && (n2 = "index");
  var r2 = q(e2);
  return r2.map(function(e3, o2) {
    return "int " + t2[o2] + " = " + n2 + " / " + e3 + "; " + (o2 === r2.length - 1 ? "int " + t2[o2 + 1] + " = " + n2 + " - " + t2[o2] + " * " + e3 : "index -= " + t2[o2] + " * " + e3) + ";";
  }).join("");
}
function Xo(t2) {
  var e2 = q(t2).map(function(t3) {
    return t3.toString();
  });
  return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * " + e2[0] + " + coords.y * " + e2[1] + " + coords.z;\n  }\n";
}
var $o = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";
function Yo(t2, e2, n2, r2) {
  var o2 = [];
  t2.forEach(function(t3) {
    var e3 = w(t3.shapeInfo.logicalShape);
    t3.shapeInfo.isUniform ? o2.push("uniform float " + t3.name + (e3 > 1 ? "[" + e3 + "]" : "") + ";") : (o2.push("uniform sampler2D " + t3.name + ";"), o2.push("uniform int offset" + t3.name + ";"));
  });
  var a2, i2, u2 = o2.join("\n"), s2 = t2.map(function(t3) {
    return function(t4, e3, n3) {
      void 0 === n3 && (n3 = false);
      var r3 = "";
      r3 += n3 ? Jo(t4) : Qo(t4);
      var o3 = t4.shapeInfo.logicalShape, a3 = e3.logicalShape;
      o3.length <= a3.length && (r3 += n3 ? function(t5, e4) {
        var n4, r4 = t5.name, o4 = r4.charAt(0).toUpperCase() + r4.slice(1), a4 = "get" + o4 + "AtOutCoords", i3 = t5.shapeInfo.logicalShape.length, u3 = e4.logicalShape.length, s3 = ho(t5.shapeInfo.logicalShape, e4.logicalShape), c3 = aa(u3), l3 = u3 - i3, h3 = ["x", "y", "z", "w", "u", "v"];
        n4 = 0 === i3 ? "" : u3 < 2 && s3.length >= 1 ? "coords = 0;" : s3.map(function(t6) {
          return "coords." + h3[t6 + l3] + " = 0;";
        }).join("\n");
        var f3 = "";
        f3 = u3 < 2 && i3 > 0 ? "coords" : t5.shapeInfo.logicalShape.map(function(t6, e5) {
          return "coords." + h3[e5 + l3];
        }).join(", ");
        var p2 = "return outputValue;", d2 = 1 === w(t5.shapeInfo.logicalShape), v2 = 1 === w(e4.logicalShape);
        if (1 !== i3 || d2 || v2) {
          if (d2 && !v2)
            p2 = 1 === u3 ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";
          else if (s3.length) {
            var m2 = i3 - 2, g2 = i3 - 1;
            s3.indexOf(m2) > -1 && s3.indexOf(g2) > -1 ? p2 = "return vec4(outputValue.x);" : s3.indexOf(m2) > -1 ? p2 = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : s3.indexOf(g2) > -1 && (p2 = "return vec4(outputValue.xx, outputValue.zz);");
          }
        } else
          p2 = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
        return "\n    vec4 " + a4 + "() {\n      " + c3 + " coords = getOutputCoords();\n      " + n4 + "\n      vec4 outputValue = get" + o4 + "(" + f3 + ");\n      " + p2 + "\n    }\n  ";
      }(t4, e3) : function(t5, e4) {
        var n4 = t5.name, r4 = n4.charAt(0).toUpperCase() + n4.slice(1), o4 = "get" + r4 + "AtOutCoords", a4 = e4.texShape, i3 = t5.shapeInfo.texShape, u3 = t5.shapeInfo.logicalShape.length, s3 = e4.logicalShape.length;
        if (!t5.shapeInfo.isUniform && u3 === s3 && null == t5.shapeInfo.flatOffset && C(i3, a4))
          return "\n      float " + o4 + "() {\n        return sampleTexture(" + n4 + ", resultUV);\n      }\n    ";
        var c3, l3 = aa(s3), h3 = ho(t5.shapeInfo.logicalShape, e4.logicalShape), f3 = s3 - u3, p2 = ["x", "y", "z", "w", "u", "v"];
        c3 = 0 === u3 ? "" : s3 < 2 && h3.length >= 1 ? "coords = 0;" : h3.map(function(t6) {
          return "coords." + p2[t6 + f3] + " = 0;";
        }).join("\n");
        var d2 = "";
        d2 = s3 < 2 && u3 > 0 ? "coords" : t5.shapeInfo.logicalShape.map(function(t6, e5) {
          return "coords." + p2[e5 + f3];
        }).join(", ");
        return "\n    float " + o4 + "() {\n      " + l3 + " coords = getOutputCoords();\n      " + c3 + "\n      return get" + r4 + "(" + d2 + ");\n    }\n  ";
      }(t4, e3));
      return r3;
    }(t3, e2, r2);
  }).join("\n"), c2 = e2.texShape, l2 = Ko(), h2 = function(t3) {
    return "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return " + t3.texture2D + "(textureSampler, uv).r;\n    }\n  ";
  }(l2), f2 = function(t3) {
    return t3.version + "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    " + t3.varyingFs + " vec2 resultUV;\n    " + t3.defineOutput + "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    " + t3.defineSpecialNaN + "\n    " + t3.defineSpecialInf + "\n    " + t3.defineRound + "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    " + Zo + "\n    " + ta + "\n    " + ea + "\n  ";
  }(l2);
  return e2.isPacked ? (a2 = function(t3, e3) {
    switch (t3.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
      case 1:
        return function(t4, e4) {
          var n4 = [Math.ceil(e4[0] / 2), Math.ceil(e4[1] / 2)];
          if (1 === n4[0])
            return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * " + n4[1] + ".0);\n      }\n    ";
          if (1 === n4[1])
            return "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * " + n4[0] + ".0);\n      }\n    ";
          return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n4[0] + ", " + n4[1] + "));\n      return 2 * (resTexRC.x * " + n4[1] + " + resTexRC.y);\n    }\n  ";
        }(0, e3);
      case 2:
        return function(t4, e4) {
          var n4 = [Math.ceil(e4[0] / 2), Math.ceil(e4[1] / 2)];
          if (C(t4, e4))
            return "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(" + n4[0] + ", " + n4[1] + "));\n      }\n    ";
          var r4 = Math.ceil(t4[1] / 2);
          return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n4[0] + ", " + n4[1] + "));\n\n      int index = resTexRC.x * " + n4[1] + " + resTexRC.y;\n      int r = 2 * (index / " + r4 + ");\n      int c = imod(index, " + r4 + ") * 2;\n\n      return ivec2(r, c);\n    }\n  ";
        }(t3, e3);
      case 3:
        return n3 = t3, r3 = e3, o3 = [Math.ceil(r3[0] / 2), Math.ceil(r3[1] / 2)], a3 = Math.ceil(n3[2] / 2), i3 = a3 * Math.ceil(n3[1] / 2), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + o3[0] + ", " + o3[1] + "));\n      int index = resTexRC.x * " + o3[1] + " + resTexRC.y;\n\n      int b = index / " + i3 + ";\n      index -= b * " + i3 + ";\n\n      int r = 2 * (index / " + a3 + ");\n      int c = imod(index, " + a3 + ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
      default:
        return function(t4, e4) {
          for (var n4 = [Math.ceil(e4[0] / 2), Math.ceil(e4[1] / 2)], r4 = Math.ceil(t4[t4.length - 1] / 2), o4 = r4 * Math.ceil(t4[t4.length - 2] / 2), a4 = o4, i4 = "", u3 = "b, r, c", s3 = 2; s3 < t4.length - 1; s3++)
            a4 *= t4[t4.length - s3 - 1], i4 = "\n      int b" + s3 + " = index / " + a4 + ";\n      index -= b" + s3 + " * " + a4 + ";\n    " + i4, u3 = "b" + s3 + ", " + u3;
          return "\n    ivec" + t4.length + " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n4[0] + ", " + n4[1] + "));\n      int index = resTexRC.x * " + n4[1] + " + resTexRC.y;\n\n      " + i4 + "\n\n      int b = index / " + o4 + ";\n      index -= b * " + o4 + ";\n\n      int r = 2 * (index / " + r4 + ");\n      int c = imod(index, " + r4 + ") * 2;\n\n      return ivec" + t4.length + "(" + u3 + ");\n    }\n  ";
        }(t3, e3);
    }
    var n3, r3, o3, a3, i3;
  }(e2.logicalShape, c2), i2 = function(t3) {
    return "\n    void setOutput(vec4 val) {\n      " + t3.output + " = val;\n    }\n  ";
  }(l2)) : (a2 = function(t3, e3) {
    switch (t3.length) {
      case 0:
        return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
      case 1:
        return function(t4, e4) {
          if (1 === e4[0])
            return "\n      int getOutputCoords() {\n        return int(resultUV.x * " + e4[1] + ".0);\n      }\n    ";
          if (1 === e4[1])
            return "\n      int getOutputCoords() {\n        return int(resultUV.y * " + e4[0] + ".0);\n      }\n    ";
          return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e4[0] + ", " + e4[1] + "));\n      return resTexRC.x * " + e4[1] + " + resTexRC.y;\n    }\n  ";
        }(0, e3);
      case 2:
        return function(t4, e4) {
          if (C(t4, e4))
            return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + e4[0] + ", " + e4[1] + "));\n      }\n    ";
          if (1 === t4[1])
            return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e4[0] + ", " + e4[1] + "));\n        int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";
          if (1 === t4[0])
            return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + e4[0] + ", " + e4[1] + "));\n        int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";
          return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + e4[0] + ", " + e4[1] + "));\n      int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n      int r = index / " + t4[1] + ";\n      int c = index - r * " + t4[1] + ";\n      return ivec2(r, c);\n    }\n  ";
        }(t3, e3);
      case 3:
        return n3 = e3, r3 = jo(["r", "c", "d"], t3), "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + n3[0] + ", " + n3[1] + "));\n      int index = resTexRC.x * " + n3[1] + " + resTexRC.y;\n      " + r3 + "\n      return ivec3(r, c, d);\n    }\n  ";
      case 4:
        return function(t4, e4) {
          var n4 = jo(["r", "c", "d", "d2"], t4);
          return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e4[0] + ", " + e4[1] + "));\n      int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n      " + n4 + "\n      return ivec4(r, c, d, d2);\n    }\n  ";
        }(t3, e3);
      case 5:
        return function(t4, e4) {
          var n4 = jo(["r", "c", "d", "d2", "d3"], t4);
          return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(" + e4[0] + ",\n                             " + e4[1] + "));\n\n      int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n\n      " + n4 + "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ";
        }(t3, e3);
      case 6:
        return function(t4, e4) {
          var n4 = jo(["r", "c", "d", "d2", "d3", "d4"], t4);
          return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + e4[0] + ", " + e4[1] + "));\n      int index = resTexRC.x * " + e4[1] + " + resTexRC.y;\n\n      " + n4 + "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ";
        }(t3, e3);
      default:
        throw new Error(t3.length + "-D output sampling is not yet supported");
    }
    var n3, r3;
  }(e2.logicalShape, c2), i2 = function(t3) {
    return "\n    void setOutput(float val) {\n      " + t3.output + " = vec4(val, 0, 0, 0);\n    }\n  ";
  }(l2)), r2 && (f2 += na), [f2, h2, i2, u2, a2, s2, n2].join("\n");
}
function Qo(t2) {
  var e2 = t2.shapeInfo.logicalShape;
  switch (e2.length) {
    case 0:
      return function(t3) {
        var e3 = t3.name, n2 = "get" + e3.charAt(0).toUpperCase() + e3.slice(1);
        if (t3.shapeInfo.isUniform)
          return "float " + n2 + "() {return " + e3 + ";}";
        var r2 = t3.shapeInfo.texShape, o2 = r2[0], a2 = r2[1];
        if (1 === o2 && 1 === a2)
          return "\n      float " + n2 + "() {\n        return sampleTexture(" + e3 + ", halfCR);\n      }\n    ";
        var i2 = t3.shapeInfo.texShape, u2 = i2[0], s2 = i2[1], c2 = ra(e3);
        return "\n    float " + n2 + "() {\n      vec2 uv = uvFromFlat(" + u2 + ", " + s2 + ", " + c2 + ");\n      return sampleTexture(" + e3 + ", uv);\n    }\n  ";
      }(t2);
    case 1:
      return function(t3) {
        var e3 = t3.name, n2 = "get" + e3.charAt(0).toUpperCase() + e3.slice(1);
        if (t3.shapeInfo.isUniform)
          return "\n      float " + n2 + "(int index) {\n        " + oa(t3) + "\n      }\n    ";
        var r2 = t3.shapeInfo.texShape, o2 = r2[0], a2 = r2[1];
        if (1 === a2 && 1 === o2)
          return "\n      float " + n2 + "(int index) {\n        return sampleTexture(" + e3 + ", halfCR);\n      }\n    ";
        var i2 = ra(e3);
        if (1 === a2)
          return "\n      float " + n2 + "(int index) {\n        vec2 uv = vec2(0.5, (float(index + " + i2 + ") + 0.5) / " + o2 + ".0);\n        return sampleTexture(" + e3 + ", uv);\n      }\n    ";
        if (1 === o2)
          return "\n      float " + n2 + "(int index) {\n        vec2 uv = vec2((float(index + " + i2 + ") + 0.5) / " + a2 + ".0, 0.5);\n        return sampleTexture(" + e3 + ", uv);\n      }\n    ";
        return "\n    float " + n2 + "(int index) {\n      vec2 uv = uvFromFlat(" + o2 + ", " + a2 + ", index + " + i2 + ");\n      return sampleTexture(" + e3 + ", uv);\n    }\n  ";
      }(t2);
    case 2:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n2 = t3.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = t3.shapeInfo.texShape;
        if (null != o2 && C(e3, o2)) {
          var a2 = o2[0], i2 = o2[1];
          return "\n    float " + r2 + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + i2 + ".0, " + a2 + ".0);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
        }
        var u2 = T(e3), s2 = u2.newShape, c2 = u2.keptDims, l2 = s2;
        if (l2.length < e3.length) {
          var h2 = ia(t3, l2);
          return "\n      " + Qo(h2) + "\n      float " + r2 + "(int row, int col) {\n        return " + r2 + "(" + ua(["row", "col"], c2) + ");\n      }\n    ";
        }
        if (t3.shapeInfo.isUniform)
          return "\n      float " + r2 + "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(" + e3[1] + ", 1)));\n        " + oa(t3) + "\n      }\n    ";
        var f2 = o2[0], p2 = o2[1], d2 = ra(n2);
        if (1 === p2)
          return "\n    float " + r2 + "(int row, int col) {\n      float index = dot(vec3(row, col, " + d2 + "), vec3(" + e3[1] + ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / " + f2 + ".0);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
        if (1 === f2)
          return "\n    float " + r2 + "(int row, int col) {\n      float index = dot(vec3(row, col, " + d2 + "), vec3(" + e3[1] + ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / " + p2 + ".0, 0.5);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
        return "\n  float " + r2 + "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * " + e3[1] + " + col + " + d2 + ";\n    vec2 uv = uvFromFlat(" + f2 + ", " + p2 + ", index);\n    return sampleTexture(" + n2 + ", uv);\n  }\n";
      }(t2);
    case 3:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n2 = t3.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = e3[1] * e3[2], a2 = e3[2], i2 = T(e3), u2 = i2.newShape, s2 = i2.keptDims, c2 = u2;
        if (c2.length < e3.length) {
          var l2 = ia(t3, c2);
          return "\n        " + Qo(l2) + "\n        float " + r2 + "(int row, int col, int depth) {\n          return " + r2 + "(" + ua(["row", "col", "depth"], s2) + ");\n        }\n      ";
        }
        if (t3.shapeInfo.isUniform)
          return "\n      float " + r2 + "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(" + o2 + ", " + a2 + ", 1)));\n        " + oa(t3) + "\n      }\n    ";
        var h2 = t3.shapeInfo.texShape, f2 = h2[0], p2 = h2[1], d2 = t3.shapeInfo.flatOffset;
        if (p2 === o2 && null == d2)
          return "\n        float " + r2 + "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(" + a2 + ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + p2 + ".0, " + f2 + ".0);\n          return sampleTexture(" + n2 + ", uv);\n        }\n      ";
        if (p2 === a2 && null == d2)
          return "\n    float " + r2 + "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(" + e3[1] + ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + p2 + ".0, " + f2 + ".0);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
        var v2 = ra(n2);
        return "\n      float " + r2 + "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * " + o2 + " + col * " + a2 + " + depth + " + v2 + ";\n        vec2 uv = uvFromFlat(" + f2 + ", " + p2 + ", index);\n        return sampleTexture(" + n2 + ", uv);\n      }\n  ";
      }(t2);
    case 4:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n2 = t3.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = e3[3], a2 = e3[2] * o2, i2 = e3[1] * a2, u2 = T(e3), s2 = u2.newShape, c2 = u2.keptDims;
        if (s2.length < e3.length) {
          var l2 = ia(t3, s2);
          return "\n      " + Qo(l2) + "\n      float " + r2 + "(int row, int col, int depth, int depth2) {\n        return " + r2 + "(" + ua(["row", "col", "depth", "depth2"], c2) + ");\n      }\n    ";
        }
        if (t3.shapeInfo.isUniform)
          return "\n      float " + r2 + "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(" + i2 + ", " + a2 + ", " + o2 + ", 1)));\n        " + oa(t3) + "\n      }\n    ";
        var h2 = t3.shapeInfo.flatOffset, f2 = t3.shapeInfo.texShape, p2 = f2[0], d2 = f2[1];
        if (d2 === i2 && null == h2)
          return "\n      float " + r2 + "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(" + a2 + ", " + o2 + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + d2 + ".0, " + p2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
        if (d2 === o2 && null == h2)
          return "\n      float " + r2 + "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(" + e3[1] * e3[2] + ", " + e3[2] + ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + d2 + ".0, " + p2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
        var v2 = ra(n2);
        return "\n    float " + r2 + "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + i2 + " + col * " + a2 + " +\n          depth * " + o2 + " + depth2;\n      vec2 uv = uvFromFlat(" + p2 + ", " + d2 + ", index + " + v2 + ");\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
      }(t2);
    case 5:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n2 = t3.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = e3[4], a2 = e3[3] * o2, i2 = e3[2] * a2, u2 = e3[1] * i2, s2 = T(e3), c2 = s2.newShape, l2 = s2.keptDims;
        if (c2.length < e3.length) {
          var h2 = ia(t3, c2);
          return "\n      " + Qo(h2) + "\n      float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n        return " + r2 + "(" + ua(["row", "col", "depth", "depth2", "depth3"], l2) + ");\n      }\n    ";
        }
        if (t3.shapeInfo.isUniform)
          return "\n      float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + u2 + ", " + i2 + ", " + a2 + ", " + o2 + ")) +\n          depth3;\n        " + oa(t3) + "\n      }\n    ";
        var f2 = t3.shapeInfo.flatOffset, p2 = t3.shapeInfo.texShape, d2 = p2[0], v2 = p2[1];
        if (v2 === u2 && null == f2)
          return "\n      float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(" + i2 + ", " + a2 + ", " + o2 + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + v2 + ".0, " + d2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
        if (v2 === o2 && null == f2)
          return "\n      float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + e3[1] * e3[2] * e3[3] + ",\n               " + e3[2] * e3[3] + ", " + e3[3] + ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + v2 + ".0, " + d2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
        var m2 = ra(n2);
        return "\n    float " + r2 + "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + u2 + " + col * " + i2 + " + depth * " + a2 + " +\n          depth2 * " + o2 + " + depth3 + " + m2 + ";\n      vec2 uv = uvFromFlat(" + d2 + ", " + v2 + ", index);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
      }(t2);
    case 6:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n2 = t3.name, r2 = "get" + n2.charAt(0).toUpperCase() + n2.slice(1), o2 = T(e3), a2 = o2.newShape, i2 = o2.keptDims;
        if (a2.length < e3.length) {
          var u2 = ia(t3, a2);
          return "\n      " + Qo(u2) + "\n      float " + r2 + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return " + r2 + "(" + ua(["row", "col", "depth", "depth2", "depth3", "depth4"], i2) + ");\n      }\n    ";
        }
        var s2 = e3[5], c2 = e3[4] * s2, l2 = e3[3] * c2, h2 = e3[2] * l2, f2 = e3[1] * h2;
        if (t3.shapeInfo.isUniform)
          return "\n      float " + r2 + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + f2 + ", " + h2 + ", " + l2 + ", " + c2 + ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(" + s2 + ", 1)));\n        " + oa(t3) + "\n      }\n    ";
        var p2 = t3.shapeInfo.flatOffset, d2 = t3.shapeInfo.texShape, v2 = d2[0], m2 = d2[1];
        if (m2 === f2 && null == p2)
          return "\n      float " + r2 + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(" + h2 + ", " + l2 + ", " + c2 + ", " + s2 + ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + m2 + ".0, " + v2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
        if (m2 === s2 && null == p2)
          return "\n      float " + r2 + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(" + e3[1] * e3[2] * e3[3] * e3[4] + ",\n               " + e3[2] * e3[3] * e3[4] + ",\n               " + e3[3] * e3[4] + ",\n               " + e3[4] + ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + m2 + ".0, " + v2 + ".0);\n        return sampleTexture(" + n2 + ", uv);\n      }\n    ";
        var g2 = ra(n2);
        return "\n    float " + r2 + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + f2 + " + col * " + h2 + " + depth * " + l2 + " +\n          depth2 * " + c2 + " + depth3 * " + s2 + " + depth4 + " + g2 + ";\n      vec2 uv = uvFromFlat(" + v2 + ", " + m2 + ", index);\n      return sampleTexture(" + n2 + ", uv);\n    }\n  ";
      }(t2);
    default:
      throw new Error(e2.length + "-D input sampling is not yet supported");
  }
}
function Jo(t2) {
  var e2, n2, r2;
  switch (t2.shapeInfo.logicalShape.length) {
    case 0:
      return e2 = t2.name, n2 = "get" + e2.charAt(0).toUpperCase() + e2.slice(1), r2 = Ko(), "\n    vec4 " + n2 + "() {\n      return " + r2.texture2D + "(" + e2 + ", halfCR);\n    }\n  ";
    case 1:
      return function(t3) {
        var e3 = t3.name, n3 = "get" + e3.charAt(0).toUpperCase() + e3.slice(1), r3 = t3.shapeInfo.texShape, o2 = [Math.ceil(r3[0] / 2), Math.ceil(r3[1] / 2)], a2 = Ko();
        return "\n    vec4 " + n3 + "(int index) {\n      vec2 uv = packedUVfrom1D(\n        " + o2[0] + ", " + o2[1] + ", index);\n      return " + a2.texture2D + "(" + e3 + ", uv);\n    }\n  ";
      }(t2);
    case 2:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n3 = t3.name, r3 = "get" + n3.charAt(0).toUpperCase() + n3.slice(1), o2 = t3.shapeInfo.texShape, a2 = o2[0], i2 = o2[1], u2 = Ko();
        if (null != o2 && C(e3, o2))
          return "\n      vec4 " + r3 + "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + i2 + ".0, " + a2 + ".0);\n\n        return " + u2.texture2D + "(" + n3 + ", uv);\n      }\n    ";
        var s2 = [Math.ceil(o2[0] / 2), Math.ceil(o2[1] / 2)], c2 = Math.ceil(e3[1] / 2);
        return "\n    vec4 " + r3 + "(int row, int col) {\n      vec2 uv = packedUVfrom2D(" + c2 + ", " + s2[0] + ", " + s2[1] + ", row, col);\n      return " + u2.texture2D + "(" + n3 + ", uv);\n    }\n  ";
      }(t2);
    case 3:
      return function(t3) {
        var e3 = t3.shapeInfo.logicalShape, n3 = t3.name, r3 = "get" + n3.charAt(0).toUpperCase() + n3.slice(1), o2 = t3.shapeInfo.texShape, a2 = [Math.ceil(o2[0] / 2), Math.ceil(o2[1] / 2)];
        if (1 === e3[0]) {
          var i2 = e3.slice(1), u2 = ia(t3, i2);
          return "\n        " + Jo(u2) + "\n        vec4 " + r3 + "(int b, int row, int col) {\n          return " + r3 + "(" + ua(["b", "row", "col"], [1, 2]) + ");\n        }\n      ";
        }
        var s2 = a2[0], c2 = a2[1], l2 = Math.ceil(e3[2] / 2), h2 = l2 * Math.ceil(e3[1] / 2), f2 = Ko();
        return "\n    vec4 " + r3 + "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        " + s2 + ", " + c2 + ", " + h2 + ", " + l2 + ", b, row, col);\n      return " + f2.texture2D + "(" + n3 + ", uv);\n    }\n  ";
      }(t2);
    default:
      return function(t3) {
        for (var e3 = t3.shapeInfo.logicalShape, n3 = e3.length, r3 = t3.name, o2 = "get" + r3.charAt(0).toUpperCase() + r3.slice(1), a2 = t3.shapeInfo.texShape, i2 = [Math.ceil(a2[0] / 2), Math.ceil(a2[1] / 2)], u2 = i2[0], s2 = i2[1], c2 = Math.ceil(e3[n3 - 1] / 2), l2 = c2 * Math.ceil(e3[n3 - 2] / 2), h2 = "int b, int row, int col", f2 = "b * " + l2 + " + (row / 2) * " + c2 + " + (col / 2)", p2 = 2; p2 < n3 - 1; p2++)
          h2 = "int b" + p2 + ", " + h2, l2 *= e3[n3 - p2 - 1], f2 = "b" + p2 + " * " + l2 + " + " + f2;
        var d2 = Ko();
        return "\n    vec4 " + o2 + "(" + h2 + ") {\n      int index = " + f2 + ";\n      int texR = index / " + s2 + ";\n      int texC = index - texR * " + s2 + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + s2 + ", " + u2 + ");\n      return " + d2.texture2D + "(" + r3 + ", uv);\n    }\n  ";
      }(t2);
  }
}
var Zo = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var ta = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var ea = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var na = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";
function ra(t2) {
  return "offset" + t2;
}
function oa(t2) {
  var e2 = t2.name, n2 = w(t2.shapeInfo.logicalShape);
  return n2 < 2 ? "return " + e2 + ";" : "\n    for (int i = 0; i < " + n2 + "; i++) {\n      if (i == index) {\n        return " + e2 + "[i];\n      }\n    }\n  ";
}
function aa(t2) {
  if (t2 <= 1)
    return "int";
  if (2 === t2)
    return "ivec2";
  if (3 === t2)
    return "ivec3";
  if (4 === t2)
    return "ivec4";
  if (5 === t2)
    return "ivec5";
  if (6 === t2)
    return "ivec6";
  throw Error("GPU for rank " + t2 + " is not yet supported");
}
function ia(t2, e2) {
  var n2 = JSON.parse(JSON.stringify(t2));
  return n2.shapeInfo.logicalShape = e2, n2;
}
function ua(t2, e2) {
  return e2.map(function(e3) {
    return t2[e3];
  }).join(", ");
}
var sa = function() {
  return function(t2, e2, n2, r2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, g(t2.length > 2, function() {
      return "Packed arg" + (n2.charAt(0).toUpperCase() + n2.slice(1)) + " supports only inputs with rank above 2.";
    });
    var o2 = t2[t2.length - 1], a2 = Math.ceil(o2 / e2);
    this.outputShape = t2.slice(0, -1), a2 > 1 && this.outputShape.push(a2), r2 || this.variableNames.push("bestIndicesA");
    var i2, u2, s2 = this.outputShape, c2 = s2.length, l2 = aa(c2), h2 = qo("coords", c2);
    if (1 === a2) {
      var f2 = aa(u2 = c2 + 1);
      i2 = "\n        " + f2 + " sourceLocR = " + f2 + "(" + h2.join() + ", 0);\n        ++" + h2[c2 - 1] + ";\n        " + f2 + " sourceLocG = " + f2 + "(" + h2.join() + ", 0);\n        ++" + h2[c2 - 2] + ";\n        " + f2 + " sourceLocA = " + f2 + "(" + h2.join() + ", 0);\n        --" + h2[c2 - 1] + ";\n        " + f2 + " sourceLocB = " + f2 + "(" + h2.join() + ", 0);\n        --" + h2[c2 - 2] + ";";
    } else
      u2 = c2, i2 = "\n        " + l2 + " sourceLocR = coords;\n        ++" + h2[c2 - 1] + ";\n        " + l2 + " sourceLocG = coords;\n        ++" + h2[c2 - 2] + ";\n        " + l2 + " sourceLocA = coords;\n        --" + h2[c2 - 1] + ";\n        " + l2 + " sourceLocB = coords;\n        --" + h2[c2 - 2] + ";";
    var p2 = ["x", "y", "z", "w", "u", "v"].slice(0, u2), d2 = "." + p2[u2 - 1], v2 = p2.map(function(t3) {
      return "int " + t3;
    }), m2 = qo("sourceLocR", u2 - 1).concat("inIdx.r"), y2 = qo("sourceLocG", u2 - 1).concat("inIdx.g"), x2 = qo("sourceLocB", u2 - 1).concat("inIdx.b"), b2 = qo("sourceLocA", u2 - 1).concat("inIdx.a"), w2 = "max" === n2 ? "greaterThan" : "lessThan", C2 = r2 ? "" : "\n          inIdx = round(vec4(getBestIndicesAChannel(" + m2.join() + "),\n                             getBestIndicesAChannel(" + y2.join() + "),\n                             getBestIndicesAChannel(" + x2.join() + "),\n                             getBestIndicesAChannel(" + b2.join() + ")));", E2 = "vec4(\n            getAChannel(" + m2.join() + "),\n            hasNextCol ? getAChannel(" + y2.join() + ") : 0.,\n            hasNextRow ? getAChannel(" + x2.join() + ") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(" + b2.join() + ") : 0.)", R2 = r2 ? "" : "\n      float getBestIndicesAChannel(" + v2.join() + ") {\n        return getChannel(getBestIndicesA(" + p2.join() + "),\n                                          vec2(" + p2.slice(-2).join() + "));\n      }";
    this.userCode = "\n      float getAChannel(" + v2.join() + ") {\n        return getChannel(getA(" + p2.join() + "),\n                               vec2(" + p2.slice(-2).join() + "));\n      }\n      " + R2 + "\n      void main() {\n        " + l2 + " coords = getOutputCoords();\n        bool hasNextCol = " + h2[c2 - 1] + " < " + (s2[c2 - 1] - 1) + ";\n        bool hasNextRow = " + h2[c2 - 2] + " < " + (s2[c2 - 2] - 1) + ";\n        " + i2 + "\n        ivec4 srcIdx = ivec4(sourceLocR" + d2 + ", sourceLocG" + d2 + ",\n          sourceLocB" + d2 + ", sourceLocA" + d2 + ") * " + e2 + ";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = " + E2 + ";\n\n        for (int i = 0; i < " + e2 + "; i++) {\n          inIdx = srcIdx;\n          " + C2 + "\n          vec4 candidate = " + E2 + ";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(" + w2 + "(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ";
  };
}();
var ca = function() {
  return function(t2) {
    this.variableNames = ["dy"], this.outputShape = t2.inShape;
    var e2 = t2.filterHeight, n2 = t2.filterWidth, r2 = t2.strideHeight, o2 = t2.strideWidth, a2 = t2.dilationHeight, i2 = t2.dilationWidth, u2 = t2.effectiveFilterHeight, s2 = t2.effectiveFilterWidth, c2 = u2 - 1 - t2.padInfo.top, l2 = s2 - 1 - t2.padInfo.left, h2 = 1 / (e2 * n2);
    this.userCode = "\n      const ivec2 pads = ivec2(" + c2 + ", " + l2 + ");\n      const float avgMultiplier = float(" + h2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + u2 + ";\n            wR += " + a2 + ") {\n          float dyR = float(dyRCorner + wR) / " + r2 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + s2 + ";\n            wC+= " + i2 + ") {\n            float dyC = float(dyCCorner + wC) / " + o2 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var la = function() {
  return function(t2) {
    this.variableNames = ["dy"], this.outputShape = t2.inShape;
    var e2 = t2.filterDepth, n2 = t2.filterHeight, r2 = t2.filterWidth, o2 = t2.strideDepth, a2 = t2.strideHeight, i2 = t2.strideWidth, u2 = t2.dilationDepth, s2 = t2.dilationHeight, c2 = t2.dilationWidth, l2 = t2.effectiveFilterDepth, h2 = t2.effectiveFilterHeight, f2 = t2.effectiveFilterWidth, p2 = l2 - 1 - t2.padInfo.front, d2 = h2 - 1 - t2.padInfo.top, v2 = f2 - 1 - t2.padInfo.left, m2 = 1 / (e2 * n2 * r2);
    this.userCode = "\n      const ivec3 pads = ivec3(" + p2 + ", " + d2 + ", " + v2 + ");\n      const float avgMultiplier = float(" + m2 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + l2 + ";\n            wD += " + u2 + ") {\n          float dyD = float(dyDCorner + wD) / " + o2 + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t2.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + h2 + ";\n              wR += " + s2 + ") {\n            float dyR = float(dyRCorner + wR) / " + a2 + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + f2 + ";\n                wC += " + c2 + ") {\n              float dyC = float(dyCCorner + wC) / " + i2 + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var ha = function() {
  return function(t2, e2, n2, r2, o2, a2) {
    this.outputShape = [], this.variableNames = ["x", "mean", "variance"], po(t2, e2), po(t2, n2);
    var i2 = "0.0";
    null != r2 && (po(t2, r2), this.variableNames.push("offset"), i2 = "getOffsetAtOutCoords()");
    var u2 = "1.0";
    null != o2 && (po(t2, o2), this.variableNames.push("scale"), u2 = "getScaleAtOutCoords()"), this.outputShape = t2, this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + i2 + ";\n        float scale = " + u2 + ";\n        float inv = scale * inversesqrt(variance + float(" + a2 + "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ";
  };
}();
var fa = function() {
  return function(t2, e2, n2, r2, o2, a2) {
    this.packedInputs = true, this.packedOutput = true, this.variableNames = ["x", "mean", "variance"], po(t2, e2), po(t2, n2);
    var i2 = "vec4(0.0)";
    null != r2 && (po(t2, r2), this.variableNames.push("offset"), i2 = "getOffsetAtOutCoords()");
    var u2 = "vec4(1.0)";
    null != o2 && (po(t2, o2), this.variableNames.push("scale"), u2 = "getScaleAtOutCoords()"), this.outputShape = t2, this.userCode = "\n      void main() {\n        vec4 offset = " + i2 + ";\n        vec4 scale = " + u2 + ";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(" + a2 + "));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ";
  };
}();
var pa = "return areal * breal - aimag * bimag;";
var da = "return areal * bimag + aimag * breal;";
var va = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = po(e2, n2), this.userCode = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        " + t2 + "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ";
  };
}();
var ma = "return a + b;";
var ga = "return a - b;";
var ya = "return a * b;";
var xa = "return (a < 0.) ? b * a : a;";
var ba = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["A", "B"], this.outputShape = po(e2, n2), this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + t2 + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";
  };
}();
var wa = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
var Ca = function() {
  return function(t2, e2, n2, r2) {
    void 0 === r2 && (r2 = false), this.variableNames = ["A", "B"], this.supportsBroadcasting = true, this.packedInputs = true, this.packedOutput = true, this.outputShape = po(e2, n2);
    var o2 = this.outputShape.length, a2 = "";
    if (r2)
      if (0 === o2 || 1 === w(this.outputShape))
        a2 = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
      else if (a2 = "\n          " + aa(o2) + " coords = getOutputCoords();\n        ", 1 === o2)
        a2 += "\n            result.y = (coords + 1) >= " + this.outputShape[0] + " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";
      else {
        var i2 = qo("coords", o2);
        a2 += "\n            bool nextRowOutOfBounds =\n              (" + i2[o2 - 2] + " + 1) >= " + this.outputShape[o2 - 2] + ";\n            bool nextColOutOfBounds =\n              (" + i2[o2 - 1] + " + 1) >= " + this.outputShape[o2 - 1] + ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ";
      }
    this.userCode = "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        " + t2 + "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        " + a2 + "\n\n        setOutput(result);\n      }\n    ";
  };
}();
var Ea = function() {
  function t2(t3) {
    this.variableNames = ["A"], this.outputShape = t3, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    ";
  }
  return t2.prototype.getCustomSetupFunc = function(t3, e2) {
    var n2 = this;
    return function(r2, o2) {
      null == n2.minLoc && (n2.minLoc = r2.getUniformLocationNoThrow(o2, "minVal"), n2.maxLoc = r2.getUniformLocationNoThrow(o2, "maxVal")), r2.gl.uniform1f(n2.minLoc, t3), r2.gl.uniform1f(n2.maxLoc, e2);
    };
  }, t2;
}();
var Ra = function() {
  function t2(t3) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t3, this.userCode = "\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    ";
  }
  return t2.prototype.getCustomSetupFunc = function(t3, e2) {
    var n2 = this;
    return function(r2, o2) {
      null == n2.minLoc && (n2.minLoc = r2.getUniformLocationNoThrow(o2, "minVal"), n2.maxLoc = r2.getUniformLocationNoThrow(o2, "maxVal")), r2.gl.uniform1f(n2.minLoc, t3), r2.gl.uniform1f(n2.maxLoc, e2);
    };
  }, t2;
}();
var Ia = function() {
  return function(t2) {
    this.variableNames = ["real", "imag"], this.outputShape = t2, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    ";
  };
}();
var ka = function() {
  return function(t2) {
    this.outputShape = [], this.outputShape = wn(t2, 1), this.variableNames = t2.map(function(t3, e3) {
      return "T" + e3;
    });
    var e2 = new Array(t2.length - 1);
    e2[0] = t2[0][1];
    for (var n2 = 1; n2 < e2.length; n2++)
      e2[n2] = e2[n2 - 1] + t2[n2][1];
    var r2 = ["if (yC < " + e2[0] + ") setOutput(getT0(yR, yC));"];
    for (n2 = 1; n2 < e2.length; n2++) {
      var o2 = e2[n2 - 1];
      r2.push("else if (yC < " + e2[n2] + ") setOutput(getT" + n2 + "(yR, yC-" + o2 + "));");
    }
    var a2 = e2.length, i2 = e2[e2.length - 1];
    r2.push("else setOutput(getT" + a2 + "(yR, yC-" + i2 + "));"), this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        " + r2.join("\n        ") + "\n      }\n    ";
  };
}();
var Sa = function() {
  return function(t2, e2) {
    this.packedInputs = true, this.packedOutput = true, this.outputShape = [], this.outputShape = wn(t2, e2);
    var n2 = this.outputShape, r2 = n2.length, o2 = aa(r2), a2 = qo("coords", r2), i2 = ["x", "y", "z", "w", "u", "v"].slice(0, r2);
    this.variableNames = t2.map(function(t3, e3) {
      return "T" + e3;
    });
    var u2 = new Array(t2.length - 1);
    u2[0] = t2[0][e2];
    for (var s2 = 1; s2 < u2.length; s2++)
      u2[s2] = u2[s2 - 1] + t2[s2][e2];
    var c2 = i2[e2], l2 = i2.slice(-2), h2 = i2.join(), f2 = "if (" + c2 + " < " + u2[0] + ") {\n        return getChannel(\n            getT0(" + h2 + "), vec2(" + l2.join() + "));\n        }";
    for (s2 = 1; s2 < u2.length; s2++) {
      var p2 = u2[s2 - 1];
      f2 += "\n        if (" + c2 + " < " + u2[s2] + "  && " + c2 + " >= " + u2[s2 - 1] + ") {\n          return getChannel(\n            getT" + s2 + "(" + Aa(i2, c2, p2) + "),\n            vec2(" + Aa(l2, c2, p2) + "));\n        }";
    }
    var d2 = u2.length, v2 = u2[u2.length - 1];
    f2 += "\n        return getChannel(\n          getT" + d2 + "(" + Aa(i2, c2, v2) + "),\n          vec2(" + Aa(l2, c2, v2) + "));", this.userCode = "\n      float getValue(" + i2.map(function(t3) {
      return "int " + t3;
    }) + ") {\n        " + f2 + "\n      }\n\n      void main() {\n        " + o2 + " coords = getOutputCoords();\n        vec4 result = vec4(getValue(" + a2 + "), 0., 0., 0.);\n\n        " + a2[r2 - 1] + " = " + a2[r2 - 1] + " + 1;\n        if (" + a2[r2 - 1] + " < " + n2[r2 - 1] + ") {\n          result.g = getValue(" + a2 + ");\n        }\n\n        " + a2[r2 - 2] + " = " + a2[r2 - 2] + " + 1;\n        if (" + a2[r2 - 2] + " < " + n2[r2 - 2] + ") {\n          result.a = getValue(" + a2 + ");\n        }\n\n        " + a2[r2 - 1] + " = " + a2[r2 - 1] + " - 1;\n        if (" + a2[r2 - 2] + " < " + n2[r2 - 2] + " &&\n            " + a2[r2 - 1] + " < " + n2[r2 - 1] + ") {\n          result.b = getValue(" + a2 + ");\n        }\n        setOutput(result);\n      }\n    ";
  };
}();
function Aa(t2, e2, n2) {
  var r2 = t2.indexOf(e2);
  return t2.map(function(t3, e3) {
    return e3 === r2 ? t3 + " - " + n2 : t3;
  }).join();
}
var Da = function() {
  return function(t2) {
    this.variableNames = ["x", "dy"], this.outputShape = t2.filterShape;
    var e2 = t2.strideHeight, n2 = t2.strideWidth, r2 = t2.padInfo.top, o2 = t2.padInfo.left, a2 = "channelsLast" === t2.dataFormat;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t2.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t2.outHeight + "; yR++) {\n            int xR = wR + yR * " + e2 + " - " + r2 + ";\n\n            if (xR < 0 || xR >= " + t2.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t2.outWidth + "; yC++) {\n              int xC = wC + yC * " + n2 + " - " + o2 + ";\n\n              if (xC < 0 || xC >= " + t2.inWidth + ") {\n                continue;\n              }\n\n              if (" + a2 + ") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var Ta = function() {
  return function(t2) {
    this.variableNames = ["dy", "W"], this.outputShape = t2.inShape;
    var e2 = t2.filterHeight, n2 = t2.filterWidth, r2 = t2.strideHeight, o2 = t2.strideWidth, a2 = "channelsLast" === t2.dataFormat, i2 = e2 - 1 - t2.padInfo.top, u2 = n2 - 1 - t2.padInfo.left, s2 = a2 ? 1 : 2, c2 = a2 ? 2 : 3, l2 = a2 ? 3 : 1;
    this.userCode = "\n      const ivec2 pads = ivec2(" + i2 + ", " + u2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[" + l2 + "];\n\n        ivec2 dyCorner = ivec2(coords[" + s2 + "], coords[" + c2 + "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + e2 + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r2 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e2 + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n2 + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + o2 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n2 + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + t2.outChannels + "; d2++) {\n\n              if (" + a2 + ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var Na = function() {
  return function(t2) {
    this.variableNames = ["x", "dy"], this.outputShape = t2.filterShape;
    var e2 = t2.strideDepth, n2 = t2.strideHeight, r2 = t2.strideWidth, o2 = t2.padInfo.front, a2 = t2.padInfo.top, i2 = t2.padInfo.left;
    this.userCode = "\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + t2.batchSize + "; b++) {\n          for (int yF = 0; yF < " + t2.outDepth + "; yF++) {\n            int xF = wF + yF * " + e2 + " - " + o2 + ";\n\n            if (xF < 0 || xF >= " + t2.inDepth + ") {\n              continue;\n            }\n\n            for (int yR = 0; yR < " + t2.outHeight + "; yR++) {\n              int xR = wR + yR * " + n2 + " - " + a2 + ";\n\n              if (xR < 0 || xR >= " + t2.inHeight + ") {\n                continue;\n              }\n\n              for (int yC = 0; yC < " + t2.outWidth + "; yC++) {\n                int xC = wC + yC * " + r2 + " - " + i2 + ";\n\n                if (xC < 0 || xC >= " + t2.inWidth + ") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var Fa = function() {
  return function(t2) {
    this.variableNames = ["dy", "W"], this.outputShape = t2.inShape;
    var e2 = t2.filterDepth, n2 = t2.filterHeight, r2 = t2.filterWidth, o2 = t2.strideDepth, a2 = t2.strideHeight, i2 = t2.strideWidth, u2 = e2 - 1 - t2.padInfo.front, s2 = n2 - 1 - t2.padInfo.top, c2 = r2 - 1 - t2.padInfo.left;
    this.userCode = "\n      const ivec3 pads = ivec3(" + u2 + ", " + s2 + ", " + c2 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + e2 + "; wF++) {\n          float dyF = float(dyFCorner + wF) / " + o2 + ".0;\n\n          if (dyF < 0.0 || dyF >= " + t2.outDepth + ".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = " + e2 + " - 1 - wF;\n\n          for (int wR = 0; wR < " + n2 + "; wR++) {\n            float dyR = float(dyRCorner + wR) / " + a2 + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = " + n2 + " - 1 - wR;\n\n            for (int wC = 0; wC < " + r2 + "; wC++) {\n              float dyC = float(dyCCorner + wC) / " + i2 + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = " + r2 + " - 1 - wC;\n\n              for (int d2 = 0; d2 < " + t2.outChannels + "; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var Oa = function() {
  return function(t2) {
    this.variableNames = ["x", "dy"], this.outputShape = t2.filterShape;
    var e2 = t2.strideHeight, n2 = t2.strideWidth, r2 = t2.padInfo.top, o2 = t2.padInfo.left, a2 = t2.outChannels / t2.inChannels;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * " + a2 + " + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < " + t2.batchSize + "; b++) {\n          for (int yR = 0; yR < " + t2.outHeight + "; yR++) {\n            int xR = wR + yR * " + e2 + " - " + r2 + ";\n\n            if (xR < 0 || xR >= " + t2.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + t2.outWidth + "; yC++) {\n              int xC = wC + yC * " + n2 + " - " + o2 + ";\n\n              if (xC < 0 || xC >= " + t2.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var _a = function() {
  return function(t2) {
    this.variableNames = ["dy", "W"], this.outputShape = t2.inShape;
    var e2 = t2.filterHeight, n2 = t2.filterWidth, r2 = t2.strideHeight, o2 = t2.strideWidth, a2 = e2 - 1 - t2.padInfo.top, i2 = n2 - 1 - t2.padInfo.left, u2 = t2.outChannels / t2.inChannels;
    this.userCode = "\n      const ivec2 pads = ivec2(" + a2 + ", " + i2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < " + e2 + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + r2 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + e2 + " - 1 - wR;\n\n          for (int wC = 0; wC < " + n2 + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + o2 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + n2 + " - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < " + u2 + "; dm++) {\n              int d2 = d1 * " + u2 + " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var Ma = function() {
  return function(t2, e2, n2, r2) {
    void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = null), void 0 === r2 && (r2 = false), this.variableNames = ["x", "W"], this.outputShape = t2.outShape;
    var o2 = t2.padInfo.top, a2 = t2.padInfo.left, i2 = t2.strideHeight, u2 = t2.strideWidth, s2 = t2.dilationHeight, c2 = t2.dilationWidth, l2 = t2.filterHeight, h2 = t2.filterWidth, f2 = 4 * Math.floor(t2.inChannels / 4), p2 = t2.inChannels % 4, d2 = "channelsLast" === t2.dataFormat, v2 = d2 ? 1 : 2, m2 = d2 ? 2 : 3, g2 = d2 ? 3 : 1, y2 = "", x2 = "";
    n2 && (y2 = r2 ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n2 + "\n        }" : "\n          float activation(float x) {\n            " + n2 + "\n          }\n        ", x2 = "result = activation(result);");
    var b2 = e2 ? "result += getBiasAtOutCoords();" : "";
    e2 && this.variableNames.push("bias"), r2 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + y2 + "\n\n      const ivec2 strides = ivec2(" + i2 + ", " + u2 + ");\n      const ivec2 pads = ivec2(" + o2 + ", " + a2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[" + g2 + "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[" + v2 + "], coords[" + m2 + "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + l2 + "; wR++) {\n          int xR = xRCorner + wR * " + s2 + ";\n\n          if (xR < 0 || xR >= " + t2.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + h2 + "; wC++) {\n            int xC = xCCorner + wC * " + c2 + ";\n\n            if (xC < 0 || xC >= " + t2.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + f2 + "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (" + d2 + ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (" + (1 === p2) + ") {\n\n              if (" + d2 + ") {\n                dotProd +=\n                    getX(batch, xR, xC, " + f2 + ") *\n                    getW(wR, wC, " + f2 + ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, " + f2 + ", xR, xC) *\n                    getW(wR, wC, " + f2 + ", d2);\n              }\n\n            } else if (" + (2 === p2) + ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, " + f2 + ", d2),\n                getW(wR, wC, " + f2 + " + 1, d2)\n              );\n\n              if (" + d2 + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, " + f2 + "),\n                  getX(batch, xR, xC, " + f2 + " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, " + f2 + ", xR, xC),\n                  getX(batch, " + f2 + " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (" + (3 === p2) + ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, " + f2 + ", d2),\n                getW(wR, wC, " + f2 + " + 1, d2),\n                getW(wR, wC, " + f2 + " + 2, d2)\n              );\n\n              if (" + d2 + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, " + f2 + "),\n                  getX(batch, xR, xC, " + f2 + " + 1),\n                  getX(batch, xR, xC, " + f2 + " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, " + f2 + ", xR, xC),\n                  getX(batch, " + f2 + " + 1, xR, xC),\n                  getX(batch, " + f2 + " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        " + b2 + "\n        " + x2 + "\n        setOutput(result);\n      }\n    ";
  };
}();
var Ba = function() {
  return function(t2) {
    this.variableNames = ["x", "W"], this.outputShape = t2.outShape;
    var e2 = t2.padInfo.front, n2 = t2.padInfo.top, r2 = t2.padInfo.left, o2 = t2.strideDepth, a2 = t2.strideHeight, i2 = t2.strideWidth, u2 = t2.dilationDepth, s2 = t2.dilationHeight, c2 = t2.dilationWidth, l2 = t2.filterDepth, h2 = t2.filterHeight, f2 = t2.filterWidth, p2 = 4 * Math.floor(t2.inChannels / 4), d2 = t2.inChannels % 4;
    this.userCode = "\n      const ivec3 strides = ivec3(" + o2 + ", " + a2 + ", " + i2 + ");\n      const ivec3 pads = ivec3(" + e2 + ", " + n2 + ", " + r2 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < " + l2 + "; wF++) {\n          int xF = xFCorner + wF * " + u2 + ";\n\n          if (xF < 0 || xF >= " + t2.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h2 + "; wR++) {\n            int xR = xRCorner + wR * " + s2 + ";\n\n            if (xR < 0 || xR >= " + t2.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + f2 + "; wC++) {\n              int xC = xCCorner + wC * " + c2 + ";\n\n              if (xC < 0 || xC >= " + t2.inWidth + ") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < " + p2 + "; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (" + (1 === d2) + ") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, " + p2 + ") *\n                  getW(wF, wR, wC, " + p2 + ", d2);\n              } else if (" + (2 === d2) + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, " + p2 + "),\n                  getX(batch, xF, xR, xC, " + p2 + " + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, " + p2 + ", d2),\n                  getW(wF, wR, wC, " + p2 + " + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (" + (3 === d2) + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, " + p2 + "),\n                  getX(batch, xF, xR, xC, " + p2 + " + 1),\n                  getX(batch, xF, xR, xC, " + p2 + " + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, " + p2 + ", d2),\n                  getW(wF, wR, wC, " + p2 + " + 1, d2),\n                  getW(wF, wR, wC, " + p2 + " + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var Pa = function() {
  return function(t2, e2, n2, r2) {
    void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = null), void 0 === r2 && (r2 = false), this.variableNames = ["x", "W"], this.outputShape = t2.outShape;
    var o2 = t2.inHeight, a2 = t2.inWidth, i2 = t2.padInfo.top, u2 = t2.padInfo.left, s2 = t2.strideHeight, c2 = t2.strideWidth, l2 = t2.dilationHeight, h2 = t2.dilationWidth, f2 = t2.filterHeight, p2 = t2.filterWidth, d2 = t2.outChannels / t2.inChannels, v2 = "", m2 = "";
    n2 && (v2 = r2 ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + n2 + "\n        }" : "\n          float activation(float x) {\n            " + n2 + "\n          }\n        ", m2 = "result = activation(result);");
    var g2 = e2 ? "result += getBiasAtOutCoords();" : "";
    e2 && this.variableNames.push("bias"), r2 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + v2 + "\n\n      const ivec2 strides = ivec2(" + s2 + ", " + c2 + ");\n      const ivec2 pads = ivec2(" + i2 + ", " + u2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + d2 + ";\n        int q = d2 - d1 * " + d2 + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + f2 + "; wR++) {\n          int xR = xRCorner + wR * " + l2 + ";\n\n          if (xR < 0 || xR >= " + o2 + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + p2 + "; wC++) {\n            int xC = xCCorner + wC * " + h2 + ";\n\n            if (xC < 0 || xC >= " + a2 + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        " + g2 + "\n        " + m2 + "\n        setOutput(result);\n      }\n    ";
  };
}();
var La = function() {
  return function(t2, e2, n2, r2) {
    void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = null), void 0 === r2 && (r2 = false), this.variableNames = ["x", "W"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t2.outShape;
    for (var o2 = t2.inHeight, a2 = t2.inWidth, i2 = t2.padInfo.top, u2 = t2.padInfo.left, s2 = t2.strideHeight, c2 = t2.strideWidth, l2 = t2.dilationHeight, h2 = t2.dilationWidth, f2 = t2.filterHeight, p2 = t2.filterWidth, d2 = p2, m2 = "int xR; int xC; int xCOffset;", g2 = 0; g2 < f2; g2++)
      for (var y2 = 0; y2 < p2; y2++)
        m2 += "\n          vec4 xTexelR" + g2 + "C" + 2 * y2 + " = vec4(0.);\n          vec4 wR" + g2 + "C" + y2 + " = vec4(0.);\n          vec4 xR" + g2 + "C" + y2 + " = vec4(0.);";
    for (g2 = 0; g2 < f2; g2++)
      for (var x2 = 0; x2 < d2; x2++) {
        if (m2 += "\n          xR = xRCorner + " + g2 * l2 + ";\n          xC = xCCorner + " + (y2 = 2 * x2) * h2 + ";\n        ", 1 === c2) {
          if (y2 < p2 && (m2 += u2 % 2 == 1 ? "\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < " + o2 + " && xCOffset >= 0 && xCOffset < " + a2 + ") {\n                  xTexelR" + g2 + "C" + y2 + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + g2 + "C" + y2 + " = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < " + o2 + " && xCOffset >= 0 && xCOffset < " + a2 + ") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n                  xR" + g2 + "C" + y2 + " = vec4(previous.zw, xTexelR" + g2 + "C" + y2 + ".xy);\n                } else {\n                  xR" + g2 + "C" + y2 + " = vec4(0, 0, xTexelR" + g2 + "C" + y2 + ".xy);\n                }\n              " : "\n                if(xR >= 0 && xR < " + o2 + " && xC >= 0 && xC < " + a2 + ") {\n                  xTexelR" + g2 + "C" + y2 + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + g2 + "C" + y2 + " = vec4(0.);\n                }\n\n                xR" + g2 + "C" + y2 + " = xTexelR" + g2 + "C" + y2 + ";\n              ", y2 + 1 < p2)) {
            var b2 = u2 % 2 == 0 ? v(h2) : h2;
            h2 % 2 == 0 && u2 % 2 == 1 || h2 % 2 != 0 && u2 % 2 != 1 ? (m2 += "\n                  xCOffset = xC + " + u2 % 2 + " + " + b2 + ";\n\n                  if(xR >= 0 && xR < " + o2 + " &&\n                    xCOffset >= 0 && xCOffset < " + a2 + ") {\n                    xTexelR" + g2 + "C" + (y2 + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n                ", h2 > 1 && (m2 += "\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < " + o2 + " &&\n                      xCOffset >= 0 && xCOffset < " + a2 + ") {\n                      xTexelR" + g2 + "C" + y2 + " = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR" + g2 + "C" + y2 + " = vec4(0.);\n                    }\n                  "), m2 += "\n                  xR" + g2 + "C" + (y2 + 1) + " = vec4(\n                    xTexelR" + g2 + "C" + y2 + ".zw, xTexelR" + g2 + "C" + (y2 + 2) + ".xy);\n                ") : m2 += "\n                  xCOffset = xC + " + b2 + ";\n\n                  if(xR >= 0 && xR < " + o2 + " &&\n                    xCOffset >= 0 && xCOffset < " + a2 + ") {\n                    xTexelR" + g2 + "C" + (y2 + 2) + " = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR" + g2 + "C" + (y2 + 1) + " = xTexelR" + g2 + "C" + (y2 + 2) + ";\n                ";
          }
        } else
          y2 < p2 && (m2 += "\n              if(xR >= 0 && xR < " + o2 + ") {\n            ", u2 % 2 == 1 ? (m2 += "\n                xCOffset = xC + 1 - " + c2 + ";\n                if(xCOffset >= 0 && xCOffset < " + a2 + ") {\n                  xTexelR" + g2 + "C" + y2 + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + g2 + "C" + y2 + " = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < " + a2 + ") {\n                  xTexelR" + g2 + "C" + (y2 + 2) + " = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR" + g2 + "C" + (y2 + 2) + " = vec4(0.);\n                }\n\n                xR" + g2 + "C" + y2 + " = vec4(\n                  xTexelR" + g2 + "C" + y2 + ".zw, xTexelR" + g2 + "C" + (y2 + 2) + ".zw);\n              ", y2 + 1 < p2 && (m2 += "\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + " + c2 + ";\n                  if(xCOffset >= 0 && xCOffset < " + a2 + ") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR" + g2 + "C" + (y2 + 1) + " = vec4(xTexelR" + g2 + "C" + (y2 + 2) + ".xy, final.xy);\n                ")) : (m2 += "\n                if(xC >= 0 && xC < " + a2 + ") {\n                  xTexelR" + g2 + "C" + y2 + " = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR" + g2 + "C" + y2 + " = vec4(0.);\n                }\n\n                xCOffset = xC + " + c2 + ";\n                if(xCOffset >= 0 && xCOffset < " + a2 + ") {\n                  xTexelR" + g2 + "C" + (y2 + 2) + " = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR" + g2 + "C" + (y2 + 2) + " = vec4(0.);\n                }\n\n                xR" + g2 + "C" + y2 + " = vec4(\n                  xTexelR" + g2 + "C" + y2 + ".xy, xTexelR" + g2 + "C" + (y2 + 2) + ".xy);\n              ", y2 + 1 < p2 && (m2 += "\n                  xR" + g2 + "C" + (y2 + 1) + " = vec4(\n                    xTexelR" + g2 + "C" + y2 + ".zw, xTexelR" + g2 + "C" + (y2 + 2) + ".zw);\n                ")), m2 += "}");
        y2 < p2 && (m2 += "\n            vec4 wTexelR" + g2 + "C" + y2 + " = getW(" + g2 + ", " + y2 + ", d1, q);\n            wR" + g2 + "C" + y2 + " = vec4(wTexelR" + g2 + "C" + y2 + ".xz, wTexelR" + g2 + "C" + y2 + ".xz);\n          ", y2 + 1 < p2 && (m2 += "\n              vec4 wTexelR" + g2 + "C" + (y2 + 1) + " = getW(" + g2 + ", " + (y2 + 1) + ", d1, q);\n              wR" + g2 + "C" + (y2 + 1) + " =\n                vec4(wTexelR" + g2 + "C" + (y2 + 1) + ".xz, wTexelR" + g2 + "C" + (y2 + 1) + ".xz);"));
      }
    for (g2 = 0; g2 < f2; g2++)
      for (y2 = 0; y2 < p2; y2++)
        m2 += "dotProd += xR" + g2 + "C" + y2 + " * wR" + g2 + "C" + y2 + ";";
    var w2 = "", C2 = "";
    n2 && (w2 = r2 ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + n2 + "\n        }" : "vec4 activation(vec4 x) {\n          " + n2 + "\n        }", C2 = "result = activation(result);");
    var E2 = e2 ? "result += getBiasAtOutCoords();" : "";
    e2 && this.variableNames.push("bias"), r2 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + w2 + "\n\n      const ivec2 strides = ivec2(" + s2 + ", " + c2 + ");\n      const ivec2 pads = ivec2(" + i2 + ", " + u2 + ");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        " + m2 + "\n\n        vec4 result = dotProd;\n        " + E2 + "\n        " + C2 + "\n        setOutput(result);\n      }\n    ";
  };
}();
var Wa = function() {
  return function(t2, e2, n2, r2, o2) {
    this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
    var a2 = t2[0], i2 = t2[1], u2 = t2[2], s2 = t2[3], c2 = e2[0], l2 = n2[0], h2 = n2[1];
    this.outputShape = [c2, l2, h2, s2];
    var f2 = "bilinear" === r2 ? 1 : 0, p2 = [i2 - 1 + ".0", u2 - 1 + ".0"], d2 = p2[0], v2 = p2[1], m2 = l2 > 1 ? ["" + (i2 - 1) / (l2 - 1), "(y2-y1) * height_ratio", "y1*" + d2 + " + float(y)*(height_scale)"] : ["0.0", "0.0", "0.5 * (y1+y2) * " + d2], g2 = m2[0], y2 = m2[1], x2 = m2[2], b2 = h2 > 1 ? ["" + (u2 - 1) / (h2 - 1), "(x2-x1) * width_ratio", "x1*" + v2 + " + float(x)*(width_scale)"] : ["0.0", "0.0", "0.5 * (x1+x2) * " + v2], w2 = b2[0], C2 = b2[1], E2 = b2[2];
    this.userCode = "\n      const float height_ratio = float(" + g2 + ");\n      const float width_ratio = float(" + w2 + ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= " + a2 + ") {\n          return;\n        }\n\n        float height_scale = " + y2 + ";\n        float width_scale = " + C2 + ";\n\n        float in_y = " + x2 + ";\n        if( in_y < 0.0 || in_y > " + d2 + " ) {\n          setOutput(float(" + o2 + "));\n          return;\n        }\n        float in_x = " + E2 + ";\n        if( in_x < 0.0 || in_x > " + v2 + " ) {\n          setOutput(float(" + o2 + "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(" + f2 + " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ";
  };
}();
var Ua = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["x"], this.outputShape = t2;
    var r2 = t2.length, o2 = t2[t2.length - 1], a2 = n2 ? "<" : ">";
    this.userCode = "\n      int getIndex(int i) {\n        " + (n2 ? "return " + o2 + " -i - 1;" : "return i;") + "\n      }\n\n      void main() {\n        " + aa(r2) + " coords = getOutputCoords();\n        int end = " + Va(r2, "coords") + ";\n        float val = 0.0;\n        for (int i = " + o2 + " - 1; i >= 0; i -= 1) {\n          int idx = getIndex(i);\n          if (idx " + a2 + " end) {\n            continue;\n          }\n          if (idx == end && " + e2 + ") {\n            continue;\n          }\n          " + Va(r2, "coords") + " = idx;\n          val += getX(" + function(t3, e3) {
      if (1 === t3)
        return "" + e3;
      if (2 === t3)
        return e3 + ".x, " + e3 + ".y";
      if (3 === t3)
        return e3 + ".x, " + e3 + ".y, " + e3 + ".z";
      if (4 === t3)
        return e3 + ".x, " + e3 + ".y, " + e3 + ".z, " + e3 + ".w";
      throw Error("Cumulative sum for rank " + t3 + " is not yet supported");
    }(r2, "coords") + ");\n        }\n        setOutput(val);\n      }\n    ";
  };
}();
function Va(t2, e2) {
  if (1 === t2)
    return "" + e2;
  if (2 === t2)
    return e2 + ".y";
  if (3 === t2)
    return e2 + ".z";
  if (4 === t2)
    return e2 + ".w";
  throw Error("Cumulative sum for rank " + t2 + " is not yet supported");
}
var za = function() {
  return function(t2) {
    this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outPackingScheme = _t.DENSE;
    var e2 = Gt(t2), n2 = Ko();
    this.outputShape = t2, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + jo(["r", "c", "d"], t2) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e2[0] + ", " + e2[1] + "));\n        int index = 4 * (resTexRC.x * " + e2[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        " + n2.output + " = result;\n      }\n    ";
  };
}();
var Ga = function() {
  return function(t2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outPackingScheme = _t.DENSE;
    var e2 = Gt(t2), n2 = Ko();
    this.outputShape = t2, this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + jo(["r", "c", "d"], t2) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(" + e2[0] + ", " + e2[1] + "));\n        int index = 4 * (resTexRC.x * " + e2[1] + " + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        " + n2.output + " = result;\n      }\n    ";
  };
}();
var Ha = function() {
  function t2(t3, e2, n2) {
    this.variableNames = ["x"], this.outputShape = [], this.outputShape = t3, this.blockSize = e2, this.dataFormat = n2, this.userCode = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = " + this.getHeightCoordString() + ";\n      int w = " + this.getWidthCoordString() + ";\n      int d = " + this.getDepthCoordString() + ";\n\n      int in_h = h / " + e2 + ";\n      int offset_h = imod(h, " + e2 + ");\n      int in_w = w / " + e2 + ";\n      int offset_w = imod(w, " + e2 + ");\n      int offset_d = (offset_h * " + e2 + " + offset_w) *\n        " + this.getOutputDepthSize() + ";\n      int in_d = d + offset_d;\n\n      float result = " + this.getInputSamplingString() + ";\n      setOutput(result);\n    }\n  ";
  }
  return t2.prototype.getHeightCoordString = function() {
    return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]";
  }, t2.prototype.getWidthCoordString = function() {
    return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]";
  }, t2.prototype.getDepthCoordString = function() {
    return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]";
  }, t2.prototype.getOutputDepthSize = function() {
    return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];
  }, t2.prototype.getInputSamplingString = function() {
    return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
  }, t2;
}();
var qa = function() {
  return function(t2) {
    this.variableNames = ["X"], this.outputShape = [t2, t2], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    ";
  };
}();
var Ka = function() {
  return function(t2) {
    this.variableNames = ["A"], this.outTexUsage = Mt.DOWNLOAD;
    var e2 = Ko();
    this.outputShape = t2, this.userCode = "\n      " + $o + "\n\n      void main() {\n        float x = getAAtOutCoords();\n        " + e2.output + " = encode_float(x);\n      }\n    ";
  };
}();
var ja = function() {
  return function(t2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outTexUsage = Mt.DOWNLOAD;
    var e2 = Ko();
    this.outputShape = t2, this.userCode = "\n      " + $o + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        " + e2.output + " = encode_float(x);\n      }\n    ";
  };
}();
var Xa = function() {
  return function(t2, e2, n2) {
    void 0 === n2 && (n2 = false), this.variableNames = ["A"];
    var r2 = Ko(), o2 = e2[0], a2 = e2[1];
    this.outputShape = t2;
    var i2 = "result";
    n2 && (i2 = "floor(result * 255. + 0.5)"), this.userCode = "\n      " + Xo(t2) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n        \n        int r = flatIndex / " + a2 + ";\n        int c = imod(flatIndex, " + a2 + ");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(" + a2 + ".0, " + o2 + ".0);\n        vec4 values = " + r2.texture2D + "(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        " + r2.output + " = vec4(" + i2 + ", 0., 0., 0.);\n      }\n    ";
  };
}();
var $a = function() {
  return function(t2, e2, n2) {
    void 0 === n2 && (n2 = false), this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true;
    var r2 = Ko(), o2 = e2[0], a2 = e2[1];
    this.outputShape = t2;
    var i2 = "", u2 = "result";
    n2 && (u2 = "floor(result * 255. + 0.5)");
    for (var s2 = 0; s2 <= 1; s2++)
      for (var c2 = 0; c2 <= 1; c2++) {
        var l2 = 2 * s2 + c2;
        i2 += "\n          localCoords = coords;\n          if(localCoords[2] + " + c2 + " < " + t2[2] + ") {\n            localCoords[2] += " + c2 + ";\n            if(localCoords[1] + " + s2 + " < " + t2[1] + ") {\n              localCoords[1] += " + s2 + ";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / " + a2 + ";\n              c = imod(flatIndex, " + a2 + ");\n              uv = (vec2(c, r) + halfCR) / vec2(" + a2 + ".0, " + o2 + ".0);\n              values = " + r2.texture2D + "(A, uv);\n\n              if(offset == 0) {\n                result[" + l2 + "] = values[0];\n              } else if(offset == 1) {\n                result[" + l2 + "] = values[1];\n              } else if(offset == 2) {\n                result[" + l2 + "] = values[2];\n              } else {\n                result[" + l2 + "] = values[3];\n              }\n            }\n          }\n        ";
      }
    this.userCode = "\n      " + Xo(t2) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        " + i2 + "\n\n        " + r2.output + " = " + u2 + ";\n      }\n    ";
  };
}();
var Ya = "return real * expR - imag * expI;";
var Qa = "return real * expI + imag * expR;";
var Ja = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["real", "imag"];
    var r2 = e2[1];
    this.outputShape = e2;
    var o2 = n2 ? "2.0 * " + Math.PI : "-2.0 * " + Math.PI, a2 = n2 ? r2 + ".0" : "1.0";
    this.userCode = "\n      const float exponentMultiplier = " + o2 + ";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        " + t2 + "\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(" + r2 + ");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < " + r2 + "; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / " + a2 + ";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ";
  };
}();
var Za = function() {
  function t2(t3, e2) {
    this.outputShape = [], this.variableNames = ["x"], this.outputShape = t3, this.userCode = "\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    ";
  }
  return t2.prototype.getCustomSetupFunc = function(t3) {
    var e2 = this;
    return function(n2, r2) {
      null == e2.valueLoc && (e2.valueLoc = n2.getUniformLocationNoThrow(r2, "value")), n2.gl.uniform1f(e2.valueLoc, t3);
    };
  }, t2;
}();
var ti = function() {
  return function(t2) {
    this.variableNames = ["A"];
    var e2 = Ko(), n2 = t2[0], r2 = t2[1];
    this.outputShape = t2, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + r2 + ".0, " + n2 + ".0);\n\n        vec4 values = " + e2.texture2D + "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ";
  };
}();
var ei = function() {
  return function(t2) {
    this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true;
    var e2 = Ko(), n2 = t2[0], r2 = t2[1];
    this.outputShape = t2, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(" + r2 + ".0, " + n2 + ".0);\n            vec4 values = " + e2.texture2D + "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        " + e2.output + " = result;\n      }\n    ";
  };
}();
var ni = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["A", "indices"];
    var r2 = t2.slice();
    r2[n2] = e2, this.outputShape = r2, this.rank = r2.length;
    var o2 = aa(this.rank), a2 = function(t3, e3) {
      var n3 = t3.length;
      if (n3 > 4)
        throw Error("Gather for rank " + n3 + " is not yet supported");
      if (1 === n3)
        return "int(getIndices(resRC))";
      for (var r3 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], o3 = [], a3 = 0; a3 < t3.length; a3++)
        a3 === e3 ? o3.push("int(getIndices(" + r3[a3] + "))") : o3.push("" + r3[a3]);
      return o3.join();
    }(t2, n2);
    this.userCode = "\n      void main() {\n        " + o2 + " resRC = getOutputCoords();\n        setOutput(getA(" + a2 + "));\n      }\n    ";
  };
}();
var ri = function() {
  return function(t2, e2, n2) {
    this.sliceDim = t2, this.strides = e2, this.variableNames = ["x", "indices"], this.outputShape = n2;
    var r2 = aa(e2.length), o2 = aa(n2.length), a2 = this.sliceDim > 1 ? "strides[j]" : "strides";
    this.userCode = "\n        " + r2 + " strides = " + r2 + "(" + this.strides + ");\n         void main() {\n          " + o2 + " coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < " + this.sliceDim + "; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * " + a2 + ";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      ";
  };
}();
function oi(t2, e2) {
  var n2 = Ko();
  return Jt(t2, e2, n2.version + "\n    precision highp float;\n    " + n2.attribute + " vec3 clipSpacePos;\n    " + n2.attribute + " vec2 uv;\n    " + n2.varyingVs + " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }");
}
function ai(t2, e2) {
  return ie(t2, e2, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]));
}
function ii(t2, e2) {
  return ue(t2, e2, new Uint16Array([0, 1, 2, 2, 1, 3]));
}
function ui(t2, e2, n2, r2, o2, a2, i2) {
  ce(n2, r2);
  var u2 = se(t2, e2), s2 = t2.TEXTURE_2D;
  return Kt(t2, e2, function() {
    return t2.bindTexture(s2, u2);
  }), Kt(t2, e2, function() {
    return t2.texParameteri(s2, t2.TEXTURE_WRAP_S, t2.CLAMP_TO_EDGE);
  }), Kt(t2, e2, function() {
    return t2.texParameteri(s2, t2.TEXTURE_WRAP_T, t2.CLAMP_TO_EDGE);
  }), Kt(t2, e2, function() {
    return t2.texParameteri(s2, t2.TEXTURE_MIN_FILTER, t2.NEAREST);
  }), Kt(t2, e2, function() {
    return t2.texParameteri(s2, t2.TEXTURE_MAG_FILTER, t2.NEAREST);
  }), Kt(t2, e2, function() {
    return t2.texImage2D(s2, 0, o2, n2, r2, 0, a2, i2, null);
  }), Kt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, null);
  }), u2;
}
function si(t2, e2, n2, r2, o2) {
  var a2 = zt(n2, r2);
  return ui(t2, e2, a2[0], a2[1], o2.internalFormatFloat, o2.textureFormatFloat, t2.FLOAT);
}
function ci(t2, e2, n2, r2, o2) {
  var a2 = zt(n2, r2);
  return ui(t2, e2, a2[0], a2[1], o2.internalFormatHalfFloat, o2.textureFormatFloat, o2.textureTypeHalfFloat);
}
function li(t2, e2, n2, r2, o2) {
  var a2 = zt(n2, r2);
  return ui(t2, e2, a2[0], a2[1], t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE);
}
function hi(t2, e2, n2, r2, o2) {
  var a2 = Ht(n2, r2);
  return ui(t2, e2, a2[0], a2[1], o2.internalFormatPackedFloat, t2.RGBA, t2.FLOAT);
}
function fi(t2, e2, n2, r2, o2) {
  var a2 = Ht(n2, r2);
  return ui(t2, e2, a2[0], a2[1], o2.internalFormatPackedHalfFloat, t2.RGBA, o2.textureTypeHalfFloat);
}
function pi(t2, e2, n2, r2) {
  return Kt(t2, e2, function() {
    return t2.bindBuffer(t2.ARRAY_BUFFER, r2);
  }), he(t2, e2, n2, "clipSpacePos", r2, 3, 20, 0) && he(t2, e2, n2, "uv", r2, 2, 20, 12);
}
function di(t2, e2, n2, r2, o2, a2, i2) {
  var u2, s2, c2;
  Kt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, n2);
  }), a2 instanceof Uint8Array ? (u2 = new Uint8Array(r2 * o2 * 4), s2 = t2.UNSIGNED_BYTE, c2 = t2.RGBA) : (u2 = new Float32Array(r2 * o2 * 4), s2 = t2.FLOAT, c2 = i2.internalFormatPackedFloat), u2.set(a2), Kt(t2, e2, function() {
    return t2.texImage2D(t2.TEXTURE_2D, 0, c2, r2, o2, 0, t2.RGBA, s2, u2);
  }), Kt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, null);
  });
}
function vi(t2, e2, n2, r2) {
  Kt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, n2);
  }), r2.data instanceof Uint8Array ? Kt(t2, e2, function() {
    return t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, r2.width, r2.height, 0, t2.RGBA, t2.UNSIGNED_BYTE, r2.data);
  }) : Kt(t2, e2, function() {
    return t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, r2);
  }), Kt(t2, e2, function() {
    return t2.bindTexture(t2.TEXTURE_2D, null);
  });
}
function mi(t2, e2, n2, r2, o2) {
  var a2 = t2.createBuffer();
  Kt(t2, e2, function() {
    return t2.bindBuffer(t2.PIXEL_PACK_BUFFER, a2);
  });
  var i2 = 16 * n2 * r2;
  return Kt(t2, e2, function() {
    return t2.bufferData(t2.PIXEL_PACK_BUFFER, i2, t2.STREAM_READ);
  }), Kt(t2, e2, function() {
    return t2.readPixels(0, 0, r2, n2, t2.RGBA, t2.FLOAT, 0);
  }), Kt(t2, e2, function() {
    return t2.bindBuffer(t2.PIXEL_PACK_BUFFER, null);
  }), a2;
}
function gi(t2, e2, n2) {
  var r2 = t2, o2 = new Float32Array(n2);
  return r2.bindBuffer(r2.PIXEL_PACK_BUFFER, e2), r2.getBufferSubData(r2.PIXEL_PACK_BUFFER, 0, o2), r2.bindBuffer(r2.PIXEL_PACK_BUFFER, null), o2;
}
function yi(t2, e2, n2, r2, o2) {
  var a2 = zt(n2, r2), i2 = a2[0], u2 = a2[1], s2 = new Uint8Array(n2 * r2 * 4);
  return Kt(t2, e2, function() {
    return t2.readPixels(0, 0, i2, u2, o2.downloadTextureFormat, t2.UNSIGNED_BYTE, s2);
  }), new Float32Array(s2.buffer);
}
function xi(t2, e2, n2, r2, o2, a2, i2, u2) {
  var s2 = t2, c2 = new Float32Array(function(t3, e3) {
    var n3 = Ht(t3, e3);
    return n3[0] * n3[1] * 4;
  }(a2, i2));
  return s2.bindBuffer(s2.PIXEL_PACK_BUFFER, e2), s2.getBufferSubData(s2.PIXEL_PACK_BUFFER, 0, c2), s2.bindBuffer(s2.PIXEL_PACK_BUFFER, null), c2;
}
function bi(t2, e2, n2, r2) {
  var o2 = new Float32Array(n2 * r2 * 4);
  return Kt(t2, e2, function() {
    return t2.readPixels(0, 0, r2, n2, t2.RGBA, t2.FLOAT, o2);
  }), o2;
}
var wi = Object.freeze({createVertexShader: oi, createVertexBuffer: ai, createIndexBuffer: ii, createFloat32MatrixTexture: si, createFloat16MatrixTexture: ci, createUnsignedBytesMatrixTexture: li, createPackedMatrixTexture: hi, createFloat16PackedMatrixTexture: fi, bindVertexProgramAttributeStreams: pi, uploadDenseMatrixToTexture: di, uploadPixelDataToTexture: vi, createBufferFromOutputTexture: mi, downloadFloat32MatrixFromBuffer: gi, downloadByteEncodedFloatMatrixFromOutputTexture: yi, downloadPackedMatrixFromBuffer: xi, downloadMatrixFromPackedOutputTexture: bi});
var Ci = function() {
  function t2(t3) {
    this.outputTexture = null, this.program = null, this.disposed = false, this.vertexAttrsAreBound = false, this.itemsToPoll = [];
    var e2 = a().getNumber("WEBGL_VERSION");
    if (null != t3 ? (this.gl = t3, Wt(e2, t3)) : this.gl = Ut(e2), 1 === a().getNumber("WEBGL_VERSION"))
      this.textureFloatExtension = Qt(this.gl, this.debug, "OES_texture_float"), this.colorBufferFloatExtension = this.gl.getExtension("WEBGL_color_buffer_float"), this.textureHalfFloatExtension = Qt(this.gl, this.debug, "OES_texture_half_float"), this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float");
    else {
      if (Ne(this.gl, "EXT_color_buffer_float"))
        this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float");
      else {
        if (!Ne(this.gl, "EXT_color_buffer_half_float"))
          throw new Error("GL context does not support color renderable floats");
        this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float");
      }
    }
    this.vertexBuffer = ai(this.gl, this.debug), this.indexBuffer = ii(this.gl, this.debug), this.framebuffer = le(this.gl, this.debug), this.textureConfig = qt(this.gl, this.textureHalfFloatExtension);
  }
  return Object.defineProperty(t2.prototype, "debug", {get: function() {
    return a().getBool("DEBUG");
  }, enumerable: true, configurable: true}), t2.prototype.dispose = function() {
    var t3 = this;
    if (!this.disposed) {
      null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
      var e2 = this.gl;
      Kt(e2, this.debug, function() {
        return e2.finish();
      }), Kt(e2, this.debug, function() {
        return e2.bindFramebuffer(e2.FRAMEBUFFER, null);
      }), Kt(e2, this.debug, function() {
        return e2.deleteFramebuffer(t3.framebuffer);
      }), Kt(e2, this.debug, function() {
        return e2.bindBuffer(e2.ARRAY_BUFFER, null);
      }), Kt(e2, this.debug, function() {
        return e2.bindBuffer(e2.ELEMENT_ARRAY_BUFFER, null);
      }), Kt(e2, this.debug, function() {
        return e2.deleteBuffer(t3.indexBuffer);
      }), this.disposed = true;
    }
  }, t2.prototype.createFloat32MatrixTexture = function(t3, e2) {
    return this.throwIfDisposed(), si(this.gl, this.debug, t3, e2, this.textureConfig);
  }, t2.prototype.createFloat16MatrixTexture = function(t3, e2) {
    return this.throwIfDisposed(), ci(this.gl, this.debug, t3, e2, this.textureConfig);
  }, t2.prototype.createUnsignedBytesMatrixTexture = function(t3, e2) {
    return this.throwIfDisposed(), li(this.gl, this.debug, t3, e2, this.textureConfig);
  }, t2.prototype.uploadPixelDataToTexture = function(t3, e2) {
    this.throwIfDisposed(), vi(this.gl, this.debug, t3, e2);
  }, t2.prototype.uploadDenseMatrixToTexture = function(t3, e2, n2, r2) {
    this.throwIfDisposed(), di(this.gl, this.debug, t3, e2, n2, r2, this.textureConfig);
  }, t2.prototype.createFloat16PackedMatrixTexture = function(t3, e2) {
    return this.throwIfDisposed(), fi(this.gl, this.debug, t3, e2, this.textureConfig);
  }, t2.prototype.createPackedMatrixTexture = function(t3, e2) {
    return this.throwIfDisposed(), hi(this.gl, this.debug, t3, e2, this.textureConfig);
  }, t2.prototype.deleteMatrixTexture = function(t3) {
    var e2 = this;
    this.throwIfDisposed(), this.outputTexture === t3 && (ge(this.gl, this.debug, this.framebuffer), this.outputTexture = null), Kt(this.gl, this.debug, function() {
      return e2.gl.deleteTexture(t3);
    });
  }, t2.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function(t3, e2, n2) {
    var r2 = this;
    return this.downloadMatrixDriver(t3, function() {
      return yi(r2.gl, r2.debug, e2, n2, r2.textureConfig);
    });
  }, t2.prototype.downloadPackedMatrixFromBuffer = function(t3, e2, n2, r2, o2, a2) {
    return xi(this.gl, t3, 0, 0, 0, o2, a2, this.textureConfig);
  }, t2.prototype.downloadFloat32MatrixFromBuffer = function(t3, e2) {
    return gi(this.gl, t3, e2);
  }, t2.prototype.createBufferFromTexture = function(t3, e2, n2) {
    this.bindTextureToFrameBuffer(t3);
    var r2 = mi(this.gl, this.debug, e2, n2, this.textureConfig);
    return this.unbindTextureToFrameBuffer(), r2;
  }, t2.prototype.createAndWaitForFence = function() {
    var t3 = this.createFence(this.gl);
    return this.pollFence(t3);
  }, t2.prototype.createFence = function(t3) {
    var e2, n2, r2 = this;
    if (a().getBool("WEBGL_FENCE_API_ENABLED")) {
      var o2 = t3, i2 = o2.fenceSync(o2.SYNC_GPU_COMMANDS_COMPLETE, 0);
      t3.flush(), n2 = function() {
        var t4 = o2.clientWaitSync(i2, 0, 0);
        return t4 === o2.ALREADY_SIGNALED || t4 === o2.CONDITION_SATISFIED;
      }, e2 = i2;
    } else
      a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (e2 = this.beginQuery(), this.endQuery(), n2 = function() {
        return r2.isQueryAvailable(e2, a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
      }) : n2 = function() {
        return true;
      };
    return {query: e2, isFencePassed: n2};
  }, t2.prototype.downloadMatrixFromPackedTexture = function(t3, e2, n2) {
    var r2 = this;
    return this.downloadMatrixDriver(t3, function() {
      return bi(r2.gl, r2.debug, e2, n2);
    });
  }, t2.prototype.createProgram = function(t3) {
    this.throwIfDisposed();
    var e2 = this.gl, n2 = Zt(e2, this.debug, t3), r2 = oi(e2, this.debug), o2 = re(e2, this.debug);
    return Kt(e2, this.debug, function() {
      return e2.attachShader(o2, r2);
    }), Kt(e2, this.debug, function() {
      return e2.attachShader(o2, n2);
    }), oe(e2, this.debug, o2), this.debug && ae(e2, this.debug, o2), this.vertexAttrsAreBound || (this.setProgram(o2), this.vertexAttrsAreBound = pi(e2, this.debug, this.program, this.vertexBuffer)), o2;
  }, t2.prototype.deleteProgram = function(t3) {
    var e2 = this;
    this.throwIfDisposed(), t3 === this.program && (this.program = null), null != t3 && Kt(this.gl, this.debug, function() {
      return e2.gl.deleteProgram(t3);
    });
  }, t2.prototype.setProgram = function(t3) {
    var e2 = this;
    this.throwIfDisposed(), this.program = t3, null != this.program && this.debug && ae(this.gl, this.debug, this.program), Kt(this.gl, this.debug, function() {
      return e2.gl.useProgram(t3);
    });
  }, t2.prototype.getUniformLocation = function(t3, e2, n2) {
    return void 0 === n2 && (n2 = true), this.throwIfDisposed(), n2 ? pe(this.gl, this.debug, t3, e2) : de(this.gl, t3, e2);
  }, t2.prototype.getAttributeLocation = function(t3, e2) {
    var n2 = this;
    return this.throwIfDisposed(), Kt(this.gl, this.debug, function() {
      return n2.gl.getAttribLocation(t3, e2);
    });
  }, t2.prototype.getUniformLocationNoThrow = function(t3, e2) {
    return this.throwIfDisposed(), this.gl.getUniformLocation(t3, e2);
  }, t2.prototype.setInputMatrixTexture = function(t3, e2, n2) {
    this.throwIfDisposed(), this.throwIfNoProgram(), ve(this.gl, this.debug, this.program, t3, e2, n2);
  }, t2.prototype.setOutputMatrixTexture = function(t3, e2, n2) {
    this.setOutputMatrixTextureDriver(t3, n2, e2);
  }, t2.prototype.setOutputPackedMatrixTexture = function(t3, e2, n2) {
    this.throwIfDisposed();
    var r2 = Ht(e2, n2), o2 = r2[0], a2 = r2[1];
    this.setOutputMatrixTextureDriver(t3, o2, a2);
  }, t2.prototype.setOutputMatrixWriteRegion = function(t3, e2, n2, r2) {
    this.setOutputMatrixWriteRegionDriver(n2, t3, r2, e2);
  }, t2.prototype.setOutputPackedMatrixWriteRegion = function(t3, e2, n2, r2) {
    throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
  }, t2.prototype.debugValidate = function() {
    null != this.program && ae(this.gl, this.debug, this.program), ye(this.gl);
  }, t2.prototype.executeProgram = function() {
    this.throwIfDisposed(), this.throwIfNoProgram();
    var t3 = this.gl;
    this.debug && this.debugValidate(), Kt(t3, this.debug, function() {
      return t3.drawElements(t3.TRIANGLES, 6, t3.UNSIGNED_SHORT, 0);
    });
  }, t2.prototype.blockUntilAllProgramsCompleted = function() {
    var t3 = this;
    this.throwIfDisposed(), Kt(this.gl, this.debug, function() {
      return t3.gl.finish();
    });
  }, t2.prototype.getQueryTimerExtension = function() {
    return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = Qt(this.gl, this.debug, 2 === a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
  }, t2.prototype.getQueryTimerExtensionWebGL2 = function() {
    return this.getQueryTimerExtension();
  }, t2.prototype.getQueryTimerExtensionWebGL1 = function() {
    return this.getQueryTimerExtension();
  }, t2.prototype.beginQuery = function() {
    if (2 === a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
      var t3 = this.gl, e2 = this.getQueryTimerExtensionWebGL2(), n2 = t3.createQuery();
      return t3.beginQuery(e2.TIME_ELAPSED_EXT, n2), n2;
    }
    var r2 = this.getQueryTimerExtensionWebGL1(), o2 = r2.createQueryEXT();
    return r2.beginQueryEXT(r2.TIME_ELAPSED_EXT, o2), o2;
  }, t2.prototype.endQuery = function() {
    if (2 !== a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
      var t3 = this.getQueryTimerExtensionWebGL1();
      t3.endQueryEXT(t3.TIME_ELAPSED_EXT);
    } else {
      var e2 = this.gl, n2 = this.getQueryTimerExtensionWebGL2();
      e2.endQuery(n2.TIME_ELAPSED_EXT);
    }
  }, t2.prototype.waitForQueryAndGetTime = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2 = this;
      return r(this, function(n2) {
        switch (n2.label) {
          case 0:
            return [4, S(function() {
              return e2.disposed || e2.isQueryAvailable(t3, a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
            })];
          case 1:
            return n2.sent(), [2, this.getQueryTime(t3, a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))];
        }
      });
    });
  }, t2.prototype.getQueryTime = function(t3, e2) {
    if (0 === e2)
      return null;
    if (2 === e2) {
      var n2 = this.gl;
      return n2.getQueryParameter(t3, n2.QUERY_RESULT) / 1e6;
    }
    var r2 = this.getQueryTimerExtensionWebGL1();
    return r2.getQueryObjectEXT(t3, r2.QUERY_RESULT_EXT) / 1e6;
  }, t2.prototype.isQueryAvailable = function(t3, e2) {
    if (0 === e2)
      return true;
    if (2 === e2) {
      var n2 = this.gl, r2 = this.getQueryTimerExtensionWebGL2(), o2 = n2.getQueryParameter(t3, n2.QUERY_RESULT_AVAILABLE);
      return null == this.disjoint && (this.disjoint = this.gl.getParameter(r2.GPU_DISJOINT_EXT)), o2 && !this.disjoint;
    }
    o2 = (r2 = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t3, r2.QUERY_RESULT_AVAILABLE_EXT);
    return null == this.disjoint && (this.disjoint = this.gl.getParameter(r2.GPU_DISJOINT_EXT)), o2 && !this.disjoint;
  }, t2.prototype.pollFence = function(t3) {
    var e2 = this;
    return new Promise(function(n2) {
      e2.addItemToPoll(function() {
        return t3.isFencePassed();
      }, function() {
        return n2();
      });
    });
  }, t2.prototype.pollItems = function() {
    for (var t3 = function(t4) {
      for (var e3 = 0; e3 < t4.length; ++e3) {
        var n2 = t4[e3]();
        if (!n2)
          break;
      }
      return e3 - 1;
    }(this.itemsToPoll.map(function(t4) {
      return t4.isDoneFn;
    })), e2 = 0; e2 <= t3; ++e2) {
      (0, this.itemsToPoll[e2].resolveFn)();
    }
    this.itemsToPoll = this.itemsToPoll.slice(t3 + 1);
  }, t2.prototype.addItemToPoll = function(t3, e2) {
    var n2 = this;
    this.itemsToPoll.push({isDoneFn: t3, resolveFn: e2}), this.itemsToPoll.length > 1 || S(function() {
      return n2.pollItems(), 0 === n2.itemsToPoll.length;
    });
  }, t2.prototype.bindTextureToFrameBuffer = function(t3) {
    this.throwIfDisposed(), me(this.gl, this.debug, t3, this.framebuffer), this.debug && ye(this.gl);
  }, t2.prototype.unbindTextureToFrameBuffer = function() {
    null != this.outputTexture ? (me(this.gl, this.debug, this.outputTexture, this.framebuffer), this.debug && ye(this.gl)) : ge(this.gl, this.debug, this.framebuffer);
  }, t2.prototype.downloadMatrixDriver = function(t3, e2) {
    this.bindTextureToFrameBuffer(t3);
    var n2 = e2();
    return this.unbindTextureToFrameBuffer(), n2;
  }, t2.prototype.setOutputMatrixTextureDriver = function(t3, e2, n2) {
    this.throwIfDisposed();
    var r2 = this.gl;
    me(r2, this.debug, t3, this.framebuffer), this.debug && ye(r2), this.outputTexture = t3, Kt(r2, this.debug, function() {
      return r2.viewport(0, 0, e2, n2);
    }), Kt(r2, this.debug, function() {
      return r2.scissor(0, 0, e2, n2);
    });
  }, t2.prototype.setOutputMatrixWriteRegionDriver = function(t3, e2, n2, r2) {
    var o2 = this;
    this.throwIfDisposed(), Kt(this.gl, this.debug, function() {
      return o2.gl.scissor(t3, e2, n2, r2);
    });
  }, t2.prototype.throwIfDisposed = function() {
    if (this.disposed)
      throw new Error("Attempted to use disposed GPGPUContext.");
  }, t2.prototype.throwIfNoProgram = function() {
    if (null == this.program)
      throw new Error("No GPU program is currently set.");
  }, t2;
}();
function Ei(t2, e2) {
  if (t2.length !== e2.length)
    throw Error("Binary was compiled with " + t2.length + " inputs, but was executed with " + e2.length + " inputs");
  t2.forEach(function(t3, n2) {
    var r2 = t3.logicalShape, o2 = e2[n2], a2 = o2.shape;
    if (!C(r2, a2))
      throw Error("Binary was compiled with different shapes than the current args. Shapes " + r2 + " and " + a2 + " must match");
    if (!t3.isUniform || !o2.isUniform) {
      var i2 = t3.texShape, u2 = o2.isUniform ? null : o2.texData.texShape;
      if (!C(i2, u2))
        throw Error("Binary was compiled with different texture shapes than the current args. Shape " + i2 + " and " + u2 + " must match");
    }
  });
}
var Ri = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t2;
    for (var r2 = n2.filterWidth, o2 = n2.inChannels, a2 = n2.strideWidth, i2 = n2.strideHeight, u2 = n2.padInfo, s2 = n2.outWidth, c2 = n2.dilationWidth, l2 = n2.dilationHeight, h2 = n2.dataFormat, f2 = u2.left, p2 = u2.top, d2 = o2 * r2, v2 = Ko(), m2 = "channelsLast" === h2, g2 = m2 ? 0 : 1, y2 = m2 ? 1 : 2, x2 = "", b2 = 0; b2 <= 1; b2++)
      for (var w2 = 0; w2 <= 1; w2++)
        x2 += "\n          blockIndex = rc.y + " + w2 + ";\n          pos = rc.x + " + b2 + ";\n\n          if(blockIndex < " + t2[1] + " && pos < " + t2[0] + ") {\n            offsetY = int(blockIndex / (" + s2 + ")) * " + i2 + " - " + p2 + ";\n            d0 = offsetY + " + l2 + " * (pos / " + d2 + ");\n\n            if(d0 < " + e2[g2] + " && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), " + s2 + ".) * " + a2 + ". - " + f2 + ".);\n              d1 = offsetX + " + c2 + " * (int(mod(float(pos), " + d2 + ".) / " + o2 + ".));\n\n              if(d1 < " + e2[y2] + " && d1 >= 0) {\n\n                ch = int(mod(float(pos), " + o2 + ".));\n\n                if (" + m2 + ") {\n                  innerDims = vec2(d1, ch);\n                  result[" + (2 * b2 + w2) + "] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[" + (2 * b2 + w2) + "] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";
    this.userCode = "\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        " + x2 + "\n\n        " + v2.output + " = result;\n      }\n    ";
  };
}();
var Ii = function() {
  return function(t2, e2, n2, r2, o2) {
    this.variableNames = ["x"], this.outputShape = [];
    var a2, i2 = e2, u2 = t2[3] - 1;
    this.outputShape = t2;
    var s2 = "float(" + n2 + ") + float(" + r2 + ") * sum";
    a2 = 0.5 === o2 ? "inversesqrt(" + s2 + ")" : 1 === o2 ? "1.0/(" + s2 + ")" : "exp(log(" + s2 + ") * float(-" + o2 + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -" + i2 + "; j <= " + i2 + "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  " + u2 + ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * " + a2 + ";\n        setOutput(val);\n      }\n    ";
  };
}();
var ki = function() {
  return function(t2, e2, n2, r2, o2) {
    this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = t2, this.depth = t2[3], this.depthRadius = e2, this.bias = n2, this.alpha = r2, this.beta = o2, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < " + this.depth + "; ++d) {\n          int depthBegin = int(max(0.0, float(d - " + e2 + ")));\n          int depthEnd = int(min(float(" + this.depth + "),\n              float(d + " + e2 + " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = " + this.depth + ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(" + r2 + ") * norm + float(" + n2 + ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(" + r2 + ")\n                * float(" + o2 + ")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * " + o2 + ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ";
  };
}();
var Si = function() {
  return function(t2, e2, n2, r2, o2) {
    this.variableNames = ["x"], this.outputShape = [], this.packedInputs = true, this.packedOutput = true;
    var a2, i2 = e2, u2 = t2[3] - 1;
    this.outputShape = t2;
    var s2 = "float(" + n2 + ") + float(" + r2 + ") * sum";
    a2 = 0.5 === o2 ? "inversesqrt(" + s2 + ")" : 1 === o2 ? "1.0/(" + s2 + ")" : "exp(log(" + s2 + ") * float(-" + o2 + "));", this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < " + this.outputShape[3] + ";\n        bool hasNextRow = c < " + this.outputShape[2] + ";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - " + i2 + ";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - " + i2 + "; j <= " + i2 + "; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(" + u2 + "));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * " + a2 + ";\n        setOutput(result);\n      }\n    ";
  };
}();
var Ai = function() {
  return function(t2) {
    this.variableNames = ["dy", "maxPos"], this.outputShape = t2.inShape;
    var e2 = t2.strideHeight, n2 = t2.strideWidth, r2 = t2.dilationHeight, o2 = t2.effectiveFilterHeight, a2 = t2.effectiveFilterWidth, i2 = o2 - 1 - t2.padInfo.top, u2 = a2 - 1 - t2.padInfo.left, s2 = o2 * a2 - 1;
    this.userCode = "\n      const ivec2 pads = ivec2(" + i2 + ", " + u2 + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + o2 + ";\n          wR += " + r2 + ") {\n          float dyR = float(dyRCorner + wR) / " + e2 + ".0;\n\n          if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + a2 + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + n2 + ".0;\n\n            if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + s2 + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + a2 + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var Di = function() {
  return function(t2) {
    this.variableNames = ["dy", "maxPos"], this.outputShape = t2.inShape;
    var e2 = t2.strideDepth, n2 = t2.strideHeight, r2 = t2.strideWidth, o2 = t2.dilationDepth, a2 = t2.dilationHeight, i2 = t2.dilationWidth, u2 = t2.effectiveFilterDepth, s2 = t2.effectiveFilterHeight, c2 = t2.effectiveFilterWidth, l2 = u2 - 1 - t2.padInfo.front, h2 = s2 - 1 - t2.padInfo.top, f2 = c2 - 1 - t2.padInfo.left, p2 = u2 * s2 * c2 - 1;
    this.userCode = "\n      const ivec3 pads = ivec3(" + l2 + ", " + h2 + ", " + f2 + ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < " + u2 + ";\n           wD += " + o2 + ") {\n          float dyD = float(dyDCorner + wD) / " + e2 + ".0;\n\n          if (dyD < 0.0 || dyD >= " + t2.outDepth + ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < " + s2 + ";\n              wR += " + a2 + ") {\n            float dyR = float(dyRCorner + wR) / " + n2 + ".0;\n\n            if (dyR < 0.0 || dyR >= " + t2.outHeight + ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < " + c2 + ";\n                wC += " + i2 + ") {\n              float dyC = float(dyCCorner + wC) / " + r2 + ".0;\n\n              if (dyC < 0.0 || dyC >= " + t2.outWidth + ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = " + p2 + " -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * " + s2 + " * " + c2 + " +\n                  wR * " + c2 + " + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  };
}();
var Ti = function() {
  return function(t2, e2, n2, r2, o2, a2, i2) {
    void 0 === n2 && (n2 = false), void 0 === r2 && (r2 = false), void 0 === o2 && (o2 = false), void 0 === a2 && (a2 = null), void 0 === i2 && (i2 = false), this.variableNames = ["matrixA", "matrixB"], this.packedInputs = true, this.packedOutput = true, this.outputShape = e2;
    var u2 = n2 ? t2[1] : t2[2], s2 = Math.ceil(u2 / 2), c2 = n2 ? "i * 2, rc.y" : "rc.y, i * 2", l2 = r2 ? "rc.z, i * 2" : "i * 2, rc.z", h2 = n2 ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"], f2 = r2 ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"], p2 = "", d2 = "";
    a2 && (p2 = i2 ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + a2 + "\n        }" : "vec4 activation(vec4 x) {\n          " + a2 + "\n        }", d2 = "result = activation(result);");
    var v2 = o2 ? "result += getBiasAtOutCoords();" : "";
    o2 && this.variableNames.push("bias"), i2 && this.variableNames.push("preluActivationWeights"), this.userCode = "\n      " + p2 + "\n\n      const float sharedDimension = " + s2 + ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < " + s2 + "; i++) {\n          vec4 a = getMatrixA(rc.x, " + c2 + ");\n          vec4 b = getMatrixB(rc.x, " + l2 + ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (" + h2[0] + " * " + f2[0] + ");\n          result += (" + h2[1] + " * " + f2[1] + ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        " + v2 + "\n\n        " + d2 + "\n\n        setOutput(result);\n      }\n    ";
  };
}();
var Ni = function() {
  function t2(t3, e2, n2) {
    this.variableNames = ["probs"], this.outputShape = [t3, n2], this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (e2 - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (e2 - 1) + "));\n      }\n    ";
  }
  return t2.prototype.getCustomSetupFunc = function(t3) {
    var e2 = this;
    return function(n2, r2) {
      null == e2.seedLoc && (e2.seedLoc = n2.getUniformLocation(r2, "seed")), n2.gl.uniform1f(e2.seedLoc, t3);
    };
  }, t2;
}();
var Fi = function() {
  return function(t2, e2, n2, r2) {
    this.variableNames = ["indices"], this.outputShape = [t2, e2], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + r2 + "), float(" + n2 + "),\n                      float(index == coords.y)));\n      }\n    ";
  };
}();
var Oi = function() {
  return function(t2) {
    this.variableNames = ["A"], this.packedInputs = false, this.packedOutput = true, this.outputShape = t2;
    var e2 = t2.length;
    if (0 === e2)
      this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
    else {
      var n2 = qo("rc", e2), r2 = aa(e2), o2 = function(t3, e3, n3) {
        if (1 === t3)
          return "rc > " + e3[0];
        for (var r3 = "", o3 = t3 - 2; o3 < t3; o3++)
          r3 += n3[o3] + " >= " + e3[o3], o3 < t3 - 1 && (r3 += "||");
        return r3;
      }(e2, t2, n2), a2 = function(t3, e3, n3, r3) {
        if (1 === t3)
          return "";
        var o3 = r3.slice(-2);
        return "\n    int r = " + o3[0] + ";\n    int c = " + o3[1] + ";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= " + e3 + ";\n    bool rEdge = rp1 >= " + n3 + ";\n  ";
      }(e2, t2[t2.length - 1], t2[t2.length - 2], n2), i2 = function(t3, e3) {
        var n3 = t3.length, r3 = function(t4, e4) {
          for (var n4 = [], r4 = 0; r4 <= 1; r4++)
            for (var o3 = 0; o3 <= 1; o3++) {
              for (var a3 = (0 === r4 ? "r" : "rp1") + ", " + (0 === o3 ? "c" : "cp1"), i3 = 2; i3 < t4; i3++)
                a3 = e4[e4.length - 1 - i3] + "," + a3;
              n4.push(a3);
            }
          return n4;
        }(n3, e3);
        return 1 === n3 ? "getA(rc),\n            rc + 1 >= " + t3[0] + " ? 0. : getA(rc + 1),\n            0, 0" : "getA(" + r3[0] + "),\n          cEdge ? 0. : getA(" + r3[1] + "),\n          rEdge ? 0. : getA(" + r3[2] + "),\n          rEdge || cEdge ? 0. : getA(" + r3[3] + ")";
      }(t2, n2);
      this.userCode = "\n        void main() {\n          " + r2 + " rc = getOutputCoords();\n\n          if(" + o2 + ") {\n            setOutput(vec4(0));\n          } else {\n            " + a2 + "\n\n            setOutput(vec4(" + i2 + "));\n          }\n        }\n      ";
    }
  };
}();
var _i = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["x"], this.outputShape = e2.map(function(e3, n3) {
      return e3[0] + t2[n3] + e3[1];
    });
    var r2 = t2.length, o2 = aa(r2), a2 = e2.map(function(t3) {
      return t3[0];
    }).join(","), i2 = e2.map(function(e3, n3) {
      return e3[0] + t2[n3];
    }).join(","), u2 = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, r2);
    this.userCode = 1 !== r2 ? "\n      " + o2 + " start = " + o2 + "(" + a2 + ");\n      " + o2 + " end = " + o2 + "(" + i2 + ");\n\n      void main() {\n        " + o2 + " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(" + n2 + "));\n        } else {\n          " + o2 + " coords = outC - start;\n          setOutput(getX(" + u2 + "));\n        }\n      }\n    " : "\n        int start = " + a2 + ";\n        int end = " + i2 + ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(" + n2 + "));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ";
  };
}();
var Mi = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true, this.outputShape = e2.map(function(e3, n3) {
      return e3[0] + t2[n3] + e3[1];
    });
    for (var r2 = t2.length, o2 = aa(r2), a2 = e2.map(function(t3) {
      return t3[0];
    }).join(","), i2 = e2.map(function(e3, n3) {
      return e3[0] + t2[n3];
    }).join(","), u2 = qo("rc", r2), s2 = qo("source", r2), c2 = u2[r2 - 1] + " < " + this.outputShape[r2 - 1], l2 = 1 === r2 ? "source" : "vec2(" + s2.slice(-2).join() + ")", h2 = [o2 + " rc = outputLoc;", u2[r2 - 1] + " += 1;\n       if(" + c2 + ") {\n      ", 1 === r2 ? "" : "}\n       rc = outputLoc;\n       " + u2[r2 - 2] + " += 1;\n       if(" + u2[r2 - 2] + " < " + this.outputShape[r2 - 2] + ") {", 1 === r2 ? "" : "  " + u2[r2 - 1] + " += 1;\n         if(" + c2 + ") {"], f2 = 1 === r2 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", p2 = "", d2 = 0, v2 = 1 === r2 ? 2 : 4; d2 < v2; d2++)
      p2 += "\n        " + h2[d2] + "\n        if (" + f2 + ") {\n          result[" + d2 + "] = float(" + n2 + ");\n        } else {\n          " + o2 + " source = rc - start;\n          result[" + d2 + "] = getChannel(getX(" + s2.join() + "), " + l2 + ");\n        }\n      ";
    p2 += 1 === r2 ? "} " : "}}", this.userCode = "\n      const " + o2 + " start = " + o2 + "(" + a2 + ");\n      const " + o2 + " end = " + o2 + "(" + i2 + ");\n\n      void main() {\n        " + o2 + " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        " + p2 + "\n        setOutput(result);\n      }\n    ";
  };
}();
var Bi = function() {
  return function(t2, e2, n2) {
    if (this.variableNames = ["x"], "avg" === e2 && n2)
      throw new Error("Cannot compute positions for average pool.");
    var r2 = t2.filterWidth, o2 = t2.strideHeight, a2 = t2.strideWidth, i2 = t2.dilationHeight, u2 = t2.dilationWidth, s2 = t2.effectiveFilterHeight, c2 = t2.effectiveFilterWidth, l2 = t2.padInfo.top, h2 = t2.padInfo.left;
    this.outputShape = t2.outShape;
    var f2 = "avg" === e2, p2 = "0.0";
    if (f2 || (p2 = "-1.0 / 1e-20"), n2)
      this.userCode = "\n        const ivec2 strides = ivec2(" + o2 + ", " + a2 + ");\n        const ivec2 pads = ivec2(" + l2 + ", " + h2 + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + s2 + ";\n              wR += " + i2 + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t2.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + c2 + ";\n                wC += " + u2 + ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + t2.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + c2 + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
    else {
      var d2 = e2 + "(" + e2 + "(" + e2 + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
      "avg" === e2 && (d2 = "avgValue / count");
      var v2 = 4 * Math.floor(r2 / 4), m2 = r2 % 4, g2 = "\n      if (" + f2 + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
      this.userCode = "\n      const ivec2 strides = ivec2(" + o2 + ", " + a2 + ");\n      const ivec2 pads = ivec2(" + l2 + ", " + h2 + ");\n      const float initializationValue = " + p2 + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + t2.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + p2 + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " + s2 + ";\n            wR += " + i2 + ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + t2.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + v2 + "; wC += 4) {\n            int xC = xCCorner + wC * " + u2 + ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + u2 + ", d),\n              getValue(batch, xR, xC + 2 * " + u2 + ", d),\n              getValue(batch, xR, xC + 3 * " + u2 + ", d)\n            );\n\n            " + g2 + "\n          }\n\n          int xC = xCCorner + " + v2 + ";\n          if (" + (1 === m2) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " + g2 + "\n          } else if (" + (2 === m2) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + u2 + ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + g2 + "\n          } else if (" + (3 === m2) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + u2 + ", d),\n              getValue(batch, xR, xC + 2 * " + u2 + ", d),\n              initializationValue\n            );\n\n            " + g2 + "\n          }\n        }\n        setOutput(" + d2 + ");\n      }\n    ";
    }
  };
}();
var Pi = function() {
  return function(t2, e2, n2) {
    if (this.variableNames = ["x"], "avg" === e2 && n2)
      throw new Error("Cannot compute positions for average pool.");
    var r2 = t2.filterWidth, o2 = t2.strideDepth, a2 = t2.strideHeight, i2 = t2.strideWidth, u2 = t2.dilationDepth, s2 = t2.dilationHeight, c2 = t2.dilationWidth, l2 = t2.effectiveFilterDepth, h2 = t2.effectiveFilterHeight, f2 = t2.effectiveFilterWidth, p2 = t2.padInfo.front, d2 = t2.padInfo.top, v2 = t2.padInfo.left;
    this.outputShape = t2.outShape;
    var m2 = "avg" === e2, g2 = "0.0";
    if (m2 || (g2 = "-1.0 / 1e-20"), n2)
      this.userCode = "\n        const ivec3 strides =\n            ivec3(" + o2 + ", " + a2 + ", " + i2 + ");\n        const ivec3 pads = ivec3(" + p2 + ", " + d2 + ", " + v2 + ");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < " + l2 + ";\n              wD += " + u2 + ") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= " + t2.inDepth + ") {\n              continue;\n            }\n\n            for (int wR = 0; wR < " + h2 + ";\n                wR += " + s2 + ") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= " + t2.inHeight + ") {\n                continue;\n              }\n\n              for (int wC = 0; wC < " + f2 + ";\n                  wC += " + c2 + ") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= " + t2.inWidth + ") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition =\n                      wD * " + h2 + " * " + f2 + " +\n                      wR * " + f2 + " + wC;;\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
    else {
      var y2 = e2 + "(" + e2 + "(" + e2 + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
      "avg" === e2 && (y2 = "avgValue / count");
      var x2 = 4 * Math.floor(r2 / 4), b2 = r2 % 4, w2 = "\n      if (" + m2 + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    ";
      this.userCode = "\n      const ivec3 strides =\n        ivec3(" + o2 + ", " + a2 + ", " + i2 + ");\n      const ivec3 pads = ivec3(" + p2 + ", " + d2 + ", " + v2 + ");\n      const float initializationValue = " + g2 + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= " + t2.inWidth + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + g2 + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < " + l2 + ";\n            wD += " + u2 + ") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= " + t2.inDepth + ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < " + h2 + ";\n            wR += " + s2 + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + t2.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + x2 + "; wC += 4) {\n              int xC = xCCorner + wC * " + c2 + ";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c2 + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c2 + ", ch),\n                getValue(batch, xD, xR, xC + 3 * " + c2 + ", ch)\n              );\n\n              " + w2 + "\n            }\n\n            int xC = xCCorner + " + x2 + ";\n            if (" + (1 === b2) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              " + w2 + "\n            } else if (" + (2 === b2) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c2 + ", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              " + w2 + "\n            } else if (" + (3 === b2) + ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + " + c2 + ", ch),\n                getValue(batch, xD, xR, xC + 2 * " + c2 + ", ch),\n                initializationValue\n              );\n\n              " + w2 + "\n            }\n          }\n          setOutput(" + y2 + ");\n        }\n      }\n    ";
    }
  };
}();
var Li = function() {
  return function(t2, e2) {
    this.variableNames = ["x"];
    var n2 = t2.windowSize, r2 = t2.batchSize, o2 = t2.inSize, a2 = Math.ceil(o2 / n2);
    this.outputShape = [r2, a2];
    var i2 = "0.0", u2 = "";
    "prod" === e2 ? i2 = "1.0" : "min" === e2 ? (i2 = "1.0 / 1e-20", u2 = "min") : "max" === e2 && (i2 = "-1.0 / 1e-20", u2 = "max");
    var s2 = e2 + "(" + e2 + "(" + e2 + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
    "sum" === e2 ? s2 = "sumValue" : "prod" === e2 ? s2 = "prodValue" : "all" === e2 ? s2 = "allValue" : "any" === e2 && (s2 = "anyValue");
    var c2 = 4 * Math.floor(n2 / 4), l2 = n2 % 4, h2 = "\n      if (" + ("sum" === e2) + ") {\n        sumValue += dot(values, ones);\n      } else if (" + ("prod" === e2) + ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = " + u2 + "(values, minMaxValue);\n      }\n    ", f2 = "vec4";
    "all" === e2 ? (i2 = "1.0", h2 = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", f2 = "bvec4") : "any" === e2 && (i2 = "0.0", h2 = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", f2 = "bvec4");
    var p2 = "";
    o2 % n2 > 0 && (p2 = "\n        if (inIdx < 0 || inIdx >= " + o2 + ") {\n          return initializationValue;\n        }\n      "), this.userCode = "\n      const float initializationValue = " + i2 + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + p2 + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + n2 + ";\n\n        vec4 minMaxValue = vec4(" + i2 + ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < " + c2 + "; i += 4) {\n          int inIdx = inOffset + i;\n          " + f2 + " values = " + f2 + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + h2 + "\n        }\n\n        int inIdx = inOffset + " + c2 + ";\n        if (" + (1 === l2) + ") {\n          " + f2 + " values = " + f2 + "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          " + h2 + "\n        } else if (" + (2 === l2) + ") {\n          " + f2 + " values = " + f2 + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          " + h2 + "\n        } else if (" + (3 === l2) + ") {\n          " + f2 + " values = " + f2 + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          " + h2 + "\n        }\n        setOutput(" + s2 + ");\n      }\n    ";
  };
}();
var Wi = function() {
  return function(t2, e2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t2;
    for (var n2 = "", r2 = 0; r2 < 4; r2++) {
      var o2 = "thisRC = rc;";
      r2 % 2 == 1 && (o2 += "thisRC.z += 1;"), r2 > 1 && (o2 += "thisRC.y += 1;"), n2 += "\n        " + o2 + "\n        " + (r2 > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "") + "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[" + r2 + "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        " + (r2 > 0 ? "}" : "") + "\n      ";
    }
    this.userCode = "\n      \n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      " + jo(["r", "c", "d"], e2) + "\n      return ivec3(r, c, d);\n    }\n  \n      " + Xo(t2) + "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = " + t2[1] + ";\n        int cols = " + t2[2] + ";\n\n        " + n2 + "\n\n        setOutput(result);\n      }\n    ";
  };
}();
var Ui = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e2.shape;
    var r2 = e2.shape, o2 = r2[1], a2 = r2[2], i2 = t2.shape, u2 = i2[1], s2 = i2[2], c2 = [n2 && u2 > 1 ? o2 - 1 : o2, n2 && s2 > 1 ? a2 - 1 : a2], l2 = [n2 && u2 > 1 ? u2 - 1 : u2, n2 && s2 > 1 ? s2 - 1 : s2], h2 = c2[0] / l2[0], f2 = c2[1] / l2[1], p2 = 1 / h2, d2 = 1 / f2, v2 = 2 * Math.ceil(p2) + 2, m2 = 2 * Math.ceil(d2) + 2;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h2 + ");\n        const float widthScale = float(" + f2 + ");\n\n        const float invHeightScale = float(" + p2 + ");\n        const float invWidthScale = float(" + d2 + ");\n\n        const int winHeight = int(" + v2 + ");\n        const int winWidth = int(" + m2 + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + u2 + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + s2 + ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), " + (o2 - 1) + ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), " + (a2 - 1) + ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
  };
}();
var Vi = function() {
  return function(t2, e2, n2, r2) {
    this.variableNames = ["A"], this.outputShape = [];
    var o2 = t2[0], a2 = t2[1], i2 = t2[2], u2 = t2[3];
    this.outputShape = [o2, e2, n2, u2];
    var s2 = [r2 && e2 > 1 ? a2 - 1 : a2, r2 && n2 > 1 ? i2 - 1 : i2], c2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2];
    this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + s2[0] / c2[0] + ",\n          " + s2[1] / c2[1] + ");\n      const vec2 inputShapeRC = vec2(" + a2 + ".0, " + i2 + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
  };
}();
var zi = function() {
  return function(t2, e2, n2, r2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = [];
    var o2 = t2[0], a2 = t2[1], i2 = t2[2], u2 = t2[3];
    this.outputShape = [o2, e2, n2, u2];
    var s2 = [r2 && e2 > 1 ? a2 - 1 : a2, r2 && n2 > 1 ? i2 - 1 : i2], c2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2];
    this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          " + s2[0] / c2[0] + ",\n          " + s2[1] / c2[1] + ",\n          " + s2[1] / c2[1] + ");\n      const vec3 inputShapeRC = vec3(" + a2 + ".0, " + i2 + ".0,\n                                     " + i2 + ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < " + (u2 - 1) + ";\n        bool hasNextRow = coords.z < " + (n2 - 1) + ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ";
  };
}();
var Gi = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["dy"], this.outputShape = [], this.outputShape = e2.shape;
    var r2 = e2.shape, o2 = r2[1], a2 = r2[2], i2 = t2.shape, u2 = i2[1], s2 = i2[2], c2 = [n2 && u2 > 1 ? o2 - 1 : o2, n2 && s2 > 1 ? a2 - 1 : a2], l2 = [n2 && u2 > 1 ? u2 - 1 : u2, n2 && s2 > 1 ? s2 - 1 : s2], h2 = c2[0] / l2[0], f2 = c2[1] / l2[1], p2 = 1 / h2, d2 = 1 / f2, v2 = 2 * Math.ceil(p2) + 2, m2 = 2 * Math.ceil(d2) + 2;
    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(" + h2 + ");\n        const float widthScale = float(" + f2 + ");\n\n        const float invHeightScale = float(" + p2 + ");\n        const float invWidthScale = float(" + d2 + ");\n\n        const int winHeight = int(" + v2 + ");\n        const int winWidth = int(" + m2 + ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= " + u2 + ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= " + s2 + ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(" + c2[0] + ") *\n                (float(dyR) / float(" + l2[0] + "));\n\n            float sourceFracCol =\n                float(" + c2[1] + ") *\n                  (float(dyC) / float(" + l2[1] + "));\n\n            int sourceNearestRow = int(min(\n                float(int(" + o2 + ") - 1),\n                " + n2 + " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(" + a2 + ") - 1),\n                " + n2 + " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ";
  };
}();
var Hi = function() {
  return function(t2, e2, n2, r2) {
    this.variableNames = ["A"], this.outputShape = [];
    var o2 = t2[0], a2 = t2[1], i2 = t2[2], u2 = t2[3];
    this.outputShape = [o2, e2, n2, u2];
    var s2 = [r2 && e2 > 1 ? a2 - 1 : a2, r2 && n2 > 1 ? i2 - 1 : i2], c2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2], l2 = r2 ? "0.5" : "0.0";
    this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + s2[0] / c2[0] + ",\n          " + s2[1] / c2[1] + ");\n      const vec2 inputShapeRC = vec2(" + a2 + ".0, " + i2 + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + " + l2 + ")));\n\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ";
  };
}();
var qi = function() {
  return function(t2, e2) {
    this.variableNames = ["x"];
    var n2 = t2.length;
    if (n2 > 4)
      throw new Error("WebGL backend: Reverse of rank-" + n2 + " tensor is not yet supported");
    if (this.outputShape = t2, 1 !== n2) {
      var r2 = t2.map(function(n3, r3) {
        return function(n4) {
          return -1 !== e2.indexOf(n4) && 1 !== t2[n4] ? t2[n4] + " - coords[" + n4 + "] - 1" : "coords[" + n4 + "]";
        }(r3);
      }).join(","), o2 = aa(n2);
      this.userCode = "\n      void main() {\n        " + o2 + " coords = getOutputCoords();\n        setOutput(getX(" + r2 + "));\n      }\n    ";
    } else
      this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" + t2[0] + " - coord - 1));\n        }\n      ";
  };
}();
var Ki = function() {
  return function(t2, e2) {
    this.variableNames = ["x"], this.packedInputs = true, this.packedOutput = true;
    var n2 = t2.length;
    if (n2 > 4)
      throw new Error("WebGL backend: Reverse of rank-" + n2 + " tensor is not yet supported");
    this.outputShape = t2;
    var r2 = qo("rc", n2), o2 = r2[n2 - 1] + " + 1 < " + this.outputShape[n2 - 1], a2 = r2[n2 - 2] + " + 1 < " + this.outputShape[n2 - 2], i2 = aa(n2);
    function u2(n3) {
      var r3 = t2.map(function(r4, o3) {
        return function(n4, r5) {
          return -1 !== e2.indexOf(n4) && 1 !== t2[n4] ? t2[n4] + " - " + r5[n4] + " - 1" : "" + r5[n4];
        }(o3, n3);
      });
      return "getChannel(getX(" + r3.join(",") + "), vec2(" + r3.slice(-2).join(",") + "))";
    }
    this.userCode = 1 === n2 ? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(" + t2[0] + " - rc - 1),\n            " + t2[0] + " - rc - 1);\n          if(" + o2 + "){\n              result.g = getChannel(getX(" + t2[0] + " - (rc  + 1) - 1),\n                " + t2[0] + " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      " : "\n        void main() {\n          " + i2 + " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = " + function(t3) {
      return u2(t3);
    }(r2.slice()) + ";\n          if(" + o2 + "){\n            result.g = " + function(t3) {
      return t3[n2 - 1] = "(" + t3[n2 - 1] + " + 1)", u2(t3);
    }(r2.slice()) + ";\n          }\n          if(" + a2 + ") {\n            result.b = " + function(t3) {
      return t3[n2 - 2] = "(" + t3[n2 - 2] + " + 1)", u2(t3);
    }(r2.slice()) + ";\n            if(" + o2 + ") {\n              result.a = " + function(t3) {
      return t3[n2 - 1] = "(" + t3[n2 - 1] + " + 1)", t3[n2 - 2] = "(" + t3[n2 - 2] + " + 1)", u2(t3);
    }(r2.slice()) + ";\n            }\n          }\n          setOutput(result);\n        }\n    ";
  };
}();
var ji = function() {
  return function(t2, e2, n2, r2, o2, a2, i2) {
    void 0 === i2 && (i2 = true), this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = a2;
    var u2 = aa(o2.length), s2 = aa(a2.length), c2 = "";
    1 === n2 ? c2 = "i" : 2 === n2 && (c2 = "i, j");
    var l2 = "getIndices(" + c2 + ")", h2 = "";
    1 === r2 ? h2 = "i" : 2 === r2 && (h2 = "i, coords[1]");
    var f2 = "getUpdates(" + h2 + ")", p2 = e2 > 1 ? "strides[j]" : "strides";
    this.userCode = "\n        " + u2 + " strides = " + u2 + "(" + o2 + ");\n\n        void main() {\n          " + s2 + " coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < " + t2 + "; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < " + e2 + "; j++) {\n              int index = round(" + l2 + ");\n              flattenedIndex += index * " + p2 + ";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += " + f2 + ";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      ";
  };
}();
var Xi = function() {
  return function(t2, e2) {
    this.variableNames = ["x", "segmentIds"];
    var n2 = t2.windowSize, r2 = t2.batchSize, o2 = t2.inSize, a2 = t2.numSegments, i2 = a2 * Math.ceil(o2 / n2);
    this.outputShape = [r2, i2];
    var u2 = 4 * Math.floor(n2 / 4), s2 = n2 % 4, c2 = "\n        sumValue += dot(values, segFilter);\n    ", l2 = "";
    o2 % n2 > 0 && (l2 = "\n        if (inIdx < 0 || inIdx >= " + o2 + ") {\n          return initializationValue;\n        }\n      ");
    var h2 = "";
    o2 % n2 > 0 && (h2 = "\n        if (inIdx < 0 || inIdx >= " + o2 + ") {\n          return -1.0;\n        }\n      "), this.userCode = "\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        " + l2 + "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        " + h2 + "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          " + a2 + ")) * float(" + n2 + "));\n        int currentSeg = int(mod(float(outIdx), float(" + a2 + ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + u2 + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          " + c2 + "\n        }\n\n        int inIdx = inOffset + " + u2 + ";\n        if (" + (1 === s2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          " + c2 + "\n        } else if (" + (2 === s2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          " + c2 + "\n        } else if (" + (3 === s2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          " + c2 + "\n        }\n        setOutput(sumValue);\n      }\n    ";
  };
}();
var $i = function() {
  return function(t2, e2, n2) {
    var r2, o2;
    if (this.variableNames = ["c", "a", "b"], this.outputShape = e2, n2 > 4)
      throw Error("Where for rank " + n2 + " is not yet supported");
    if (1 === n2)
      o2 = "resRC", r2 = "resRC";
    else {
      for (var a2 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], i2 = [], u2 = [], s2 = 0; s2 < e2.length; s2++)
        u2.push("" + a2[s2]), s2 < t2 && i2.push("" + a2[s2]);
      r2 = i2.join(), o2 = u2.join();
    }
    var c2 = aa(n2);
    this.userCode = "\n      void main() {\n        " + c2 + " resRC = getOutputCoords();\n        float cVal = getC(" + r2 + ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" + o2 + "));\n        } else {\n          setOutput(getB(" + o2 + "));\n        }\n      }\n    ";
  };
}();
var Yi = function() {
  function t2(t3) {
    this.variableNames = ["source"], this.outputShape = t3, this.rank = t3.length;
    var e2, n2 = aa(this.rank), r2 = "uniform int start[" + this.rank + "];", o2 = function(t4) {
      if (1 === t4)
        return "sourceLoc";
      if (t4 <= 6)
        return Qi.slice(0, t4).map(function(t5) {
          return "sourceLoc." + t5;
        }).join(",");
      throw Error("Slicing for rank " + t4 + " is not yet supported");
    }(this.rank);
    e2 = "\n        " + n2 + " sourceLoc;\n        " + n2 + " coords = getOutputCoords();\n        " + t3.map(function(t4, e3) {
      return "sourceLoc." + Qi[e3] + " = start[" + e3 + "] + coords." + Qi[e3] + ";";
    }).join("\n") + "\n      ", this.userCode = "\n      " + r2 + "\n      void main() {\n        " + e2 + "\n        setOutput(getSource(" + o2 + "));\n      }\n    ";
  }
  return t2.prototype.getCustomSetupFunc = function(t3) {
    var e2 = this;
    if (t3.length !== this.rank)
      throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t3.length + ")");
    return function(n2, r2) {
      null == e2.startLoc && (e2.startLoc = n2.getUniformLocationNoThrow(r2, "start"), null == e2.startLoc) || n2.gl.uniform1iv(e2.startLoc, t3);
    };
  }, t2;
}();
var Qi = ["x", "y", "z", "w", "u", "v"];
var Ji = function() {
  function t2(t3) {
    this.variableNames = ["source"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t3, this.rank = t3.length;
    var e2 = aa(this.rank), n2 = qo("coords", this.rank), r2 = qo("sourceLoc", this.rank), o2 = 1 === this.rank ? "sourceLoc" : "vec2(" + r2.slice(-2).join() + ")", a2 = "getChannel(getSource(" + r2.join() + "), " + o2 + ")", i2 = "\n      result.x = " + a2 + ";\n      if (++" + n2[this.rank - 1] + " < " + t3[this.rank - 1] + ") {\n        ++" + r2[this.rank - 1] + ";\n        result.y = " + a2 + ";\n        --" + r2[this.rank - 1] + ";\n      }\n    ", u2 = 1 === this.rank ? "" : "\n      --" + n2[this.rank - 1] + ";\n      if (++" + n2[this.rank - 2] + " < " + t3[this.rank - 2] + ") {\n        ++" + r2[this.rank - 2] + ";\n        result.z = " + a2 + ";\n        if (++" + n2[this.rank - 1] + " < " + t3[this.rank - 1] + ") {\n          ++" + r2[this.rank - 1] + ";\n          result.w = " + a2 + ";\n        }\n      }\n    ", s2 = this.rank <= 4 ? "sourceLoc = coords +\n            " + e2 + "(" + t3.map(function(t4, e3) {
      return "start[" + e3 + "]";
    }).join() + ");" : t3.map(function(t4, e3) {
      return r2[e3] + " = " + n2[e3] + " + start[" + e3 + "];";
    }).join("\n");
    this.userCode = "\n      uniform int start[" + this.rank + "];\n      void main() {\n        " + e2 + " coords = getOutputCoords();\n        " + e2 + " sourceLoc;\n        " + s2 + "\n        vec4 result = vec4(0.);\n        " + i2 + "\n        " + u2 + "\n        setOutput(result);\n      }\n    ";
  }
  return t2.prototype.getCustomSetupFunc = function(t3) {
    var e2 = this;
    if (t3.length !== this.rank)
      throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + t3.length + ")");
    return function(n2, r2) {
      null == e2.startLoc && (e2.startLoc = n2.getUniformLocationNoThrow(r2, "start"), null == e2.startLoc) || n2.gl.uniform1iv(e2.startLoc, t3);
    };
  }, t2;
}();
var Zi = function() {
  return function(t2, e2, n2) {
    this.variableNames = ["x"], this.outputShape = n2;
    var r2 = n2.length, o2 = aa(n2.length), a2 = aa(n2.length), i2 = "";
    if (1 === r2)
      i2 = "coords * strides + begin";
    else {
      var u2 = 0;
      i2 = n2.map(function(t3, e3) {
        return u2++, 1 === n2.length ? "coords * strides[" + e3 + "] + begin[" + e3 + "]" : "coords[" + (u2 - 1) + "] * strides[" + e3 + "] + begin[" + e3 + "]";
      }).join(",");
    }
    this.userCode = "\n      " + o2 + " begin = " + o2 + "(" + t2 + ");\n      " + o2 + " strides = " + o2 + "(" + e2 + ");\n\n      void main() {\n        " + a2 + " coords = getOutputCoords();\n        setOutput(getX(" + i2 + "));\n      }\n    ";
  };
}();
var tu = function() {
  function t2(t3) {
    this.gpgpu = t3, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {}, this.logEnabled = false, this.usedTextures = {};
  }
  return t2.prototype.acquireTexture = function(t3, e2, n2) {
    var r2, o2 = eu(e2, n2), a2 = nu(t3, o2, n2);
    if (a2 in this.freeTextures || (this.freeTextures[a2] = []), a2 in this.usedTextures || (this.usedTextures[a2] = []), this.freeTextures[a2].length > 0) {
      this.numFreeTextures--, this.numUsedTextures++, this.log();
      var i2 = this.freeTextures[a2].shift();
      return this.usedTextures[a2].push(i2), i2;
    }
    return this.numUsedTextures++, this.log(), o2 === Bt.PACKED_2X2_FLOAT32 ? r2 = this.gpgpu.createPackedMatrixTexture(t3[0], t3[1]) : o2 === Bt.PACKED_2X2_FLOAT16 ? r2 = this.gpgpu.createFloat16PackedMatrixTexture(t3[0], t3[1]) : o2 === Bt.UNPACKED_FLOAT32 ? r2 = this.gpgpu.createFloat32MatrixTexture(t3[0], t3[1]) : o2 === Bt.UNPACKED_FLOAT16 ? r2 = this.gpgpu.createFloat16MatrixTexture(t3[0], t3[1]) : o2 === Bt.PACKED_4X1_UNSIGNED_BYTE && (r2 = this.gpgpu.createUnsignedBytesMatrixTexture(t3[0], t3[1])), this.usedTextures[a2].push(r2), r2;
  }, t2.prototype.releaseTexture = function(t3, e2, n2, r2) {
    if (null != this.freeTextures) {
      var o2 = nu(e2, eu(n2, r2), r2);
      o2 in this.freeTextures || (this.freeTextures[o2] = []), this.freeTextures[o2].push(t3), this.numFreeTextures++, this.numUsedTextures--;
      var a2 = this.usedTextures[o2], i2 = a2.indexOf(t3);
      if (i2 < 0)
        throw new Error("Cannot release a texture that was never provided by this texture manager");
      a2.splice(i2, 1), this.log();
    }
  }, t2.prototype.log = function() {
    if (this.logEnabled) {
      var t3 = this.numFreeTextures + this.numUsedTextures;
      console.log("Free/Used", this.numFreeTextures + " / " + this.numUsedTextures, "(" + t3 + ")");
    }
  }, t2.prototype.getNumUsedTextures = function() {
    return this.numUsedTextures;
  }, t2.prototype.getNumFreeTextures = function() {
    return this.numFreeTextures;
  }, t2.prototype.dispose = function() {
    var t3 = this;
    if (null != this.freeTextures) {
      for (var e2 in this.freeTextures)
        this.freeTextures[e2].forEach(function(e3) {
          t3.gpgpu.deleteMatrixTexture(e3);
        });
      for (var e2 in this.usedTextures)
        this.usedTextures[e2].forEach(function(e3) {
          t3.gpgpu.deleteMatrixTexture(e3);
        });
      this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0;
    }
  }, t2;
}();
function eu(t2, e2) {
  if (t2 === Mt.UPLOAD)
    return Bt.PACKED_2X2_FLOAT32;
  if (t2 === Mt.RENDER || null == t2)
    return function(t3) {
      return a().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? t3 ? Bt.PACKED_2X2_FLOAT32 : Bt.UNPACKED_FLOAT32 : t3 ? Bt.PACKED_2X2_FLOAT16 : Bt.UNPACKED_FLOAT16;
    }(e2);
  if (t2 === Mt.DOWNLOAD || t2 === Mt.PIXELS)
    return Bt.PACKED_4X1_UNSIGNED_BYTE;
  throw new Error("Unknown logical texture type " + t2);
}
function nu(t2, e2, n2) {
  return t2[0] + "_" + t2[1] + "_" + e2 + "_" + n2;
}
var ru = function() {
  return function(t2, e2) {
    this.variableNames = ["A"];
    for (var n2 = new Array(t2.length), r2 = 0; r2 < n2.length; r2++)
      n2[r2] = t2[r2] * e2[r2];
    this.outputShape = n2, this.rank = n2.length;
    var o2 = aa(this.rank), a2 = function(t3) {
      var e3 = t3.length;
      if (e3 > 5)
        throw Error("Tile for rank " + e3 + " is not yet supported");
      if (1 === e3)
        return "imod(resRC, " + t3[0] + ")";
      for (var n3 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], r3 = [], o3 = 0; o3 < t3.length; o3++)
        r3.push("imod(" + n3[o3] + ", " + t3[o3] + ")");
      return r3.join();
    }(t2);
    this.userCode = "\n      void main() {\n        " + o2 + " resRC = getOutputCoords();\n        setOutput(getA(" + a2 + "));\n      }\n    ";
  };
}();
var ou = function() {
  return function(t2, e2) {
    this.variableNames = ["A"];
    for (var n2 = new Array(t2.length), r2 = 0; r2 < n2.length; r2++)
      n2[r2] = t2[e2[r2]];
    this.outputShape = n2, this.rank = n2.length;
    var o2 = aa(this.rank), a2 = function(t3) {
      var e3 = t3.length;
      if (e3 > 6)
        throw Error("Transpose for rank " + e3 + " is not yet supported");
      for (var n3 = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], r3 = new Array(e3), o3 = 0; o3 < t3.length; o3++)
        r3[t3[o3]] = n3[o3];
      return r3.join();
    }(e2);
    this.userCode = "\n    void main() {\n      " + o2 + " resRC = getOutputCoords();\n      setOutput(getA(" + a2 + "));\n    }\n    ";
  };
}();
var au = function() {
  return function(t2, e2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true;
    for (var n2 = new Array(t2.length), r2 = 0; r2 < n2.length; r2++)
      n2[r2] = t2[e2[r2]];
    if (this.outputShape = n2, this.rank = n2.length, this.rank > 6)
      throw Error("Packed transpose for rank " + this.rank + " is not yet supported.");
    var o2 = aa(this.rank), a2 = Ho("rc", this.rank), i2 = new Array(this.rank);
    for (r2 = 0; r2 < e2.length; r2++)
      i2[e2[r2]] = a2[r2];
    var u2 = "vec2(" + i2.slice(-2).join() + ")", s2 = "++" + a2[this.rank - 1] + " < " + n2[this.rank - 1], c2 = "getChannel(getA(" + i2.join() + "), " + u2 + ")";
    this.userCode = "\n    void main() {\n      " + o2 + " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = " + c2 + ";\n      if(" + s2 + ") {\n        result[1] = " + c2 + ";\n      }\n      --" + a2[this.rank - 1] + ";\n      if(++" + a2[this.rank - 2] + " < " + n2[this.rank - 2] + ") {\n        result[2] = " + c2 + ";\n        if(" + s2 + ") {\n          result[3] = " + c2 + ";\n        }\n      }\n      setOutput(result);\n    }\n    ";
  };
}();
var iu = 1.7580993408473768;
var uu = 1.0507009873554805;
var su = function() {
  return function(t2, e2) {
    this.variableNames = ["A"], this.outputShape = t2, this.userCode = "\n      float unaryOperation(float x) {\n        " + e2 + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
  };
}();
var cu = "if (isnan(x)) return x;";
var lu = "return x;";
var hu = "return abs(x);";
var fu = cu + "\n  return (x < 0.0) ? 0.0 : x;\n";
var pu = cu + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";
var du = "return (x >= 0.0) ? x : (exp(x) - 1.0);";
var vu = "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = " + iu + ";\n  float scale = " + uu + ";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";
var mu = "return -x;";
var gu = "return ceil(x);";
var yu = "return floor(x);";
var xu = "return exp(x);";
var bu = "return exp(x) - 1.0;";
var wu = cu + "\n  return sin(x);\n";
var Cu = cu + "\n  return cos(x);\n";
var Eu = cu + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n";
var Ru = cu + "\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n";
var Iu = cu + "\n  return atan(x);\n";
var ku = cu + "return log(x + sqrt(x * x + 1.0));";
var Su = cu + "\n  if (x < 1.0) return NAN;\n  return log(x + sqrt(x * x - 1.0));";
var Au = cu + "\n  if ((x < -1.0) || (x > 1.0)) return NAN;\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;";
var Du = "return x;";
var Tu = "return x;";
var Nu = "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";
var Fu = "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";
var Ou = "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n";
var _u = function() {
  return function(t2, e2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = true, this.outputShape = t2, this.userCode = "\n      vec4 unaryOperation(vec4 x) {\n        " + e2 + "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
  };
}();
var Mu = function() {
  return function(t2) {
    this.variableNames = ["A"], this.packedInputs = true, this.packedOutput = false, this.outputShape = t2;
    var e2 = t2.length, n2 = qo("rc", e2), r2 = aa(e2), o2 = function(t3, e3) {
      if (1 === t3)
        return "rc";
      for (var n3 = "", r3 = 0; r3 < t3; r3++)
        n3 += e3[r3], r3 < t3 - 1 && (n3 += ",");
      return n3;
    }(e2, n2), a2 = n2.slice(-2), i2 = e2 <= 1 ? "rc" : "vec2(" + a2.join(",") + ")";
    this.userCode = "\n      void main() {\n        " + r2 + " rc = getOutputCoords();\n        vec4 packedInput = getA(" + o2 + ");\n\n        setOutput(getChannel(packedInput, " + i2 + "));\n      }\n    ";
  };
}();
var Bu = {};
function Pu(t2, e2) {
  if (void 0 === e2 && (e2 = false), "linear" === t2)
    return e2 ? Tu : lu;
  if ("relu" === t2)
    return e2 ? Nu : fu;
  if ("elu" === t2)
    return e2 ? Ou : du;
  if ("relu6" === t2)
    return e2 ? Fu : pu;
  if ("prelu" === t2)
    return e2 ? wa : xa;
  throw new Error("Activation " + t2 + " has not been implemented for the WebGL backend.");
}
var Lu = 600;
var Wu = function(t2) {
  function o2(e2) {
    var n2, r2 = t2.call(this) || this;
    if (r2.gpgpu = e2, r2.pendingRead = new WeakMap(), r2.pendingDisposal = new WeakSet(), r2.dataRefCount = new WeakMap(), r2.numBytesInGPU = 0, r2.uploadWaitMs = 0, r2.downloadWaitMs = 0, r2.warnedAboutMemory = false, r2.pendingDeletes = 0, r2.disposed = false, !a().getBool("HAS_WEBGL"))
      throw new Error("WebGL is not supported on this device");
    if (null == e2) {
      var o3 = Ut(a().getNumber("WEBGL_VERSION"));
      r2.binaryCache = (n2 = a().getNumber("WEBGL_VERSION")) in Bu ? Bu[n2] : (Bu[n2] = {}, Bu[n2]), r2.gpgpu = new Ci(o3), r2.canvas = o3.canvas, r2.gpgpuCreatedLocally = true;
    } else
      r2.binaryCache = {}, r2.gpgpuCreatedLocally = false, r2.canvas = e2.gl.canvas;
    return r2.textureManager = new tu(r2.gpgpu), r2.numMBBeforeWarning = null == a().global.screen ? 1024 : a().global.screen.height * a().global.screen.width * window.devicePixelRatio * Lu / 1024 / 1024, r2.texData = new so(r2, Nt), r2;
  }
  return e(o2, t2), o2.prototype.numDataIds = function() {
    return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes;
  }, o2.prototype.fromPixels = function(t3, e2) {
    if (null == t3)
      throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
    var n2 = "undefined" != typeof OffscreenCanvas && t3 instanceof OffscreenCanvas || "undefined" != typeof HTMLCanvasElement && t3 instanceof HTMLCanvasElement, r2 = t3.data instanceof Uint8Array, o3 = "undefined" != typeof ImageData && t3 instanceof ImageData, i2 = "undefined" != typeof HTMLVideoElement && t3 instanceof HTMLVideoElement, u2 = "undefined" != typeof HTMLImageElement && t3 instanceof HTMLImageElement, s2 = i2 ? [t3.videoWidth, t3.videoHeight] : [t3.width, t3.height], c2 = s2[0], l2 = s2[1], h2 = [l2, c2], f2 = [l2, c2, e2];
    if (!(n2 || r2 || o3 || i2 || u2))
      throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was " + t3.constructor.name);
    (u2 || i2) && (null == this.fromPixels2DContext && (this.fromPixels2DContext = Vt(a().getNumber("WEBGL_VERSION")).getContext("2d")), this.fromPixels2DContext.canvas.width = c2, this.fromPixels2DContext.canvas.height = l2, this.fromPixels2DContext.drawImage(t3, 0, 0, c2, l2), t3 = this.fromPixels2DContext.canvas);
    var p2, d2, v2 = this.makeTensorInfo(h2, "int32");
    return this.texData.get(v2.dataId).usage = Mt.PIXELS, this.gpgpu.uploadPixelDataToTexture(this.getTexture(v2.dataId), t3), a().getBool("WEBGL_PACK") ? (p2 = new ei(f2), d2 = this.compileAndRun(p2, [v2])) : (p2 = new ti(f2), d2 = this.compileAndRun(p2, [v2])), this.disposeData(v2.dataId), d2;
  }, o2.prototype.write = function(t3, e2, n2) {
    if (a().getBool("DEBUG") && this.checkNumericalProblems(t3), "complex64" === n2 && null != t3)
      throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    var r2 = {};
    return this.texData.set(r2, {shape: e2, dtype: n2, values: t3, usage: Mt.UPLOAD}), r2;
  }, o2.prototype.move = function(t3, e2, n2, r2) {
    if (a().getBool("DEBUG") && this.checkNumericalProblems(e2), "complex64" === r2)
      throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    this.texData.set(t3, {shape: n2, dtype: r2, values: e2, usage: Mt.UPLOAD});
  }, o2.prototype.readSync = function(t3) {
    var e2 = this.texData.get(t3), n2 = e2.values, r2 = e2.dtype, o3 = e2.complexTensors, a2 = e2.slice, i2 = e2.shape, u2 = e2.isPacked;
    if (null != a2) {
      var s2 = void 0;
      s2 = u2 ? new _u(i2, Du) : new su(i2, Du);
      var c2 = this.runWebGLProgram(s2, [{dataId: t3, shape: i2, dtype: r2}], r2), l2 = this.readSync(c2.dataId);
      return this.disposeData(c2.dataId), l2;
    }
    if (null != n2)
      return this.convertAndCacheOnCPU(t3);
    if ("string" === r2)
      return n2;
    var h2, f2, p2 = null != this.activeTimers;
    (p2 && (h2 = Y()), "complex64" === r2) ? f2 = No(o3.real.dataSync(), o3.imag.dataSync()) : f2 = this.getValuesFromTexture(t3);
    return p2 && (this.downloadWaitMs += Y() - h2), this.convertAndCacheOnCPU(t3, f2);
  }, o2.prototype.read = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2, o3, i2, u2, s2, c2, l2, h2, f2, p2, d2, v2, m2, g2, y2, x2, b2, C2, E2, R2, I2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (this.pendingRead.has(t3))
              return e2 = this.pendingRead.get(t3), [2, new Promise(function(t4) {
                return e2.push(t4);
              })];
            if (n2 = this.texData.get(t3), o3 = n2.values, i2 = n2.shape, u2 = n2.slice, s2 = n2.dtype, c2 = n2.complexTensors, l2 = n2.isPacked, null != u2)
              return h2 = void 0, h2 = l2 ? new _u(i2, Du) : new su(i2, Du), f2 = this.runWebGLProgram(h2, [{dataId: t3, shape: i2, dtype: s2}], s2), p2 = this.read(f2.dataId), this.disposeData(f2.dataId), [2, p2];
            if (null != o3)
              return [2, this.convertAndCacheOnCPU(t3)];
            if (!a().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && 2 === a().getNumber("WEBGL_VERSION"))
              throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
            return d2 = null, "complex64" !== s2 && a().get("WEBGL_BUFFER_SUPPORTED") && (v2 = this.decode(t3), m2 = this.texData.get(v2.dataId), d2 = (I2 = this.gpgpu).createBufferFromTexture.apply(I2, [m2.texture].concat(Gt(i2)))), this.pendingRead.set(t3, []), "complex64" === s2 ? [3, 2] : [4, this.gpgpu.createAndWaitForFence()];
          case 1:
            r2.sent(), r2.label = 2;
          case 2:
            return "complex64" !== s2 ? [3, 4] : [4, Promise.all([c2.real.data(), c2.imag.data()])];
          case 3:
            return y2 = r2.sent(), x2 = y2[0], b2 = y2[1], g2 = No(x2, b2), [3, 5];
          case 4:
            null == d2 ? g2 = this.getValuesFromTexture(t3) : (C2 = w(i2), g2 = this.gpgpu.downloadFloat32MatrixFromBuffer(d2, C2)), r2.label = 5;
          case 5:
            return null != v2 && this.disposeData(v2.dataId), E2 = this.convertAndCacheOnCPU(t3, g2), R2 = this.pendingRead.get(t3), this.pendingRead.delete(t3), R2.forEach(function(t4) {
              return t4(E2);
            }), this.pendingDisposal.has(t3) && (this.pendingDisposal.delete(t3), this.disposeData(t3), this.pendingDeletes--), [2, E2];
        }
      });
    });
  }, o2.prototype.checkNumericalProblems = function(t3) {
    if (null != t3)
      for (var e2 = 0; e2 < t3.length; e2++) {
        var n2 = t3[e2];
        if (!$t(n2)) {
          if (a().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))
            throw Error("The value " + n2 + " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");
          throw Error("The value " + n2 + " cannot be represented on this device.");
        }
      }
  }, o2.prototype.getValuesFromTexture = function(t3) {
    var e2, n2 = this.texData.get(t3), r2 = n2.shape, o3 = n2.dtype, i2 = n2.isPacked, u2 = w(r2);
    if (a().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
      var s2 = this.decode(t3), c2 = this.texData.get(s2.dataId), l2 = (e2 = this.gpgpu).downloadMatrixFromPackedTexture.apply(e2, [c2.texture].concat(Gt(r2))).subarray(0, u2);
      return this.disposeData(s2.dataId), l2;
    }
    var h2 = a().getBool("WEBGL_PACK") && true === i2, f2 = h2 ? Re(r2) : r2, p2 = h2 ? new ja(f2) : new Ka(f2), d2 = this.runWebGLProgram(p2, [{shape: f2, dtype: o3, dataId: t3}], "float32"), v2 = this.texData.get(d2.dataId), m2 = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(v2.texture, v2.texShape[0], v2.texShape[1]).subarray(0, u2);
    return this.disposeData(d2.dataId), m2;
  }, o2.prototype.time = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2, o3, a2, i2, u2, s2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            return e2 = this.activeTimers, n2 = [], o3 = false, null == this.programTimersStack ? (this.programTimersStack = n2, o3 = true) : this.activeTimers.push(n2), this.activeTimers = n2, t3(), a2 = b(this.activeTimers.map(function(t4) {
              return t4.query;
            })).filter(function(t4) {
              return null != t4;
            }), i2 = b(this.activeTimers.map(function(t4) {
              return t4.name;
            })).filter(function(t4) {
              return null != t4;
            }), this.activeTimers = e2, o3 && (this.programTimersStack = null), [4, Promise.all(a2)];
          case 1:
            return u2 = r2.sent(), s2 = {uploadWaitMs: this.uploadWaitMs, downloadWaitMs: this.downloadWaitMs, kernelMs: m(u2), getExtraProfileInfo: function() {
              return u2.map(function(t4, e3) {
                return {name: i2[e3], ms: t4};
              }).map(function(t4) {
                return t4.name + ": " + t4.ms;
              }).join(", ");
            }, wallMs: null}, this.uploadWaitMs = 0, this.downloadWaitMs = 0, [2, s2];
        }
      });
    });
  }, o2.prototype.memory = function() {
    return {unreliable: false, numBytesInGPU: this.numBytesInGPU};
  }, o2.prototype.startTimer = function() {
    return a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? this.gpgpu.beginQuery() : {startMs: Y(), endMs: null};
  }, o2.prototype.endTimer = function(t3) {
    return a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (this.gpgpu.endQuery(), t3) : (t3.endMs = Y(), t3);
  }, o2.prototype.getQueryTime = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2;
      return r(this, function(n2) {
        return a().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? [2, this.gpgpu.waitForQueryAndGetTime(t3)] : [2, (e2 = t3).endMs - e2.startMs];
      });
    });
  }, o2.prototype.disposeData = function(t3) {
    if (!this.pendingDisposal.has(t3)) {
      if (this.pendingRead.has(t3))
        return this.pendingDisposal.add(t3), void this.pendingDeletes++;
      if (this.texData.has(t3)) {
        this.releaseGPUData(t3);
        var e2 = this.texData.get(t3).complexTensors;
        null != e2 && (e2.real.dispose(), e2.imag.dispose()), this.texData.delete(t3);
      }
    }
  }, o2.prototype.releaseGPUData = function(t3) {
    var e2 = this.texData.get(t3), n2 = e2.texture, r2 = e2.dtype, o3 = e2.texShape, a2 = e2.usage, i2 = e2.isPacked, u2 = e2.slice, s2 = u2 && u2.origDataId || t3, c2 = this.dataRefCount.get(s2);
    c2 > 1 ? this.dataRefCount.set(s2, c2 - 1) : (this.dataRefCount.delete(s2), null != n2 && (this.numBytesInGPU -= this.computeBytes(o3, r2), this.textureManager.releaseTexture(n2, o3, a2, i2)));
    var l2 = this.texData.get(t3);
    l2.texture = null, l2.texShape = null, l2.isPacked = false, l2.slice = null;
  }, o2.prototype.getTexture = function(t3) {
    return this.uploadToGPU(t3), this.texData.get(t3).texture;
  }, o2.prototype.getDataInfo = function(t3) {
    return this.texData.get(t3);
  }, o2.prototype.getCPUBackend = function() {
    return a().getBool("WEBGL_CPU_FORWARD") ? (null == this.cpuBackend && (this.cpuBackend = Nt.findBackend("cpu")), this.cpuBackend) : null;
  }, o2.prototype.shouldExecuteOnCPU = function(t3, e2) {
    var n2 = this;
    return void 0 === e2 && (e2 = 128), null != this.getCPUBackend() && t3.every(function(t4) {
      return null == n2.texData.get(t4.dataId).texture && t4.size < e2;
    });
  }, o2.prototype.getGPGPUContext = function() {
    return this.gpgpu;
  }, o2.prototype.complex = function(t3, e2) {
    var n2 = this.makeOutput(t3.shape, "complex64");
    return this.texData.get(n2.dataId).complexTensors = {real: Nt.keep(t3.clone()), imag: Nt.keep(e2.clone())}, n2;
  }, o2.prototype.real = function(t3) {
    return this.texData.get(t3.dataId).complexTensors.real.clone();
  }, o2.prototype.imag = function(t3) {
    return this.texData.get(t3.dataId).complexTensors.imag.clone();
  }, o2.prototype.slice = function(t3, e2, n2) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.slice(t3, e2, n2);
    if (0 === w(n2))
      return kn([], n2, t3.dtype);
    var r2 = this.texData.get(t3.dataId).isPacked, o3 = Yr(t3.shape, e2, n2);
    if (r2 || !o3) {
      var i2 = a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Ji(n2) : new Yi(n2), u2 = i2.getCustomSetupFunc(e2);
      return this.compileAndRun(i2, [t3], null, u2);
    }
    return this.uploadToGPU(t3.dataId), this.shallowSlice(t3, e2, n2);
  }, o2.prototype.shallowSlice = function(t3, e2, n2) {
    var r2 = this.texData.get(t3.dataId), o3 = this.makeOutput(n2, t3.dtype), a2 = this.texData.get(o3.dataId);
    Object.assign(a2, r2), a2.shape = n2, a2.dtype = t3.dtype;
    var i2 = Qr(e2, t3.strides);
    r2.slice && (i2 += r2.slice.flatOffset), a2.slice = {flatOffset: i2, origDataId: r2.slice && r2.slice.origDataId || t3.dataId};
    var u2 = this.dataRefCount.get(a2.slice.origDataId) || 1;
    return this.dataRefCount.set(a2.slice.origDataId, u2 + 1), o3;
  }, o2.prototype.stridedSlice = function(t3, e2, n2, r2) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.stridedSlice(t3, e2, n2, r2);
    var o3 = jr(e2, n2, r2);
    if (o3.some(function(t4) {
      return 0 === t4;
    }))
      return kn([], o3);
    var a2 = new Zi(e2, r2, o3);
    return this.compileAndRun(a2, [t3]);
  }, o2.prototype.reverse = function(t3, e2) {
    var n2 = a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Ki(t3.shape, e2) : new qi(t3.shape, e2);
    return this.compileAndRun(n2, [t3]);
  }, o2.prototype.concat = function(t3, e2) {
    if ("complex64" === t3[0].dtype) {
      var n2 = t3.map(function(t4) {
        return Rn(t4);
      }), r2 = t3.map(function(t4) {
        return In(t4);
      });
      return En(this.concat(n2, e2), this.concat(r2, e2));
    }
    if (this.shouldExecuteOnCPU(t3))
      return this.cpuBackend.concat(t3, e2);
    if (1 === t3.length)
      return t3[0];
    if (t3.length > a().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      var o3 = Math.floor(t3.length / 2), i2 = this.concat(t3.slice(0, o3), e2), u2 = this.concat(t3.slice(o3), e2);
      return this.concat([i2, u2], e2);
    }
    if (a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && t3[0].rank > 1) {
      var s2 = new Sa(t3.map(function(t4) {
        return t4.shape;
      }), e2);
      return this.compileAndRun(s2, t3);
    }
    var c2 = wn(t3.map(function(t4) {
      return t4.shape;
    }), e2), l2 = t3.map(function(t4) {
      return t4.as2D(-1, w(t4.shape.slice(e2)));
    }), h2 = new ka(l2.map(function(t4) {
      return t4.shape;
    }));
    return this.compileAndRun(h2, l2).reshape(c2);
  }, o2.prototype.neg = function(t3) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.neg(t3);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
      return this.packedUnaryOp(t3, mu, t3.dtype);
    var e2 = new su(t3.shape, mu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.batchMatMul = function(t3, e2, n2, r2) {
    var o3 = n2 ? t3.shape[2] : t3.shape[1], a2 = r2 ? e2.shape[1] : e2.shape[2], i2 = n2 ? t3.shape[1] : t3.shape[2], u2 = t3.shape[0];
    if ((1 === o3 || 1 === a2) && i2 > 1e3) {
      n2 && (t3 = t3.transpose([0, 2, 1])), r2 && (e2 = e2.transpose([0, 2, 1]));
      var s2 = 1 === a2 ? t3 : t3.as3D(u2, i2, 1), c2 = 1 === a2 ? 2 : 1, l2 = 1 === a2 ? e2.as3D(u2, 1, i2) : e2;
      return this.multiply(s2, l2).sum(c2, true);
    }
    var h2 = Ct(t3.dtype, e2.dtype), f2 = new Ti(t3.shape, [u2, o3, a2], n2, r2);
    return this.compileAndRun(f2, [t3, e2], h2);
  }, o2.prototype.fusedBatchMatMul = function(t3) {
    var e2 = t3.a, n2 = t3.b, r2 = t3.transposeA, o3 = t3.transposeB, a2 = t3.bias, i2 = t3.activation, u2 = t3.preluActivationWeights, s2 = r2 ? e2.shape[2] : e2.shape[1], c2 = o3 ? n2.shape[1] : n2.shape[2], l2 = e2.shape[0], h2 = Ct(e2.dtype, n2.dtype), f2 = null != a2, p2 = null != u2, d2 = i2 ? Pu(i2, true) : null, v2 = new Ti(e2.shape, [l2, s2, c2], r2, o3, f2, d2, p2), m2 = [e2, n2];
    return a2 && m2.push(a2), u2 && m2.push(u2), this.compileAndRun(v2, m2, h2);
  }, o2.prototype.multiply = function(t3, e2) {
    if ("complex64" === t3.dtype) {
      var n2 = this.texData.get(t3.dataId), r2 = this.texData.get(e2.dataId), o3 = new va(pa, t3.shape, e2.shape), i2 = new va(da, t3.shape, e2.shape), u2 = [this.makeComplexComponentTensorInfo(t3, n2.complexTensors.real), this.makeComplexComponentTensorInfo(t3, n2.complexTensors.imag), this.makeComplexComponentTensorInfo(e2, r2.complexTensors.real), this.makeComplexComponentTensorInfo(e2, r2.complexTensors.imag)], s2 = this.compileAndRun(o3, u2), c2 = this.compileAndRun(i2, u2), l2 = this.complex(s2, c2);
      return s2.dispose(), c2.dispose(), l2;
    }
    if (this.shouldExecuteOnCPU([t3, e2]))
      return this.cpuBackend.multiply(t3, e2);
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, ya, t3.dtype);
    var h2 = new ba(ya, t3.shape, e2.shape);
    return this.compileAndRun(h2, [t3, e2], t3.dtype);
  }, o2.prototype.batchNormalization = function(t3, e2, n2, r2, o3, i2) {
    var u2 = [t3, e2, n2], s2 = null;
    null != i2 && (s2 = i2.shape, u2.push(i2));
    var c2 = null;
    if (null != o3 && (c2 = o3.shape, u2.push(o3)), a().getBool("WEBGL_PACK_NORMALIZATION")) {
      var l2 = new fa(t3.shape, e2.shape, n2.shape, s2, c2, r2);
      return this.compileAndRun(l2, u2);
    }
    var h2 = new ha(t3.shape, e2.shape, n2.shape, s2, c2, r2);
    return this.compileAndRun(h2, u2);
  }, o2.prototype.localResponseNormalization4D = function(t3, e2, n2, r2, o3) {
    var i2 = a().getBool("WEBGL_PACK_NORMALIZATION") ? new Si(t3.shape, e2, n2, r2, o3) : new Ii(t3.shape, e2, n2, r2, o3);
    return this.compileAndRun(i2, [t3]);
  }, o2.prototype.LRNGrad = function(t3, e2, n2, r2, o3, a2, i2) {
    var u2 = new ki(e2.shape, r2, o3, a2, i2);
    return this.compileAndRun(u2, [e2, n2, t3]);
  }, o2.prototype.tile = function(t3, e2) {
    if ("string" === t3.dtype) {
      var n2 = this.readSync(t3.dataId).map(function(t4) {
        return Z(t4);
      });
      return Lo(ur(t3.shape, t3.dtype, n2), e2);
    }
    var r2 = new ru(t3.shape, e2);
    return this.compileAndRun(r2, [t3]);
  }, o2.prototype.pad = function(t3, e2, n2) {
    var r2 = a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Mi(t3.shape, e2, n2) : new _i(t3.shape, e2, n2);
    return this.compileAndRun(r2, [t3]);
  }, o2.prototype.transpose = function(t3, e2) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.transpose(t3, e2);
    var n2 = a().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new au(t3.shape, e2) : new ou(t3.shape, e2);
    return this.compileAndRun(n2, [t3]);
  }, o2.prototype.gather = function(t3, e2, n2) {
    if (this.shouldExecuteOnCPU([t3, e2]))
      return this.cpuBackend.gather(t3, e2, n2);
    var r2 = new ni(t3.shape, e2.size, n2);
    return this.compileAndRun(r2, [t3, e2]);
  }, o2.prototype.batchToSpaceND = function(t3, e2, n2) {
    g(t3.rank <= 4, function() {
      return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet";
    });
    var r2 = e2.reduce(function(t4, e3) {
      return t4 * e3;
    }), o3 = Mr(t3.shape, e2, r2), a2 = Br(o3.length, e2.length), i2 = Pr(t3.shape, e2, r2), u2 = Lr(n2, e2.length), s2 = Wr(i2, n2, e2.length);
    return t3.reshape(o3).transpose(a2).reshape(i2).slice(u2, s2);
  }, o2.prototype.spaceToBatchND = function(t3, e2, n2) {
    g(t3.rank <= 4, function() {
      return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet";
    });
    var r2 = e2.reduce(function(t4, e3) {
      return t4 * e3;
    }), o3 = [[0, 0]];
    o3.push.apply(o3, n2);
    for (var a2 = 1 + e2.length; a2 < t3.shape.length; ++a2)
      o3.push([0, 0]);
    var i2 = t3.pad(o3), u2 = Mr(i2.shape, e2, r2, false), s2 = Br(u2.length, e2.length, false), c2 = Pr(i2.shape, e2, r2, false);
    return i2.reshape(u2).transpose(s2).reshape(c2);
  }, o2.prototype.reduce = function(t3, e2, n2) {
    var r2 = t3.shape[0], o3 = t3.shape[1], a2 = zr(o3), i2 = new Li({windowSize: a2, inSize: o3, batchSize: r2}, e2), u2 = this.compileAndRun(i2, [t3], n2);
    return 1 === u2.shape[1] ? u2 : this.reduce(u2, e2, n2);
  }, o2.prototype.argReduce = function(t3, e2, n2) {
    void 0 === n2 && (n2 = null);
    var r2 = t3.shape[0], o3 = t3.shape[1];
    null != n2 && (r2 = n2.shape[0], o3 = n2.shape[1]);
    var a2 = zr(o3), i2 = new Go({windowSize: a2, inSize: o3, batchSize: r2}, e2, null == n2), u2 = [t3];
    null != n2 && u2.push(n2);
    var s2 = this.compileAndRun(i2, u2, "int32");
    return 1 === s2.shape[1] ? s2 : this.argReduce(t3, e2, s2);
  }, o2.prototype.argReducePacked = function(t3, e2, n2) {
    void 0 === n2 && (n2 = null);
    var r2 = null != n2 ? n2.shape : t3.shape, o3 = zr(r2[r2.length - 1]), a2 = new sa(r2, o3, e2, null == n2), i2 = null == n2 ? [t3] : [t3, n2], u2 = this.compileAndRun(a2, i2, "int32");
    return u2.rank === t3.rank ? this.argReducePacked(t3, e2, u2) : u2;
  }, o2.prototype.sum = function(t3, e2) {
    mn("sum", e2, t3.rank);
    var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = w(n2[1]), a2 = t3.as2D(-1, o3), i2 = Et(t3.dtype);
    return this.reduce(a2, "sum", i2).reshape(r2);
  }, o2.prototype.prod = function(t3, e2) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.prod(t3, e2);
    var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = w(n2[1]), a2 = t3.as2D(-1, o3), i2 = Et(t3.dtype);
    return this.reduce(a2, "prod", i2).reshape(r2);
  }, o2.prototype.unsortedSegmentSum = function(t3, e2, n2) {
    var r2 = 0, o3 = gn([r2], t3.rank), a2 = t3;
    null != o3 && (a2 = t3.transpose(o3), r2 = xn(1, t3.rank)[0]);
    var i2 = function(t4, e3, n3) {
      for (var r3 = [], o4 = t4.length, a3 = 0; a3 < o4; a3++)
        a3 !== e3 ? r3.push(t4[a3]) : r3.push(n3);
      return r3;
    }(a2.shape, r2, n2), u2 = w([a2.shape[r2]]), s2 = a2.as2D(-1, u2), c2 = Et(t3.dtype), l2 = this.segOpCompute(s2, "unsortedSegmentSum", e2, c2, n2).reshape(i2);
    return null != o3 && (l2 = l2.transpose(yn(o3))), l2;
  }, o2.prototype.segOpCompute = function(t3, e2, n2, r2, o3) {
    var a2 = t3.shape[0], i2 = t3.shape[1], u2 = function(t4, e3) {
      var n3, r3 = false;
      for (t4 <= Vr ? (n3 = t4, r3 = true) : n3 = H(t4, Math.floor(Math.sqrt(t4))); !r3; )
        n3 > e3 || n3 === t4 ? r3 = true : n3 = H(t4, n3 + 1);
      return n3;
    }(i2, o3), s2 = new Xi({windowSize: u2, inSize: i2, batchSize: a2, numSegments: o3}, e2), c2 = this.compileAndRun(s2, [t3, n2], r2);
    return c2.shape[1] === o3 ? c2 : (n2 = Un(0, o3).tile([i2 / u2]), this.segOpCompute(c2, e2, n2, r2, o3));
  }, o2.prototype.argMinMaxReduce = function(t3, e2, n2) {
    var r2 = [e2];
    if (mn("arg" + n2.charAt(0).toUpperCase() + n2.slice(1), r2, t3.rank), !a().getBool("WEBGL_PACK_REDUCE") || t3.rank <= 2) {
      var o3 = dn(t3.shape, r2), i2 = o3[0], u2 = w(o3[1]), s2 = t3.as2D(-1, u2);
      return this.argReduce(s2, n2).reshape(i2);
    }
    return this.argReducePacked(t3, n2);
  }, o2.prototype.argMin = function(t3, e2) {
    return this.argMinMaxReduce(t3, e2, "min");
  }, o2.prototype.argMax = function(t3, e2) {
    return this.argMinMaxReduce(t3, e2, "max");
  }, o2.prototype.cumsum = function(t3, e2, n2, r2) {
    if (e2 !== t3.rank - 1)
      throw new Error("WebGL cumsum shader expects an inner-most axis=" + (t3.rank - 1) + " but got axis=" + e2);
    var o3 = new Ua(t3.shape, n2, r2);
    return this.compileAndRun(o3, [t3]);
  }, o2.prototype.equal = function(t3, e2) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, "\n  return vec4(equal(a, b));\n", "bool");
    var n2 = new ba("return float(a == b);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "bool");
  }, o2.prototype.notEqual = function(t3, e2) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, "\n  return vec4(notEqual(a, b));\n", "bool");
    var n2 = new ba("return float(a != b);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "bool");
  }, o2.prototype.less = function(t3, e2) {
    if (this.shouldExecuteOnCPU([t3, e2]))
      return this.cpuBackend.less(t3, e2);
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, "\n  return vec4(lessThan(a, b));\n", "bool");
    var n2 = new ba("return float(a < b);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "bool");
  }, o2.prototype.lessEqual = function(t3, e2) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, "\n  return vec4(lessThanEqual(a, b));\n", "bool");
    var n2 = new ba("return float(a <= b);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "bool");
  }, o2.prototype.greater = function(t3, e2) {
    if (this.shouldExecuteOnCPU([t3, e2]))
      return this.cpuBackend.greater(t3, e2);
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, "\n  return vec4(greaterThan(a, b));\n", "bool");
    var n2 = new ba("return float(a > b);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "bool");
  }, o2.prototype.greaterEqual = function(t3, e2) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, "\n  return vec4(greaterThanEqual(a, b));\n", "bool");
    var n2 = new ba("return float(a >= b);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "bool");
  }, o2.prototype.logicalNot = function(t3) {
    var e2 = new su(t3.shape, "return float(!(x >= 1.0));");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.logicalAnd = function(t3, e2) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n", "bool");
    var n2 = new ba("return float(a >= 1.0 && b >= 1.0);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "bool");
  }, o2.prototype.logicalOr = function(t3, e2) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n", "bool");
    var n2 = new ba("return float(a >= 1.0 || b >= 1.0);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "bool");
  }, o2.prototype.select = function(t3, e2, n2) {
    var r2 = new $i(t3.rank, e2.shape, e2.rank);
    return this.compileAndRun(r2, [t3, e2, n2], Ct(e2.dtype, n2.dtype));
  }, o2.prototype.where = function(t3) {
    un("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
    var e2 = t3.dataSync();
    return Uo(t3.shape, e2);
  }, o2.prototype.topk = function(t3, e2, n2) {
    return Wo(t3.dataSync(), t3.shape, t3.dtype, e2);
  }, o2.prototype.min = function(t3, e2) {
    mn("min", e2, t3.rank);
    var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = w(n2[1]), a2 = t3.as2D(-1, o3);
    return this.reduce(a2, "min", a2.dtype).reshape(r2);
  }, o2.prototype.minimum = function(t3, e2) {
    if (this.shouldExecuteOnCPU([t3, e2]))
      return this.cpuBackend.minimum(t3, e2);
    var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t3.shape, e2.shape) : new ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2]);
  }, o2.prototype.mod = function(t3, e2) {
    var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t3.shape, e2.shape) : new ba("if (b == 0.0) return NAN;\n  return mod(a, b);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2]);
  }, o2.prototype.max = function(t3, e2) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.max(t3, e2);
    mn("max", e2, t3.rank);
    var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = w(n2[1]), a2 = t3.as2D(-1, o3);
    return this.reduce(a2, "max", a2.dtype).reshape(r2);
  }, o2.prototype.maximum = function(t3, e2) {
    if (this.shouldExecuteOnCPU([t3, e2]))
      return this.cpuBackend.maximum(t3, e2);
    var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t3.shape, e2.shape) : new ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2]);
  }, o2.prototype.all = function(t3, e2) {
    mn("all", e2, t3.rank);
    var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = w(n2[1]), a2 = t3.as2D(-1, o3);
    return this.reduce(a2, "all", a2.dtype).reshape(r2);
  }, o2.prototype.any = function(t3, e2) {
    mn("any", e2, t3.rank);
    var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = w(n2[1]), a2 = t3.as2D(-1, o3);
    return this.reduce(a2, "any", a2.dtype).reshape(r2);
  }, o2.prototype.squaredDifference = function(t3, e2) {
    var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("return (a - b) * (a - b);", t3.shape, e2.shape) : new ba("return (a - b) * (a - b);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2]);
  }, o2.prototype.realDivide = function(t3, e2) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
      return this.packedBinaryOp(t3, e2, "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n", "float32", true);
    }
    var n2 = new ba("\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "float32");
  }, o2.prototype.floorDiv = function(t3, e2) {
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n", "int32");
    var n2 = new ba("\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2], "int32");
  }, o2.prototype.add = function(t3, e2) {
    if ("complex64" === t3.dtype && "complex64" === e2.dtype)
      return this.complexSeparableBinaryOp(t3, e2, ma);
    if (this.shouldExecuteOnCPU([t3, e2]))
      return this.cpuBackend.add(t3, e2);
    var n2 = Ct(t3.dtype, e2.dtype);
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, ma, n2);
    var r2 = new ba(ma, t3.shape, e2.shape);
    return this.compileAndRun(r2, [t3, e2], n2);
  }, o2.prototype.packedUnaryOp = function(t3, e2, n2) {
    var r2 = new _u(t3.shape, e2);
    return this.compileAndRun(r2, [t3], n2);
  }, o2.prototype.packedBinaryOp = function(t3, e2, n2, r2, o3) {
    void 0 === o3 && (o3 = false);
    var a2 = new Ca(n2, t3.shape, e2.shape, o3);
    return this.compileAndRun(a2, [t3, e2], r2);
  }, o2.prototype.complexSeparableBinaryOp = function(t3, e2, n2) {
    var r2 = this, o3 = this.texData.get(t3.dataId), a2 = this.texData.get(e2.dataId), i2 = [[o3.complexTensors.real, a2.complexTensors.real], [o3.complexTensors.imag, a2.complexTensors.imag]].map(function(o4) {
      var a3 = o4[0], i3 = o4[1], u3 = r2.makeComplexComponentTensorInfo(t3, a3), s3 = r2.makeComplexComponentTensorInfo(e2, i3), c3 = new ba(n2, t3.shape, e2.shape);
      return r2.compileAndRun(c3, [u3, s3], Ct(a3.dtype, i3.dtype));
    }), u2 = i2[0], s2 = i2[1], c2 = this.complex(u2, s2);
    return u2.dispose(), s2.dispose(), c2;
  }, o2.prototype.makeComplexComponentTensorInfo = function(t3, e2) {
    return {dataId: e2.dataId, dtype: e2.dtype, shape: t3.shape};
  }, o2.prototype.addN = function(t3) {
    if (1 === t3.length)
      return t3[0];
    if (t3.length > a().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      var e2 = Math.floor(t3.length / 2), n2 = this.addN(t3.slice(0, e2)), r2 = this.addN(t3.slice(e2));
      return this.addN([n2, r2]);
    }
    var o3 = t3.map(function(t4) {
      return t4.dtype;
    }).reduce(function(t4, e3) {
      return Ct(t4, e3);
    }), i2 = t3.map(function(t4) {
      return t4.shape;
    }), u2 = a().getBool("WEBGL_PACK") ? new zo(t3[0].shape, i2) : new Vo(t3[0].shape, i2);
    return this.compileAndRun(u2, t3, o3);
  }, o2.prototype.subtract = function(t3, e2) {
    if ("complex64" === t3.dtype && "complex64" === e2.dtype)
      return this.complexSeparableBinaryOp(t3, e2, ga);
    if (this.shouldExecuteOnCPU([t3, e2]))
      return this.cpuBackend.subtract(t3, e2);
    var n2 = Ct(t3.dtype, e2.dtype);
    if (a().getBool("WEBGL_PACK_BINARY_OPERATIONS"))
      return this.packedBinaryOp(t3, e2, ga, t3.dtype);
    var r2 = new ba(ga, t3.shape, e2.shape);
    return this.compileAndRun(r2, [t3, e2], n2);
  }, o2.prototype.pow = function(t3, e2) {
    var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t3.shape, e2.shape) : new ba("\nif(a < 0.0 && floor(b) < b){\n  return NAN;\n}\nif (b == 0.0) {\n  return 1.0;\n}\nreturn (round(mod(b, 2.0)) != 1) ?\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\n", t3.shape, e2.shape), r2 = Ct(t3.dtype, e2.dtype);
    return this.compileAndRun(n2, [t3, e2], r2);
  }, o2.prototype.ceil = function(t3) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.ceil(t3);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
      return this.packedUnaryOp(t3, gu, t3.dtype);
    var e2 = new su(t3.shape, gu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.floor = function(t3) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.floor(t3);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
      return this.packedUnaryOp(t3, yu, t3.dtype);
    var e2 = new su(t3.shape, yu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.sign = function(t3) {
    var e2 = new su(t3.shape, "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.isNaN = function(t3) {
    var e2 = new su(t3.shape, "return float(isnan(x));");
    return this.compileAndRun(e2, [t3], "bool");
  }, o2.prototype.isInf = function(t3) {
    var e2 = new su(t3.shape, "return float(isinf(x));");
    return this.compileAndRun(e2, [t3], "bool");
  }, o2.prototype.isFinite = function(t3) {
    var e2 = new su(t3.shape, "return float(!isnan(x) && !isinf(x));");
    return this.compileAndRun(e2, [t3], "bool");
  }, o2.prototype.round = function(t3) {
    var e2 = new su(t3.shape, "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.exp = function(t3) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.exp(t3);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
      return this.packedUnaryOp(t3, xu, t3.dtype);
    var e2 = new su(t3.shape, xu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.expm1 = function(t3) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.expm1(t3);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
      return this.packedUnaryOp(t3, bu, t3.dtype);
    var e2 = new su(t3.shape, bu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.log = function(t3) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.log(t3);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
      return this.packedUnaryOp(t3, "\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n", t3.dtype);
    var e2 = new su(t3.shape, "if (x < 0.0) return NAN;\n  return log(x);");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.log1p = function(t3) {
    var e2 = new su(t3.shape, "return log(1.0 + x);");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.sqrt = function(t3) {
    var e2 = new su(t3.shape, "return sqrt(x);");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.rsqrt = function(t3) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.rsqrt(t3);
    var e2 = new su(t3.shape, "return inversesqrt(x);");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.reciprocal = function(t3) {
    var e2 = new su(t3.shape, "return 1.0 / x;");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.relu = function(t3) {
    var e2;
    return e2 = a().getBool("WEBGL_PACK") ? new _u(t3.shape, Nu) : new su(t3.shape, fu), this.compileAndRun(e2, [t3]);
  }, o2.prototype.relu6 = function(t3) {
    var e2;
    return e2 = a().getBool("WEBGL_PACK") ? new _u(t3.shape, Fu) : new su(t3.shape, pu), this.compileAndRun(e2, [t3]);
  }, o2.prototype.prelu = function(t3, e2) {
    var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca(wa, t3.shape, e2.shape) : new ba(xa, t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2]);
  }, o2.prototype.elu = function(t3) {
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
      return this.packedUnaryOp(t3, Ou, t3.dtype);
    var e2 = new su(t3.shape, du);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.eluDer = function(t3, e2) {
    var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", t3.shape, e2.shape) : new ba("return (b >= 1.0) ? a : a * (b + 1.0);", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2]);
  }, o2.prototype.selu = function(t3) {
    var e2 = new su(t3.shape, vu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.int = function(t3) {
    var e2 = new su(t3.shape, "return float(int(x));");
    return this.compileAndRun(e2, [t3], "int32");
  }, o2.prototype.clip = function(t3, e2, n2) {
    var r2, o3 = (r2 = a().getBool("WEBGL_PACK_CLIP") ? new Ra(t3.shape) : new Ea(t3.shape)).getCustomSetupFunc(e2, n2);
    return this.compileAndRun(r2, [t3], null, o3);
  }, o2.prototype.abs = function(t3) {
    if (this.shouldExecuteOnCPU([t3]))
      return this.cpuBackend.abs(t3);
    if (a().getBool("WEBGL_PACK_UNARY_OPERATIONS"))
      return this.packedUnaryOp(t3, hu, t3.dtype);
    var e2 = new su(t3.shape, hu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.complexAbs = function(t3) {
    var e2 = this.texData.get(t3.dataId), n2 = new Ia(t3.shape), r2 = [this.makeComplexComponentTensorInfo(t3, e2.complexTensors.real), this.makeComplexComponentTensorInfo(t3, e2.complexTensors.imag)];
    return this.compileAndRun(n2, r2);
  }, o2.prototype.sigmoid = function(t3) {
    var e2 = new su(t3.shape, "return 1.0 / (1.0 + exp(-1.0 * x));");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.softplus = function(t3) {
    var e2 = new su(t3.shape, "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.sin = function(t3) {
    var e2 = new su(t3.shape, wu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.cos = function(t3) {
    var e2 = new su(t3.shape, Cu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.tan = function(t3) {
    var e2 = new su(t3.shape, "return tan(x);");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.asin = function(t3) {
    var e2 = new su(t3.shape, Eu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.acos = function(t3) {
    var e2 = new su(t3.shape, Ru);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.atan = function(t3) {
    var e2 = new su(t3.shape, Iu);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.atan2 = function(t3, e2) {
    var n2 = a().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new Ca("\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n", t3.shape, e2.shape) : new ba("\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n", t3.shape, e2.shape);
    return this.compileAndRun(n2, [t3, e2]);
  }, o2.prototype.sinh = function(t3) {
    var e2 = new su(t3.shape, "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.cosh = function(t3) {
    var e2 = new su(t3.shape, "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.tanh = function(t3) {
    var e2 = new su(t3.shape, "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n");
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.asinh = function(t3) {
    var e2 = new su(t3.shape, ku);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.acosh = function(t3) {
    var e2 = new su(t3.shape, Su);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.atanh = function(t3) {
    var e2 = new su(t3.shape, Au);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.erf = function(t3) {
    var e2 = new su(t3.shape, '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = 0.3275911;\n  float a1 = 0.254829592;\n  float a2 = -0.284496736;\n  float a3 = 1.421413741;\n  float a4 = -1.453152027;\n  float a5 = 1.061405429;\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n');
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.step = function(t3, e2) {
    var n2 = new su(t3.shape, function(t4) {
      return void 0 === t4 && (t4 = 0), cu + "\n    return x > 0.0 ? 1.0 : float(" + t4 + ");\n  ";
    }(e2));
    return this.compileAndRun(n2, [t3]);
  }, o2.prototype.conv2dByMatMul = function(t3, e2, n2, r2, o3, i2) {
    var u2 = t3.shape, s2 = this.texData.get(t3.dataId), c2 = n2.inChannels, l2 = u2[0] * u2[1] * u2[2], h2 = n2.outChannels, f2 = "channelsLast" === n2.dataFormat, p2 = (1 === l2 || 1 === h2) && c2 > 1e3, d2 = u2[2] % 2 != 0 && !!s2.isPacked;
    if (p2 || !a().getBool("WEBGL_LAZILY_UNPACK") || !a().getBool("WEBGL_PACK_BINARY_OPERATIONS") || !d2) {
      var v2 = f2 ? u2[0] * u2[1] * u2[2] : u2[0] * u2[2] * u2[3], m2 = this.reshape(t3, [1, v2, n2.inChannels]), y2 = this.reshape(e2, [1, n2.inChannels, n2.outChannels]);
      return this.reshape(this.fusedBatchMatMul({a: m2, b: y2, transposeA: false, transposeB: false, bias: r2, activation: o3, preluActivationWeights: i2}), n2.outShape);
    }
    var x2 = f2 ? u2[0] * u2[1] * (u2[2] + 1) : u2[0] * u2[2] * (u2[3] + 1), b2 = {dataId: t3.dataId, shape: [1, x2, n2.inChannels], dtype: t3.dtype}, w2 = s2.shape;
    s2.shape = s2.shape.slice(), s2.shape[s2.shape.length - 2]++, g(Se(s2.shape, b2.shape), function() {
      return "packed reshape " + s2.shape + " to " + b2.shape + " isn't free";
    });
    var C2 = this.reshape(e2, [1, n2.inChannels, n2.outChannels]), E2 = this.fusedBatchMatMul({a: b2, b: C2, transposeA: false, transposeB: false, bias: r2, activation: o3, preluActivationWeights: i2}), R2 = this.texData.get(E2.dataId);
    return g(R2.isPacked, function() {
      return "batchMatMul result is expected to be packed";
    }), s2.shape = w2, R2.shape = n2.outShape, Nt.makeTensorFromDataId(E2.dataId, n2.outShape, E2.dtype);
  }, o2.prototype.conv2dWithIm2Row = function(t3, e2, n2, r2, o3, a2) {
    var i2 = n2.filterWidth, u2 = n2.filterHeight, s2 = n2.inChannels, c2 = n2.outWidth, l2 = n2.outHeight, h2 = "channelsLast" === n2.dataFormat, f2 = i2 * u2 * s2, p2 = l2 * c2, d2 = [f2, p2], v2 = t3.squeeze([0]), m2 = e2.reshape([1, f2, -1]), g2 = new Ri(d2, v2.shape, n2), y2 = this.compileAndRun(g2, [v2]).reshape([1, d2[0], d2[1]]), x2 = null != r2, b2 = null != a2, w2 = o3 ? Pu(o3, true) : null, C2 = new Ti(y2.shape, [1, p2, n2.outChannels], true, false, x2, w2, b2), E2 = [y2, m2];
    r2 && E2.push(r2), b2 && E2.push(a2);
    var R2 = this.compileAndRun(C2, E2);
    return h2 ? R2.reshape([1, l2, c2, n2.outChannels]) : R2.reshape([1, n2.outChannels, l2, c2]);
  }, o2.prototype.fusedConv2d = function(t3) {
    var e2 = t3.input, n2 = t3.filter, r2 = t3.convInfo, o3 = t3.bias, i2 = t3.activation, u2 = t3.preluActivationWeights;
    if (1 === r2.filterHeight && 1 === r2.filterWidth && 1 === r2.dilationHeight && 1 === r2.dilationWidth && 1 === r2.strideHeight && 1 === r2.strideWidth && ("SAME" === r2.padInfo.type || "VALID" === r2.padInfo.type))
      return this.conv2dByMatMul(e2, n2, r2, o3, i2, u2);
    if (a().getBool("WEBGL_CONV_IM2COL") && 1 === e2.shape[0])
      return this.conv2dWithIm2Row(e2, n2, r2, o3, i2, u2);
    var s2 = null != o3, c2 = null != u2, l2 = i2 ? Pu(i2, false) : null, h2 = new Ma(r2, s2, l2, c2), f2 = [e2, n2];
    return o3 && f2.push(o3), u2 && f2.push(u2), this.compileAndRun(h2, f2);
  }, o2.prototype.conv2d = function(t3, e2, n2) {
    if (1 === n2.filterHeight && 1 === n2.filterWidth && 1 === n2.dilationHeight && 1 === n2.dilationWidth && 1 === n2.strideHeight && 1 === n2.strideWidth && ("SAME" === n2.padInfo.type || "VALID" === n2.padInfo.type))
      return this.conv2dByMatMul(t3, e2, n2);
    if (a().getBool("WEBGL_CONV_IM2COL") && 1 === t3.shape[0])
      return this.conv2dWithIm2Row(t3, e2, n2);
    var r2 = new Ma(n2);
    return this.compileAndRun(r2, [t3, e2]);
  }, o2.prototype.conv2dDerInput = function(t3, e2, n2) {
    var r2 = new Ta(n2);
    return this.compileAndRun(r2, [t3, e2]);
  }, o2.prototype.conv2dDerFilter = function(t3, e2, n2) {
    var r2 = new Da(n2);
    return this.compileAndRun(r2, [t3, e2]);
  }, o2.prototype.fusedDepthwiseConv2D = function(t3) {
    var e2, n2 = t3.input, r2 = t3.filter, o3 = t3.convInfo, i2 = t3.bias, u2 = t3.activation, s2 = t3.preluActivationWeights, c2 = a().getBool("WEBGL_PACK_DEPTHWISECONV") && o3.strideWidth <= 2 && o3.outChannels / o3.inChannels == 1, l2 = u2 ? Pu(u2, c2) : null, h2 = [n2, r2], f2 = null != i2, p2 = null != s2;
    return f2 && h2.push(i2), p2 && h2.push(s2), c2 ? (e2 = new La(o3, f2, l2, p2), this.compileAndRun(e2, h2)) : (e2 = new Pa(o3, f2, l2, p2), this.compileAndRun(e2, h2));
  }, o2.prototype.depthwiseConv2D = function(t3, e2, n2) {
    var r2;
    return a().getBool("WEBGL_PACK_DEPTHWISECONV") && n2.strideWidth <= 2 && n2.outChannels / n2.inChannels == 1 ? (r2 = new La(n2), this.compileAndRun(r2, [t3, e2])) : (r2 = new Pa(n2), this.compileAndRun(r2, [t3, e2]));
  }, o2.prototype.depthwiseConv2DDerInput = function(t3, e2, n2) {
    var r2 = new _a(n2);
    return this.compileAndRun(r2, [t3, e2]);
  }, o2.prototype.depthwiseConv2DDerFilter = function(t3, e2, n2) {
    var r2 = new Oa(n2);
    return this.compileAndRun(r2, [t3, e2]);
  }, o2.prototype.conv3d = function(t3, e2, n2) {
    var r2 = new Ba(n2);
    return this.compileAndRun(r2, [t3, e2]);
  }, o2.prototype.conv3dDerInput = function(t3, e2, n2) {
    var r2 = new Fa(n2);
    return this.compileAndRun(r2, [t3, e2]);
  }, o2.prototype.conv3dDerFilter = function(t3, e2, n2) {
    var r2 = new Na(n2);
    return this.compileAndRun(r2, [t3, e2]);
  }, o2.prototype.maxPool = function(t3, e2) {
    var n2 = new Bi(e2, "max", false);
    return this.compileAndRun(n2, [t3]);
  }, o2.prototype.avgPool = function(t3, e2) {
    var n2 = new Bi(e2, "avg", false);
    return this.compileAndRun(n2, [t3], "float32");
  }, o2.prototype.maxPoolBackprop = function(t3, e2, n2, r2) {
    var o3 = new Bi(r2, "max", true), a2 = this.compileAndRun(o3, [e2]), i2 = new Ai(r2), u2 = this.compileAndRun(i2, [t3, a2], e2.dtype);
    return a2.dispose(), u2;
  }, o2.prototype.avgPoolBackprop = function(t3, e2, n2) {
    var r2 = new ca(n2);
    return this.compileAndRun(r2, [t3], e2.dtype);
  }, o2.prototype.cast = function(t3, e2) {
    return So(t3, e2, this);
  }, o2.prototype.unstack = function(t3, e2) {
    for (var n2 = t3.shape[e2], r2 = new Array(t3.rank - 1), o3 = 0, a2 = 0; a2 < t3.rank; a2++)
      a2 !== e2 && (r2[o3++] = t3.shape[a2]);
    var i2 = new Array(t3.rank).fill(0), u2 = t3.shape.slice();
    u2[e2] = 1;
    var s2 = new Array(n2);
    for (a2 = 0; a2 < s2.length; a2++)
      i2[e2] = a2, s2[a2] = this.slice(t3, i2, u2).reshape(r2);
    return s2;
  }, o2.prototype.avgPool3d = function(t3, e2) {
    var n2 = new Pi(e2, "avg", false);
    return this.compileAndRun(n2, [t3], "float32");
  }, o2.prototype.avgPool3dBackprop = function(t3, e2, n2) {
    var r2 = new la(n2);
    return this.compileAndRun(r2, [t3], e2.dtype);
  }, o2.prototype.maxPool3d = function(t3, e2) {
    var n2 = new Pi(e2, "max", false);
    return this.compileAndRun(n2, [t3], "float32");
  }, o2.prototype.maxPool3dBackprop = function(t3, e2, n2, r2) {
    var o3 = new Pi(r2, "max", true), a2 = this.compileAndRun(o3, [e2]), i2 = new Di(r2), u2 = this.compileAndRun(i2, [t3, a2], e2.dtype);
    return a2.dispose(), u2;
  }, o2.prototype.reshape = function(t3, e2) {
    var n2 = this.texData.get(t3.dataId);
    if (n2.isPacked && !Se(t3.shape, e2) && (null === n2.texture || !Se(n2.shape, e2))) {
      var r2 = this.packedReshape(t3, e2);
      return Nt.makeTensorFromDataId(r2.dataId, r2.shape, r2.dtype);
    }
    return Ao(t3, e2);
  }, o2.prototype.resizeBilinear = function(t3, e2, n2, r2) {
    var o3 = a().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new zi(t3.shape, e2, n2, r2) : new Vi(t3.shape, e2, n2, r2);
    return this.compileAndRun(o3, [t3]);
  }, o2.prototype.resizeBilinearBackprop = function(t3, e2, n2) {
    var r2 = new Ui(t3, e2, n2);
    return this.compileAndRun(r2, [t3]);
  }, o2.prototype.resizeNearestNeighbor = function(t3, e2, n2, r2) {
    var o3 = new Hi(t3.shape, e2, n2, r2);
    return this.compileAndRun(o3, [t3]);
  }, o2.prototype.resizeNearestNeighborBackprop = function(t3, e2, n2) {
    var r2 = new Gi(t3, e2, n2);
    return this.compileAndRun(r2, [t3]);
  }, o2.prototype.multinomial = function(t3, e2, n2, r2) {
    var o3 = e2 ? t3 : io(t3), a2 = o3.shape[0], i2 = o3.shape[1], u2 = new Ni(a2, i2, n2), s2 = u2.getCustomSetupFunc(r2);
    return this.compileAndRun(u2, [o3], "int32", s2);
  }, o2.prototype.oneHot = function(t3, e2, n2, r2) {
    var o3 = new Fi(t3.size, e2, n2, r2);
    return this.compileAndRun(o3, [t3]);
  }, o2.prototype.diag = function(t3) {
    var e2 = new qa(t3.size);
    return this.compileAndRun(e2, [t3]);
  }, o2.prototype.nonMaxSuppression = function(t3, e2, n2, r2, o3) {
    return un("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"), Mo(t3.dataSync(), e2.dataSync(), n2, r2, o3);
  }, o2.prototype.cropAndResize = function(t3, e2, n2, r2, o3, a2) {
    var i2 = new Wa(t3.shape, e2.shape, r2, o3, a2);
    return this.compileAndRun(i2, [t3, e2, n2]);
  }, o2.prototype.depthToSpace = function(t3, e2, n2) {
    g(e2 > 1, function() {
      return "blockSize should be > 1 for depthToSpace, but was: " + e2;
    });
    var r2 = t3.shape[0], o3 = "NHWC" === n2 ? t3.shape[1] : t3.shape[2], a2 = "NHWC" === n2 ? t3.shape[2] : t3.shape[3], i2 = "NHWC" === n2 ? t3.shape[3] : t3.shape[1], u2 = o3 * e2, s2 = a2 * e2, c2 = i2 / (e2 * e2), l2 = new Ha("NHWC" === n2 ? [r2, u2, s2, c2] : [r2, c2, u2, s2], e2, n2);
    return this.compileAndRun(l2, [t3]);
  }, o2.prototype.split = function(t3, e2, n2) {
    return Po(t3, e2, n2);
  }, o2.prototype.scatterND = function(t3, e2, n2) {
    var r2 = Hr(0, t3, n2), o3 = r2.sliceRank, a2 = r2.numUpdates, i2 = r2.sliceSize, u2 = r2.strides, s2 = r2.outputSize, c2 = [s2 / i2, i2], l2 = t3.reshape([a2, o3]), h2 = e2.reshape([a2, i2]);
    if (0 === s2)
      return Ao(kn([]), n2);
    var f2 = An(0), p2 = new ji(a2, o3, l2.rank, h2.rank, u2, c2);
    return this.compileAndRun(p2, [h2, l2, f2]).reshape(n2);
  }, o2.prototype.sparseToDense = function(t3, e2, n2, r2) {
    var o3 = Hr(0, t3, n2), a2 = o3.sliceRank, i2 = o3.numUpdates, u2 = o3.strides, s2 = o3.outputSize, c2 = new ji(i2, a2, t3.rank, e2.rank, u2, [s2, 1], false);
    return this.compileAndRun(c2, [e2, t3, r2]).reshape(n2);
  }, o2.prototype.fft = function(t3) {
    return this.fftImpl(t3, false);
  }, o2.prototype.ifft = function(t3) {
    return this.fftImpl(t3, true);
  }, o2.prototype.fftImpl = function(t3, e2) {
    var n2 = this.texData.get(t3.dataId), r2 = new Ja(Ya, t3.shape, e2), o3 = new Ja(Qa, t3.shape, e2), a2 = [this.makeComplexComponentTensorInfo(t3, n2.complexTensors.real), this.makeComplexComponentTensorInfo(t3, n2.complexTensors.imag)], i2 = this.compileAndRun(r2, a2), u2 = this.compileAndRun(o3, a2), s2 = this.complex(i2, u2).as2D(t3.shape[0], t3.shape[1]);
    return i2.dispose(), u2.dispose(), s2;
  }, o2.prototype.gatherND = function(t3, e2) {
    var n2 = e2.shape, r2 = n2[n2.length - 1], o3 = Ur(t3, e2), a2 = o3[0], i2 = o3[1], u2 = o3[2], s2 = o3[3], c2 = e2.reshape([i2, r2]), l2 = t3.reshape([t3.size / u2, u2]), h2 = new ri(r2, s2, [i2, u2]);
    return this.compileAndRun(h2, [l2, c2]).reshape(a2);
  }, o2.prototype.fill = function(t3, e2, n2) {
    if ("string" === (n2 = n2 || z(e2))) {
      var r2 = F(n2, w(t3));
      return r2.fill(e2), Nt.makeTensor(r2, t3, n2, this);
    }
    var o3 = new Za(t3, e2), a2 = o3.getCustomSetupFunc(e2);
    return this.compileAndRun(o3, [], n2, a2);
  }, o2.prototype.onesLike = function(t3) {
    if ("string" === t3.dtype)
      throw new Error("onesLike is not supported under string dtype");
    return this.fill(t3.shape, 1, t3.dtype);
  }, o2.prototype.zerosLike = function(t3) {
    return this.fill(t3.shape, "string" === t3.dtype ? "" : 0, t3.dtype);
  }, o2.prototype.linspace = function(t3, e2, n2) {
    return Do(t3, e2, n2);
  }, o2.prototype.makeTensorInfo = function(t3, e2) {
    var n2 = this.write(null, t3, e2);
    return this.texData.get(n2).usage = null, {dataId: n2, shape: t3, dtype: e2};
  }, o2.prototype.makeOutput = function(t3, e2) {
    var n2 = this.makeTensorInfo(t3, e2).dataId;
    return Nt.makeTensorFromDataId(n2, t3, e2, this);
  }, o2.prototype.unpackTensor = function(t3) {
    var e2 = new Mu(t3.shape);
    return this.runWebGLProgram(e2, [t3], t3.dtype);
  }, o2.prototype.packTensor = function(t3) {
    var e2 = new Oi(t3.shape);
    return this.runWebGLProgram(e2, [t3], t3.dtype, null, true);
  }, o2.prototype.packedReshape = function(t3, e2) {
    var n2 = [Ce(t3.shape)].concat(Ee(t3.shape)), r2 = {dtype: t3.dtype, shape: n2, dataId: t3.dataId}, o3 = [Ce(e2)].concat(Ee(e2)), a2 = new Wi(o3, n2), i2 = this.runWebGLProgram(a2, [r2], t3.dtype, null, true);
    return {dataId: i2.dataId, shape: e2, dtype: i2.dtype};
  }, o2.prototype.decode = function(t3) {
    var e2, n2 = this.texData.get(t3), r2 = n2.isPacked, o3 = n2.shape, a2 = n2.dtype, i2 = Re(o3);
    e2 = r2 ? new Ga(i2) : new za(i2);
    return {dtype: a2, shape: o3, dataId: this.runWebGLProgram(e2, [{shape: i2, dtype: a2, dataId: t3}], a2, null, true).dataId};
  }, o2.prototype.runWebGLProgram = function(t3, e2, n2, r2, o3) {
    var i2 = this;
    void 0 === o3 && (o3 = false);
    var u2 = this.makeTensorInfo(t3.outputShape, n2), s2 = this.texData.get(u2.dataId);
    if (t3.packedOutput && (s2.isPacked = true), t3.outPackingScheme === _t.DENSE) {
      var c2 = Gt(t3.outputShape);
      s2.texShape = c2.map(function(t4) {
        return 2 * t4;
      });
    }
    if (null != t3.outTexUsage && (s2.usage = t3.outTexUsage), 0 === w(u2.shape))
      return s2.values = N(u2.dtype, 0), u2;
    var l2 = [], h2 = e2.map(function(e3) {
      if ("complex64" === e3.dtype)
        throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
      var n3 = i2.texData.get(e3.dataId);
      if (null == n3.texture) {
        if (!t3.packedInputs && w(e3.shape) <= a().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))
          return {shape: e3.shape, texData: null, isUniform: true, uniformValues: n3.values};
        t3.packedInputs && (n3.isPacked = true, n3.shape = e3.shape);
      } else if (!!n3.isPacked != !!t3.packedInputs)
        e3 = n3.isPacked ? i2.unpackTensor(e3) : i2.packTensor(e3), l2.push(e3), n3 = i2.texData.get(e3.dataId);
      else if (n3.isPacked && !Se(n3.shape, e3.shape)) {
        var r3 = e3, o4 = e3.shape;
        e3.shape = n3.shape, e3 = i2.packedReshape(e3, o4), l2.push(e3), n3 = i2.texData.get(e3.dataId), r3.shape = o4;
      }
      return i2.uploadToGPU(e3.dataId), {shape: e3.shape, texData: n3, isUniform: false};
    });
    this.uploadToGPU(u2.dataId);
    var f2, p2 = {shape: u2.shape, texData: s2, isUniform: false}, d2 = function(t4, e3, n3) {
      var r3 = "";
      e3.concat(n3).forEach(function(t5) {
        var e4 = null != t5.texData && null != t5.texData.slice && t5.texData.slice.flatOffset > 0, n4 = t5.isUniform ? "uniform" : t5.texData.texShape;
        r3 += t5.shape + "_" + n4 + "_" + e4;
      });
      var o4 = t4.userCode, a2 = t4.constructor.name;
      return a2 += "_" + r3 + "_" + o4;
    }(t3, h2, p2), v2 = this.getAndSaveBinary(d2, function() {
      return function(t4, e3, n3, r3) {
        var o4 = e3.userCode, i3 = n3.map(function(t5, n4) {
          var r4 = {logicalShape: t5.shape, texShape: t5.isUniform ? null : t5.texData.texShape, isUniform: t5.isUniform, isPacked: !t5.isUniform && t5.texData.isPacked, flatOffset: null};
          return null != t5.texData && null != t5.texData.slice && t5.texData.slice.flatOffset > 0 && (r4.flatOffset = t5.texData.slice.flatOffset), {name: e3.variableNames[n4], shapeInfo: r4};
        }), u3 = i3.map(function(t5) {
          return t5.shapeInfo;
        }), s3 = {logicalShape: r3.shape, texShape: r3.texData.texShape, isUniform: false, isPacked: r3.texData.isPacked, flatOffset: null}, c3 = Yo(i3, s3, o4, e3.packedInputs), l3 = t4.createProgram(c3), h3 = null, f3 = t4.getUniformLocation(l3, "NAN", false);
        1 === a().getNumber("WEBGL_VERSION") && (h3 = t4.getUniformLocation(l3, "INFINITY", false));
        for (var p3 = {}, d3 = 0; d3 < e3.variableNames.length; d3++) {
          var v3 = e3.variableNames[d3];
          p3[v3] = t4.getUniformLocation(l3, v3, false), p3["offset" + v3] = t4.getUniformLocation(l3, "offset" + v3, false);
        }
        return {program: e3, source: c3, webGLProgram: l3, uniformLocations: p3, inShapeInfos: u3, outShapeInfo: s3, infLoc: h3, nanLoc: f3};
      }(i2.gpgpu, t3, h2, p2);
    }), m2 = null != this.activeTimers;
    if (m2 && (f2 = this.startTimer()), function(t4, e3, n3, r3, o4) {
      Ei(e3.inShapeInfos, n3), Ei([e3.outShapeInfo], [r3]);
      var i3 = r3.texData.texture, u3 = r3.texData.texShape;
      r3.texData.isPacked ? t4.setOutputPackedMatrixTexture(i3, u3[0], u3[1]) : t4.setOutputMatrixTexture(i3, u3[0], u3[1]), t4.setProgram(e3.webGLProgram), 1 === a().getNumber("WEBGL_VERSION") && null !== e3.infLoc && t4.gl.uniform1f(e3.infLoc, 1 / 0), null !== e3.nanLoc && t4.gl.uniform1f(e3.nanLoc, NaN), n3.forEach(function(n4, r4) {
        var o5 = e3.program.variableNames[r4], a2 = e3.uniformLocations[o5], i4 = e3.uniformLocations["offset" + o5];
        if (null != a2)
          if (n4.isUniform)
            if (w(n4.shape) < 2)
              t4.gl.uniform1f(a2, n4.uniformValues[0]);
            else {
              var u4 = n4.uniformValues;
              u4 instanceof Float32Array || (u4 = new Float32Array(u4)), t4.gl.uniform1fv(a2, u4);
            }
          else
            null != n4.texData.slice && null != i4 && t4.gl.uniform1i(i4, n4.texData.slice.flatOffset), t4.setInputMatrixTexture(n4.texData.texture, a2, r4);
      }), null != o4 && o4(t4, e3.webGLProgram), t4.executeProgram();
    }(this.gpgpu, v2, h2, p2, r2), l2.forEach(function(t4) {
      return i2.disposeData(t4.dataId);
    }), m2 && (f2 = this.endTimer(f2), this.activeTimers.push({name: t3.constructor.name, query: this.getQueryTime(f2)})), !a().getBool("WEBGL_LAZILY_UNPACK") && s2.isPacked && false === o3) {
      var g2 = this.unpackTensor(u2);
      return this.disposeData(u2.dataId), g2;
    }
    return u2;
  }, o2.prototype.compileAndRun = function(t3, e2, n2, r2, o3) {
    void 0 === o3 && (o3 = false), n2 = n2 || e2[0].dtype;
    var a2 = this.runWebGLProgram(t3, e2, n2, r2, o3);
    return Nt.makeTensorFromDataId(a2.dataId, a2.shape, a2.dtype);
  }, o2.prototype.getAndSaveBinary = function(t3, e2) {
    return t3 in this.binaryCache || (this.binaryCache[t3] = e2()), this.binaryCache[t3];
  }, o2.prototype.getTextureManager = function() {
    return this.textureManager;
  }, o2.prototype.dispose = function() {
    this.disposed || (this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, null != this.fromPixels2DContext && this.fromPixels2DContext.canvas.remove && this.fromPixels2DContext.canvas.remove(), this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = true);
  }, o2.prototype.floatPrecision = function() {
    var t3 = this;
    return null == this.floatPrecisionValue && (this.floatPrecisionValue = je(function() {
      if (!a().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
        var e2 = a().getBool("DEBUG");
        a().set("DEBUG", false);
        var n2 = t3.abs(An(1e-8)).dataSync()[0];
        if (a().set("DEBUG", e2), n2 > 0)
          return 32;
      }
      return 16;
    })), this.floatPrecisionValue;
  }, o2.prototype.epsilon = function() {
    return 32 === this.floatPrecision() ? 1e-7 : 1e-4;
  }, o2.prototype.uploadToGPU = function(t3) {
    var e2, n2 = this.texData.get(t3), r2 = n2.shape, o3 = n2.dtype, a2 = n2.values, i2 = n2.texture, u2 = n2.usage, s2 = n2.isPacked;
    if (null == i2) {
      var c2, l2 = null != this.activeTimers;
      l2 && (c2 = Y());
      var h2 = n2.texShape;
      if (null == h2 && (h2 = Ie(r2, s2), n2.texShape = h2), null != a2) {
        var f2 = Re(r2), p2 = void 0, d2 = h2[1], v2 = h2[0], m2 = a2 instanceof Uint8Array;
        s2 ? (d2 = (e2 = Ht(h2[0], h2[1]))[0], v2 = e2[1], p2 = new $a(f2, [v2, d2], m2)) : p2 = new Xa(f2, [v2, d2], m2);
        var g2 = this.makeTensorInfo([v2, d2], o3);
        this.texData.get(g2.dataId).usage = m2 ? Mt.PIXELS : Mt.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(g2.dataId), d2, v2, a2);
        var y2 = this.runWebGLProgram(p2, [g2], o3, null, true), x2 = this.texData.get(y2.dataId);
        n2.texture = x2.texture, n2.texShape = x2.texShape, n2.isPacked = x2.isPacked, n2.usage = x2.usage, this.disposeData(g2.dataId), this.texData.delete(y2.dataId), n2.values = null, l2 && (this.uploadWaitMs += Y() - c2);
      } else {
        var b2 = this.acquireTexture(h2, u2, o3, s2);
        n2.texture = b2;
      }
    }
  }, o2.prototype.convertAndCacheOnCPU = function(t3, e2) {
    var n2 = this.texData.get(t3), r2 = n2.dtype;
    return this.releaseGPUData(t3), null != e2 && (n2.values = function(t4, e3) {
      if ("float32" === e3 || "complex64" === e3)
        return t4;
      if ("int32" === e3 || "bool" === e3) {
        for (var n3 = "int32" === e3 ? new Int32Array(t4.length) : new Uint8Array(t4.length), r3 = 0; r3 < n3.length; ++r3)
          n3[r3] = Math.round(t4[r3]);
        return n3;
      }
      throw new Error("Unknown dtype " + e3);
    }(e2, r2)), n2.values;
  }, o2.prototype.acquireTexture = function(t3, e2, n2, r2) {
    if (this.numBytesInGPU += this.computeBytes(t3, n2), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
      var o3 = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
      this.warnedAboutMemory = true, console.warn("High memory usage in GPU: " + o3 + " MB, most likely due to a memory leak");
    }
    return this.textureManager.acquireTexture(t3, e2, r2);
  }, o2.prototype.computeBytes = function(t3, e2) {
    return t3[0] * t3[1] * P(e2);
  }, o2;
}(co);
Ft() && Nt.registerBackend("webgl", function() {
  return new Wu();
}, 2);
var Uu = Cn({square_: function(t2) {
  var e2 = ln(t2, "x", "square"), n2 = [e2];
  return Nt.runKernelFunc(function(t3, n3) {
    return n3([e2]), t3.square(e2);
  }, {x: e2}, function(t3, e3) {
    var n3 = e3[0];
    return {x: function() {
      return t3.mul(n3.toFloat().mul(2));
    }};
  }, "Square", {}, n2, []);
}});
var Vu = Cn({abs_: function(t2) {
  var e2 = ln(t2, "x", "abs");
  return "complex64" === e2.dtype ? Nt.runKernelFunc(function(t3) {
    return t3.complexAbs(e2);
  }, {$x: e2}) : Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.abs(e2);
    return n2([e2]), r2;
  }, {x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {x: function() {
      return t3.mul(n2.toFloat().step(-1));
    }};
  }, "Abs");
}});
var zu = Cn({acos_: function(t2) {
  var e2 = ln(t2, "x", "acos");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.acos(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.divStrict(An(1).sub(n2.toFloat().square()).sqrt()).neg();
    }};
  });
}});
var Gu = Cn({acosh_: function(t2) {
  var e2 = ln(t2, "x", "acosh");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.acosh(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.divStrict(n2.toFloat().square().sub(1).sqrt());
    }};
  });
}});
var Hu = Cn({asin_: function(t2) {
  var e2 = ln(t2, "x", "asin");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.asin(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.divStrict(An(1).sub(n2.toFloat().square()).sqrt());
    }};
  });
}});
var qu = Cn({asinh_: function(t2) {
  var e2 = ln(t2, "x", "asinh");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.asinh(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.divStrict(An(1).add(n2.toFloat().square()).sqrt());
    }};
  });
}});
var Ku = Cn({atan_: function(t2) {
  var e2 = ln(t2, "x", "atan");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.atan(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.div(n2.toFloat().square().add(1));
    }};
  });
}});
var ju = Cn({atanh_: function(t2) {
  var e2 = ln(t2, "x", "atanh");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.atanh(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.div(An(1).sub(n2.toFloat().square()));
    }};
  });
}});
var Xu = Cn({ceil_: function(t2) {
  var e2 = ln(t2, "x", "ceil");
  return Nt.runKernelFunc(function(t3) {
    return t3.ceil(e2);
  }, {$x: e2}, function(t3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var $u = Cn({clipByValue_: function(t2, e2, n2) {
  var r2 = ln(t2, "x", "clipByValue");
  return g(e2 <= n2, function() {
    return "Error in clip: min (" + e2 + ") must be less than or equal to max (" + n2 + ").";
  }), Nt.runKernelFunc(function(t3, o2) {
    var a2 = t3.clip(r2, e2, n2);
    return o2([r2]), a2;
  }, {$x: r2}, function(t3, r3) {
    var o2 = r3[0];
    return {$x: function() {
      return t3.where(o2.greaterEqual(e2).logicalAnd(o2.lessEqual(n2)), zn(t3));
    }};
  });
}});
var Yu = Cn({cos_: function(t2) {
  var e2 = ln(t2, "x", "cos");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.cos(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return n2.toFloat().sin().neg().mul(t3);
    }};
  });
}});
var Qu = Cn({cosh_: function(t2) {
  var e2 = ln(t2, "x", "cosh");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.cosh(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return n2.toFloat().sinh().mulStrict(t3);
    }};
  });
}});
var Ju = Cn({erf_: function(t2) {
  var e2 = ln(t2, "x", "erf");
  return g("int32" === e2.dtype || "float32" === e2.dtype, function() {
    return "Input dtype must be `int32` or `float32`.";
  }), "int32" === e2.dtype && (e2 = e2.toFloat()), Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.erf(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.mul(n2.square().neg().exp().mul(2 / Math.sqrt(Math.PI)));
    }};
  });
}});
var Zu = Cn({exp_: function(t2) {
  var e2 = ln(t2, "x", "exp");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.exp(e2);
    return n2([r2]), r2;
  }, {$x: e2}, function(t3, e3) {
    return {$x: function() {
      return t3.mulStrict(e3[0]);
    }};
  });
}});
var ts = Cn({expm1_: function(t2) {
  var e2 = ln(t2, "x", "expm1");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.expm1(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.mul(n2.exp());
    }};
  });
}});
var es = Cn({floor_: function(t2) {
  var e2 = ln(t2, "x", "floor");
  return Nt.runKernelFunc(function(t3) {
    return t3.floor(e2);
  }, {$x: e2}, function(t3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var ns = Cn({log_: function(t2) {
  var e2 = ln(t2, "x", "log");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.log(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.div(n2.toFloat());
    }};
  });
}});
var rs = Cn({log1p_: function(t2) {
  var e2 = ln(t2, "x", "log1p");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.log1p(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.div(n2.add(1));
    }};
  });
}});
var os = Cn({logSigmoid_: function(t2) {
  var e2 = ln(t2, "x", "logSigmoid");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.softplus(e2.neg()).neg();
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.mul(n2.neg().sigmoid());
    }};
  });
}});
var as = Cn({neg_: function(t2) {
  var e2 = ln(t2, "x", "neg");
  return Nt.runKernelFunc(function(t3) {
    return t3.neg(e2);
  }, {$x: e2}, function(t3) {
    return {$x: function() {
      return t3.neg();
    }};
  });
}});
var is = Cn({reciprocal_: function(t2) {
  var e2 = ln(t2, "x", "reciprocal");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.reciprocal(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.div(n2.square().neg());
    }};
  });
}});
var us = Cn({round_: function(t2) {
  var e2 = ln(t2, "x", "round");
  return Nt.runKernelFunc(function(t3) {
    return t3.round(e2);
  }, {$x: e2}, function(t3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var ss = Cn({rsqrt_: function(t2) {
  var e2 = ln(t2, "x", "rsqrt");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.rsqrt(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.div(n2.pow(1.5).mul(2)).neg();
    }};
  });
}});
var cs = Cn({sigmoid_: function(t2) {
  var e2 = ln(t2, "x", "sigmoid");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.sigmoid(e2);
    return n2([r2]), r2;
  }, {x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {x: function() {
      return t3.mul(n2.mul(An(1).sub(n2)));
    }};
  }, "Sigmoid");
}});
var ls = Cn({sign_: function(t2) {
  var e2 = ln(t2, "x", "sign");
  return Nt.runKernelFunc(function(t3) {
    return t3.sign(e2);
  }, {$x: e2}, function(t3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var hs = Cn({isNaN_: function(t2) {
  var e2 = ln(t2, "x", "isNaN");
  return Nt.runKernelFunc(function(t3) {
    return t3.isNaN(e2);
  }, {$x: e2}, function(t3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var fs = Cn({isInf_: function(t2) {
  var e2 = ln(t2, "x", "isInf");
  return Nt.runKernelFunc(function(t3) {
    return t3.isInf(e2);
  }, {$x: e2}, function(t3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var ps = Cn({isFinite_: function(t2) {
  var e2 = ln(t2, "x", "isFinite");
  return Nt.runKernelFunc(function(t3) {
    return t3.isFinite(e2);
  }, {$x: e2}, function(t3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var ds = Cn({sin_: function(t2) {
  var e2 = ln(t2, "x", "sin");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.sin(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return n2.toFloat().cos().mul(t3);
    }};
  });
}});
var vs = Cn({sinh_: function(t2) {
  var e2 = ln(t2, "x", "sinh");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.sinh(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return n2.toFloat().cosh().mulStrict(t3);
    }};
  });
}});
var ms = Cn({softplus_: function(t2) {
  var e2 = ln(t2, "x", "softplus");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.softplus(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.mul(n2.sigmoid());
    }};
  });
}});
var gs = Cn({sqrt_: function(t2) {
  var e2 = ln(t2, "x", "sqrt");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.sqrt(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.div(n2.toFloat().sqrt().mul(2));
    }};
  });
}});
var ys = Cn({step_: function(t2, e2) {
  void 0 === e2 && (e2 = 0);
  var n2 = ln(t2, "x", "step");
  return Nt.runKernelFunc(function(t3) {
    return t3.step(n2, e2);
  }, {$x: n2}, function(t3) {
    return {$x: function() {
      return zn(t3);
    }};
  });
}});
var xs = Cn({tan_: function(t2) {
  var e2 = ln(t2, "x", "tan");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.tan(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.div(n2.cos().square());
    }};
  });
}});
var bs = Cn({tanh_: function(t2) {
  var e2 = ln(t2, "x", "tanh");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.tanh(e2);
    return n2([r2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return An(1).sub(n2.square()).mulStrict(t3);
    }};
  });
}});
function ws(t2, e2, n2, r2, o2, a2) {
  var i2, u2, s2 = ln(t2, "x", "batchNorm"), c2 = ln(e2, "mean", "batchNorm"), l2 = ln(n2, "variance", "batchNorm");
  return null != o2 && (i2 = ln(o2, "scale", "batchNorm")), null != r2 && (u2 = ln(r2, "offset", "batchNorm")), g(2 === s2.rank, function() {
    return "Error in batchNorm3D: x must be rank 3 but got rank " + s2.rank + ".";
  }), g(2 === c2.rank || 1 === c2.rank, function() {
    return "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank " + c2.rank + ".";
  }), g(2 === l2.rank || 1 === l2.rank, function() {
    return "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank " + l2.rank + ".";
  }), null != i2 && g(2 === i2.rank || 1 === i2.rank, function() {
    return "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank " + i2.rank + ".";
  }), null != u2 && g(2 === u2.rank || 1 === u2.rank, function() {
    return "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank " + u2.rank + ".";
  }), Rs(s2, c2, l2, u2, i2, a2);
}
function Cs(t2, e2, n2, r2, o2, a2) {
  var i2, u2, s2 = ln(t2, "x", "batchNorm"), c2 = ln(e2, "mean", "batchNorm"), l2 = ln(n2, "variance", "batchNorm");
  return null != o2 && (i2 = ln(o2, "scale", "batchNorm")), null != r2 && (u2 = ln(r2, "offset", "batchNorm")), g(3 === s2.rank, function() {
    return "Error in batchNorm3D: x must be rank 3 but got rank " + s2.rank + ".";
  }), g(3 === c2.rank || 1 === c2.rank, function() {
    return "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank " + c2.rank + ".";
  }), g(3 === l2.rank || 1 === l2.rank, function() {
    return "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank " + l2.rank + ".";
  }), null != i2 && g(3 === i2.rank || 1 === i2.rank, function() {
    return "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank " + i2.rank + ".";
  }), null != u2 && g(3 === u2.rank || 1 === u2.rank, function() {
    return "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank " + u2.rank + ".";
  }), Rs(s2, c2, l2, u2, i2, a2);
}
function Es(t2, e2, n2, r2, o2, a2) {
  var i2, u2, s2 = ln(t2, "x", "batchNorm"), c2 = ln(e2, "mean", "batchNorm"), l2 = ln(n2, "variance", "batchNorm");
  return null != o2 && (i2 = ln(o2, "scale", "batchNorm")), null != r2 && (u2 = ln(r2, "offset", "batchNorm")), g(4 === s2.rank, function() {
    return "Error in batchNorm4D: x must be rank 4 but got rank " + s2.rank + ".";
  }), g(4 === c2.rank || 1 === c2.rank, function() {
    return "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank " + c2.rank + ".";
  }), g(4 === l2.rank || 1 === l2.rank, function() {
    return "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank " + l2.rank + ".";
  }), null != i2 && g(4 === i2.rank || 1 === i2.rank, function() {
    return "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank " + i2.rank + ".";
  }), null != u2 && g(4 === u2.rank || 1 === u2.rank, function() {
    return "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank " + u2.rank + ".";
  }), Rs(s2, c2, l2, u2, i2, a2);
}
function Rs(t2, e2, n2, r2, o2, a2) {
  null == a2 && (a2 = 1e-3);
  var i2, u2, s2, c2 = ln(t2, "x", "batchNorm"), l2 = ln(e2, "mean", "batchNorm"), h2 = ln(n2, "variance", "batchNorm");
  null != o2 && (i2 = ln(o2, "scale", "batchNorm")), null != r2 && (u2 = ln(r2, "offset", "batchNorm")), g(l2.rank === h2.rank, function() {
    return "Batch normalization gradient requires mean and variance to have equal ranks.";
  }), g(null == u2 || l2.rank === u2.rank, function() {
    return "Batch normalization gradient requires mean and offset to have equal ranks.";
  }), g(null == i2 || l2.rank === i2.rank, function() {
    return "Batch normalization gradient requires mean and scale to have equal ranks.";
  }), s2 = 0 === c2.rank || 1 === c2.rank ? c2.as4D(1, 1, 1, c2.size) : 2 === c2.rank ? c2.as4D(1, 1, c2.shape[0], c2.shape[1]) : 3 === c2.rank ? c2.as4D(1, c2.shape[0], c2.shape[1], c2.shape[2]) : c2;
  var f2 = [c2, l2, h2, i2];
  return Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.batchNormalization(s2, Is(l2), Is(h2), a2, Is(i2), Is(u2));
    return e3([c2, l2, h2, i2]), n3;
  }, {x: c2, mean: l2, variance: h2, scale: i2, offset: u2}, function(t3, e3) {
    var n3 = e3, r3 = n3[0], o3 = n3[1], i3 = n3[2], u3 = n3[3], c3 = null == u3 ? An(1) : u3, l3 = fo(o3.shape, s2.shape), h3 = [];
    if (1 === o3.rank) {
      for (var f3 = 0; f3 < s2.shape.length - 1; ++f3)
        h3.push(s2.shape[f3]);
      h3.push(1);
    }
    var p2 = r3.sub(o3), d2 = t3.mul(c3), v2 = ss(i3.add(An(a2))), m2 = v2.mul(v2).mul(v2).mul(An(-0.5));
    return {x: function() {
      return 1 === o3.rank ? t3.mul(Nr(v2.as4D(1, 1, 1, o3.shape[0]), h3)).mul(c3).reshape(r3.shape) : t3.mul(v2).mul(c3).reshape(r3.shape);
    }, mean: function() {
      var t4 = v2.mul(An(-1)).mul(d2);
      return 1 === o3.rank && (t4 = t4.sum(l3)), t4.reshape(o3.shape);
    }, variance: function() {
      var t4 = m2.mul(p2).mul(d2);
      return 1 === o3.rank && (t4 = t4.sum(l3)), t4.reshape(o3.shape);
    }, scale: function() {
      var e4 = p2.mul(v2), n4 = t3.mul(e4);
      return 1 === o3.rank && (n4 = n4.sum(l3)), n4.reshape(o3.shape);
    }, offset: function() {
      var e4 = t3;
      return 1 === o3.rank && (e4 = e4.sum(l3)), e4.reshape(o3.shape);
    }};
  }, "BatchNormalization", {varianceEpsilon: a2}, f2).reshape(c2.shape);
}
function Is(t2) {
  return null == t2 ? null : 0 === t2.rank ? t2.as1D() : 1 === t2.rank ? t2 : 2 === t2.rank ? t2.as4D(1, 1, t2.shape[0], t2.shape[1]) : 3 === t2.rank ? t2.as4D(1, t2.shape[0], t2.shape[1], t2.shape[2]) : t2;
}
function ks() {
  ze("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon");
}
var Ss = Cn({batchNormalization2d_: function(t2, e2, n2, r2, o2, a2) {
  return void 0 === r2 && (r2 = 1e-3), ks(), ws(t2, e2, n2, a2, o2, r2);
}});
var As = Cn({batchNormalization3d_: function(t2, e2, n2, r2, o2, a2) {
  return void 0 === r2 && (r2 = 1e-3), ks(), Cs(t2, e2, n2, a2, o2, r2);
}});
var Ds = Cn({batchNormalization4d_: function(t2, e2, n2, r2, o2, a2) {
  return void 0 === r2 && (r2 = 1e-3), ks(), Es(t2, e2, n2, a2, o2, r2);
}});
var Ts = Cn({batchNormalization_: function(t2, e2, n2, r2, o2, a2) {
  return void 0 === r2 && (r2 = 1e-3), ks(), Rs(t2, e2, n2, a2, o2, r2);
}});
var Ns = Cn({batchNorm_: Rs});
var Fs = Cn({batchNorm2d_: ws});
var Os = Cn({batchNorm3d_: Cs});
var _s = Cn({batchNorm4d_: Es});
var Ms = Cn({logicalAnd_: function(t2, e2) {
  var n2 = ln(t2, "a", "logicalAnd", "bool"), r2 = ln(e2, "b", "logicalAnd", "bool");
  return po(n2.shape, r2.shape), Nt.runKernelFunc(function(t3) {
    return t3.logicalAnd(n2, r2);
  }, {$a: n2, $b: r2});
}});
var Bs = Cn({logicalNot_: function(t2) {
  var e2 = ln(t2, "x", "logicalNot", "bool");
  return Nt.runKernelFunc(function(t3) {
    return t3.logicalNot(e2);
  }, {$x: e2});
}});
var Ps = Cn({logicalOr_: function(t2, e2) {
  var n2 = ln(t2, "a", "logicalOr", "bool"), r2 = ln(e2, "b", "logicalOr", "bool");
  return po(n2.shape, r2.shape), Nt.runKernelFunc(function(t3) {
    return t3.logicalOr(n2, r2);
  }, {$a: n2, $b: r2});
}});
var Ls = Cn({logicalXor_: function(t2, e2) {
  var n2 = ln(t2, "a", "logicalXor", "bool"), r2 = ln(e2, "b", "logicalXor", "bool");
  return po(n2.shape, r2.shape), Ps(t2, e2).logicalAnd(Ms(t2, e2).logicalNot());
}});
var Ws = Cn({where_: function(t2, e2, n2) {
  var r2 = ln(e2, "a", "where"), o2 = ln(n2, "b", "where"), a2 = ln(t2, "condition", "where", "bool");
  return y(r2.shape, o2.shape, "Error in where: "), 1 === a2.rank ? g(a2.shape[0] === r2.shape[0], function() {
    return "The first dimension of `a` must match the size of `condition`.";
  }) : y(a2.shape, o2.shape, "Error in where: "), Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.select(a2, r2, o2);
    return e3([a2]), n3;
  }, {$condition: a2, $a: r2, $b: o2}, function(t3, e3) {
    var n3 = e3[0];
    return {$condition: function() {
      return zn(n3).toFloat();
    }, $a: function() {
      return t3.mul(n3.cast(t3.dtype));
    }, $b: function() {
      return t3.mul(n3.logicalNot().cast(t3.dtype));
    }};
  });
}});
var Us = function(t2) {
  return n(this, void 0, void 0, function() {
    var e2, n2, o2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          return [4, (e2 = ln(t2, "condition", "whereAsync", "bool")).data()];
        case 1:
          return n2 = r2.sent(), o2 = Uo(e2.shape, n2), t2 !== e2 && e2.dispose(), [2, o2];
      }
    });
  });
};
var Vs = Cn({add_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "add"), o2 = ln(e2, "b", "add");
  n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1];
  var a2 = po(r2.shape, o2.shape);
  return Nt.runKernelFunc(function(t3) {
    return t3.add(r2, o2);
  }, {a: r2, b: o2}, function(t3) {
    return {a: function() {
      var e3 = t3, n3 = fo(r2.shape, a2);
      return n3.length > 0 && (e3 = e3.sum(n3)), e3.reshape(r2.shape);
    }, b: function() {
      var e3 = t3, n3 = fo(o2.shape, a2);
      return n3.length > 0 && (e3 = e3.sum(n3)), e3.reshape(o2.shape);
    }};
  }, "Add");
}});
var zs = Cn({addN_: function(t2) {
  g(Array.isArray(t2), function() {
    return "The argument passed to tf.addN() must be a list of tensors";
  }), g(t2.length >= 1, function() {
    return "Must pass at least one tensor to tf.addN(), but got " + t2.length;
  });
  var e2 = t2.map(function(t3, e3) {
    return ln(t3, "tensors" + e3, "addN");
  }), n2 = e2[0];
  e2.forEach(function(t3) {
    if (t3.dtype !== n2.dtype)
      throw new Error("All tensors passed to tf.addN() must have the same dtype");
  }), e2.forEach(function(t3) {
    if (!C(t3.shape, n2.shape))
      throw new Error("All tensors passed to tf.addN() must have the same shape");
  });
  var r2 = e2;
  return Nt.runKernelFunc(function(t3) {
    return t3.addN(e2);
  }, r2, function(t3) {
    var n3 = {};
    return e2.forEach(function(e3, r3) {
      n3[r3] = function() {
        return t3.clone();
      };
    }), n3;
  });
}});
var Gs = Cn({addStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "addStrict"), r2 = ln(e2, "b", "addStrict");
  return y(n2.shape, r2.shape, "Error in addStrict: "), n2.add(r2);
}});
var Hs = Cn({atan2_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "atan2"), o2 = ln(e2, "b", "atan2");
  n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1];
  var a2 = po(r2.shape, o2.shape);
  return Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.atan2(r2, o2);
    return e3([r2, o2]), n3;
  }, {$a: r2, $b: o2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1];
    return {$a: function() {
      var e4 = Vs(n3.square(), r3.square()), o3 = t3.mul(r3.div(e4)), i2 = fo(n3.shape, a2);
      return i2.length > 0 && (o3 = o3.sum(i2)), o3.reshape(n3.shape);
    }, $b: function() {
      var e4 = Vs(n3.square(), r3.square()), o3 = as(t3.mul(n3.div(e4))), i2 = fo(r3.shape, a2);
      return i2.length > 0 && (o3 = o3.sum(i2)), o3.reshape(r3.shape);
    }};
  });
}});
var qs = Cn({div_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "div"), o2 = ln(e2, "b", "div");
  if (n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], "int32" === r2.dtype && "int32" === o2.dtype)
    return Xs(r2, o2);
  var a2 = po(r2.shape, o2.shape);
  return Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.realDivide(r2, o2);
    return e3([r2, o2]), n3;
  }, {a: r2, b: o2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1];
    return {a: function() {
      var e4 = t3.div(r3.toFloat()), o3 = fo(n3.shape, a2);
      return o3.length > 0 ? e4.sum(o3).reshape(n3.shape) : e4;
    }, b: function() {
      var e4 = t3.mul(n3.toFloat()), o3 = fo(r3.shape, a2);
      o3.length > 0 && (e4 = e4.sum(o3).reshape(r3.shape));
      var i2 = r3.square();
      return e4.div(i2.toFloat()).neg();
    }};
  }, "Div");
}});
var Ks = Cn({divNoNan_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "div"), o2 = ln(e2, "b", "div");
  r2 = (n2 = Rt(r2, o2))[0], o2 = n2[1];
  var a2 = qs(r2, o2), i2 = zn(a2), u2 = o2.equal(i2);
  return Ws(u2, i2, a2);
}});
var js = Cn({divStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "div"), r2 = ln(e2, "b", "div");
  return y(n2.shape, r2.shape, "Error in divideStrict: "), n2.div(r2);
}});
var Xs = Cn({floorDiv_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "floorDiv"), o2 = ln(e2, "b", "floorDiv");
  n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1];
  var a2 = po(r2.shape, o2.shape);
  return Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.floorDiv(r2, o2);
    return e3([r2, o2]), n3;
  }, {$a: r2, $b: o2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1];
    return {$a: function() {
      var e4 = t3.div(r3.toFloat()), o3 = fo(n3.shape, a2);
      return o3.length > 0 ? e4.sum(o3).reshape(n3.shape) : e4;
    }, $b: function() {
      var e4 = t3.mul(n3.toFloat()), o3 = fo(r3.shape, a2);
      o3.length > 0 && (e4 = e4.sum(o3).reshape(r3.shape));
      var i2 = r3.square();
      return e4.div(i2.toFloat()).neg();
    }};
  });
}});
var $s = Cn({maximum_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "maximum"), o2 = ln(e2, "b", "maximum");
  return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], "bool" === r2.dtype && (r2 = r2.toInt(), o2 = o2.toInt()), po(r2.shape, o2.shape), Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.maximum(r2, o2);
    return e3([r2, o2]), n3;
  }, {$a: r2, $b: o2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1];
    return {$a: function() {
      return t3.mul(n3.greaterEqual(r3).toFloat());
    }, $b: function() {
      return t3.mul(n3.less(r3).toFloat());
    }};
  });
}});
var Ys = Cn({maximumStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "maximumStrict"), r2 = ln(e2, "b", "maximumStrict");
  return y(n2.shape, r2.shape, "Error in maximumStrict: "), n2.maximum(r2);
}});
var Qs = Cn({minimum_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "minimum"), o2 = ln(e2, "b", "minimum");
  return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], "bool" === r2.dtype && (r2 = r2.toInt(), o2 = o2.toInt()), po(r2.shape, o2.shape), Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.minimum(r2, o2);
    return e3([r2, o2]), n3;
  }, {$a: r2, $b: o2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1];
    return {$a: function() {
      return t3.mul(n3.lessEqual(r3).toFloat());
    }, $b: function() {
      return t3.mul(n3.greater(r3).toFloat());
    }};
  });
}});
var Js = Cn({minimumStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "minimumStrict"), r2 = ln(e2, "b", "minimumStrict");
  return y(n2.shape, r2.shape, "Error in minimumStrict: "), n2.minimum(r2);
}});
var Zs = Cn({mod_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "mod"), o2 = ln(e2, "b", "mod");
  n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1];
  var a2 = po(r2.shape, o2.shape);
  return Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.mod(r2, o2);
    return e3([r2, o2]), n3;
  }, {$a: r2, $b: o2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1];
    return {$a: function() {
      var e4 = fo(n3.shape, a2);
      return e4.length > 0 ? t3.sum(e4).reshape(n3.shape) : t3;
    }, $b: function() {
      var e4 = t3.mul(n3.div(r3).floor().neg()), o3 = fo(r3.shape, a2);
      return o3.length > 0 ? e4.sum(o3).reshape(r3.shape) : e4;
    }};
  });
}});
var tc = Cn({modStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "modStrict"), r2 = ln(e2, "b", "modStrict");
  return y(n2.shape, r2.shape, "Error in modStrict: "), n2.mod(r2);
}});
var ec = Cn({mul_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "mul"), o2 = ln(e2, "b", "mul");
  n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1];
  var a2 = po(r2.shape, o2.shape);
  return Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.multiply(r2, o2);
    return e3([r2, o2]), n3;
  }, {a: r2, b: o2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1];
    return {a: function() {
      var e4 = t3.mul(r3.toFloat()), o3 = fo(n3.shape, a2);
      return o3.length > 0 ? e4.sum(o3).reshape(n3.shape) : e4;
    }, b: function() {
      var e4 = t3.mul(n3.toFloat()), o3 = fo(r3.shape, a2);
      return o3.length > 0 ? e4.sum(o3).reshape(r3.shape) : e4;
    }};
  }, "Mul");
}});
var nc = Cn({mulStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "mul"), r2 = ln(e2, "b", "mul");
  return y(n2.shape, r2.shape, "Error in multiplyStrict: "), n2.mul(r2);
}});
var rc = Cn({pow_: function(t2, e2) {
  var n2 = ln(t2, "base", "pow"), r2 = ln(e2, "exp", "pow"), o2 = po(n2.shape, r2.shape);
  return t2 = n2.cast(Ct(n2.dtype, r2.dtype)), e2 = r2.cast(Ct(n2.dtype, r2.dtype)), Nt.runKernelFunc(function(t3, e3) {
    var o3 = t3.pow(n2, r2);
    return e3([n2, r2, o3]), o3;
  }, {$base: n2, $exp: r2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1], a2 = e3[2];
    return {$base: function() {
      var e4 = r3.toFloat(), a3 = t3.mul(e4.mul(n3.pow(e4.sub(An(1))))), i2 = fo(n3.shape, o2);
      return i2.length > 0 && (a3 = a3.sum(i2)), a3.reshape(n3.shape);
    }, $exp: function() {
      var e4 = n3.greater(0), i2 = n3.log().where(e4, zn(n3)), u2 = t3.mul(a2.mul(i2)), s2 = fo(r3.shape, o2);
      return s2.length > 0 && (u2 = u2.sum(s2)), u2.reshape(r3.shape);
    }};
  });
}});
var oc = Cn({powStrict_: function(t2, e2) {
  return y(t2.shape, e2.shape, "Error in powStrict: "), t2.pow(e2);
}});
var ac = Cn({squaredDifference_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "squaredDifference"), o2 = ln(e2, "b", "squaredDifference");
  return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.squaredDifference(r2, o2);
    return e3([r2, o2]), n3;
  }, {$a: r2, $b: o2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1], o3 = An(2);
    return {$a: function() {
      return t3.mul(n3.sub(r3).mul(o3));
    }, $b: function() {
      return t3.mul(r3.sub(n3).mul(o3));
    }};
  });
}});
var ic = Cn({squaredDifferenceStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "squaredDifferenceStrict"), r2 = ln(e2, "b", "squaredDifferenceStrict");
  return y(n2.shape, r2.shape, "Error in squaredDifferenceStrict: "), n2.squaredDifference(r2);
}});
var uc = Cn({sub_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "sub"), o2 = ln(e2, "b", "sub");
  n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1];
  var a2 = po(r2.shape, o2.shape);
  return Nt.runKernelFunc(function(t3) {
    return t3.subtract(r2, o2);
  }, {a: r2, b: o2}, function(t3) {
    return {a: function() {
      var e3 = t3, n3 = fo(r2.shape, a2);
      return n3.length > 0 && (e3 = e3.sum(n3)), e3.reshape(r2.shape);
    }, b: function() {
      var e3 = t3, n3 = fo(o2.shape, a2);
      return n3.length > 0 && (e3 = e3.sum(n3)), e3.neg().reshape(o2.shape);
    }};
  }, "Sub");
}});
var sc = Cn({subStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "subStrict"), r2 = ln(e2, "b", "subStrict");
  return y(n2.shape, r2.shape, "Error in subStrict: "), n2.sub(r2);
}});
var cc = Cn({equal_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "equal"), o2 = ln(e2, "b", "equal");
  return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t3) {
    return t3.equal(r2, o2);
  }, {$a: r2, $b: o2});
}});
var lc = Cn({equalStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "equalStrict"), r2 = ln(e2, "b", "equalStrict");
  return y(n2.shape, r2.shape, "Error in equalStrict: "), n2.equal(r2);
}});
var hc = Cn({greater_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "greater"), o2 = ln(e2, "b", "greater");
  return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t3) {
    return t3.greater(r2, o2);
  }, {$a: r2, $b: o2});
}});
var fc = Cn({greaterEqual_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "greaterEqual"), o2 = ln(e2, "b", "greaterEqual");
  return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.greaterEqual(r2, o2);
    return e3([r2, o2]), n3;
  }, {$a: r2, $b: o2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1];
    return {$a: function() {
      return zn(n3);
    }, $b: function() {
      return zn(r3);
    }};
  });
}});
var pc = Cn({greaterEqualStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "greaterEqualStrict"), r2 = ln(e2, "b", "greaterEqualStrict");
  return y(n2.shape, r2.shape, "Error in greaterEqualStrict: "), n2.greaterEqual(r2);
}});
var dc = Cn({greaterStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "greaterStrict"), r2 = ln(e2, "b", "greaterStrict");
  return y(n2.shape, r2.shape, "Error in greaterStrict: "), n2.greater(r2);
}});
var vc = Cn({less_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "less"), o2 = ln(e2, "b", "less");
  return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t3) {
    return t3.less(r2, o2);
  }, {$a: r2, $b: o2});
}});
var mc = Cn({lessEqual_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "lessEqual"), o2 = ln(e2, "b", "lessEqual");
  return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t3) {
    return t3.lessEqual(r2, o2);
  }, {$a: r2, $b: o2});
}});
var gc = Cn({lessEqualStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "lessEqualStrict"), r2 = ln(e2, "b", "lessEqualStrict");
  return y(n2.shape, r2.shape, "Error in lessEqualStrict: "), n2.lessEqual(r2);
}});
var yc = Cn({lessStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "lessStrict"), r2 = ln(e2, "b", "lessStrict");
  return y(n2.shape, r2.shape, "Error in lessStrict: "), n2.less(r2);
}});
var xc = Cn({notEqual_: function(t2, e2) {
  var n2, r2 = ln(t2, "a", "notEqual"), o2 = ln(e2, "b", "notEqual");
  return n2 = Rt(r2, o2), r2 = n2[0], o2 = n2[1], po(r2.shape, o2.shape), Nt.runKernelFunc(function(t3) {
    return t3.notEqual(r2, o2);
  }, {$a: r2, $b: o2});
}});
var bc = Cn({notEqualStrict_: function(t2, e2) {
  var n2 = ln(t2, "a", "notEqualStrict"), r2 = ln(e2, "b", "notEqualStrict");
  return y(n2.shape, r2.shape, "Error in notEqualStrict: "), n2.notEqual(r2);
}});
function wc(t2, e2) {
  for (var n2 = [], r2 = t2; r2 < e2; ++r2)
    n2.push(r2);
  return n2;
}
function Cc(t2) {
  for (var e2 = [], n2 = 0; n2 < t2.length; ++n2)
    for (var r2 = 0; r2 < t2[n2].length; ++r2)
      e2.push(t2[n2][r2]);
  return e2;
}
var Ec = Cn({gather_: function(t2, e2, n2) {
  void 0 === n2 && (n2 = 0);
  var r2 = ln(t2, "x", "gather"), o2 = ln(e2, "indices", "gather", "int32");
  n2 = D(n2, r2.shape)[0];
  var a2 = function(t3, e3, n3) {
    for (var r3 = t3.shape[n3], o3 = [], a3 = 1, i2 = 1, u2 = 0; u2 < n3; u2++)
      o3.push(t3.shape[u2]), a3 *= t3.shape[u2];
    for (u2 = 0; u2 < e3.rank; u2++)
      o3.push(e3.shape[u2]);
    for (u2 = n3 + 1; u2 < t3.rank; u2++)
      o3.push(t3.shape[u2]), i2 *= t3.shape[u2];
    return {batchSize: a3, sliceSize: i2, dimSize: r3, outputShape: o3};
  }(r2, o2, n2);
  return Nt.runKernelFunc(function(t3, e3) {
    var a3 = t3.gather(r2, o2.flatten(), n2);
    return e3([o2]), a3;
  }, {$x: r2}, function(t3, e3) {
    var o3 = e3[0];
    return {$x: function() {
      var e4 = r2.shape, a3 = o3.size, i2 = e4.slice(0, n2), u2 = i2.length, s2 = e4.slice(n2, e4.length).slice(1), c2 = s2.length, l2 = wc(0, u2), h2 = wc(u2 + 1, u2 + 1 + c2), f2 = Cc([i2, [a3], s2]), p2 = t3.reshape(f2), d2 = o3.reshape([a3]), v2 = Cc([[u2], l2, h2]), m2 = p2.transpose(v2), g2 = Rc(m2, d2, r2.shape[n2]), y2 = yn(v2);
      return g2 = g2.transpose(y2);
    }};
  }).reshape(a2.outputShape);
}});
var Rc = Cn({unsortedSegmentSum_: function(t2, e2, n2) {
  var r2 = ln(t2, "x", "unsortedSegmentSum"), o2 = ln(e2, "segmentIds", "unsortedSegmentSum", "int32");
  return g(E(n2), function() {
    return "numSegments must be of dtype int";
  }), Nt.runKernelFunc(function(t3, e3) {
    var a2 = t3.unsortedSegmentSum(r2, o2, n2);
    return e3([o2]), a2;
  }, {$x: r2}, function(t3, e3) {
    var n3 = e3[0];
    return {$x: function() {
      return function(t4, e4) {
        for (var n4 = $s(e4, zn(e4)), r3 = Ec(t4, n4), o3 = fc(e4, An(0, "int32")), a2 = r3.rank - o3.rank, i2 = 0; i2 < a2; ++i2)
          o3 = dr(o3, i2 + 1);
        o3 = Ms(o3, Bn(r3.shape, "bool"));
        var u2 = zn(r3);
        return Ws(o3, r3, u2);
      }(t3, n3);
    }};
  });
}});
var Ic = function(t2, e2, o2) {
  return n(this, void 0, void 0, function() {
    var n2, a2, i2, u2, s2, c2, l2, h2, f2, p2, d2, v2, m2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          for (n2 = ln(t2, "tensor", "boolMask"), a2 = ln(e2, "mask", "boolMask", "bool"), i2 = null == o2 ? 0 : o2, u2 = a2.rank, s2 = n2.shape, g(u2 > 0, function() {
            return "mask cannot be scalar";
          }), y(s2.slice(i2, i2 + u2), a2.shape, "mask's shape must match the first K dimensions of tensor's shape,"), c2 = 1, l2 = i2; l2 < i2 + u2; l2++)
            c2 *= s2[l2];
          return h2 = s2.slice(0, i2).concat([c2], s2.slice(i2 + u2)), f2 = n2.reshape(h2), p2 = a2.reshape([-1]), [4, Us(p2)];
        case 1:
          return d2 = r2.sent(), v2 = d2.squeeze([1]), m2 = Ec(f2, v2, i2), t2 !== n2 && n2.dispose(), e2 !== a2 && a2.dispose(), v2.dispose(), f2.dispose(), p2.dispose(), d2.dispose(), [2, m2];
      }
    });
  });
};
function kc(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === a2 && (a2 = "NHWC"), g(t2.length === e2.rank, function() {
    return "Length of inShape (" + t2.length + ") and rank of dy (" + e2.rank + ") must match";
  });
  var u2 = t2, s2 = e2, c2 = false;
  3 === e2.rank && (c2 = true, s2 = e2.as4D(1, e2.shape[0], e2.shape[1], e2.shape[2]), u2 = [1, t2[0], t2[1], t2[2]]), g(4 === u2.length, function() {
    return "Error in conv2dDerInput: inShape must be length 4, but got length " + u2.length + ".";
  }), g(4 === s2.rank, function() {
    return "Error in conv2dDerInput: dy must be rank 4, but got rank " + s2.rank;
  }), g(4 === n2.rank, function() {
    return "Error in conv2dDerInput: filter must be rank 4, but got rank " + n2.rank;
  });
  var l2 = "NHWC" === a2 ? u2[3] : u2[1], h2 = "NHWC" === a2 ? s2.shape[3] : s2.shape[1];
  g(l2 === n2.shape[2], function() {
    return "Error in conv2dDerInput: depth of input (" + l2 + ") must match input depth for filter " + n2.shape[2] + ".";
  }), g(h2 === n2.shape[3], function() {
    return "Error in conv2dDerInput: depth of output (" + h2 + ") must match output depth for filter " + n2.shape[3] + ".";
  }), null != i2 && g(E(o2), function() {
    return "Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + o2 + ".";
  });
  var f2 = ko(a2), p2 = go(u2, n2.shape, r2, 1, o2, i2, false, f2), d2 = Nt.runKernelFunc(function(t3, e3) {
    var r3 = t3.conv2dDerInput(s2, n2, p2);
    return e3([n2, s2]), r3;
  }, {dy4D: s2, filter: n2}, function(t3, e3) {
    var n3 = e3[0], u3 = e3[1];
    return {dy4D: function() {
      return Tc(t3, n3, r2, o2, a2, 1, i2);
    }, filter: function() {
      return Fc(t3, u3, n3.shape, r2, o2, a2, i2);
    }};
  });
  return c2 ? d2.as3D(d2.shape[1], d2.shape[2], d2.shape[3]) : d2;
}
function Sc(t2) {
  var e2 = function(t3) {
    return "number" == typeof t3 ? [t3, t3, t3] : 2 === t3.length ? [t3[0], t3[1], 1] : t3;
  }(t2), n2 = e2[0], r2 = e2[1], o2 = e2[2];
  return 1 === n2 && 1 === r2 && 1 === o2;
}
function Ac(t2, e2, n2, r2, o2) {
  g(t2.length === e2.rank, function() {
    return "Length of inShape (" + t2.length + ") and rank of dy (" + e2.rank + ") must match";
  });
  var a2 = t2, i2 = e2, u2 = false;
  4 === e2.rank && (u2 = true, i2 = e2.as5D(1, e2.shape[0], e2.shape[1], e2.shape[2], e2.shape[3]), a2 = [1, t2[0], t2[1], t2[2], t2[3]]);
  var s2 = a2[4], c2 = i2.shape[4];
  g(5 === a2.length, function() {
    return "Error in conv3dDerInput: inShape must be length 5, but got length " + a2.length + ".";
  }), g(5 === i2.rank, function() {
    return "Error in conv3dDerInput: dy must be rank 5, but got rank " + i2.rank;
  }), g(5 === n2.rank, function() {
    return "Error in conv3dDerInput: filter must be rank 5, but got rank " + n2.rank;
  }), g(s2 === n2.shape[3], function() {
    return "Error in conv3dDerInput: depth of input (" + s2 + ") must match input depth for filter " + n2.shape[3] + ".";
  }), g(c2 === n2.shape[4], function() {
    return "Error in conv3dDerInput: depth of output (" + c2 + ") must match output depth for filter " + n2.shape[4] + ".";
  });
  var l2 = yo(a2, n2.shape, r2, 1, o2), h2 = Nt.runKernelFunc(function(t3) {
    return t3.conv3dDerInput(i2, n2, l2);
  }, {dy5D: i2});
  return u2 ? h2.as4D(h2.shape[1], h2.shape[2], h2.shape[3], h2.shape[4]) : h2;
}
var Dc = Cn({conv1d_: function(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === o2 && (o2 = "NWC"), void 0 === a2 && (a2 = 1);
  var u2 = ln(t2, "x", "conv1d"), s2 = ln(e2, "filter", "conv1d"), c2 = u2, l2 = false;
  2 === u2.rank && (l2 = true, c2 = u2.as3D(1, u2.shape[0], u2.shape[1])), g(3 === c2.rank, function() {
    return "Error in conv1d: input must be rank 3, but got rank " + c2.rank + ".";
  }), g(3 === s2.rank, function() {
    return "Error in conv1d: filter must be rank 3, but got rank " + s2.rank + ".";
  }), null != i2 && g(E(r2), function() {
    return "Error in conv1d: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + r2 + ".";
  }), g(c2.shape[2] === s2.shape[1], function() {
    return "Error in conv1d: depth of input (" + c2.shape[2] + ") must match input depth for filter " + s2.shape[1] + ".";
  }), g(Io(n2, a2), function() {
    return "Error in conv1D: Either stride or dilation must be 1. Got stride " + n2 + " and dilation '" + a2 + "'";
  }), g("NWC" === o2, function() {
    return "Error in conv1d: got dataFormat of " + o2 + " but only NWC is currently supported.";
  });
  var h2 = s2.as4D(1, s2.shape[0], s2.shape[1], s2.shape[2]), f2 = c2.as4D(c2.shape[0], 1, c2.shape[1], c2.shape[2]), p2 = Tc(f2, h2, [1, n2], r2, "NHWC", [1, a2], i2);
  return l2 ? p2.as2D(p2.shape[2], p2.shape[3]) : p2.as3D(p2.shape[0], p2.shape[2], p2.shape[3]);
}});
var Tc = Cn({conv2d_: function(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === o2 && (o2 = "NHWC"), void 0 === a2 && (a2 = [1, 1]);
  var u2 = ln(t2, "x", "conv2d"), s2 = ln(e2, "filter", "conv2d"), c2 = u2, l2 = false;
  3 === u2.rank && (l2 = true, c2 = u2.as4D(1, u2.shape[0], u2.shape[1], u2.shape[2])), g(4 === c2.rank, function() {
    return "Error in conv2d: input must be rank 4, but got rank " + c2.rank + ".";
  }), g(4 === s2.rank, function() {
    return "Error in conv2d: filter must be rank 4, but got rank " + s2.rank + ".";
  }), null != i2 && g(E(r2), function() {
    return "Error in conv2d: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + r2 + ".";
  });
  var h2 = "NHWC" === o2 ? c2.shape[3] : c2.shape[1];
  g(h2 === s2.shape[2], function() {
    return "Error in conv2d: depth of input (" + h2 + ") must match input depth for filter " + s2.shape[2] + ".";
  }), g(Io(n2, a2), function() {
    return "Error in conv2D: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + a2 + "'";
  });
  var f2 = ko(o2), p2 = go(c2.shape, s2.shape, n2, a2, r2, i2, false, f2), d2 = [s2, c2], v2 = Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.conv2d(c2, s2, p2);
    return e3([s2, c2]), n3;
  }, {x: c2, filter: s2}, function(t3, e3) {
    var i3 = e3, u3 = i3[0], s3 = i3[1];
    return g(Ro(a2), function() {
      return "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + a2 + "'";
    }), {x: function() {
      return Oc(s3.shape, t3, u3, n2, r2, o2);
    }, filter: function() {
      return Fc(s3, t3, u3.shape, n2, r2, o2);
    }};
  }, "Conv2D", p2, d2);
  return l2 ? v2.as3D(v2.shape[1], v2.shape[2], v2.shape[3]) : v2;
}});
var Nc = Cn({conv3d_: function(t2, e2, n2, r2, o2, a2) {
  void 0 === o2 && (o2 = "NDHWC"), void 0 === a2 && (a2 = [1, 1, 1]);
  var i2 = ln(t2, "x", "conv3d"), u2 = ln(e2, "filter", "conv3d"), s2 = i2, c2 = false;
  4 === i2.rank && (c2 = true, s2 = i2.as5D(1, i2.shape[0], i2.shape[1], i2.shape[2], i2.shape[3])), g(5 === s2.rank, function() {
    return "Error in conv3d: input must be rank 5, but got rank " + s2.rank + ".";
  }), g(5 === u2.rank, function() {
    return "Error in conv3d: filter must be rank 5, but got rank " + u2.rank + ".";
  }), g(s2.shape[4] === u2.shape[3], function() {
    return "Error in conv3d: depth of input (" + s2.shape[4] + ") must match input depth for filter " + u2.shape[3] + ".";
  }), g(function(t3, e3) {
    return Sc(t3) || Sc(e3);
  }(n2, a2), function() {
    return "Error in conv3D: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + a2 + "'";
  }), g("NDHWC" === o2, function() {
    return "Error in conv3d: got dataFormat of " + o2 + " but only NDHWC is currently supported.";
  });
  var l2 = yo(s2.shape, u2.shape, n2, a2, r2), h2 = Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.conv3d(s2, u2, l2);
    return e3([s2, u2]), n3;
  }, {x: s2, $filter: u2}, function(t3, e3) {
    g(Sc(a2), function() {
      return "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + a2 + "'";
    });
    var o3 = e3[0], i3 = e3[1];
    return {x: function() {
      return Ac(o3.shape, t3, i3, n2, r2);
    }, $filter: function() {
      return function(t4, e4, n3, r3, o4) {
        var a3 = t4;
        4 === t4.rank && (a3 = t4.as5D(1, t4.shape[0], t4.shape[1], t4.shape[2], t4.shape[3]));
        var i4 = e4;
        4 === i4.rank && (i4 = e4.as5D(1, e4.shape[0], e4.shape[1], e4.shape[2], e4.shape[3])), g(5 === a3.rank, function() {
          return "Error in conv3dDerFilter: input must be rank 5, but got shape " + a3.shape + ".";
        }), g(5 === i4.rank, function() {
          return "Error in conv3dDerFilter: dy must be rank 5, but got shape " + i4.shape + ".";
        }), g(5 === n3.length, function() {
          return "Error in conv3dDerFilter: filterShape must be length 5, but got " + n3 + ".";
        }), g(a3.shape[4] === n3[3], function() {
          return "Error in conv3dDerFilter: depth of input " + a3.shape[4] + ") must match input depth in filter (" + n3[3] + ".";
        }), g(i4.shape[4] === n3[4], function() {
          return "Error in conv3dDerFilter: depth of dy (" + i4.shape[4] + ") must match output depth for filter (" + n3[4] + ").";
        });
        var u3 = yo(a3.shape, n3, r3, 1, o4);
        return Nt.runKernelFunc(function(t5) {
          return t5.conv3dDerFilter(a3, i4, u3);
        }, {x5D: a3, dy5D: i4});
      }(o3, t3, i3.shape, n2, r2);
    }};
  });
  return c2 ? h2.as4D(h2.shape[1], h2.shape[2], h2.shape[3], h2.shape[4]) : h2;
}});
var Fc = Cn({conv2dDerFilter_: function(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === a2 && (a2 = "NHWC");
  var u2 = t2;
  3 === t2.rank && (u2 = t2.as4D(1, t2.shape[0], t2.shape[1], t2.shape[2]));
  var s2 = e2;
  3 === s2.rank && (s2 = e2.as4D(1, e2.shape[0], e2.shape[1], e2.shape[2])), g(4 === u2.rank, function() {
    return "Error in conv2dDerFilter: input must be rank 4, but got shape " + u2.shape + ".";
  }), g(4 === s2.rank, function() {
    return "Error in conv2dDerFilter: dy must be rank 4, but got shape " + s2.shape + ".";
  }), g(4 === n2.length, function() {
    return "Error in conv2dDerFilter: filterShape must be length 4, but got " + n2 + ".";
  });
  var c2 = "NHWC" === a2 ? u2.shape[3] : u2.shape[1], l2 = "NHWC" === a2 ? s2.shape[3] : s2.shape[1];
  g(c2 === n2[2], function() {
    return "Error in conv2dDerFilter: depth of input " + c2 + ") must match input depth in filter (" + n2[2] + ".";
  }), g(l2 === n2[3], function() {
    return "Error in conv2dDerFilter: depth of dy (" + l2 + ") must match output depth for filter (" + n2[3] + ").";
  }), null != i2 && g(E(o2), function() {
    return "Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + o2 + ".";
  });
  var h2 = ko(a2), f2 = go(u2.shape, n2, r2, 1, o2, i2, false, h2);
  return Nt.runKernelFunc(function(t3) {
    return t3.conv2dDerFilter(u2, s2, f2);
  }, {x4D: u2, dy4D: s2});
}});
var Oc = Cn({conv2dDerInput_: kc});
var _c = Cn({depthwiseConv2d_: function(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === o2 && (o2 = "NHWC"), void 0 === a2 && (a2 = [1, 1]);
  var u2 = ln(t2, "x", "depthwiseConv2d"), s2 = ln(e2, "filter", "depthwiseConv2d"), c2 = u2, l2 = false;
  3 === u2.rank && (l2 = true, c2 = u2.as4D(1, u2.shape[0], u2.shape[1], u2.shape[2])), g(4 === c2.rank, function() {
    return "Error in depthwiseConv2d: input must be rank 4, but got rank " + c2.rank + ".";
  }), g(4 === s2.rank, function() {
    return "Error in depthwiseConv2d: filter must be rank 4, but got rank " + s2.rank + ".";
  }), g(c2.shape[3] === s2.shape[2], function() {
    return "Error in depthwiseConv2d: number of input channels (" + c2.shape[3] + ") must match the inChannels dimension in filter " + s2.shape[2] + ".";
  }), null == a2 && (a2 = [1, 1]), g(Io(n2, a2), function() {
    return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + a2 + "'";
  }), null != i2 && g(E(r2), function() {
    return "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode " + i2 + " but got pad " + r2 + ".";
  });
  var h2 = go(c2.shape, s2.shape, n2, a2, r2, i2, true), f2 = Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.depthwiseConv2D(c2, s2, h2);
    return e3([c2, s2]), n3;
  }, {x: c2, $filter: s2}, function(t3, e3) {
    g(Ro(a2), function() {
      return "Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + a2 + "'";
    });
    var n3 = e3[0], r3 = e3[1];
    return {x: function() {
      return Mc(n3.shape, t3, r3, h2);
    }, $filter: function() {
      return Bc(n3, t3, r3.shape, h2);
    }};
  });
  return l2 ? f2.as3D(f2.shape[1], f2.shape[2], f2.shape[3]) : f2;
}});
var Mc = Cn({depthwiseConv2dDerInput_: function(t2, e2, n2, r2) {
  var o2 = e2, a2 = false;
  3 === e2.rank && (a2 = true, o2 = e2.as4D(1, e2.shape[0], e2.shape[1], e2.shape[2]));
  var i2 = Nt.runKernelFunc(function(t3) {
    return t3.depthwiseConv2DDerInput(o2, n2, r2);
  }, {dy4D: o2});
  return a2 ? i2.as3D(i2.shape[1], i2.shape[2], i2.shape[3]) : i2;
}});
var Bc = Cn({depthwiseConv2dDerFilter_: function(t2, e2, n2, r2) {
  var o2 = t2;
  3 === t2.rank && (o2 = t2.as4D(1, t2.shape[0], t2.shape[1], t2.shape[2]));
  var a2 = e2;
  return 3 === a2.rank && (a2 = e2.as4D(1, e2.shape[0], e2.shape[1], e2.shape[2])), Nt.runKernelFunc(function(t3) {
    return t3.depthwiseConv2DDerFilter(o2, a2, r2);
  }, {x4D: o2, dy4D: a2});
}});
var Pc = Cn({separableConv2d_: function(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === a2 && (a2 = [1, 1]), void 0 === i2 && (i2 = "NHWC");
  var u2 = ln(t2, "x", "separableConv2d"), s2 = ln(e2, "depthwiseFilter", "separableConv2d"), c2 = ln(n2, "pointwiseFilter", "separableConv2d"), l2 = u2, h2 = false;
  if (3 === u2.rank && (h2 = true, l2 = u2.as4D(1, u2.shape[0], u2.shape[1], u2.shape[2])), "NCHW" === i2)
    throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
  g(4 === l2.rank, function() {
    return "Error in separableConv2d: input must be rank 4, but got rank " + l2.rank + ".";
  }), g(4 === s2.rank, function() {
    return "Error in separableConv2d: depthwise filter must be rank 4, but got rank " + s2.rank + ".";
  }), g(4 === c2.rank, function() {
    return "Error in separableConv2d: pointwise filter must be rank 4, but got rank " + s2.rank + ".";
  }), g(1 === c2.shape[0], function() {
    return "Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got " + c2.shape[0] + ".";
  }), g(1 === c2.shape[1], function() {
    return "Error in separableConv2d: the second dimension of pointwise filter must be 1, but got " + c2.shape[1] + ".";
  });
  var f2 = s2.shape[2], p2 = s2.shape[3];
  g(c2.shape[2] === f2 * p2, function() {
    return "Error in separableConv2d: the third dimension of pointwise filter must be " + f2 * p2 + ", but got " + c2.shape[2] + ".";
  });
  var d2 = _c(l2, s2, r2, o2, i2, a2), v2 = Tc(d2, c2, 1, "valid", i2);
  return h2 ? v2.as3D(v2.shape[1], v2.shape[2], v2.shape[3]) : v2;
}});
var Lc = Cn({conv2dTranspose_: function(t2, e2, n2, r2, o2, a2) {
  return kc(n2, ln(t2, "x", "conv2dTranspose"), ln(e2, "filter", "conv2dTranspose"), r2, o2, "NHWC", a2);
}});
var Wc = Cn({conv3dTranspose_: function(t2, e2, n2, r2, o2) {
  return Ac(n2, ln(t2, "x", "conv3dTranspose"), ln(e2, "filter", "conv3dTranspose"), r2, o2);
}});
var Uc = Cn({matMul_: function(t2, e2, n2, r2) {
  var o2;
  void 0 === n2 && (n2 = false), void 0 === r2 && (r2 = false);
  var a2 = ln(t2, "a", "matMul"), i2 = ln(e2, "b", "matMul");
  o2 = Rt(a2, i2), a2 = o2[0], i2 = o2[1];
  var u2 = n2 ? a2.shape[a2.rank - 2] : a2.shape[a2.rank - 1], s2 = r2 ? i2.shape[i2.rank - 1] : i2.shape[i2.rank - 2], c2 = n2 ? a2.shape[a2.rank - 1] : a2.shape[a2.rank - 2], l2 = r2 ? i2.shape[i2.rank - 2] : i2.shape[i2.rank - 1], h2 = a2.shape.slice(0, -2), f2 = i2.shape.slice(0, -2), p2 = w(h2), d2 = w(f2);
  g(a2.rank >= 2 && i2.rank >= 2 && a2.rank === i2.rank, function() {
    return "Error in matMul: inputs must have the same rank of at least 2, got ranks " + a2.rank + " and " + i2.rank + ".";
  }), g(C(h2, f2), function() {
    return "Error in matMul: outer dimensions (" + h2 + ") and (" + f2 + ") of Tensors with shapes " + a2.shape + " and " + i2.shape + " must match.";
  }), g(u2 === s2, function() {
    return "Error in matMul: inner shapes (" + u2 + ") and (" + s2 + ") of Tensors with shapes " + a2.shape + " and " + i2.shape + " and transposeA=" + n2 + " and transposeB=" + r2 + " must match.";
  });
  var v2 = a2.shape.slice(0, -2).concat([c2, l2]), m2 = n2 ? a2.as3D(p2, u2, c2) : a2.as3D(p2, c2, u2), y2 = r2 ? i2.as3D(d2, l2, s2) : i2.as3D(d2, s2, l2), x2 = {transposeA: n2, transposeB: r2};
  return Nt.runKernelFunc(function(t3, e3) {
    var o3 = t3.batchMatMul(m2, y2, n2, r2);
    return e3([m2, y2]), o3;
  }, {a: m2, b: y2}, function(t3, e3) {
    var o3 = e3, a3 = o3[0], i3 = o3[1];
    return n2 || r2 ? !n2 && r2 ? {a: function() {
      return t3.matMul(i3, false, false);
    }, b: function() {
      return t3.matMul(a3, true, false);
    }} : n2 && !r2 ? {a: function() {
      return i3.matMul(t3, false, true);
    }, b: function() {
      return a3.matMul(t3, false, false);
    }} : {a: function() {
      return i3.matMul(t3, true, true);
    }, b: function() {
      return t3.matMul(a3, true, true);
    }} : {a: function() {
      return t3.matMul(i3, false, true);
    }, b: function() {
      return a3.matMul(t3, true, false);
    }};
  }, "BatchMatMul", x2).reshape(v2);
}});
var Vc = Cn({dot_: function(t2, e2) {
  var n2 = ln(t2, "t1", "dot"), r2 = ln(e2, "t2", "dot");
  g(!(1 !== n2.rank && 2 !== n2.rank || 1 !== r2.rank && 2 !== r2.rank), function() {
    return "Error in dot: inputs must all be rank 1 or 2, but got ranks " + n2.rank + " and " + r2.rank + ".";
  });
  var o2 = 1 === n2.rank ? n2.size : n2.shape[1], a2 = 1 === r2.rank ? r2.size : r2.shape[0];
  return g(o2 === a2, function() {
    return "Error in dot: inner dimensions of inputs must match, but got " + o2 + " and " + a2 + ".";
  }), 1 === n2.rank && 1 === r2.rank ? n2.as2D(1, -1).matMul(r2.as2D(-1, 1)).asScalar() : 1 === n2.rank && 2 === r2.rank ? n2.as2D(1, -1).matMul(r2.as2D(r2.shape[0], r2.shape[1])).as1D() : 2 === n2.rank && 1 === r2.rank ? n2.matMul(r2.as2D(-1, 1)).as1D() : n2.matMul(r2.as2D(r2.shape[0], r2.shape[1]));
}});
var zc = Cn({outerProduct_: function(t2, e2) {
  var n2 = ln(t2, "v1", "outerProduct"), r2 = ln(e2, "v2", "outerProduct");
  return g(1 === n2.rank && 1 === r2.rank, function() {
    return "Error in outerProduct: inputs must be rank 1, but got ranks " + n2.rank + " and " + r2.rank + ".";
  }), n2.as2D(-1, 1).matMul(r2.as2D(1, -1));
}});
var Gc = Cn({reverse_: function(t2, e2) {
  var n2 = ln(t2, "x", "reverse");
  if (0 === n2.rank)
    return n2.clone();
  var r2 = D(e2, n2.shape);
  return Nt.runKernelFunc(function(t3) {
    return t3.reverse(n2, r2);
  }, {$x: n2}, function(t3) {
    return {$x: function() {
      return t3.reverse(r2);
    }};
  }).reshapeAs(n2);
}});
var Hc = Cn({reverse1d_: function(t2) {
  var e2 = ln(t2, "x", "reverse");
  return g(1 === e2.rank, function() {
    return "Error in reverse1D: x must be rank 1 but got rank " + e2.rank + ".";
  }), Gc(e2, 0);
}});
var qc = Cn({reverse2d_: function(t2, e2) {
  var n2 = ln(t2, "x", "reverse");
  return g(2 === n2.rank, function() {
    return "Error in reverse2D: x must be rank 2 but got rank " + n2.rank + ".";
  }), Gc(n2, e2);
}});
var Kc = Cn({reverse3d_: function(t2, e2) {
  var n2 = ln(t2, "x", "reverse");
  return g(3 === n2.rank, function() {
    return "Error in reverse3D: x must be rank 3 but got rank " + n2.rank + ".";
  }), Gc(n2, e2);
}});
var jc = Cn({reverse4d_: function(t2, e2) {
  var n2 = ln(t2, "x", "reverse");
  return g(4 === n2.rank, function() {
    return "Error in reverse4D: x must be rank 4 but got rank " + n2.rank + ".";
  }), Gc(n2, e2);
}});
function Xc(t2, e2, n2, r2, o2, a2) {
  var i2 = ln(t2, "x", "maxPool"), u2 = i2, s2 = false;
  3 === i2.rank && (s2 = true, u2 = i2.as4D(1, i2.shape[0], i2.shape[1], i2.shape[2])), null == r2 && (r2 = [1, 1]), g(4 === u2.rank, function() {
    return "Error in maxPool: input must be rank 4 but got rank " + u2.rank + ".";
  }), g(Io(n2, r2), function() {
    return "Error in maxPool: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + r2 + "'";
  }), null != a2 && g(E(o2), function() {
    return "Error in maxPool: pad must be an integer when using, dimRoundingMode " + a2 + " but got pad " + o2 + ".";
  });
  var c2 = vo(u2.shape, e2, n2, r2, o2, a2), l2 = Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.maxPool(u2, c2);
    return e3([u2, n3]), n3;
  }, {x: u2}, function(t3, a3) {
    var i3 = a3[0], u3 = a3[1];
    return {x: function() {
      return function(t4, e3, n3, r3, o3, a4, i4, u4) {
        var s3 = ln(t4, "dy", "maxPoolBackprop"), c3 = ln(e3, "input", "maxPoolBackprop"), l3 = ln(n3, "output", "maxPoolBackprop");
        g(c3.rank === s3.rank, function() {
          return "Rank of input (" + c3.rank + ") does not match rank of dy (" + s3.rank + ")";
        }), null == a4 && (a4 = [1, 1]), g(Io(o3, a4), function() {
          return "Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides " + o3 + " and dilations '" + a4 + "'";
        }), g(4 === s3.rank, function() {
          return "Error in maxPoolBackprop: dy must be rank 4 but got rank " + s3.rank + ".";
        }), g(4 === c3.rank, function() {
          return "Error in maxPoolBackprop: input must be rank 4 but got rank " + c3.rank + ".";
        }), null != u4 && g(E(i4), function() {
          return "Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode " + u4 + " but got pad " + i4 + ".";
        });
        var h2 = vo(c3.shape, r3, o3, a4, i4, u4);
        return Nt.runKernelFunc(function(t5) {
          return t5.maxPoolBackprop(s3, c3, l3, h2);
        }, {$dy: s3, $input: c3});
      }(t3, i3, u3, e2, n2, r2, o2);
    }};
  });
  return s2 ? l2.as3D(l2.shape[1], l2.shape[2], l2.shape[3]) : l2;
}
function $c(t2, e2, n2, r2, o2, a2) {
  var i2 = ln(t2, "x", "avgPool", "float32");
  null == r2 && (r2 = [1, 1]), g(Io(n2, r2), function() {
    return "Error in avgPool: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + r2 + "'";
  });
  var u2 = i2, s2 = false;
  3 === i2.rank && (s2 = true, u2 = i2.as4D(1, i2.shape[0], i2.shape[1], i2.shape[2])), g(4 === u2.rank, function() {
    return "Error in avgPool: x must be rank 4 but got rank " + u2.rank + ".";
  }), null != a2 && g(E(o2), function() {
    return "Error in avgPool: pad must be an integer when using, dimRoundingMode " + a2 + " but got pad " + o2 + ".";
  });
  var c2 = vo(u2.shape, e2, n2, r2, o2, a2), l2 = Nt.runKernelFunc(function(t3) {
    return t3.avgPool(u2, c2);
  }, {x: u2}, function(t3) {
    return {x: function() {
      return function(t4, e3, n3, r3, o3, a3) {
        var i3 = ln(t4, "dy", "avgPoolBackprop"), u3 = ln(e3, "input", "avgPoolBackprop");
        g(u3.rank === i3.rank, function() {
          return "Rank of input (" + u3.rank + ") does not match rank of dy (" + i3.rank + ")";
        }), null == o3 && (o3 = [1, 1]), g(Io(r3, o3), function() {
          return "Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides " + r3 + " and dilations '" + o3 + "'";
        });
        var s3 = u3, c3 = i3, l3 = false;
        3 === u3.rank && (l3 = true, s3 = u3.as4D(1, u3.shape[0], u3.shape[1], u3.shape[2]), c3 = i3.as4D(1, i3.shape[0], i3.shape[1], i3.shape[2])), g(4 === c3.rank, function() {
          return "Error in avgPoolBackprop: dy must be rank 4 but got rank " + c3.rank + ".";
        }), g(4 === s3.rank, function() {
          return "Error in avgPoolBackprop: input must be rank 4 but got rank " + s3.rank + ".";
        });
        var h2 = vo(s3.shape, n3, r3, o3, a3), f2 = Nt.runKernelFunc(function(t5) {
          return t5.avgPoolBackprop(c3, s3, h2);
        }, {dy4D: c3, input4D: s3});
        return l3 ? f2.as3D(f2.shape[1], f2.shape[2], f2.shape[3]) : f2;
      }(t3, u2, e2, n2, r2, o2);
    }};
  });
  return l2 = l2.cast(i2.dtype), s2 ? l2.as3D(l2.shape[1], l2.shape[2], l2.shape[3]) : l2;
}
var Yc = Cn({maxPool_: function(t2, e2, n2, r2, o2) {
  return Xc(t2, e2, n2, 1, r2, o2);
}});
var Qc = Cn({avgPool_: function(t2, e2, n2, r2, o2) {
  return $c(t2, e2, n2, 1, r2, o2);
}});
var Jc = Cn({pool_: function(t2, e2, n2, r2, o2, a2) {
  null == o2 && (o2 = [1, 1]), null == a2 && (a2 = 1), 0 === r2 && (r2 = "valid");
  var i2 = ln(t2, "x", "maxPool"), u2 = i2, s2 = false;
  3 === i2.rank && (s2 = true, u2 = i2.as4D(1, i2.shape[0], i2.shape[1], i2.shape[2])), g(Io(a2, o2), function() {
    return "Error in pool: Either strides or dilations must be 1. Got strides " + a2 + " and dilations '" + o2 + "'";
  });
  var c2, l2 = vo(u2.shape, e2, a2, o2, r2), h2 = [l2.dilationHeight, l2.dilationWidth];
  c2 = "same" === r2 ? function(t3, e3) {
    var n3 = t3.map(function(t4, n4) {
      return t4 + (t4 - 1) * (e3[n4] - 1);
    }).map(function(t4) {
      return t4 - 1;
    }), r3 = n3.map(function(t4) {
      return Math.floor(t4 / 2);
    }), o3 = n3.map(function(t4, e4) {
      return t4 - r3[e4];
    });
    return n3.map(function(t4, e4) {
      return [r3[e4], o3[e4]];
    });
  }([l2.filterHeight, l2.filterWidth], h2) : [[0, 0], [0, 0]];
  var f2 = 1 === h2[0] && 1 === h2[1], p2 = function(t3, e3, n3) {
    var r3 = n3.map(function(t4) {
      return t4[0];
    }), o3 = n3.map(function(t4) {
      return t4[1];
    }), a3 = t3.concat(r3, o3), i3 = e3.map(function(t4, e4) {
      return (t4 - a3[e4] % t4) % t4;
    }), u3 = o3.map(function(t4, e4) {
      return t4 + i3[e4];
    }), s3 = e3.map(function(t4, e4) {
      return [r3[e4], u3[e4]];
    }), c3 = e3.map(function(t4, e4) {
      return [0, i3[e4]];
    });
    return [s3, c3];
  }([l2.inHeight, l2.inWidth], h2, c2), d2 = p2[0], v2 = p2[1], m2 = f2 ? r2 : "valid", y2 = f2 ? u2 : Ar(u2, h2, d2), x2 = ("avg" === n2 ? function() {
    return $c(y2, e2, a2, 1, m2);
  } : function() {
    return Xc(y2, e2, a2, 1, m2);
  })(), b2 = f2 ? x2 : cr(x2, h2, v2);
  return s2 ? b2.as3D(b2.shape[1], b2.shape[2], b2.shape[3]) : b2;
}});
var Zc = Cn({maxPool3d_: function(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === a2 && (a2 = "NDHWC");
  var u2 = ln(t2, "x", "maxPool3d"), s2 = u2, c2 = false;
  4 === u2.rank && (c2 = true, s2 = u2.as5D(1, u2.shape[0], u2.shape[1], u2.shape[2], u2.shape[3])), null == i2 && (i2 = [1, 1, 1]), g(5 === s2.rank, function() {
    return "Error in maxPool3d: x must be rank 5 but got rank " + s2.rank + ".";
  }), g("NDHWC" === a2, function() {
    return "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of " + a2;
  }), g(Io(n2, i2), function() {
    return "Error in maxPool3d: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + i2 + "'";
  }), null != o2 && g(E(r2), function() {
    return "Error in maxPool3d: pad must be an integer when using, dimRoundingMode " + o2 + " but got pad " + r2 + ".";
  });
  var l2 = mo(s2.shape, e2, n2, i2, r2, o2, a2), h2 = Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.maxPool3d(s2, l2);
    return e3([s2, n3]), n3;
  }, {x: s2}, function(t3, a3) {
    var u3 = a3[0], s3 = a3[1];
    return {x: function() {
      return function(t4, e3, n3, r3, o3, a4, i3, u4) {
        var s4 = ln(t4, "dy", "maxPool3dBackprop"), c3 = ln(e3, "input", "maxPool3dBackprop"), l3 = ln(n3, "output", "maxPool3dBackprop"), h3 = s4, f2 = c3, p2 = l3, d2 = false;
        4 === c3.rank && (d2 = true, h3 = s4.as5D(1, s4.shape[0], s4.shape[1], s4.shape[2], s4.shape[3]), f2 = c3.as5D(1, c3.shape[0], c3.shape[1], c3.shape[2], c3.shape[3]), p2 = l3.as5D(1, l3.shape[0], l3.shape[1], l3.shape[2], l3.shape[3])), g(5 === h3.rank, function() {
          return "Error in maxPool3dBackprop: dy must be rank 5 but got rank " + h3.rank + ".";
        }), g(5 === f2.rank, function() {
          return "Error in maxPool3dBackprop: input must be rank 5 but got rank " + f2.rank + ".";
        }), g(5 === p2.rank, function() {
          return "Error in maxPool3dBackprop: output must be rank 5 but got rank " + p2.rank + ".";
        }), null == a4 && (a4 = [1, 1, 1]), g(Io(o3, a4), function() {
          return "Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides " + o3 + " and dilations '" + a4 + "'";
        }), null != u4 && g(E(i3), function() {
          return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + u4 + " but got pad " + i3 + ".";
        });
        var v2 = mo(f2.shape, r3, o3, a4, i3, u4), m2 = Nt.runKernelFunc(function(t5) {
          return t5.maxPool3dBackprop(h3, f2, p2, v2);
        }, {dy5D: h3, input5D: f2});
        return d2 ? m2.as4D(m2.shape[1], m2.shape[2], m2.shape[3], m2.shape[4]) : m2;
      }(t3, u3, s3, e2, n2, i2, r2, o2);
    }};
  });
  return c2 ? h2.as4D(h2.shape[1], h2.shape[2], h2.shape[3], h2.shape[4]) : h2;
}});
var tl = Cn({avgPool3d_: function(t2, e2, n2, r2, o2, a2, i2) {
  void 0 === a2 && (a2 = "NDHWC");
  var u2 = ln(t2, "x", "avgPool3d", "float32"), s2 = u2, c2 = false;
  4 === u2.rank && (c2 = true, s2 = u2.as5D(1, u2.shape[0], u2.shape[1], u2.shape[2], u2.shape[3])), null == i2 && (i2 = [1, 1, 1]), g(5 === s2.rank, function() {
    return "Error in avgPool3d: x must be rank 5 but got rank " + s2.rank + ".";
  }), g("NDHWC" === a2, function() {
    return "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of " + a2;
  }), g(Io(n2, i2), function() {
    return "Error in avgPool3d: Either strides or dilations must be 1. Got strides " + n2 + " and dilations '" + i2 + "'";
  }), null != o2 && g(E(r2), function() {
    return "Error in avgPool3d: pad must be an integer when using, dimRoundingMode " + o2 + " but got pad " + r2 + ".";
  });
  var l2 = mo(s2.shape, e2, n2, i2, r2, o2, a2), h2 = Nt.runKernelFunc(function(t3) {
    return t3.avgPool3d(s2, l2);
  }, {x: s2}, function(t3) {
    return {x: function() {
      return function(t4, e3, n3, r3, o3, a3, i3) {
        var u3 = ln(t4, "dy", "avgPool3dBackprop"), s3 = ln(e3, "input", "avgPool3dBackprop"), c3 = u3, l3 = s3, h3 = false;
        4 === s3.rank && (h3 = true, c3 = u3.as5D(1, u3.shape[0], u3.shape[1], u3.shape[2], u3.shape[3]), l3 = s3.as5D(1, s3.shape[0], s3.shape[1], s3.shape[2], s3.shape[3])), g(5 === c3.rank, function() {
          return "Error in avgPool3dBackprop: dy must be rank 5 but got rank " + c3.rank + ".";
        }), g(5 === l3.rank, function() {
          return "Error in avgPool3dBackprop: input must be rank 5 but got rank " + l3.rank + ".";
        }), null == o3 && (o3 = [1, 1, 1]), g(Io(r3, o3), function() {
          return "Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides " + r3 + " and dilations '" + o3 + "'";
        }), null != i3 && g(E(a3), function() {
          return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + i3 + " but got pad " + a3 + ".";
        });
        var f2 = mo(l3.shape, n3, r3, o3, a3, i3), p2 = Nt.runKernelFunc(function(t5) {
          return t5.avgPool3dBackprop(c3, l3, f2);
        }, {dy5D: c3, input5D: l3});
        return h3 ? p2.as4D(p2.shape[1], p2.shape[2], p2.shape[3], p2.shape[4]) : p2;
      }(t3, s2, e2, n2, i2, r2, o2);
    }};
  });
  return h2 = h2.cast(s2.dtype), c2 ? h2.as4D(h2.shape[1], h2.shape[2], h2.shape[3], h2.shape[4]) : h2;
}});
var el = Cn({slice_: function(t2, e2, n2) {
  var r2, o2, a2 = ln(t2, "x", "slice");
  if (0 === a2.rank)
    throw new Error("Slicing scalar is not possible");
  (r2 = "number" == typeof e2 ? [e2].concat(new Array(a2.rank - 1).fill(0)) : e2.length < a2.rank ? e2.concat(new Array(a2.rank - e2.length).fill(0)) : e2.slice()).forEach(function(t3) {
    g(-1 !== t3, function() {
      return "slice() does not support negative begin indexing.";
    });
  }), o2 = (o2 = null == n2 ? new Array(a2.rank).fill(-1) : "number" == typeof n2 ? [n2].concat(new Array(a2.rank - 1).fill(-1)) : n2.length < a2.rank ? n2.concat(new Array(a2.rank - n2.length).fill(-1)) : n2).map(function(t3, e3) {
    return t3 >= 0 ? t3 : (g(-1 === t3, function() {
      return "Negative size values should be exactly -1 but got " + t3 + " for the slice() size at index " + e3 + ".";
    }), a2.shape[e3] - r2[e3]);
  }), qr(a2, r2, o2);
  var i2 = a2.shape, u2 = {begin: r2, size: o2};
  return Nt.runKernelFunc(function(t3) {
    return t3.slice(a2, r2, o2);
  }, {x: a2}, function(t3) {
    for (var e3 = [], n3 = 0; n3 < t3.rank; n3++)
      e3.push([r2[n3], i2[n3] - r2[n3] - o2[n3]]);
    return {x: function() {
      return t3.pad(e3);
    }};
  }, "Slice", u2);
}});
var nl = Cn({slice1d_: function(t2, e2, n2) {
  var r2 = ln(t2, "x", "slice1d");
  return g(1 === r2.rank, function() {
    return "slice1d expects a rank-1 tensor, but got a rank-" + r2.rank + " tensor";
  }), el(r2, [e2], [n2]);
}});
var rl = Cn({slice2d_: function(t2, e2, n2) {
  var r2 = ln(t2, "x", "slice2d");
  return g(2 === r2.rank, function() {
    return "slice2d expects a rank-2 tensor, but got a rank-" + r2.rank + " tensor";
  }), el(r2, e2, n2);
}});
var ol = Cn({slice3d_: function(t2, e2, n2) {
  var r2 = ln(t2, "x", "slice3d");
  return g(3 === r2.rank, function() {
    return "slice3d expects a rank-3 tensor, but got a rank-" + r2.rank + " tensor";
  }), el(r2, e2, n2);
}});
var al = Cn({slice4d_: function(t2, e2, n2) {
  var r2 = ln(t2, "x", "slice4d");
  return g(4 === r2.rank, function() {
    return "slice4d expects a rank-4 tensor, but got a rank-" + r2.rank + " tensor";
  }), el(r2, e2, n2);
}});
function il(t2, e2, n2, r2, o2) {
  return e2.rank < n2.rank && (e2 = e2.reshape(vn(e2.shape, r2))), t2.rank < n2.rank && (t2 = t2.reshape(vn(t2.shape, r2))), {x: function() {
    var r3 = t2.mul(n2.equal(e2).cast(t2.dtype));
    return null == o2 ? r3 : r3.transpose(o2);
  }};
}
var ul = Cn({all_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "x", "all", "bool"), o2 = D(e2, r2.shape), a2 = o2, i2 = gn(a2, r2.rank);
  null != i2 && (r2 = r2.transpose(i2), a2 = xn(a2.length, r2.rank));
  var u2 = Nt.runKernelFunc(function(t3) {
    return t3.all(r2, a2);
  }, {$x: r2});
  if (n2) {
    var s2 = vn(u2.shape, o2);
    return u2.reshape(s2);
  }
  return u2;
}});
var sl = Cn({any_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "x", "any", "bool"), o2 = D(e2, r2.shape), a2 = o2, i2 = gn(a2, r2.rank);
  null != i2 && (r2 = r2.transpose(i2), a2 = xn(a2.length, r2.rank));
  var u2 = Nt.runKernelFunc(function(t3) {
    return t3.any(r2, a2);
  }, {$x: r2});
  if (n2) {
    var s2 = vn(u2.shape, o2);
    return u2.reshape(s2);
  }
  return u2;
}});
var cl = Cn({argMax_: function(t2, e2) {
  void 0 === e2 && (e2 = 0);
  var n2 = ln(t2, "x", "argMax");
  null == e2 && (e2 = 0);
  var r2 = D(e2, n2.shape), o2 = gn(r2, n2.rank);
  return null != o2 && (n2 = n2.transpose(o2), r2 = xn(r2.length, n2.rank)), Nt.runKernelFunc(function(t3, e3) {
    var o3 = t3.argMax(n2, r2[0]);
    return e3([n2]), o3;
  }, {$x: n2}, function(t3, e3) {
    var n3 = e3[0];
    return {$x: function() {
      return zn(n3);
    }};
  });
}});
var ll = Cn({argMin_: function(t2, e2) {
  void 0 === e2 && (e2 = 0);
  var n2 = ln(t2, "x", "argMin");
  null == e2 && (e2 = 0);
  var r2 = D(e2, n2.shape), o2 = gn(r2, n2.rank);
  return null != o2 && (n2 = n2.transpose(o2), r2 = xn(r2.length, n2.rank)), Nt.runKernelFunc(function(t3, e3) {
    var o3 = t3.argMin(n2, r2[0]);
    return e3([n2]), o3;
  }, {$x: n2}, function(t3, e3) {
    var n3 = e3[0];
    return {$x: function() {
      return zn(n3);
    }};
  });
}});
var hl = Cn({logSumExp_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "x", "logSumExp"), o2 = D(e2, r2.shape), a2 = r2.max(o2, true), i2 = r2.sub(a2).exp().sum(o2).log(), u2 = a2.reshape(i2.shape).add(i2);
  if (n2) {
    var s2 = vn(u2.shape, o2);
    return u2.reshape(s2);
  }
  return u2;
}});
var fl = Cn({max_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "x", "max"), o2 = r2, a2 = D(e2, r2.shape), i2 = a2, u2 = gn(i2, r2.rank);
  null != u2 && (r2 = r2.transpose(u2), i2 = xn(i2.length, r2.rank));
  var s2 = [r2], c2 = Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.max(r2, i2);
    return e3([o2, n3]), n3;
  }, {x: r2}, function(t3, e3) {
    return il(t3, e3[1], e3[0], a2, u2);
  }, "Max", {axes: i2}, s2, [true]);
  if (n2) {
    var l2 = vn(c2.shape, a2);
    c2 = c2.reshape(l2);
  }
  return c2;
}});
var pl = Cn({mean_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "x", "mean"), o2 = D(e2, r2.shape), a2 = w(dn(r2.shape, o2)[1]);
  return oo(function(t3) {
    var r3 = An(a2);
    return {value: (r3.dtype === t3.dtype ? t3 : t3.cast(r3.dtype)).div(r3).sum(e2, n2), gradFunc: function(e3) {
      var n3 = t3.shape.slice();
      return o2.forEach(function(t4) {
        n3[t4] = 1;
      }), e3.reshape(n3).mul(Bn(t3.shape, "float32")).div(a2);
    }};
  })(r2);
}});
var dl = Cn({min_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "x", "min"), o2 = r2, a2 = D(e2, r2.shape), i2 = a2, u2 = gn(i2, r2.rank);
  null != u2 && (r2 = r2.transpose(u2), i2 = xn(i2.length, r2.rank));
  var s2 = [r2], c2 = Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.min(r2, i2);
    return e3([o2, n3]), n3;
  }, {x: r2}, function(t3, e3) {
    return il(t3, e3[1], e3[0], a2, u2);
  }, "Min", {axes: i2}, s2, [true]);
  if (n2) {
    var l2 = vn(c2.shape, a2);
    c2 = c2.reshape(l2);
  }
  return c2;
}});
var vl = Cn({moments_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
  var r2 = D(e2, (t2 = ln(t2, "x", "moments")).shape), o2 = t2.mean(r2, n2), a2 = o2.shape;
  n2 || (a2 = vn(o2.shape, r2));
  var i2 = t2.toFloat().sub(o2.reshape(a2)).square();
  return {mean: o2, variance: i2.mean(r2, n2)};
}});
var ml = Cn({sum_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "x", "sum");
  "bool" === r2.dtype && (r2 = r2.toInt());
  var o2 = D(e2, r2.shape);
  return oo(function(t3) {
    var e3 = gn(o2, t3.rank), r3 = o2, a2 = t3;
    null != e3 && (a2 = t3.transpose(e3), r3 = xn(r3.length, t3.rank));
    var i2 = Nt.runKernelFunc(function(t4) {
      return t4.sum(a2, r3);
    }, {permutedX: a2});
    if (n2) {
      var u2 = vn(i2.shape, o2);
      i2 = i2.reshape(u2);
    }
    return {value: i2, gradFunc: function(e4) {
      var n3 = t3.shape.slice();
      return o2.forEach(function(t4) {
        n3[t4] = 1;
      }), e4.reshape(n3).mul(Bn(t3.shape, "float32"));
    }};
  })(r2);
}});
var gl = Cn({prod_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = null), void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "x", "prod");
  "bool" === r2.dtype && (r2 = r2.toInt());
  var o2 = D(e2, r2.shape), a2 = gn(o2, r2.rank), i2 = o2, u2 = r2;
  null != a2 && (u2 = r2.transpose(a2), i2 = xn(i2.length, r2.rank));
  var s2 = Nt.runKernelFunc(function(t3) {
    return t3.prod(u2, i2);
  }, {permutedX: u2});
  if (n2) {
    var c2 = vn(s2.shape, o2);
    s2 = s2.reshape(c2);
  }
  return s2;
}});
var yl = Cn({elu_: function(t2) {
  var e2 = ln(t2, "x", "elu");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.elu(e2);
    return n2([r2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return Nt.runKernelFunc(function(e4) {
        return e4.eluDer(t3, n2);
      }, {dy: t3, y: n2});
    }};
  });
}});
var xl = Cn({leakyRelu_: function(t2, e2) {
  void 0 === e2 && (e2 = 0.2);
  var n2 = ln(t2, "x", "leakyRelu");
  return $s(An(e2).mul(n2), n2);
}});
var bl = Cn({prelu_: function(t2, e2) {
  var n2 = ln(t2, "x", "prelu"), r2 = ln(e2, "alpha", "prelu");
  return Nt.runKernelFunc(function(t3, e3) {
    var o2 = t3.prelu(n2, r2);
    return e3([n2, r2]), o2;
  }, {x: n2, alpha: r2}, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1], o2 = n3.greater(0);
    return {x: function() {
      return Ws(o2, t3, t3.mul(r3));
    }, alpha: function() {
      var e4 = Ws(o2, zn(t3), t3.mul(n3)), a2 = fo(r3.shape, t3.shape);
      return a2.length > 0 && (e4 = e4.sum(a2)), e4.reshape(r3.shape);
    }};
  }, "Prelu");
}});
var wl = Cn({relu_: function(t2) {
  var e2 = ln(t2, "x", "relu");
  return "bool" === e2.dtype ? e2.toInt() : Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.relu(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      return t3.mulStrict(n2.step().toFloat());
    }};
  });
}});
var Cl = Cn({relu6_: function(t2) {
  var e2 = ln(t2, "x", "relu6");
  return "bool" === e2.dtype ? e2.toInt() : Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.relu6(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0], r2 = n2.lessEqual(6).mul(n2.step());
    return {$x: function() {
      return t3.mulStrict(r2.toFloat());
    }};
  });
}});
var El = Cn({selu_: function(t2) {
  var e2 = ln(t2, "x", "selu");
  return Nt.runKernelFunc(function(t3, n2) {
    var r2 = t3.selu(e2);
    return n2([e2]), r2;
  }, {$x: e2}, function(t3, e3) {
    var n2 = e3[0];
    return {$x: function() {
      var e4 = n2.greater(An(0)), r2 = An(iu), o2 = An(uu), a2 = t3.mul(o2), i2 = t3.mul(r2).mul(n2.toFloat().exp());
      return Ws(e4, a2, i2);
    }};
  });
}});
var Rl = Cn({transpose_: function(t2, e2) {
  var n2 = ln(t2, "x", "transpose");
  if (null == e2 && (e2 = n2.shape.map(function(t3, e3) {
    return e3;
  }).reverse()), g(n2.rank === e2.length, function() {
    return "Error in transpose: rank of input " + n2.rank + " must match length of perm " + e2 + ".";
  }), e2.forEach(function(t3) {
    g(t3 >= 0 && t3 < n2.rank, function() {
      return "All entries in 'perm' must be between 0 and " + (n2.rank - 1) + " but got " + e2;
    });
  }), n2.rank <= 1)
    return n2.clone();
  var r2 = {perm: e2};
  return Nt.runKernelFunc(function(t3) {
    return t3.transpose(n2, e2);
  }, {x: n2}, function(t3) {
    var n3 = yn(e2);
    return {x: function() {
      return t3.transpose(n3);
    }};
  }, "Transpose", r2);
}});
var Il = Cn({localResponseNormalization_: function(t2, e2, n2, r2, o2) {
  void 0 === e2 && (e2 = 5), void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = 1), void 0 === o2 && (o2 = 0.5);
  var a2 = ln(t2, "x", "localResponseNormalization");
  g(4 === a2.rank || 3 === a2.rank, function() {
    return "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " + a2.rank + ".";
  }), g(E(e2), function() {
    return "Error in localResponseNormalization: depthRadius must be an integer but got depthRadius " + e2 + ".";
  });
  var i2 = a2, u2 = false;
  3 === a2.rank && (u2 = true, i2 = a2.as4D(1, a2.shape[0], a2.shape[1], a2.shape[2]));
  var s2 = Nt.runKernelFunc(function(t3, a3) {
    var u3 = t3.localResponseNormalization4D(i2, e2, n2, r2, o2);
    return a3([i2, u3]), u3;
  }, {x4D: i2}, function(t3, a3) {
    var i3 = a3[0], u3 = a3[1];
    return {x4D: function() {
      return Nt.runKernelFunc(function(a4) {
        return a4.LRNGrad(t3, i3, u3, e2, n2, r2, o2);
      }, {});
    }};
  });
  return u2 ? s2.as3D(s2.shape[1], s2.shape[2], s2.shape[3]) : s2;
}});
var kl = Cn({norm_: function(t2, e2, n2, r2) {
  void 0 === e2 && (e2 = "euclidean"), void 0 === n2 && (n2 = null), void 0 === r2 && (r2 = false);
  var o2 = function t3(e3, n3, r3) {
    if (void 0 === r3 && (r3 = null), 0 === e3.rank)
      return e3.abs();
    if (1 !== e3.rank && null === r3)
      return t3(e3.reshape([-1]), n3, r3);
    if (1 === e3.rank || "number" == typeof r3 || Array.isArray(r3) && 1 === r3.length) {
      if (1 === n3)
        return e3.abs().sum(r3);
      if (n3 === 1 / 0)
        return e3.abs().max(r3);
      if (n3 === -1 / 0)
        return e3.abs().min(r3);
      if ("euclidean" === n3 || 2 === n3)
        return e3.abs().pow(An(2, "int32")).sum(r3).sqrt();
      throw new Error("Error in norm: invalid ord value: " + n3);
    }
    if (Array.isArray(r3) && 2 === r3.length) {
      if (1 === n3)
        return e3.abs().sum(r3[0]).max(r3[1] - 1);
      if (n3 === 1 / 0)
        return e3.abs().sum(r3[1]).max(r3[0]);
      if (n3 === -1 / 0)
        return e3.abs().sum(r3[1]).min(r3[0]);
      if ("fro" === n3 || "euclidean" === n3)
        return e3.square().sum(r3).sqrt();
      throw new Error("Error in norm: invalid ord value: " + n3);
    }
    throw new Error("Error in norm: invalid axis: " + r3);
  }(t2 = ln(t2, "x", "norm"), e2, n2), a2 = o2.shape;
  if (r2) {
    var i2 = D(n2, t2.shape);
    a2 = vn(o2.shape, i2);
  }
  return o2.reshape(a2);
}});
var Sl = Cn({basicLSTMCell_: function(t2, e2, n2, r2, o2, a2) {
  var i2 = ln(t2, "forgetBias", "basicLSTMCell"), u2 = ln(e2, "lstmKernel", "basicLSTMCell"), s2 = ln(n2, "lstmBias", "basicLSTMCell"), c2 = ln(r2, "data", "basicLSTMCell"), l2 = ln(o2, "c", "basicLSTMCell"), h2 = ln(a2, "h", "basicLSTMCell"), f2 = c2.concat(h2, 1).matMul(u2).add(s2), p2 = f2.shape[0], d2 = f2.shape[1] / 4, v2 = [p2, d2], m2 = f2.slice([0, 0], v2), g2 = f2.slice([0, d2], v2), y2 = f2.slice([0, 2 * d2], v2), x2 = f2.slice([0, 3 * d2], v2), b2 = m2.sigmoid().mulStrict(g2.tanh()).addStrict(l2.mulStrict(i2.add(y2).sigmoid())), w2 = b2.tanh().mulStrict(x2.sigmoid());
  return [b2, w2];
}});
var Al = Cn({multiRNNCell_: function(t2, e2, n2, r2) {
  for (var o2 = ln(e2, "data", "multiRNNCell"), a2 = hn(n2, "c", "multiRNNCell"), i2 = hn(r2, "h", "multiRNNCell"), u2 = o2, s2 = [], c2 = 0; c2 < t2.length; c2++) {
    var l2 = t2[c2](u2, a2[c2], i2[c2]);
    s2.push(l2[0]), s2.push(l2[1]), u2 = l2[1];
  }
  var h2 = [], f2 = [];
  for (c2 = 0; c2 < s2.length; c2 += 2)
    h2.push(s2[c2]), f2.push(s2[c2 + 1]);
  return [h2, f2];
}});
var Dl = Cn({movingAverage_: function(t2, e2, n2, r2, o2) {
  void 0 === o2 && (o2 = true);
  var a2 = ln(t2, "v", "movingAverage"), i2 = ln(e2, "x", "movingAverage"), u2 = ln(n2, "decay", "movingAverage");
  It(a2, i2), g(C(a2.shape, i2.shape), function() {
    return "Shape mismatch in v and x";
  });
  var s2 = An(1), c2 = s2.sub(u2), l2 = i2.sub(a2).mul(c2);
  if (o2) {
    g(null != r2, function() {
      return "When using zeroDebias: true, step is required.";
    });
    var h2 = ln(r2, "step", "movingAverage");
    l2 = l2.div(s2.sub(rc(u2, h2)));
  }
  return a2.add(l2);
}});
var Tl = Cn({stridedSlice_: function(t2, e2, n2, r2, o2, a2, i2, u2, s2) {
  if (void 0 === o2 && (o2 = 0), void 0 === a2 && (a2 = 0), void 0 === i2 && (i2 = 0), void 0 === u2 && (u2 = 0), void 0 === s2 && (s2 = 0), null == r2 && (r2 = new Array(e2.length)), 0 !== i2)
    throw new Error("ellipsis mask is not yet supported");
  var c2 = ln(t2, "x", "stridedSlice"), l2 = Kr(u2), h2 = c2.shape.slice();
  l2.forEach(function(t3) {
    e2[t3] = 0, n2[t3] = 1, h2.splice(t3, 0, 1);
  }), c2 = c2.reshape(h2);
  for (var f2 = 0; f2 < c2.rank; f2++)
    e2[f2] = Xr(o2, e2, r2, c2.shape, f2), n2[f2] = $r(a2, n2, r2, c2.shape, f2), r2[f2] = r2[f2] || 1;
  var p2 = Kr(s2);
  p2.forEach(function(t3) {
    n2[t3] = e2[t3] + 1, r2[t3] = 1;
  });
  var d2 = jr(e2, n2, r2), v2 = d2.filter(function(t3, e3) {
    return -1 === p2.indexOf(e3);
  });
  return r2.every(function(t3) {
    return 1 === t3;
  }) ? el(c2, e2, d2).reshape(v2) : Nt.runKernelFunc(function(t3) {
    return t3.stridedSlice(c2, e2, n2, r2);
  }, {$x: c2}).reshape(v2);
}});
var Nl = Cn({topk_: function(t2, e2, n2) {
  void 0 === e2 && (e2 = 1), void 0 === n2 && (n2 = true);
  var r2 = ln(t2, "x", "topk");
  if (0 === r2.rank)
    throw new Error("topk() expects the input to be of rank 1 or higher");
  var o2 = r2.shape[r2.shape.length - 1];
  if (e2 > o2)
    throw new Error("'k' passed to topk() must be <= the last dimension (" + o2 + ") but got " + e2);
  var a2 = Nt.runKernelFunc(function(t3) {
    return t3.topk(r2, e2, n2);
  }, {$x: r2});
  return {values: a2[0], indices: a2[1]};
}});
var Fl = Cn({scatterND_: function(t2, e2, n2) {
  var r2 = ln(t2, "indices", "scatterND", "int32"), o2 = ln(e2, "updates", "scatterND");
  return Gr(o2, r2, n2), Nt.runKernelFunc(function(t3) {
    return t3.scatterND(r2, o2, n2);
  }, {$indices: r2, $updates: o2});
}});
var Ol = Cn({fft_: function(t2) {
  g("complex64" === t2.dtype, function() {
    return "The dtype for tf.spectral.fft() must be complex64 but got " + t2.dtype + ".";
  });
  var e2 = t2.shape[t2.shape.length - 1], n2 = t2.size / e2, r2 = t2.as2D(n2, e2);
  return Nt.runKernelFunc(function(t3) {
    return t3.fft(r2);
  }, {input: t2}).reshape(t2.shape);
}});
var _l = Cn({ifft_: function(t2) {
  g("complex64" === t2.dtype, function() {
    return "The dtype for tf.spectral.ifft() must be complex64 but got " + t2.dtype + ".";
  });
  var e2 = t2.shape[t2.shape.length - 1], n2 = t2.size / e2, r2 = t2.as2D(n2, e2);
  return Nt.runKernelFunc(function(t3) {
    return t3.ifft(r2);
  }, {input: t2}).reshape(t2.shape);
}});
var Ml = Cn({rfft_: function(t2, e2) {
  g("float32" === t2.dtype, function() {
    return "The dtype for rfft() must be real value but got " + t2.dtype;
  });
  var n2, r2 = t2.shape[t2.shape.length - 1], o2 = t2.size / r2;
  if (null != e2 && e2 < r2) {
    var a2 = t2.shape.map(function(t3) {
      return 0;
    }), i2 = t2.shape.map(function(t3) {
      return t3;
    });
    i2[t2.shape.length - 1] = e2, n2 = t2.slice(a2, i2), r2 = e2;
  } else if (null != e2 && e2 > r2) {
    var u2 = t2.shape.map(function(t3) {
      return t3;
    });
    u2[t2.shape.length - 1] = e2 - r2, n2 = t2.concat(Pn(u2), t2.shape.length - 1), r2 = e2;
  } else
    n2 = t2;
  var s2 = n2.zerosLike(), c2 = En(n2, s2).as2D(o2, r2), l2 = Ol(c2), h2 = Math.floor(r2 / 2) + 1, f2 = Rn(l2), p2 = In(l2), d2 = f2.split([h2, r2 - h2], f2.shape.length - 1), v2 = p2.split([h2, r2 - h2], p2.shape.length - 1), m2 = n2.shape.slice();
  return m2[n2.shape.length - 1] = h2, En(d2[0], v2[0]).reshape(m2);
}});
var Bl = Cn({irfft_: function(t2) {
  var e2 = t2.shape[t2.shape.length - 1], n2 = t2.size / e2;
  if (e2 <= 2) {
    var r2 = t2.as2D(n2, e2), o2 = _l(r2);
    return Rn(o2);
  }
  var a2 = [n2, 2 * (e2 - 1)], i2 = Rn(t2).as2D(n2, e2), u2 = In(t2).as2D(n2, e2), s2 = i2.slice([0, 1], [n2, e2 - 2]).reverse(1), c2 = u2.slice([0, 1], [n2, e2 - 2]).reverse(1).mul(An(-1)), l2 = i2.concat(s2, 1), h2 = u2.concat(c2, 1);
  return r2 = En(l2, h2).as2D(a2[0], a2[1]), o2 = _l(r2), Rn(o2);
}});
var Pl = Object.freeze({fft: Ol, ifft: _l, rfft: Ml, irfft: Bl});
var Ll = Cn({sparseToDense_: function(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = 0);
  var o2 = ln(t2, "sparseIndices", "sparseToDense", "int32"), a2 = ln(e2, "sparseValues", "sparseToDense"), i2 = ln(r2, "defaultValue", "sparseToDense", a2.dtype);
  return function(t3, e3, n3, r3) {
    if ("int32" !== t3.dtype)
      throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was " + t3.dtype + ".");
    if (t3.rank > 2)
      throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape " + t3.shape + ".");
    var o3 = t3.rank > 0 ? t3.shape[0] : 1, a3 = t3.rank > 1 ? t3.shape[1] : 1;
    if (n3.length !== a3)
      throw new Error("outputShape has incorrect number of elements:, " + n3.length + ", should be: " + a3 + ".");
    var i3 = e3.size;
    if (0 !== e3.rank && (1 !== e3.rank || i3 !== o3))
      throw new Error("sparseValues has incorrect shape " + e3.shape + ", should be [] or [" + o3 + "]");
    if (e3.dtype !== r3.dtype)
      throw new Error("sparseValues.dtype must match defaultValues.dtype");
  }(o2, a2, n2, i2), Nt.runKernelFunc(function(t3) {
    return t3.sparseToDense(o2, a2, n2, i2);
  }, {$sparseIndices: o2, $sparseValues: a2, $defaultValue: i2});
}});
var Wl = Cn({gatherND_: function(t2, e2) {
  var n2 = ln(e2, "indices", "gatherND", "int32"), r2 = ln(t2, "x", "gatherND");
  return Nt.runKernelFunc(function(t3) {
    return t3.gatherND(r2, n2);
  }, {$x: r2, $indices: n2});
}});
var Ul = Cn({diag_: function(t2) {
  var e2 = ln(t2, "x", "diag").flatten(), n2 = t2.shape.concat(t2.shape);
  return Nt.runKernelFunc(function(t3) {
    return t3.diag(e2);
  }, {$x: e2}).reshape(n2);
}});
var Vl = Cn({dropout_: function(t2, e2, n2, r2) {
  var o2 = ln(t2, "x", "dropout");
  if (g("float32" === o2.dtype, function() {
    return "x has to be a floating point tensor since it's going to be scaled, but got a " + o2.dtype + " tensor instead.";
  }), g(e2 >= 0 && e2 < 1, function() {
    return "rate must be a float in the range [0, 1), but got " + e2 + ".";
  }), 0 === e2)
    return t2 instanceof dt ? o2.clone() : o2;
  var a2 = function(t3, e3) {
    if (null == e3)
      return t3.shape.slice();
    if (C(t3.shape, e3))
      return e3;
    if (t3.shape.length === e3.length) {
      for (var n3 = [], r3 = 0; r3 < t3.shape.length; r3++)
        null == e3[r3] && null != t3.shape[r3] ? n3.push(t3.shape[r3]) : n3.push(e3[r3]);
      return n3;
    }
    return e3;
  }(o2, n2), i2 = 1 - e2, u2 = kr(a2, 0, 1, "float32", r2).add(i2).floor().div(i2);
  return o2.mul(u2);
}});
function zl(t2, e2, n2) {
  for (var r2 = 1 - t2 % 2, o2 = new Float32Array(t2), a2 = 0; a2 < t2; ++a2) {
    var i2 = 2 * Math.PI * a2 / (t2 + r2 - 1);
    o2[a2] = e2 - n2 * Math.cos(i2);
  }
  return Dn(o2, "float32");
}
var Gl = Cn({hannWindow_: function(t2) {
  return zl(t2, 0.5, 0.5);
}});
var Hl = Cn({hammingWindow_: function(t2) {
  return zl(t2, 0.54, 0.46);
}});
var ql = Cn({frame_: function(t2, e2, n2, r2, o2) {
  void 0 === r2 && (r2 = false), void 0 === o2 && (o2 = 0);
  for (var a2 = 0, i2 = []; a2 + e2 <= t2.size; )
    i2.push(el(t2, a2, e2)), a2 += n2;
  if (r2)
    for (; a2 < t2.size; ) {
      var u2 = a2 + e2 - t2.size, s2 = Gn([el(t2, a2, e2 - u2), Ln([u2], o2)]);
      i2.push(s2), a2 += n2;
    }
  return 0 === i2.length ? Tn([], [0, e2]) : Gn(i2).as2D(i2.length, e2);
}});
var Kl = Cn({stft_: function(t2, e2, n2, r2, o2) {
  var a2;
  void 0 === o2 && (o2 = Gl), null == r2 && (a2 = e2, r2 = Math.floor(Math.pow(2, Math.ceil(Math.log(a2) / Math.log(2)))));
  for (var i2 = ql(t2, e2, n2), u2 = ec(i2, o2(e2)), s2 = [], c2 = 0; c2 < i2.shape[0]; c2++)
    s2.push(Ml(u2.slice([c2, 0], [1, e2]), r2));
  return Gn(s2);
}});
var jl = Object.freeze({hannWindow: Gl, hammingWindow: Hl, frame: ql, stft: Kl});
var Xl;
var $l = function(t2, e2, o2) {
  return void 0 === o2 && (o2 = 1), n(this, void 0, void 0, function() {
    var n2, a2, i2, u2, s2, c2, l2, h2, f2, p2, d2, v2, m2, x2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          return n2 = ln(t2, "predictions", "inTopK"), a2 = ln(e2, "targets", "inTopK"), g(n2.rank > 1, function() {
            return "inTopK() expects the predictions to be of rank 2 or higher, but got " + n2.rank;
          }), g(n2.rank - 1 === a2.rank, function() {
            return "predictions rank should be 1 larger than targets rank, but got predictions rank " + n2.rank + " and targets rank " + a2.rank;
          }), y(n2.shape.slice(0, n2.shape.length - 1), a2.shape, "predictions's shape should be align with the targets' shape, except the last dimension."), i2 = n2.shape[n2.shape.length - 1], g(o2 > 0 && o2 <= i2, function() {
            return "'k' passed to inTopK() must be > 0 && <= the predictions last dimension (" + i2 + "), but got " + o2;
          }), [4, n2.data()];
        case 1:
          return u2 = r2.sent(), [4, a2.data()];
        case 2:
          for (s2 = r2.sent(), c2 = [u2.length / i2, i2], h2 = c2[1], f2 = N("bool", l2 = c2[0]), p2 = 0; p2 < l2; p2++) {
            for (d2 = p2 * h2, v2 = u2.subarray(d2, d2 + h2), m2 = [], x2 = 0; x2 < v2.length; x2++)
              m2.push({value: v2[x2], index: x2});
            for (m2.sort(function(t3, e3) {
              return e3.value - t3.value;
            }), f2[p2] = 0, x2 = 0; x2 < o2; x2++)
              if (m2[x2].index === s2[p2]) {
                f2[p2] = 1;
                break;
              }
          }
          return t2 !== n2 && n2.dispose(), e2 !== a2 && a2.dispose(), [2, kn(f2, a2.shape, "bool")];
      }
    });
  });
};
!function(t2) {
  t2[t2.NONE = 0] = "NONE", t2[t2.MEAN = 1] = "MEAN", t2[t2.SUM = 2] = "SUM", t2[t2.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
}(Xl || (Xl = {}));
var Yl = Cn({absoluteDifference_: function(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = Xl.SUM_BY_NONZERO_WEIGHTS);
  var o2 = ln(t2, "labels", "absoluteDifference"), a2 = ln(e2, "predictions", "absoluteDifference"), i2 = null;
  null != n2 && (i2 = ln(n2, "weights", "absoluteDifference")), y(o2.shape, a2.shape, "Error in absoluteDifference: ");
  var u2 = o2.sub(a2).abs();
  return Ql(u2, i2, r2);
}});
var Ql = Cn({computeWeightedLoss_: function(t2, e2, n2) {
  void 0 === n2 && (n2 = Xl.SUM_BY_NONZERO_WEIGHTS);
  var r2 = ln(t2, "losses", "computeWeightedLoss"), o2 = null;
  null != e2 && (o2 = ln(e2, "weights", "computeWeightedLoss"));
  var a2 = null == o2 ? r2 : r2.mul(o2);
  if (n2 === Xl.NONE)
    return a2;
  if (n2 === Xl.SUM)
    return a2.sum();
  if (n2 === Xl.MEAN) {
    if (null == o2)
      return a2.mean();
    var i2 = r2.size / o2.size, u2 = a2.sum().div(o2.sum());
    return i2 > 1 ? u2.div(An(i2)) : u2;
  }
  if (n2 === Xl.SUM_BY_NONZERO_WEIGHTS) {
    if (null == o2)
      return a2.sum().div(An(r2.size));
    var s2 = o2.mul(Bn(r2.shape)).notEqual(An(0)).sum().toFloat();
    return a2.sum().div(s2);
  }
  throw Error("Unknown reduction: " + n2);
}});
var Jl = Cn({cosineDistance_: function(t2, e2, n2, r2, o2) {
  void 0 === o2 && (o2 = Xl.SUM_BY_NONZERO_WEIGHTS);
  var a2 = ln(t2, "labels", "cosineDistance"), i2 = ln(e2, "predictions", "cosineDistance"), u2 = null;
  null != r2 && (u2 = ln(r2, "weights", "cosineDistance")), y(a2.shape, i2.shape, "Error in cosineDistance: ");
  var s2 = An(1).sub(a2.mul(i2).sum(n2, true));
  return Ql(s2, u2, o2);
}});
var Zl = Cn({hingeLoss_: function(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = Xl.SUM_BY_NONZERO_WEIGHTS);
  var o2 = ln(t2, "labels", "hingeLoss"), a2 = ln(e2, "predictions", "hingeLoss"), i2 = null;
  null != n2 && (i2 = ln(n2, "weights", "hingeLoss")), y(o2.shape, a2.shape, "Error in hingeLoss: ");
  var u2 = An(1);
  o2 = An(2).mul(o2).sub(u2);
  var s2 = u2.sub(o2.mul(a2)).relu();
  return Ql(s2, i2, r2);
}});
var th = Cn({huberLoss_: function(t2, e2, n2, r2, o2) {
  void 0 === r2 && (r2 = 1), void 0 === o2 && (o2 = Xl.SUM_BY_NONZERO_WEIGHTS);
  var a2 = ln(t2, "labels", "huberLoss"), i2 = ln(e2, "predictions", "huberLoss"), u2 = null;
  null != n2 && (u2 = ln(n2, "weights", "huberLoss")), y(a2.shape, i2.shape, "Error in huberLoss: ");
  var s2 = An(r2), c2 = i2.sub(a2).abs(), l2 = Qs(c2, s2), h2 = c2.sub(l2), f2 = An(0.5).mul(l2.square()).add(s2.mul(h2));
  return Ql(f2, u2, o2);
}});
var eh = Cn({logLoss_: function(t2, e2, n2, r2, o2) {
  void 0 === r2 && (r2 = 1e-7), void 0 === o2 && (o2 = Xl.SUM_BY_NONZERO_WEIGHTS);
  var a2 = ln(t2, "labels", "logLoss"), i2 = ln(e2, "predictions", "logLoss"), u2 = null;
  null != n2 && (u2 = ln(n2, "weights", "logLoss")), y(a2.shape, i2.shape, "Error in logLoss: ");
  var s2 = An(1), c2 = An(r2), l2 = a2.mul(i2.add(c2).log()).neg().sub(s2.sub(a2).mul(s2.sub(i2).add(c2).log()));
  return Ql(l2, u2, o2);
}});
var nh = Cn({meanSquaredError_: function(t2, e2, n2, r2) {
  void 0 === r2 && (r2 = Xl.SUM_BY_NONZERO_WEIGHTS);
  var o2 = ln(t2, "labels", "meanSquaredError"), a2 = ln(e2, "predictions", "meanSquaredError"), i2 = null;
  null != n2 && (i2 = ln(n2, "weights", "meanSquaredError")), y(o2.shape, a2.shape, "Error in meanSquaredError: ");
  var u2 = o2.squaredDifference(a2);
  return Ql(u2, i2, r2);
}});
var rh = Cn({sigmoidCrossEntropy_: function(t2, e2, n2, r2, o2) {
  void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = Xl.SUM_BY_NONZERO_WEIGHTS);
  var a2 = ln(t2, "multiClassLabels", "sigmoidCrossEntropy"), i2 = ln(e2, "logits", "sigmoidCrossEntropy"), u2 = null;
  if (null != n2 && (u2 = ln(n2, "weights", "sigmoidCrossEntropy")), y(a2.shape, i2.shape, "Error in sigmoidCrossEntropy: "), r2 > 0) {
    var s2 = An(r2), c2 = An(1), l2 = An(0.5);
    a2 = a2.mul(c2.sub(s2)).add(l2.mul(s2));
  }
  var h2 = function(t3, e3) {
    var n3 = ln(t3, "labels", "sigmoidCrossEntropyWithLogits"), r3 = ln(e3, "logits", "sigmoidCrossEntropyWithLogits");
    y(n3.shape, r3.shape, "Error in sigmoidCrossEntropyWithLogits: ");
    var o3 = r3.relu(), a3 = r3.mul(n3), i3 = r3.abs().neg().exp().log1p();
    return o3.sub(a3).add(i3);
  }(a2, i2);
  return Ql(h2, u2, o2);
}});
var oh = Cn({softmaxCrossEntropy_: function(t2, e2, n2, r2, o2) {
  void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = Xl.SUM_BY_NONZERO_WEIGHTS);
  var a2 = ln(t2, "onehotLabels", "softmaxCrossEntropy"), i2 = ln(e2, "logits", "softmaxCrossEntropy"), u2 = null;
  if (null != n2 && (u2 = ln(n2, "weights", "softmaxCrossEntropy")), y(a2.shape, i2.shape, "Error in softmaxCrossEntropy: "), r2 > 0) {
    var s2 = An(r2), c2 = An(1), l2 = An(a2.shape[1]);
    a2 = a2.mul(c2.sub(s2)).add(s2.div(l2));
  }
  var h2 = function(t3, e3, n3) {
    if (void 0 === n3 && (n3 = -1), -1 === n3 && (n3 = e3.rank - 1), n3 !== e3.rank - 1)
      throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank " + e3.rank + " and dim was " + n3);
    return oo(function(t4, e4, r3) {
      var o3 = e4.logSumExp([n3], true), a3 = e4.toFloat().sub(o3);
      return r3([t4, a3]), {value: a3.mul(t4).neg().sum([n3]), gradFunc: function(t5, e5) {
        var r4 = e5[0], o4 = e5[1], a4 = vn(t5.shape, [n3]);
        return [t5.reshape(a4).mul(r4.toFloat().sub(o4.exp())), t5.reshape(a4).mul(o4.exp().sub(r4.toFloat()))];
      }};
    })(t3, e3);
  }(a2, i2);
  return Ql(h2, u2, o2);
}});
var ah = Object.freeze({get Reduction() {
  return Xl;
}, absoluteDifference: Yl, computeWeightedLoss: Ql, cosineDistance: Jl, hingeLoss: Zl, huberLoss: th, logLoss: eh, meanSquaredError: nh, sigmoidCrossEntropy: rh, softmaxCrossEntropy: oh});
function ih(t2, e2) {
  return void 0 === e2 && (e2 = false), Nt.tidy(function() {
    if (2 !== t2.shape.length)
      throw new Error("qr2d() requires a 2D Tensor, but got a " + t2.shape.length + "D Tensor.");
    for (var n2 = t2.shape[0], r2 = t2.shape[1], o2 = vr(n2), a2 = t2.clone(), i2 = Tn([[1]], [1, 1]), u2 = i2.clone(), s2 = n2 >= r2 ? r2 : n2, c2 = function(t3) {
      var e3, s3 = a2, c3 = u2, l3 = o2;
      e3 = Nt.tidy(function() {
        var e4 = a2.slice([t3, t3], [n2 - t3, 1]), s4 = e4.norm(), c4 = a2.slice([t3, t3], [1, 1]), l4 = Tn([[-1]]).where(c4.greater(0), Tn([[1]])), h2 = c4.sub(l4.mul(s4)), f2 = e4.div(h2);
        u2 = 1 === f2.shape[0] ? i2.clone() : i2.concat(f2.slice([1, 0], [f2.shape[0] - 1, f2.shape[1]]), 0);
        var p2 = l4.matMul(h2).div(s4).neg(), d2 = a2.slice([t3, 0], [n2 - t3, r2]), v2 = p2.mul(u2);
        if (0 === t3)
          a2 = d2.sub(v2.matMul(u2.transpose().matMul(d2)));
        else {
          var m2 = d2.sub(v2.matMul(u2.transpose().matMul(d2)));
          a2 = a2.slice([0, 0], [t3, r2]).concat(m2, 0);
        }
        var g2 = o2.slice([0, t3], [n2, o2.shape[1] - t3]);
        if (0 === t3)
          o2 = g2.sub(g2.matMul(u2).matMul(v2.transpose()));
        else {
          var y2 = g2.sub(g2.matMul(u2).matMul(v2.transpose()));
          o2 = o2.slice([0, 0], [n2, t3]).concat(y2, 1);
        }
        return [u2, a2, o2];
      }), u2 = e3[0], a2 = e3[1], o2 = e3[2], Xe([s3, c3, l3]);
    }, l2 = 0; l2 < s2; ++l2)
      c2(l2);
    return !e2 && n2 > r2 && (o2 = o2.slice([0, 0], [n2, r2]), a2 = a2.slice([0, 0], [r2, r2])), [o2, a2];
  });
}
var uh = Cn({gramSchmidt_: function(t2) {
  var e2;
  if (Array.isArray(t2)) {
    e2 = false, g(null != t2 && t2.length > 0, function() {
      return "Gram-Schmidt process: input must not be null, undefined, or empty";
    });
    for (var n2 = t2[0].shape[0], r2 = function(e3) {
      g(t2[e3].shape[0] === n2, function() {
        return "Gram-Schmidt: Non-unique lengths found in the input vectors: (" + t2[e3].shape[0] + " vs. " + n2 + ")";
      });
    }, o2 = 1; o2 < t2.length; ++o2)
      r2(o2);
  } else
    e2 = true, t2 = Xn(t2, t2.shape[0], 0).map(function(t3) {
      return Dr(t3, [0]);
    });
  g(t2.length <= t2[0].shape[0], function() {
    return "Gram-Schmidt: Number of vectors (" + t2.length + ") exceeds number of dimensions (" + t2[0].shape[0] + ").";
  });
  var a2 = [], i2 = t2, u2 = function(t3) {
    a2.push(Nt.tidy(function() {
      var e3 = i2[t3];
      if (t3 > 0)
        for (var n3 = 0; n3 < t3; ++n3) {
          var r3 = ml(a2[n3].mulStrict(e3)).mul(a2[n3]);
          e3 = e3.sub(r3);
        }
      return e3.div(kl(e3, "euclidean"));
    }));
  };
  for (o2 = 0; o2 < t2.length; ++o2)
    u2(o2);
  return e2 ? Tr(a2, 0) : a2;
}});
var sh = Cn({qr_: function(t2, e2) {
  if (void 0 === e2 && (e2 = false), t2.rank < 2)
    throw new Error("qr() requires input tensor to have a rank >= 2, but got rank " + t2.rank);
  if (2 === t2.rank)
    return ih(t2, e2);
  var n2 = t2.shape.slice(0, t2.shape.length - 2).reduce(function(t3, e3) {
    return t3 * e3;
  }), r2 = Or(t2.reshape([n2, t2.shape[t2.shape.length - 2], t2.shape[t2.shape.length - 1]]), 0), o2 = [], a2 = [];
  return r2.forEach(function(t3) {
    var n3 = ih(t3, e2), r3 = n3[0], i2 = n3[1];
    o2.push(r3), a2.push(i2);
  }), [Tr(o2, 0).reshape(t2.shape), Tr(a2, 0).reshape(t2.shape)];
}});
var ch = Object.freeze({gramSchmidt: uh, qr: sh});
function lh(t2, e2, n2, r2, o2) {
  null == r2 && (r2 = 0.5), null == o2 && (o2 = Number.NEGATIVE_INFINITY);
  var a2 = t2.shape[0];
  return n2 = Math.min(n2, a2), g(0 <= r2 && r2 <= 1, function() {
    return "iouThreshold must be in [0, 1], but was '" + r2 + "'";
  }), g(2 === t2.rank, function() {
    return "boxes must be a 2D tensor, but was of rank '" + t2.rank + "'";
  }), g(4 === t2.shape[1], function() {
    return "boxes must have 4 columns, but 2nd dimension was " + t2.shape[1];
  }), g(1 === e2.rank, function() {
    return "scores must be a 1D tensor";
  }), g(e2.shape[0] === a2, function() {
    return "scores has incompatible shape with boxes. Expected " + a2 + ", but was " + e2.shape[0];
  }), {maxOutputSize: n2, iouThreshold: r2, scoreThreshold: o2};
}
var hh = Cn({resizeBilinear_: function(t2, e2, n2) {
  void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "images", "resizeBilinear");
  g(3 === r2.rank || 4 === r2.rank, function() {
    return "Error in resizeBilinear: x must be rank 3 or 4, but got rank " + r2.rank + ".";
  }), g(2 === e2.length, function() {
    return "Error in resizeBilinear: new shape must 2D, but got shape " + e2 + ".";
  });
  var o2 = r2, a2 = false;
  3 === r2.rank && (a2 = true, o2 = r2.as4D(1, r2.shape[0], r2.shape[1], r2.shape[2]));
  var i2 = e2[0], u2 = e2[1], s2 = Nt.runKernelFunc(function(t3, e3) {
    return e3([o2]), t3.resizeBilinear(o2, i2, u2, n2);
  }, {batchImages: o2}, function(t3, e3) {
    return {batchImages: function() {
      return Nt.runKernelFunc(function(r3) {
        return r3.resizeBilinearBackprop(t3, e3[0], n2);
      }, {});
    }};
  });
  return a2 ? s2.as3D(s2.shape[1], s2.shape[2], s2.shape[3]) : s2;
}});
var fh = Cn({resizeNearestNeighbor_: function(t2, e2, n2) {
  void 0 === n2 && (n2 = false);
  var r2 = ln(t2, "images", "resizeNearestNeighbor");
  g(3 === r2.rank || 4 === r2.rank, function() {
    return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank " + r2.rank + ".";
  }), g(2 === e2.length, function() {
    return "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + e2 + ".";
  }), g("float32" === r2.dtype || "int32" === r2.dtype, function() {
    return "`images` must have `int32` or `float32` as dtype";
  });
  var o2 = r2, a2 = false;
  3 === r2.rank && (a2 = true, o2 = r2.as4D(1, r2.shape[0], r2.shape[1], r2.shape[2]));
  var i2 = e2[0], u2 = e2[1], s2 = Nt.runKernelFunc(function(t3, e3) {
    return e3([o2]), t3.resizeNearestNeighbor(o2, i2, u2, n2);
  }, {batchImages: o2}, function(t3, e3) {
    return {batchImages: function() {
      return Nt.runKernelFunc(function(r3) {
        return r3.resizeNearestNeighborBackprop(t3, e3[0], n2);
      }, {});
    }};
  });
  return a2 ? s2.as3D(s2.shape[1], s2.shape[2], s2.shape[3]) : s2;
}});
var ph = Cn({nonMaxSuppression_: function(t2, e2, n2, r2, o2) {
  void 0 === r2 && (r2 = 0.5), void 0 === o2 && (o2 = Number.NEGATIVE_INFINITY);
  var a2 = ln(t2, "boxes", "nonMaxSuppression"), i2 = ln(e2, "scores", "nonMaxSuppression"), u2 = lh(a2, i2, n2, r2, o2);
  return n2 = u2.maxOutputSize, r2 = u2.iouThreshold, o2 = u2.scoreThreshold, Nt.runKernelFunc(function(t3) {
    return t3.nonMaxSuppression(a2, i2, n2, r2, o2);
  }, {$boxes: a2});
}});
var dh = function(t2, e2, o2, a2, i2) {
  return void 0 === a2 && (a2 = 0.5), void 0 === i2 && (i2 = Number.NEGATIVE_INFINITY), n(this, void 0, void 0, function() {
    var n2, u2, s2, c2, l2, h2, f2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          return n2 = ln(t2, "boxes", "nonMaxSuppressionAsync"), u2 = ln(e2, "scores", "nonMaxSuppressionAsync"), s2 = lh(n2, u2, o2, a2, i2), o2 = s2.maxOutputSize, a2 = s2.iouThreshold, i2 = s2.scoreThreshold, [4, Promise.all([n2.data(), u2.data()])];
        case 1:
          return c2 = r2.sent(), l2 = c2[0], h2 = c2[1], f2 = Mo(l2, h2, o2, a2, i2), n2 !== t2 && n2.dispose(), u2 !== e2 && u2.dispose(), [2, f2];
      }
    });
  });
};
var vh = Cn({cropAndResize_: function(t2, e2, n2, r2, o2, a2) {
  var i2 = ln(t2, "image", "cropAndResize", "float32"), u2 = ln(e2, "boxes", "cropAndResize", "float32"), s2 = ln(n2, "boxInd", "cropAndResize", "int32");
  o2 = o2 || "bilinear", a2 = a2 || 0;
  var c2 = u2.shape[0];
  return g(4 === i2.rank, function() {
    return "Error in cropAndResize: image must be rank 4,but got rank " + i2.rank + ".";
  }), g(2 === u2.rank && 4 === u2.shape[1], function() {
    return "Error in cropAndResize: boxes must be have size [" + c2 + ",4] but had shape " + u2.shape + ".";
  }), g(1 === s2.rank && s2.shape[0] === c2, function() {
    return "Error in cropAndResize: boxInd must be have size [" + c2 + "] but had shape " + u2.shape + ".";
  }), g(2 === r2.length, function() {
    return "Error in cropAndResize: cropSize must be of length 2, but got length " + r2.length + ".";
  }), g(r2[0] >= 1 && r2[1] >= 1, function() {
    return "cropSize must be atleast [1,1], but was " + r2;
  }), g("bilinear" === o2 || "nearest" === o2, function() {
    return "method must be bilinear or nearest, but was " + o2;
  }), Nt.runKernelFunc(function(t3, e3) {
    return t3.cropAndResize(i2, u2, s2, r2, o2, a2);
  }, {images: i2, boxes: u2, boxInd: s2}, null, "CropAndResize", {method: o2, extrapolationValue: a2, cropSize: r2});
}});
var mh = Object.freeze({resizeBilinear: hh, resizeNearestNeighbor: fh, nonMaxSuppression: ph, nonMaxSuppressionAsync: dh, cropAndResize: vh});
var gh = function(t2, e2) {
  return !(t2 > 0) && ("linear" === e2 || "relu" === e2);
};
var yh = function(t2, e2, n2) {
  if (null == n2 || "linear" === n2)
    return t2;
  if ("relu" === n2)
    return t2.mul(e2.step());
  throw new Error("Gradient for activation " + n2 + " has not been implemented yet.");
};
var xh = function(t2, e2) {
  var n2 = e2, r2 = fo(t2.shape, e2.shape);
  return r2.length > 0 && (n2 = n2.sum(r2)), n2.reshape(t2.shape);
};
var bh = function(t2, e2, n2) {
  if ("linear" === e2)
    return t2;
  if ("relu" === e2)
    return wl(t2);
  if ("elu" === e2)
    return yl(t2);
  if ("relu6" === e2)
    return Cl(t2);
  if ("prelu" === e2)
    return bl(t2, n2);
  throw new Error("Unknown fused activation " + e2 + ".");
};
var wh = Cn({matMul_: function(t2) {
  var e2, n2 = t2.a, r2 = t2.b, o2 = t2.transposeA, a2 = void 0 !== o2 && o2, i2 = t2.transposeB, u2 = void 0 !== i2 && i2, s2 = t2.bias, c2 = t2.activation, l2 = void 0 === c2 ? "linear" : c2, h2 = t2.preluActivationWeights;
  if (false === gh(Nt.state.gradientDepth, l2)) {
    var f2 = Uc(n2, r2, a2, u2);
    return null != s2 && (f2 = Vs(f2, s2)), bh(f2, l2, h2);
  }
  var p2 = ln(n2, "a", "fused matMul"), d2 = ln(r2, "b", "fused matMul");
  e2 = Rt(p2, d2), p2 = e2[0], d2 = e2[1];
  var v2 = a2 ? p2.shape[p2.rank - 2] : p2.shape[p2.rank - 1], m2 = u2 ? d2.shape[d2.rank - 1] : d2.shape[d2.rank - 2], y2 = a2 ? p2.shape[p2.rank - 1] : p2.shape[p2.rank - 2], x2 = u2 ? d2.shape[d2.rank - 2] : d2.shape[d2.rank - 1], b2 = p2.shape.slice(0, -2), E2 = d2.shape.slice(0, -2), R2 = w(b2), I2 = w(E2);
  g(p2.rank >= 2 && d2.rank >= 2 && p2.rank === d2.rank, function() {
    return "Error in fused matMul: inputs must have the same rank of at least 2, got ranks " + p2.rank + " and " + d2.rank + ".";
  }), g(C(b2, E2), function() {
    return "Error in fused matMul: outer dimensions (" + b2 + ") and (" + E2 + ") of Tensors with shapes " + p2.shape + " and " + d2.shape + " must match.";
  }), g(v2 === m2, function() {
    return "Error in fused matMul: inner shapes (" + v2 + ") and (" + m2 + ") of Tensors with shapes " + p2.shape + " and " + d2.shape + " and transposeA=" + a2 + " and transposeB=" + u2 + " must match.";
  });
  var k2, S2, A2 = p2.shape.slice(0, -2).concat([y2, x2]), D2 = a2 ? p2.as3D(R2, v2, y2) : p2.as3D(R2, y2, v2), T2 = u2 ? d2.as3D(I2, x2, m2) : d2.as3D(I2, m2, x2);
  null != s2 && po(A2, (k2 = Rt(k2 = ln(s2, "bias", "fused matMul"), p2)[0]).shape), null != h2 && (S2 = ln(h2, "prelu weights", "fused matMul"));
  var N2 = {$a: D2, $b: T2};
  return null != s2 && (N2.$bias = k2), null != h2 && (N2.$preluActivationWeights = S2), Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.fusedBatchMatMul({a: D2, b: T2, transposeA: a2, transposeB: u2, bias: k2, activation: l2, preluActivationWeights: S2});
    return e3([D2, T2, n3]), n3;
  }, N2, function(t3, e3) {
    var n3 = e3[0], r3 = e3[1], o3 = e3[2], i3 = yh(t3, o3, l2), c3 = {};
    return null != s2 && (c3 = {$bias: function() {
      return xh(k2, i3);
    }}), a2 || u2 ? !a2 && u2 ? Object.assign({$a: function() {
      return i3.matMul(r3, false, false);
    }, $b: function() {
      return i3.matMul(n3, true, false);
    }}, c3) : a2 && !u2 ? Object.assign({$a: function() {
      return r3.matMul(i3, false, true);
    }, $b: function() {
      return n3.matMul(i3, false, false);
    }}, c3) : Object.assign({$a: function() {
      return r3.matMul(i3, true, true);
    }, $b: function() {
      return i3.matMul(n3, true, true);
    }}, c3) : Object.assign({$a: function() {
      return i3.matMul(r3, false, true);
    }, $b: function() {
      return n3.matMul(i3, true, false);
    }}, c3);
  }).reshape(A2);
}});
var Ch = Cn({conv2d_: function(t2) {
  var e2 = t2.x, n2 = t2.filter, r2 = t2.strides, o2 = t2.pad, a2 = t2.dataFormat, i2 = void 0 === a2 ? "NHWC" : a2, u2 = t2.dilations, s2 = void 0 === u2 ? [1, 1] : u2, c2 = t2.dimRoundingMode, l2 = t2.bias, h2 = t2.activation, f2 = void 0 === h2 ? "linear" : h2, p2 = t2.preluActivationWeights;
  if (f2 = f2 || "linear", false === gh(Nt.state.gradientDepth, f2)) {
    var d2 = Tc(e2, n2, r2, o2, i2, s2, c2);
    return null != l2 && (d2 = Vs(d2, l2)), bh(d2, f2, p2);
  }
  var v2 = ln(e2, "x", "conv2d"), m2 = ln(n2, "filter", "conv2d"), y2 = v2, x2 = false;
  3 === v2.rank && (x2 = true, y2 = v2.as4D(1, v2.shape[0], v2.shape[1], v2.shape[2])), g(4 === y2.rank, function() {
    return "Error in fused conv2d: input must be rank 4, but got rank " + y2.rank + ".";
  }), g(4 === m2.rank, function() {
    return "Error in fused conv2d: filter must be rank 4, but got rank " + m2.rank + ".";
  }), null != c2 && g(E(o2), function() {
    return "Error in fused conv2d: pad must be an integer when using, dimRoundingMode " + c2 + " but got pad " + o2 + ".";
  }), g(y2.shape[3] === m2.shape[2], function() {
    return "Error in conv2d: depth of input (" + y2.shape[3] + ") must match input depth for filter " + m2.shape[2] + ".";
  }), g(Io(r2, s2), function() {
    return "Error in conv2D: Either strides or dilations must be 1. Got strides " + r2 + " and dilations '" + s2 + "'";
  }), g("NHWC" === i2, function() {
    return "Error in conv2d: got dataFormat of " + i2 + " but only NHWC is currently supported.";
  });
  var b2, w2, C2 = go(y2.shape, m2.shape, r2, s2, o2, c2);
  null != l2 && (b2 = Rt(b2 = ln(l2, "bias", "fused conv2d"), v2)[0], po(C2.outShape, b2.shape)), null != p2 && (w2 = ln(p2, "prelu weights", "fused conv2d"));
  var R2 = {x: y2, filter: m2};
  null != l2 && (R2.bias = b2), null != p2 && (R2.preluActivationWeights = w2);
  var I2 = [m2, y2], k2 = Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.fusedConv2d({input: y2, filter: m2, convInfo: C2, bias: b2, activation: f2, preluActivationWeights: w2});
    return e3([m2, y2, n3]), n3;
  }, R2, function(t3, e3) {
    var n3 = e3, a3 = n3[0], i3 = n3[1], u3 = n3[2], c3 = yh(t3, u3, f2);
    g(Ro(s2), function() {
      return "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + s2 + "'";
    });
    var h3 = {};
    return null != l2 && (h3 = {$bias: function() {
      return xh(b2, c3);
    }}), Object.assign({x: function() {
      return Oc(i3.shape, c3, a3, r2, o2);
    }, filter: function() {
      return Fc(i3, c3, a3.shape, r2, o2);
    }}, h3);
  }, "FusedConv2D", {convInfo: C2, activation: f2}, I2, [true]);
  return x2 ? k2.as3D(k2.shape[1], k2.shape[2], k2.shape[3]) : k2;
}});
var Eh = Cn({depthwiseConv2d_: function(t2) {
  var e2 = t2.x, n2 = t2.filter, r2 = t2.strides, o2 = t2.pad, a2 = t2.dataFormat, i2 = void 0 === a2 ? "NHWC" : a2, u2 = t2.dilations, s2 = void 0 === u2 ? [1, 1] : u2, c2 = t2.dimRoundingMode, l2 = t2.bias, h2 = t2.activation, f2 = void 0 === h2 ? "linear" : h2, p2 = t2.preluActivationWeights;
  if (false === gh(Nt.state.gradientDepth, f2)) {
    var d2 = _c(e2, n2, r2, o2, i2, s2, c2);
    return null != l2 && (d2 = Vs(d2, l2)), bh(d2, f2, p2);
  }
  var v2 = ln(e2, "x", "depthwiseConv2d"), m2 = ln(n2, "filter", "depthwiseConv2d"), y2 = v2, x2 = false;
  3 === v2.rank && (x2 = true, y2 = v2.as4D(1, v2.shape[0], v2.shape[1], v2.shape[2])), g(4 === y2.rank, function() {
    return "Error in fused depthwiseConv2d: input must be rank 4, but got rank " + y2.rank + ".";
  }), g(4 === m2.rank, function() {
    return "Error in fused depthwiseConv2d: filter must be rank 4, but got rank " + m2.rank + ".";
  }), g(y2.shape[3] === m2.shape[2], function() {
    return "Error in fused depthwiseConv2d: number of input channels (" + y2.shape[3] + ") must match the inChannels dimension in filter " + m2.shape[2] + ".";
  }), null == s2 && (s2 = [1, 1]), g(Io(r2, s2), function() {
    return "Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides " + r2 + " and dilations '" + s2 + "'";
  }), null != c2 && g(E(o2), function() {
    return "Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode " + c2 + " but got pad " + o2 + ".";
  });
  var b2, w2, C2 = go(y2.shape, m2.shape, r2, s2, o2, c2, true);
  null != l2 && (b2 = Rt(b2 = ln(l2, "bias", "fused conv2d"), v2)[0], po(C2.outShape, b2.shape)), null != p2 && (w2 = ln(p2, "prelu weights", "fused depthwiseConv2d"));
  var R2 = {x: y2, $filter: m2};
  null != l2 && (R2.$bias = b2), null != p2 && (R2.$preluActivationWeights = w2);
  var I2 = Nt.runKernelFunc(function(t3, e3) {
    var n3 = t3.fusedDepthwiseConv2D({input: y2, filter: m2, convInfo: C2, bias: b2, activation: f2, preluActivationWeights: w2});
    return e3([y2, m2, n3]), n3;
  }, R2, function(t3, e3) {
    g(Ro(s2), function() {
      return "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + s2 + "'";
    });
    var n3 = e3[0], r3 = e3[1], o3 = e3[2], a3 = yh(t3, o3, f2), i3 = {};
    return null != l2 && (i3 = {$bias: function() {
      return xh(b2, a3);
    }}), Object.assign({x: function() {
      return Mc(n3.shape, a3, r3, C2);
    }, $filter: function() {
      return Bc(n3, a3, r3.shape, C2);
    }}, i3);
  });
  return x2 ? I2.as3D(I2.shape[1], I2.shape[2], I2.shape[3]) : I2;
}});
var Rh = Object.freeze({matMul: wh, conv2d: Ch, depthwiseConv2d: Eh});
var Ih = Object.freeze({image: mh, linalg: ch, losses: ah, spectral: Pl, fused: Rh, signal: jl, square: Uu, conv1d: Dc, conv2d: Tc, conv3d: Nc, depthwiseConv2d: _c, separableConv2d: Pc, conv2dTranspose: Lc, conv3dTranspose: Wc, op: Cn, batchNormalization2d: Ss, batchNormalization3d: As, batchNormalization4d: Ds, batchNormalization: Ts, batchNorm: Ns, batchNorm2d: Fs, batchNorm3d: Os, batchNorm4d: _s, booleanMaskAsync: Ic, complex: En, real: Rn, imag: In, concat: Gn, concat1d: Hn, concat2d: qn, concat3d: Kn, concat4d: jn, split: Xn, matMul: Uc, dot: Vc, outerProduct: zc, reverse: Gc, reverse1d: Hc, reverse2d: qc, reverse3d: Kc, reverse4d: jc, maxPool: Yc, avgPool: Qc, pool: Jc, maxPool3d: Zc, avgPool3d: tl, slice: el, slice1d: nl, slice2d: rl, slice3d: ol, slice4d: al, abs: Vu, acos: zu, acosh: Gu, asin: Hu, asinh: qu, atan: Ku, atanh: ju, ceil: Xu, clipByValue: $u, cos: Yu, cosh: Qu, erf: Ju, exp: Zu, expm1: ts, floor: es, log: ns, log1p: rs, logSigmoid: os, neg: as, reciprocal: is, round: us, rsqrt: ss, sigmoid: cs, sign: ls, isNaN: hs, isInf: fs, isFinite: ps, sin: ds, sinh: vs, softplus: ms, sqrt: gs, step: ys, tan: xs, tanh: bs, all: ul, any: sl, argMax: cl, argMin: ll, logSumExp: hl, max: fl, mean: pl, min: dl, moments: vl, sum: ml, prod: gl, equal: cc, equalStrict: lc, greater: hc, greaterEqual: fc, greaterEqualStrict: pc, greaterStrict: dc, less: vc, lessEqual: mc, lessEqualStrict: gc, lessStrict: yc, notEqual: xc, notEqualStrict: bc, add: Vs, addN: zs, addStrict: Gs, atan2: Hs, div: qs, divNoNan: Ks, divStrict: js, floorDiv: Xs, maximum: $s, maximumStrict: Ys, minimum: Qs, minimumStrict: Js, mod: Zs, modStrict: tc, mul: ec, mulStrict: nc, pow: rc, powStrict: oc, squaredDifference: ac, squaredDifferenceStrict: ic, sub: uc, subStrict: sc, elu: yl, leakyRelu: xl, prelu: bl, relu: wl, relu6: Cl, selu: El, logicalAnd: Ms, logicalNot: Bs, logicalOr: Ps, logicalXor: Ls, where: Ws, whereAsync: Us, buffer: ur, print: sr, batchToSpaceND: cr, cast: lr, clone: hr, cumsum: fr, depthToSpace: pr, expandDims: dr, eye: vr, multinomial: mr, oneHot: gr, pad: yr, pad1d: xr, pad2d: br, pad3d: wr, pad4d: Cr, rand: Er, randomNormal: Rr, randomGamma: Ir, randomUniform: kr, reshape: Sr, spaceToBatchND: Ar, squeeze: Dr, stack: Tr, tile: Nr, truncatedNormal: Fr, unstack: Or, setdiff1dAsync: _r, fill: Ln, linspace: Wn, ones: Bn, range: Un, scalar: An, tensor: kn, tensor1d: Dn, tensor2d: Tn, tensor3d: Nn, tensor4d: Fn, tensor5d: On, tensor6d: _n, variable: Mn, zeros: Pn, onesLike: Vn, zerosLike: zn, transpose: Rl, softmax: io, logSoftmax: uo, localResponseNormalization: Il, norm: kl, gather: Ec, unsortedSegmentSum: Rc, basicLSTMCell: Sl, multiRNNCell: Al, movingAverage: Dl, stridedSlice: Tl, topk: Nl, scatterND: Fl, fft: Ol, ifft: _l, rfft: Ml, irfft: Bl, sparseToDense: Ll, gatherND: Wl, diag: Ul, dropout: Vl, hannWindow: Gl, hammingWindow: Hl, frame: ql, stft: Kl, inTopKAsync: $l});
function kh(t2, e2) {
  Array.isArray(t2) || (t2 = [t2]), t2.forEach(function(t3) {
    null != t3 && g("complex64" !== t3.dtype, function() {
      return e2 + " does not support complex64 tensors.";
    });
  });
}
function Sh(t2, e2, n2, r2) {
  if ("linear" === n2)
    return t2.linear(e2);
  if ("relu" === n2)
    return t2.relu(e2);
  if ("elu" === n2)
    return t2.elu(e2);
  if ("relu6" === n2)
    return t2.relu6(e2);
  if ("prelu" === n2)
    return t2.prelu(e2, r2);
  throw new Error("Activation " + n2 + " has not been implemented for the CPU backend.");
}
var Ah = function(t2) {
  function o2() {
    var e2 = t2.call(this) || this;
    if (e2.blockSize = 48, e2.firstUse = true, a().get("IS_BROWSER")) {
      var n2 = "undefined" != typeof OffscreenCanvas ? new OffscreenCanvas(300, 150) : "undefined" != typeof document ? document.createElement("canvas") : null;
      null !== n2 && (e2.fromPixels2DContext = n2.getContext("2d"));
    }
    return e2.data = new so(e2, Nt), e2;
  }
  return e(o2, t2), o2.prototype.write = function(t3, e2, n2) {
    this.firstUse && (this.firstUse = false, a().get("IS_NODE") && un("\n============================\nHi there 👋. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================\n"));
    var r2 = {};
    return this.data.set(r2, {values: t3, dtype: n2}), r2;
  }, o2.prototype.move = function(t3, e2, n2, r2) {
    this.data.set(t3, {values: e2, dtype: r2});
  }, o2.prototype.numDataIds = function() {
    return this.data.numDataIds();
  }, o2.prototype.fromPixels = function(t3, e2) {
    if (null == t3)
      throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
    var n2, r2, o3 = t3.data instanceof Uint8Array, i2 = "undefined" != typeof ImageData && t3 instanceof ImageData, u2 = "undefined" != typeof HTMLVideoElement && t3 instanceof HTMLVideoElement, s2 = "undefined" != typeof HTMLImageElement && t3 instanceof HTMLImageElement, c2 = u2 ? [t3.videoWidth, t3.videoHeight] : [t3.width, t3.height], l2 = c2[0], h2 = c2[1];
    if (a().get("IS_NODE") && null == t3.getContext)
      throw new Error("When running in node, pixels must be an HTMLCanvasElement like the one returned by the `canvas` npm package");
    if (null != t3.getContext)
      n2 = t3.getContext("2d").getImageData(0, 0, l2, h2).data;
    else if (i2 || o3)
      n2 = t3.data;
    else {
      if (!s2 && !u2)
        throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData or {data: Uint32Array, width: number, height: number}, but was " + t3.constructor.name);
      if (null == this.fromPixels2DContext)
        throw new Error("Can't read pixels from HTMLImageElement outside the browser.");
      this.fromPixels2DContext.canvas.width = l2, this.fromPixels2DContext.canvas.height = h2, this.fromPixels2DContext.drawImage(t3, 0, 0, l2, h2), n2 = this.fromPixels2DContext.getImageData(0, 0, l2, h2).data;
    }
    if (4 === e2)
      r2 = new Int32Array(n2);
    else {
      var f2 = l2 * h2;
      r2 = new Int32Array(f2 * e2);
      for (var p2 = 0; p2 < f2; p2++)
        for (var d2 = 0; d2 < e2; ++d2)
          r2[p2 * e2 + d2] = n2[4 * p2 + d2];
    }
    return Nn(r2, [h2, l2, e2], "int32");
  }, o2.prototype.read = function(t3) {
    return n(this, void 0, void 0, function() {
      return r(this, function(e2) {
        return [2, this.readSync(t3)];
      });
    });
  }, o2.prototype.readSync = function(t3) {
    var e2 = this.data.get(t3), n2 = e2.dtype, r2 = e2.complexTensors;
    return "complex64" === n2 ? No(this.readSync(r2.real.dataId), this.readSync(r2.imag.dataId)) : this.data.get(t3).values;
  }, o2.prototype.bufferSync = function(t3) {
    var e2 = this.readSync(t3.dataId), n2 = e2;
    if ("string" === t3.dtype)
      try {
        n2 = e2.map(function(t4) {
          return Z(t4);
        });
      } catch (t4) {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
    return ur(t3.shape, t3.dtype, n2);
  }, o2.prototype.makeOutput = function(t3, e2, n2) {
    var r2 = this.write(t3, e2, n2);
    return Nt.makeTensorFromDataId(r2, e2, n2, this);
  }, o2.prototype.disposeData = function(t3) {
    if (this.data.has(t3)) {
      var e2 = this.data.get(t3).complexTensors;
      null != e2 && (e2.real.dispose(), e2.imag.dispose()), this.data.delete(t3);
    }
  }, o2.prototype.time = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2;
      return r(this, function(n2) {
        return e2 = Y(), t3(), [2, {kernelMs: Y() - e2}];
      });
    });
  }, o2.prototype.memory = function() {
    return {unreliable: true, reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]};
  }, o2.prototype.complex = function(t3, e2) {
    var n2 = this.makeOutput(null, t3.shape, "complex64");
    return this.data.get(n2.dataId).complexTensors = {real: Nt.keep(t3.clone()), imag: Nt.keep(e2.clone())}, n2;
  }, o2.prototype.real = function(t3) {
    return this.data.get(t3.dataId).complexTensors.real.clone();
  }, o2.prototype.imag = function(t3) {
    return this.data.get(t3.dataId).complexTensors.imag.clone();
  }, o2.prototype.slice = function(t3, e2, n2) {
    if (kh(t3, "slice"), Yr(t3.shape, e2, n2)) {
      var r2 = Qr(e2, t3.strides), o3 = w(n2);
      return kn(this.readSync(t3.dataId).subarray(r2, r2 + o3), n2, t3.dtype);
    }
    for (var a2 = ur(n2, t3.dtype), i2 = this.bufferSync(t3), u2 = 0; u2 < a2.size; ++u2) {
      var s2 = a2.indexToLoc(u2).map(function(t4, n3) {
        return t4 + e2[n3];
      });
      a2.values[u2] = i2.get.apply(i2, s2);
    }
    return a2.toTensor();
  }, o2.prototype.stridedSlice = function(t3, e2, n2, r2) {
    kh(t3, "stridedSlice");
    var o3 = jr(e2, n2, r2);
    if (o3.some(function(t4) {
      return 0 === t4;
    }))
      return kn([], o3);
    for (var a2 = ur(o3, t3.dtype), i2 = this.bufferSync(t3), u2 = 0; u2 < a2.size; u2++) {
      for (var s2 = a2.indexToLoc(u2), c2 = new Array(s2.length), l2 = 0; l2 < c2.length; l2++)
        c2[l2] = s2[l2] * r2[l2] + e2[l2];
      a2.set.apply(a2, [i2.get.apply(i2, c2)].concat(s2));
    }
    return a2.toTensor();
  }, o2.prototype.diag = function(t3) {
    for (var e2 = this.readSync(t3.dataId), n2 = ur([t3.size, t3.size], t3.dtype), r2 = n2.values, o3 = 0; o3 < e2.length; o3++)
      r2[o3 * t3.size + o3] = e2[o3];
    return n2.toTensor();
  }, o2.prototype.unstack = function(t3, e2) {
    for (var n2 = t3.shape[e2], r2 = new Array(t3.rank - 1), o3 = 0, a2 = 0; a2 < t3.rank; a2++)
      a2 !== e2 && (r2[o3++] = t3.shape[a2]);
    var i2 = new Array(t3.rank).fill(0), u2 = t3.shape.slice();
    u2[e2] = 1;
    var s2 = new Array(n2);
    for (a2 = 0; a2 < s2.length; a2++)
      i2[e2] = a2, s2[a2] = this.slice(t3, i2, u2).reshape(r2);
    return s2;
  }, o2.prototype.reverse = function(t3, e2) {
    kh(t3, "reverse");
    for (var n2 = ur(t3.shape, t3.dtype), r2 = this.bufferSync(t3), o3 = function(o4) {
      var a3 = n2.indexToLoc(o4), i2 = a3.slice();
      e2.forEach(function(e3) {
        return i2[e3] = t3.shape[e3] - 1 - i2[e3];
      }), n2.set.apply(n2, [r2.get.apply(r2, i2)].concat(a3));
    }, a2 = 0; a2 < n2.size; a2++)
      o3(a2);
    return n2.toTensor();
  }, o2.prototype.concat = function(t3, e2) {
    var n2 = this;
    if ("complex64" === t3[0].dtype) {
      var r2 = t3.map(function(t4) {
        return Rn(t4);
      }), o3 = t3.map(function(t4) {
        return In(t4);
      });
      return En(this.concat(r2, e2), this.concat(o3, e2));
    }
    var a2 = t3.map(function(t4) {
      var n3 = w(t4.shape.slice(e2));
      return t4.as2D(-1, n3);
    }), i2 = wn(a2.map(function(t4) {
      return t4.shape;
    }), 1), u2 = ur(i2, t3[0].dtype).values;
    if (1 === a2[0].shape[0]) {
      var s2 = 0;
      a2.forEach(function(t4) {
        u2.set(n2.readSync(t4.dataId), s2), s2 += t4.size;
      });
    } else {
      var c2 = 0;
      a2.forEach(function(t4) {
        for (var e3 = n2.readSync(t4.dataId), r3 = 0, o4 = 0; o4 < t4.shape[0]; ++o4)
          for (var a3 = o4 * i2[1] + c2, s3 = 0; s3 < t4.shape[1]; ++s3)
            u2[a3 + s3] = e3[r3++];
        c2 += t4.shape[1];
      });
    }
    var l2 = wn(t3.map(function(t4) {
      return t4.shape;
    }), e2);
    return kn(u2, l2, t3[0].dtype);
  }, o2.prototype.neg = function(t3) {
    return kh(t3, "neg"), this.multiply(An(-1), t3);
  }, o2.prototype.add = function(t3, e2) {
    return "complex64" === t3.dtype || "complex64" === e2.dtype ? this.broadcastedBinaryComplexOp(t3.cast("complex64"), e2.cast("complex64"), function(t4, e3, n2, r2) {
      return {real: t4 + n2, imag: e3 + r2};
    }) : this.broadcastedBinaryOp(t3, e2, Ct(t3.dtype, e2.dtype), function(t4, e3) {
      return t4 + e3;
    });
  }, o2.prototype.addN = function(t3) {
    var e2 = this;
    kh(t3, "addN");
    for (var n2 = t3.map(function(t4) {
      return e2.readSync(t4.dataId);
    }), r2 = ur(t3[0].shape, t3[0].dtype), o3 = r2.values, a2 = 0; a2 < t3.length; a2++)
      for (var i2 = n2[a2], u2 = 0; u2 < o3.length; u2++)
        o3[u2] += i2[u2];
    return r2.toTensor();
  }, o2.prototype.subtract = function(t3, e2) {
    return "complex64" === t3.dtype || "complex64" === e2.dtype ? this.broadcastedBinaryComplexOp(t3.cast("complex64"), e2.cast("complex64"), function(t4, e3, n2, r2) {
      return {real: t4 - n2, imag: e3 - r2};
    }) : this.broadcastedBinaryOp(t3, e2, Ct(t3.dtype, e2.dtype), function(t4, e3) {
      return t4 - e3;
    });
  }, o2.prototype.pow = function(t3, e2) {
    return kh([t3, e2], "pow"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
      return Math.pow(t4, e3);
    });
  }, o2.prototype.batchMatMul = function(t3, e2, n2, r2) {
    kh([t3, e2], "matMul");
    for (var o3 = n2 ? t3.shape[1] : t3.shape[2], a2 = n2 ? t3.shape[2] : t3.shape[1], i2 = r2 ? e2.shape[1] : e2.shape[2], u2 = t3.shape[0], s2 = this.readSync(t3.dataId), c2 = this.readSync(e2.dataId), l2 = n2 ? [t3.strides[0], 1, t3.strides[1]] : [t3.strides[0], t3.strides[1], 1], h2 = l2[0], f2 = l2[1], p2 = l2[2], d2 = r2 ? [1, e2.strides[1], e2.strides[0]] : [e2.strides[1], 1, e2.strides[0]], v2 = d2[0], m2 = d2[1], g2 = d2[2], y2 = a2 * i2, x2 = ur([u2, a2, i2], t3.dtype), b2 = x2.values, w2 = this.blockSize, C2 = 0; C2 < u2; C2++)
      for (var E2 = 0; E2 < a2; E2 += w2)
        for (var R2 = 0; R2 < i2; R2 += w2)
          for (var I2 = 0; I2 < o3; I2 += w2)
            for (var k2 = Math.min(E2 + w2, a2), S2 = Math.min(R2 + w2, i2), A2 = Math.min(I2 + w2, o3), D2 = E2; D2 < k2; D2++)
              for (var T2 = R2; T2 < S2; T2++) {
                for (var N2 = 0, F2 = I2; F2 < A2; F2++)
                  N2 += s2[C2 * h2 + D2 * f2 + F2 * p2] * c2[F2 * v2 + T2 * m2 + C2 * g2];
                b2[C2 * y2 + (D2 * i2 + T2)] += N2;
              }
    return x2.toTensor();
  }, o2.prototype.fusedBatchMatMul = function(t3) {
    var e2 = t3.a, n2 = t3.b, r2 = t3.transposeA, o3 = t3.transposeB, a2 = t3.bias, i2 = t3.activation, u2 = t3.preluActivationWeights, s2 = this.batchMatMul(e2, n2, r2, o3);
    return a2 && (s2 = this.add(s2, a2)), i2 && (s2 = Sh(this, s2, i2, u2)), s2;
  }, o2.prototype.multiply = function(t3, e2) {
    return "complex64" === t3.dtype || "complex64" === e2.dtype ? this.broadcastedBinaryComplexOp(t3.cast("complex64"), e2.cast("complex64"), function(t4, e3, n2, r2) {
      return {real: t4 * n2 - e3 * r2, imag: t4 * r2 + e3 * n2};
    }) : this.broadcastedBinaryOp(t3, e2, Ct(t3.dtype, e2.dtype), function(t4, e3) {
      return t4 * e3;
    });
  }, o2.prototype.realDivide = function(t3, e2) {
    kh([t3, e2], "realDivide");
    return this.broadcastedBinaryOp(t3, e2, "float32", function(t4, e3) {
      return t4 / e3;
    });
  }, o2.prototype.floorDiv = function(t3, e2) {
    kh([t3, e2], "floorDiv");
    return this.broadcastedBinaryOp(t3, e2, "int32", function(t4, e3) {
      return Math.floor(t4 / e3);
    });
  }, o2.prototype.sum = function(t3, e2) {
    kh(t3, "sum"), mn("sum", e2, t3.rank);
    for (var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Pn(r2, Ct(t3.dtype, "int32")), i2 = w(o3), u2 = this.readSync(a2.dataId), s2 = this.readSync(t3.dataId), c2 = 0; c2 < u2.length; ++c2) {
      for (var l2 = c2 * i2, h2 = 0, f2 = 0; f2 < i2; ++f2)
        h2 += s2[l2 + f2];
      u2[c2] = h2;
    }
    return a2;
  }, o2.prototype.prod = function(t3, e2) {
    kh(t3, "sum");
    for (var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Pn(r2, Ct(t3.dtype, "int32")), i2 = w(o3), u2 = this.readSync(a2.dataId), s2 = this.readSync(t3.dataId), c2 = 0; c2 < u2.length; ++c2) {
      for (var l2 = c2 * i2, h2 = 1, f2 = 0; f2 < i2; ++f2)
        h2 *= s2[l2 + f2];
      u2[c2] = h2;
    }
    return a2;
  }, o2.prototype.unsortedSegmentSum = function(t3, e2, n2) {
    kh(t3, "unsortedSegmentSum");
    for (var r2 = [], o3 = t3.rank - e2.rank, a2 = 0; a2 < o3; ++a2)
      e2 = e2.expandDims(a2 + 1);
    for (a2 = 0; a2 < n2; ++a2) {
      var i2 = An(a2, "int32"), u2 = cc(i2, e2).asType("float32").mul(t3).sum(0);
      r2.push(u2);
    }
    return Tr(r2);
  }, o2.prototype.argMin = function(t3, e2) {
    kh(t3, "argMin");
    var n2 = [e2];
    mn("argMin", n2, t3.rank);
    for (var r2 = dn(t3.shape, n2), o3 = r2[0], a2 = r2[1], i2 = Pn(o3, "int32"), u2 = w(a2), s2 = this.readSync(i2.dataId), c2 = this.readSync(t3.dataId), l2 = 0; l2 < s2.length; ++l2) {
      for (var h2 = l2 * u2, f2 = c2[h2], p2 = 0, d2 = 0; d2 < u2; ++d2) {
        var v2 = c2[h2 + d2];
        v2 < f2 && (f2 = v2, p2 = d2);
      }
      s2[l2] = p2;
    }
    return i2;
  }, o2.prototype.argMax = function(t3, e2) {
    kh(t3, "argMax");
    var n2 = [e2];
    mn("argMax", n2, t3.rank);
    for (var r2 = dn(t3.shape, n2), o3 = r2[0], a2 = r2[1], i2 = Pn(o3, "int32"), u2 = w(a2), s2 = this.readSync(i2.dataId), c2 = this.readSync(t3.dataId), l2 = 0; l2 < s2.length; ++l2) {
      for (var h2 = l2 * u2, f2 = c2[h2], p2 = 0, d2 = 0; d2 < u2; ++d2) {
        var v2 = c2[h2 + d2];
        v2 > f2 && (f2 = v2, p2 = d2);
      }
      s2[l2] = p2;
    }
    return i2;
  }, o2.prototype.cumsum = function(t3, e2, n2, r2) {
    if (kh(t3, "cumsum"), e2 !== t3.rank - 1)
      throw new Error("backend.cumsum in CPU expects an inner-most axis=" + (t3.rank - 1) + " but got axis=" + e2);
    for (var o3 = Ct(t3.dtype, "int32"), a2 = Pn(t3.shape, o3), i2 = this.readSync(a2.dataId), u2 = this.readSync(t3.dataId), s2 = t3.shape[t3.rank - 1], c2 = r2 ? function(t4, e3) {
      return t4 + s2 - e3 - 1;
    } : function(t4, e3) {
      return t4 + e3;
    }, l2 = 0; l2 < u2.length; l2 += s2)
      for (var h2 = 0; h2 < s2; h2++) {
        var f2 = c2(l2, h2);
        if (0 === h2)
          i2[f2] = n2 ? 0 : u2[f2];
        else {
          var p2 = c2(l2, h2 - 1);
          i2[f2] = n2 ? u2[p2] + i2[p2] : u2[f2] + i2[p2];
        }
      }
    return a2;
  }, o2.prototype.equal = function(t3, e2) {
    return kh([t3, e2], "equal"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
      return t4 === e3 ? 1 : 0;
    });
  }, o2.prototype.notEqual = function(t3, e2) {
    return kh([t3, e2], "notEqual"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
      return t4 !== e3 ? 1 : 0;
    });
  }, o2.prototype.less = function(t3, e2) {
    return kh([t3, e2], "less"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
      return t4 < e3 ? 1 : 0;
    });
  }, o2.prototype.lessEqual = function(t3, e2) {
    return kh([t3, e2], "lessEqual"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
      return t4 <= e3 ? 1 : 0;
    });
  }, o2.prototype.greater = function(t3, e2) {
    return kh([t3, e2], "greater"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
      return t4 > e3 ? 1 : 0;
    });
  }, o2.prototype.greaterEqual = function(t3, e2) {
    return kh([t3, e2], "greaterEqual"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
      return t4 >= e3 ? 1 : 0;
    });
  }, o2.prototype.logicalNot = function(t3) {
    kh(t3, "logicalNot");
    for (var e2 = this.readSync(t3.dataId), n2 = new Uint8Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      n2[r2] = e2[r2] ? 0 : 1;
    return this.makeOutput(n2, t3.shape, "bool");
  }, o2.prototype.logicalAnd = function(t3, e2) {
    return kh([t3, e2], "logicalAnd"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
      return t4 && e3;
    });
  }, o2.prototype.logicalOr = function(t3, e2) {
    return kh([t3, e2], "logicalOr"), this.broadcastedBinaryOp(t3, e2, "bool", function(t4, e3) {
      return t4 || e3;
    });
  }, o2.prototype.select = function(t3, e2, n2) {
    kh([t3, e2, n2], "select");
    for (var r2 = this.readSync(t3.dataId), o3 = this.readSync(e2.dataId), a2 = this.readSync(n2.dataId), i2 = Pn(e2.shape, Ct(e2.dtype, n2.dtype)), u2 = this.readSync(i2.dataId), s2 = 0, c2 = 0 === t3.rank || t3.rank > 1 || 1 === e2.rank ? 1 : w(e2.shape.slice(1)), l2 = 0; l2 < r2.length; l2++)
      for (var h2 = 0; h2 < c2; h2++)
        1 === r2[l2] ? u2[s2++] = o3[l2] : u2[s2++] = a2[l2];
    return i2;
  }, o2.prototype.where = function(t3) {
    kh([t3], "where");
    var e2 = this.readSync(t3.dataId);
    return Uo(t3.shape, e2);
  }, o2.prototype.topk = function(t3, e2, n2) {
    return kh(t3, "topk"), Wo(this.readSync(t3.dataId), t3.shape, t3.dtype, e2);
  }, o2.prototype.min = function(t3, e2) {
    kh(t3, "min"), mn("min", e2, t3.rank);
    for (var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Pn(r2, t3.dtype), i2 = w(o3), u2 = this.readSync(a2.dataId), s2 = this.readSync(t3.dataId), c2 = 0; c2 < u2.length; ++c2) {
      for (var l2 = c2 * i2, h2 = s2[l2], f2 = 0; f2 < i2; ++f2) {
        var p2 = s2[l2 + f2];
        p2 < h2 && (h2 = p2);
      }
      u2[c2] = h2;
    }
    return a2;
  }, o2.prototype.minimum = function(t3, e2) {
    return kh([t3, e2], "minimum"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
      return Math.min(t4, e3);
    });
  }, o2.prototype.mod = function(t3, e2) {
    return kh([t3, e2], "mod"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
      var n2 = t4 % e3;
      return t4 < 0 && e3 < 0 || t4 >= 0 && e3 >= 0 ? n2 : (n2 + e3) % e3;
    });
  }, o2.prototype.max = function(t3, e2) {
    kh(t3, "max"), mn("max", e2, t3.rank);
    for (var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Pn(r2, t3.dtype), i2 = w(o3), u2 = this.readSync(a2.dataId), s2 = this.readSync(t3.dataId), c2 = 0; c2 < u2.length; ++c2) {
      for (var l2 = c2 * i2, h2 = s2[l2], f2 = 0; f2 < i2; ++f2) {
        var p2 = s2[l2 + f2];
        p2 > h2 && (h2 = p2);
      }
      u2[c2] = h2;
    }
    return a2;
  }, o2.prototype.maximum = function(t3, e2) {
    return kh([t3, e2], "maximum"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
      return Math.max(t4, e3);
    });
  }, o2.prototype.all = function(t3, e2) {
    kh(t3, "all"), mn("all", e2, t3.rank);
    for (var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Pn(r2, t3.dtype), i2 = w(o3), u2 = this.readSync(a2.dataId), s2 = this.readSync(t3.dataId), c2 = 0; c2 < u2.length; ++c2) {
      for (var l2 = c2 * i2, h2 = s2[l2], f2 = 0; f2 < i2; ++f2) {
        var p2 = s2[l2 + f2];
        h2 = h2 && p2;
      }
      u2[c2] = h2;
    }
    return a2;
  }, o2.prototype.any = function(t3, e2) {
    kh(t3, "any"), mn("any", e2, t3.rank);
    for (var n2 = dn(t3.shape, e2), r2 = n2[0], o3 = n2[1], a2 = Pn(r2, t3.dtype), i2 = w(o3), u2 = this.readSync(a2.dataId), s2 = this.readSync(t3.dataId), c2 = 0; c2 < u2.length; ++c2) {
      for (var l2 = c2 * i2, h2 = s2[l2], f2 = 0; f2 < i2; ++f2) {
        var p2 = s2[l2 + f2];
        h2 = h2 || p2;
      }
      u2[c2] = h2;
    }
    return a2;
  }, o2.prototype.squaredDifference = function(t3, e2) {
    return kh([t3, e2], "squaredDifference"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
      var n2 = t4 - e3;
      return n2 * n2;
    });
  }, o2.prototype.ceil = function(t3) {
    kh(t3, "ceil");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      n2[r2] = Math.ceil(e2[r2]);
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.floor = function(t3) {
    kh(t3, "floor");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      n2[r2] = Math.floor(e2[r2]);
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.sign = function(t3) {
    kh(t3, "x");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      e2[r2] < 0 ? n2[r2] = -1 : e2[r2] > 0 ? n2[r2] = 1 : n2[r2] = 0;
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.isNaN = function(t3) {
    kh(t3, "x");
    for (var e2 = this.readSync(t3.dataId), n2 = new Uint8Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      Number.isNaN(e2[r2]) && (n2[r2] = 1);
    return this.makeOutput(n2, t3.shape, "bool");
  }, o2.prototype.isInf = function(t3) {
    kh(t3, "x");
    for (var e2 = this.readSync(t3.dataId), n2 = new Uint8Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      Math.abs(e2[r2]) === 1 / 0 && (n2[r2] = 1);
    return this.makeOutput(n2, t3.shape, "bool");
  }, o2.prototype.isFinite = function(t3) {
    kh(t3, "x");
    for (var e2 = this.readSync(t3.dataId), n2 = new Uint8Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      Number.isFinite(e2[r2]) && (n2[r2] = 1);
    return this.makeOutput(n2, t3.shape, "bool");
  }, o2.prototype.round = function(t3) {
    kh(t3, "round");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
      var o3 = Math.floor(e2[r2]);
      e2[r2] - o3 < 0.5 ? n2[r2] = Math.floor(e2[r2]) : e2[r2] - o3 > 0.5 ? n2[r2] = Math.ceil(e2[r2]) : n2[r2] = o3 % 2 == 0 ? o3 : o3 + 1;
    }
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.exp = function(t3) {
    kh(t3, "exp");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      n2[r2] = Math.exp(e2[r2]);
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.expm1 = function(t3) {
    kh(t3, "expm1");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      n2[r2] = Math.expm1(e2[r2]);
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.log = function(t3) {
    kh(t3, "log");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
      var o3 = e2[r2];
      n2[r2] = Math.log(o3);
    }
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.log1p = function(t3) {
    kh(t3, "log1p");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
      var o3 = e2[r2];
      n2[r2] = Math.log1p(o3);
    }
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.sqrt = function(t3) {
    kh(t3, "sqrt");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
      var o3 = e2[r2];
      n2[r2] = Math.sqrt(o3);
    }
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.rsqrt = function(t3) {
    kh(t3, "rsqrt");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2) {
      var o3 = e2[r2];
      n2[r2] = 1 / Math.sqrt(o3);
    }
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.reciprocal = function(t3) {
    kh(t3, "reciprocal");
    for (var e2 = this.readSync(t3.dataId), n2 = new Float32Array(e2.length), r2 = 0; r2 < e2.length; ++r2)
      n2[r2] = 1 / e2[r2];
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.linear = function(t3) {
    return t3;
  }, o2.prototype.relu = function(t3) {
    kh(t3, "relu");
    for (var e2 = Pn(t3.shape, t3.dtype), n2 = this.readSync(e2.dataId), r2 = this.readSync(t3.dataId), o3 = 0; o3 < r2.length; ++o3)
      n2[o3] = Math.max(0, r2[o3]);
    return e2;
  }, o2.prototype.relu6 = function(t3) {
    kh(t3, "relu");
    for (var e2 = Pn(t3.shape, t3.dtype), n2 = this.readSync(e2.dataId), r2 = this.readSync(t3.dataId), o3 = 0; o3 < r2.length; ++o3)
      n2[o3] = Math.min(Math.max(0, r2[o3]), 6);
    return e2;
  }, o2.prototype.prelu = function(t3, e2) {
    return kh([t3, e2], "prelu"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
      return t4 < 0 ? e3 * t4 : t4;
    });
  }, o2.prototype.elu = function(t3) {
    kh(t3, "elu");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) {
      var o3 = n2[r2];
      e2[r2] = o3 >= 0 ? o3 : Math.exp(o3) - 1;
    }
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.eluDer = function(t3, e2) {
    kh([t3, e2], "eluDer");
    for (var n2 = new Float32Array(e2.size), r2 = this.readSync(e2.dataId), o3 = this.readSync(t3.dataId), a2 = 0; a2 < r2.length; ++a2) {
      var i2 = r2[a2];
      n2[a2] = i2 >= 1 ? o3[a2] : o3[a2] * (i2 + 1);
    }
    return this.makeOutput(n2, e2.shape, "float32");
  }, o2.prototype.selu = function(t3) {
    kh(t3, "selu");
    for (var e2 = iu, n2 = uu, r2 = new Float32Array(t3.size), o3 = this.readSync(t3.dataId), a2 = 0; a2 < o3.length; ++a2) {
      var i2 = o3[a2];
      r2[a2] = i2 >= 0 ? n2 * i2 : e2 * (Math.exp(i2) - 1);
    }
    return this.makeOutput(r2, t3.shape, "float32");
  }, o2.prototype.clip = function(t3, e2, n2) {
    kh(t3, "clip");
    for (var r2 = new Float32Array(t3.size), o3 = this.readSync(t3.dataId), a2 = 0; a2 < o3.length; ++a2) {
      var i2 = o3[a2];
      r2[a2] = i2 > n2 ? n2 : i2 < e2 ? e2 : i2;
    }
    return this.makeOutput(r2, t3.shape, "float32");
  }, o2.prototype.abs = function(t3) {
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.abs(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.complexAbs = function(t3) {
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < t3.size; ++r2) {
      var o3 = n2[2 * r2], a2 = n2[2 * r2 + 1];
      e2[r2] = Math.hypot(o3, a2);
    }
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.int = function(t3) {
    kh(t3, "int");
    for (var e2 = new Int32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = n2[r2];
    return this.makeOutput(e2, t3.shape, "int32");
  }, o2.prototype.sigmoid = function(t3) {
    kh(t3, "sigmoid");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = 1 / (1 + Math.exp(-n2[r2]));
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.softplus = function(t3) {
    kh(t3, "softplus");
    for (var e2 = Math.log(11920928955078125e-23) + 2, n2 = new Float32Array(t3.size), r2 = this.readSync(t3.dataId), o3 = 0; o3 < r2.length; ++o3) {
      var a2 = r2[o3] > -e2, i2 = r2[o3] < e2, u2 = Math.exp(r2[o3]), s2 = void 0;
      s2 = i2 ? u2 : a2 ? r2[o3] : Math.log(1 + u2), n2[o3] = s2;
    }
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.sin = function(t3) {
    kh(t3, "sin");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.sin(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.cos = function(t3) {
    kh(t3, "cos");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.cos(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.tan = function(t3) {
    kh(t3, "tan");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.tan(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.asin = function(t3) {
    kh(t3, "asin");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.asin(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.acos = function(t3) {
    kh(t3, "acos");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.acos(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.atan = function(t3) {
    kh(t3, "atan");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.atan(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.atan2 = function(t3, e2) {
    return kh([t3, e2], "atan2"), this.broadcastedBinaryOp(t3, e2, t3.dtype, function(t4, e3) {
      return Math.atan2(t4, e3);
    });
  }, o2.prototype.sinh = function(t3) {
    kh(t3, "sinh");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.sinh(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.cosh = function(t3) {
    kh(t3, "cosh");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.cosh(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.tanh = function(t3) {
    kh(t3, "tanh");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = R(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.asinh = function(t3) {
    kh(t3, "asinh");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.asinh(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.acosh = function(t3) {
    kh(t3, "acosh");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.acosh(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.atanh = function(t3) {
    kh(t3, "atanh");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2)
      e2[r2] = Math.atanh(n2[r2]);
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.erf = function(t3) {
    kh(t3, "erf");
    for (var e2 = new Float32Array(t3.size), n2 = this.readSync(t3.dataId), r2 = 0; r2 < n2.length; ++r2) {
      var o3 = Math.sign(n2[r2]), a2 = Math.abs(n2[r2]), i2 = 1 / (1 + 0.3275911 * a2);
      e2[r2] = o3 * (1 - ((((1.061405429 * i2 - 1.453152027) * i2 + 1.421413741) * i2 - 0.284496736) * i2 + 0.254829592) * i2 * Math.exp(-a2 * a2));
    }
    return this.makeOutput(e2, t3.shape, "float32");
  }, o2.prototype.step = function(t3, e2) {
    void 0 === e2 && (e2 = 0), kh(t3, "step");
    for (var n2 = new Float32Array(t3.size), r2 = this.readSync(t3.dataId), o3 = 0; o3 < r2.length; ++o3) {
      var a2 = r2[o3];
      isNaN(a2) ? n2[o3] = NaN : n2[o3] = a2 > 0 ? 1 : e2;
    }
    return this.makeOutput(n2, t3.shape, "float32");
  }, o2.prototype.fusedConv2d = function(t3) {
    var e2 = t3.input, n2 = t3.filter, r2 = t3.convInfo, o3 = t3.bias, a2 = t3.activation, i2 = t3.preluActivationWeights, u2 = this.conv2d(e2, n2, r2);
    return o3 && (u2 = this.add(u2, o3)), a2 && (u2 = Sh(this, u2, a2, i2)), u2;
  }, o2.prototype.conv2d = function(t3, e2, n2) {
    kh([t3, e2], "conv2d");
    for (var r2 = n2.filterHeight, o3 = n2.filterWidth, a2 = n2.dilationHeight, i2 = n2.dilationWidth, u2 = n2.padInfo.left, s2 = n2.padInfo.top, c2 = "channelsLast" === n2.dataFormat, l2 = ur(n2.outShape, t3.dtype), h2 = t3.strides[0], f2 = c2 ? t3.strides[1] : t3.strides[2], p2 = c2 ? t3.strides[2] : 1, d2 = c2 ? 1 : t3.strides[1], v2 = l2.strides[0], m2 = c2 ? l2.strides[1] : l2.strides[2], g2 = c2 ? l2.strides[2] : 1, y2 = c2 ? 1 : l2.strides[1], x2 = this.readSync(t3.dataId), b2 = this.readSync(e2.dataId), w2 = l2.values, C2 = 0; C2 < n2.batchSize; ++C2)
      for (var E2 = C2 * h2, R2 = C2 * v2, I2 = 0; I2 < n2.outHeight; ++I2)
        for (var k2 = R2 + I2 * m2, S2 = I2 * n2.strideHeight - s2, A2 = 0; A2 < r2; A2++) {
          var D2 = S2 + A2 * a2;
          if (!(D2 < 0 || D2 >= n2.inHeight))
            for (var T2 = A2 * e2.strides[0], N2 = E2 + D2 * f2, F2 = 0; F2 < n2.outWidth; ++F2)
              for (var O2 = k2 + F2 * g2, _2 = F2 * n2.strideWidth - u2, M2 = 0; M2 < o3; M2++) {
                var B2 = _2 + M2 * i2;
                if (!(B2 < 0 || B2 >= n2.inWidth))
                  for (var P2 = N2 + B2 * p2, L2 = T2 + M2 * e2.strides[1], W2 = 0; W2 < n2.inChannels; ++W2) {
                    for (var U2 = x2[P2 + W2 * d2], V2 = 0; V2 < n2.outChannels; ++V2)
                      w2[O2 + V2 * y2] += U2 * b2[L2 + V2];
                    L2 += n2.outChannels;
                  }
              }
        }
    return l2.toTensor();
  }, o2.prototype.conv3d = function(t3, e2, n2) {
    for (var r2 = n2.filterDepth, o3 = n2.filterHeight, a2 = n2.filterWidth, i2 = n2.dilationDepth, u2 = n2.dilationHeight, s2 = n2.dilationWidth, c2 = n2.padInfo.front, l2 = n2.padInfo.left, h2 = n2.padInfo.top, f2 = ur(n2.outShape, t3.dtype), p2 = this.readSync(t3.dataId), d2 = this.readSync(e2.dataId), v2 = f2.values, m2 = 0; m2 < n2.batchSize; ++m2)
      for (var g2 = m2 * t3.strides[0], y2 = m2 * f2.strides[0], x2 = 0; x2 < n2.outDepth; ++x2)
        for (var b2 = y2 + x2 * f2.strides[1], w2 = x2 * n2.strideDepth - c2, C2 = 0; C2 < r2; C2++) {
          var E2 = w2 + C2 * i2;
          if (!(E2 < 0 || E2 >= n2.inDepth))
            for (var R2 = C2 * e2.strides[0], I2 = g2 + E2 * t3.strides[1], k2 = 0; k2 < n2.outHeight; ++k2)
              for (var S2 = b2 + k2 * f2.strides[2], A2 = k2 * n2.strideHeight - h2, D2 = 0; D2 < o3; D2++) {
                var T2 = A2 + D2 * u2;
                if (!(T2 < 0 || T2 >= n2.inHeight))
                  for (var N2 = R2 + D2 * e2.strides[1], F2 = I2 + T2 * t3.strides[2], O2 = 0; O2 < n2.outWidth; ++O2)
                    for (var _2 = S2 + O2 * n2.outChannels, M2 = O2 * n2.strideWidth - l2, B2 = 0; B2 < a2; B2++) {
                      var P2 = M2 + B2 * s2;
                      if (!(P2 < 0 || P2 >= n2.inWidth))
                        for (var L2 = N2 + B2 * e2.strides[2], W2 = F2 + P2 * n2.inChannels, U2 = L2, V2 = 0; V2 < n2.inChannels; ++V2) {
                          for (var z2 = p2[W2 + V2], G2 = 0; G2 < n2.outChannels; ++G2)
                            v2[_2 + G2] += z2 * d2[U2 + G2];
                          U2 += n2.outChannels;
                        }
                    }
              }
        }
    return f2.toTensor();
  }, o2.prototype.conv2dDerInput = function(t3, e2, n2) {
    kh([t3, e2], "conv2dDerInput");
    for (var r2 = ur(n2.inShape, "float32"), o3 = r2.values, a2 = this.readSync(t3.dataId), i2 = this.readSync(e2.dataId), u2 = e2.strides, s2 = u2[0], c2 = u2[1], l2 = u2[2], h2 = n2.batchSize, f2 = n2.filterHeight, p2 = n2.filterWidth, d2 = n2.inChannels, v2 = n2.inHeight, m2 = n2.inWidth, g2 = n2.outChannels, y2 = n2.outHeight, x2 = n2.outWidth, b2 = n2.strideHeight, w2 = n2.strideWidth, C2 = n2.dataFormat, E2 = f2 - 1 - n2.padInfo.top, R2 = p2 - 1 - n2.padInfo.left, I2 = "channelsLast" === C2, k2 = r2.strides[0], S2 = I2 ? r2.strides[1] : r2.strides[2], A2 = I2 ? r2.strides[2] : 1, D2 = I2 ? 1 : r2.strides[1], T2 = t3.strides[0], N2 = I2 ? t3.strides[1] : t3.strides[2], F2 = I2 ? t3.strides[2] : 1, O2 = I2 ? 1 : t3.strides[1], _2 = 0; _2 < h2; ++_2)
      for (var M2 = 0; M2 < d2; ++M2)
        for (var B2 = 0; B2 < v2; ++B2)
          for (var P2 = B2 - E2, L2 = Math.max(0, Math.ceil(P2 / b2)), W2 = Math.min(y2, (f2 + P2) / b2), U2 = 0; U2 < m2; ++U2) {
            for (var V2 = U2 - R2, z2 = Math.max(0, Math.ceil(V2 / w2)), G2 = Math.min(x2, (p2 + V2) / w2), H2 = 0, q2 = L2; q2 < W2; ++q2)
              for (var K2 = q2 * b2 - P2, j2 = z2; j2 < G2; ++j2)
                for (var X2 = T2 * _2 + N2 * q2 + F2 * j2, $2 = s2 * (f2 - 1 - K2) + c2 * (p2 - 1 - (j2 * w2 - V2)) + l2 * M2, Y2 = 0; Y2 < g2; ++Y2) {
                  H2 += a2[X2 + O2 * Y2] * i2[$2 + Y2];
                }
            o3[k2 * _2 + S2 * B2 + A2 * U2 + D2 * M2] = H2;
          }
    return r2.toTensor();
  }, o2.prototype.conv3dDerInput = function(t3, e2, n2) {
    for (var r2 = ur(n2.inShape, "float32"), o3 = r2.values, a2 = r2.strides, i2 = a2[0], u2 = a2[1], s2 = a2[2], c2 = a2[3], l2 = this.readSync(t3.dataId), h2 = t3.strides, f2 = h2[0], p2 = h2[1], d2 = h2[2], v2 = h2[3], m2 = this.readSync(e2.dataId), g2 = e2.strides, y2 = g2[0], x2 = g2[1], b2 = g2[2], w2 = g2[3], C2 = n2.batchSize, E2 = n2.filterDepth, R2 = n2.filterHeight, I2 = n2.filterWidth, k2 = n2.inChannels, S2 = n2.inDepth, A2 = n2.inHeight, D2 = n2.inWidth, T2 = n2.outChannels, N2 = n2.outDepth, F2 = n2.outHeight, O2 = n2.outWidth, _2 = n2.strideDepth, M2 = n2.strideHeight, B2 = n2.strideWidth, P2 = E2 - 1 - n2.padInfo.front, L2 = R2 - 1 - n2.padInfo.top, W2 = I2 - 1 - n2.padInfo.left, U2 = 0; U2 < C2; ++U2)
      for (var V2 = 0; V2 < k2; ++V2)
        for (var z2 = 0; z2 < S2; ++z2)
          for (var G2 = z2 - P2, H2 = Math.max(0, Math.ceil(G2 / _2)), q2 = Math.min(N2, (E2 + G2) / _2), K2 = 0; K2 < A2; ++K2)
            for (var j2 = K2 - L2, X2 = Math.max(0, Math.ceil(j2 / M2)), $2 = Math.min(F2, (R2 + j2) / M2), Y2 = 0; Y2 < D2; ++Y2) {
              for (var Q2 = Y2 - W2, J2 = Math.max(0, Math.ceil(Q2 / B2)), Z2 = Math.min(O2, (I2 + Q2) / B2), tt2 = 0, et2 = H2; et2 < q2; ++et2)
                for (var nt2 = et2 * _2 - G2, rt2 = X2; rt2 < $2; ++rt2)
                  for (var ot2 = rt2 * M2 - j2, at2 = J2; at2 < Z2; ++at2)
                    for (var it2 = f2 * U2 + p2 * et2 + d2 * rt2 + v2 * at2, ut2 = y2 * (E2 - 1 - nt2) + x2 * (R2 - 1 - ot2) + b2 * (I2 - 1 - (at2 * B2 - Q2)) + w2 * V2, st2 = 0; st2 < T2; ++st2) {
                      tt2 += l2[it2 + st2] * m2[ut2 + st2];
                    }
              o3[i2 * U2 + u2 * z2 + s2 * K2 + c2 * Y2 + V2] = tt2;
            }
    return r2.toTensor();
  }, o2.prototype.conv2dDerFilter = function(t3, e2, n2) {
    kh([t3, e2], "conv2dDerFilter");
    for (var r2 = n2.strideHeight, o3 = n2.strideWidth, a2 = n2.filterHeight, i2 = n2.filterWidth, u2 = "channelsLast" === n2.dataFormat, s2 = ur(n2.filterShape, "float32"), c2 = n2.padInfo.left, l2 = n2.padInfo.top, h2 = this.bufferSync(t3), f2 = this.bufferSync(e2), p2 = 0; p2 < a2; ++p2)
      for (var d2 = Math.max(0, Math.ceil((l2 - p2) / r2)), v2 = Math.min(n2.outHeight, (n2.inHeight + l2 - p2) / r2), m2 = 0; m2 < i2; ++m2)
        for (var g2 = Math.max(0, Math.ceil((c2 - m2) / o3)), y2 = Math.min(n2.outWidth, (n2.inWidth + c2 - m2) / o3), x2 = 0; x2 < n2.inChannels; ++x2)
          for (var b2 = 0; b2 < n2.outChannels; ++b2) {
            for (var w2 = 0, C2 = 0; C2 < n2.batchSize; ++C2)
              for (var E2 = d2; E2 < v2; ++E2)
                for (var R2 = p2 + E2 * r2 - l2, I2 = g2; I2 < y2; ++I2) {
                  var k2 = m2 + I2 * o3 - c2;
                  w2 += u2 ? h2.get(C2, R2, k2, x2) * f2.get(C2, E2, I2, b2) : h2.get(C2, x2, R2, k2) * f2.get(C2, b2, E2, I2);
                }
            s2.set(w2, p2, m2, x2, b2);
          }
    return s2.toTensor();
  }, o2.prototype.conv3dDerFilter = function(t3, e2, n2) {
    for (var r2 = n2.strideDepth, o3 = n2.strideHeight, a2 = n2.strideWidth, i2 = n2.filterDepth, u2 = n2.filterHeight, s2 = n2.filterWidth, c2 = ur(n2.filterShape, "float32"), l2 = c2.values, h2 = c2.strides, f2 = h2[0], p2 = h2[1], d2 = h2[2], v2 = h2[3], m2 = this.readSync(e2.dataId), g2 = e2.strides, y2 = g2[0], x2 = g2[1], b2 = g2[2], w2 = g2[3], C2 = this.readSync(t3.dataId), E2 = t3.strides, R2 = E2[0], I2 = E2[1], k2 = E2[2], S2 = E2[3], A2 = n2.padInfo.front, D2 = n2.padInfo.left, T2 = n2.padInfo.top, N2 = 0; N2 < i2; ++N2)
      for (var F2 = Math.max(0, Math.ceil((A2 - N2) / r2)), O2 = Math.min(n2.outDepth, (n2.inDepth + A2 - N2) / r2), _2 = N2 * f2, M2 = 0; M2 < u2; ++M2)
        for (var B2 = Math.max(0, Math.ceil((T2 - M2) / o3)), P2 = Math.min(n2.outHeight, (n2.inHeight + T2 - M2) / o3), L2 = M2 * p2 + _2, W2 = 0; W2 < s2; ++W2)
          for (var U2 = Math.max(0, Math.ceil((D2 - W2) / a2)), V2 = Math.min(n2.outWidth, (n2.inWidth + D2 - W2) / a2), z2 = W2 * d2 + L2, G2 = 0; G2 < n2.inChannels; ++G2)
            for (var H2 = G2 * v2 + z2, q2 = 0; q2 < n2.outChannels; ++q2) {
              for (var K2 = 0, j2 = 0; j2 < n2.batchSize; ++j2)
                for (var X2 = j2 * R2, $2 = j2 * y2, Y2 = F2; Y2 < O2; ++Y2)
                  for (var Q2 = (N2 + Y2 * r2 - A2) * I2 + X2, J2 = Y2 * x2 + $2, Z2 = B2; Z2 < P2; ++Z2)
                    for (var tt2 = (M2 + Z2 * o3 - T2) * k2 + Q2, et2 = Z2 * b2 + J2, nt2 = U2; nt2 < V2; ++nt2) {
                      var rt2 = nt2 * w2 + et2;
                      K2 += C2[(W2 + nt2 * a2 - D2) * S2 + tt2 + G2] * m2[rt2 + q2];
                    }
              l2[H2 + q2] = K2;
            }
    return c2.toTensor();
  }, o2.prototype.fusedDepthwiseConv2D = function(t3) {
    var e2 = t3.input, n2 = t3.filter, r2 = t3.convInfo, o3 = t3.bias, a2 = t3.activation, i2 = t3.preluActivationWeights, u2 = this.depthwiseConv2D(e2, n2, r2);
    return o3 && (u2 = this.add(u2, o3)), a2 && (u2 = Sh(this, u2, a2, i2)), u2;
  }, o2.prototype.depthwiseConv2D = function(t3, e2, n2) {
    kh([t3, e2], "depthwiseConv2D");
    for (var r2 = n2.filterHeight, o3 = n2.filterWidth, a2 = n2.dilationHeight, i2 = n2.dilationWidth, u2 = n2.padInfo.left, s2 = n2.padInfo.top, c2 = n2.outChannels / n2.inChannels, l2 = ur(n2.outShape, t3.dtype), h2 = this.readSync(t3.dataId), f2 = this.readSync(e2.dataId), p2 = l2.values, d2 = 0; d2 < n2.batchSize; ++d2)
      for (var v2 = d2 * t3.strides[0], m2 = d2 * l2.strides[0], g2 = 0; g2 < n2.outHeight; ++g2)
        for (var y2 = m2 + g2 * l2.strides[1], x2 = g2 * n2.strideHeight - u2, b2 = 0; b2 < r2; ++b2) {
          var w2 = x2 + b2 * a2;
          if (!(w2 < 0 || w2 >= n2.inHeight))
            for (var C2 = b2 * e2.strides[0], E2 = v2 + w2 * t3.strides[1], R2 = 0; R2 < n2.outWidth; ++R2)
              for (var I2 = y2 + R2 * l2.strides[2], k2 = R2 * n2.strideWidth - s2, S2 = 0; S2 < o3; ++S2) {
                var A2 = k2 + S2 * i2;
                if (!(A2 < 0 || A2 >= n2.inWidth))
                  for (var D2 = C2 + S2 * e2.strides[1], T2 = E2 + A2 * n2.inChannels, N2 = I2, F2 = D2, O2 = 0; O2 < n2.inChannels; ++O2) {
                    for (var _2 = h2[T2 + O2], M2 = 0; M2 < c2; ++M2)
                      p2[N2 + M2] += _2 * f2[F2 + M2];
                    N2 += c2, F2 += c2;
                  }
              }
        }
    return l2.toTensor();
  }, o2.prototype.depthwiseConv2DDerInput = function(t3, e2, n2) {
    kh([t3, e2], "depthwiseConv2DDerInput");
    for (var r2 = ur(n2.inShape, "float32"), o3 = r2.values, a2 = r2.strides, i2 = a2[0], u2 = a2[1], s2 = a2[2], c2 = this.readSync(t3.dataId), l2 = t3.strides, h2 = l2[0], f2 = l2[1], p2 = l2[2], d2 = this.readSync(e2.dataId), v2 = e2.strides, m2 = v2[0], g2 = v2[1], y2 = v2[2], x2 = n2.batchSize, b2 = n2.filterHeight, w2 = n2.filterWidth, C2 = n2.inChannels, E2 = n2.inHeight, R2 = n2.inWidth, I2 = n2.outChannels, k2 = n2.outHeight, S2 = n2.outWidth, A2 = n2.strideHeight, D2 = n2.strideWidth, T2 = b2 - 1 - n2.padInfo.top, N2 = w2 - 1 - n2.padInfo.left, F2 = I2 / C2, O2 = 0; O2 < x2; ++O2)
      for (var _2 = 0; _2 < C2; ++_2)
        for (var M2 = 0; M2 < E2; ++M2)
          for (var B2 = M2 - T2, P2 = Math.max(0, Math.ceil(B2 / A2)), L2 = Math.min(k2, (b2 + B2) / A2), W2 = 0; W2 < R2; ++W2) {
            for (var U2 = W2 - N2, V2 = Math.max(0, Math.ceil(U2 / D2)), z2 = Math.min(S2, (w2 + U2) / D2), G2 = 0, H2 = P2; H2 < L2; ++H2)
              for (var q2 = H2 * A2 - B2, K2 = V2; K2 < z2; ++K2)
                for (var j2 = h2 * O2 + f2 * H2 + p2 * K2, X2 = m2 * (b2 - 1 - q2) + g2 * (w2 - 1 - (K2 * D2 - U2)) + y2 * _2, $2 = 0; $2 < F2; ++$2) {
                  G2 += c2[j2 + (_2 * F2 + $2)] * d2[X2 + $2];
                }
            o3[i2 * O2 + u2 * M2 + s2 * W2 + _2] = G2;
          }
    return r2.toTensor();
  }, o2.prototype.depthwiseConv2DDerFilter = function(t3, e2, n2) {
    kh([t3, e2], "depthwiseConv2DDerFilter");
    for (var r2 = n2.strideHeight, o3 = n2.strideWidth, a2 = n2.filterHeight, i2 = n2.filterWidth, u2 = ur(n2.filterShape, "float32"), s2 = n2.padInfo.left, c2 = n2.padInfo.top, l2 = n2.outChannels / n2.inChannels, h2 = this.bufferSync(t3), f2 = this.bufferSync(e2), p2 = 0; p2 < a2; ++p2)
      for (var d2 = Math.max(0, Math.ceil((c2 - p2) / r2)), v2 = Math.min(n2.outHeight, (n2.inHeight + c2 - p2) / r2), m2 = 0; m2 < i2; ++m2)
        for (var g2 = Math.max(0, Math.ceil((s2 - m2) / o3)), y2 = Math.min(n2.outWidth, (n2.inWidth + s2 - m2) / o3), x2 = 0; x2 < n2.outChannels; ++x2) {
          for (var b2 = Math.trunc(x2 / l2), w2 = x2 % l2, C2 = 0, E2 = 0; E2 < n2.batchSize; ++E2)
            for (var R2 = d2; R2 < v2; ++R2)
              for (var I2 = p2 + R2 * r2 - c2, k2 = g2; k2 < y2; ++k2) {
                var S2 = m2 + k2 * o3 - s2;
                C2 += h2.get(E2, I2, S2, b2) * f2.get(E2, R2, k2, x2);
              }
          u2.set(C2, p2, m2, b2, w2);
        }
    return u2.toTensor();
  }, o2.prototype.tile = function(t3, e2) {
    return kh(t3, "tile"), Lo(this.bufferSync(t3), e2);
  }, o2.prototype.pad = function(t3, e2, n2) {
    kh(t3, "pad");
    var r2 = e2.map(function(e3, n3) {
      return e3[0] + t3.shape[n3] + e3[1];
    }), o3 = e2.map(function(t4) {
      return t4[0];
    }), a2 = this.bufferSync(t3), i2 = ur(r2, t3.dtype);
    0 !== n2 && i2.values.fill(n2);
    for (var u2 = 0; u2 < t3.size; u2++) {
      var s2 = a2.indexToLoc(u2), c2 = s2.map(function(t4, e3) {
        return t4 + o3[e3];
      });
      i2.set.apply(i2, [a2.get.apply(a2, s2)].concat(c2));
    }
    return i2.toTensor();
  }, o2.prototype.transpose = function(t3, e2) {
    kh(t3, "transpose");
    for (var n2 = new Array(t3.rank), r2 = 0; r2 < n2.length; r2++)
      n2[r2] = t3.shape[e2[r2]];
    var o3 = this.readSync(t3.dataId), a2 = ur(n2, t3.dtype), i2 = this.bufferSync(t3);
    for (r2 = 0; r2 < t3.size; ++r2) {
      for (var u2 = i2.indexToLoc(r2), s2 = new Array(u2.length), c2 = 0; c2 < s2.length; c2++)
        s2[c2] = u2[e2[c2]];
      var l2 = a2.locToIndex(s2);
      a2.values[l2] = o3[r2];
    }
    return a2.toTensor();
  }, o2.prototype.gather = function(t3, e2, n2) {
    kh([t3, e2], "gather");
    var r2 = t3.shape.slice(), o3 = this.readSync(e2.dataId);
    r2[n2] = o3.length;
    for (var a2 = ur(r2, t3.dtype), i2 = this.bufferSync(t3), u2 = 0; u2 < a2.size; ++u2) {
      var s2 = a2.indexToLoc(u2), c2 = s2.slice();
      c2[n2] = o3[s2[n2]];
      var l2 = i2.locToIndex(c2);
      a2.values[u2] = i2.values[l2];
    }
    return a2.toTensor();
  }, o2.prototype.batchToSpaceND = function(t3, e2, n2) {
    kh([t3], "batchToSpaceND");
    var r2 = e2.reduce(function(t4, e3) {
      return t4 * e3;
    }), o3 = Mr(t3.shape, e2, r2), a2 = Br(o3.length, e2.length), i2 = Pr(t3.shape, e2, r2), u2 = Lr(n2, e2.length), s2 = Wr(i2, n2, e2.length);
    return t3.reshape(o3).transpose(a2).reshape(i2).slice(u2, s2);
  }, o2.prototype.spaceToBatchND = function(t3, e2, n2) {
    kh([t3], "spaceToBatchND");
    var r2 = e2.reduce(function(t4, e3) {
      return t4 * e3;
    }), o3 = [[0, 0]];
    o3.push.apply(o3, n2);
    for (var a2 = 1 + e2.length; a2 < t3.shape.length; ++a2)
      o3.push([0, 0]);
    var i2 = t3.pad(o3), u2 = Mr(i2.shape, e2, r2, false), s2 = Br(u2.length, e2.length, false), c2 = Pr(i2.shape, e2, r2, false);
    return i2.reshape(u2).transpose(s2).reshape(c2);
  }, o2.prototype.pool = function(t3, e2, n2) {
    kh(t3, "pool");
    for (var r2 = e2.strideHeight, o3 = e2.strideWidth, a2 = e2.dilationHeight, i2 = e2.dilationWidth, u2 = e2.effectiveFilterHeight, s2 = e2.effectiveFilterWidth, c2 = e2.padInfo.top, l2 = e2.padInfo.left, h2 = "max" === n2 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, f2 = this.readSync(t3.dataId), p2 = ur(e2.outShape, t3.dtype), d2 = p2.values, v2 = e2.outShape[1] * e2.outShape[2] * e2.outShape[3], m2 = e2.outShape[2] * e2.outShape[3], g2 = e2.outShape[3], y2 = 0; y2 < e2.batchSize; ++y2)
      for (var x2 = y2 * v2, b2 = y2 * t3.strides[0], w2 = 0; w2 < e2.inChannels; ++w2)
        for (var C2 = 0; C2 < e2.outHeight; ++C2)
          for (var E2 = C2 * r2 - c2, R2 = Math.max(0, E2), I2 = Math.min(e2.inHeight, u2 + E2), k2 = x2 + C2 * m2, S2 = 0; S2 < e2.outWidth; ++S2) {
            for (var A2 = S2 * o3 - l2, D2 = Math.max(0, A2), T2 = Math.min(e2.inWidth, s2 + A2), N2 = h2, F2 = 0, O2 = 0, _2 = R2; _2 < I2; _2 += a2) {
              for (var M2 = b2 + _2 * t3.strides[1], B2 = D2; B2 < T2; B2 += i2) {
                var P2 = f2[M2 + B2 * t3.strides[2] + w2];
                "max" === n2 && P2 > N2 ? N2 = P2 : "avg" === n2 && (F2 += P2, O2++);
              }
              if (isNaN(N2))
                break;
            }
            d2[k2 + S2 * g2 + w2] = "avg" === n2 ? F2 / O2 : N2;
          }
    return p2.toTensor();
  }, o2.prototype.maxPool = function(t3, e2) {
    return this.pool(t3, e2, "max");
  }, o2.prototype.maxPoolPositions = function(t3, e2) {
    for (var n2 = ur(e2.outShape, "int32"), r2 = e2.strideHeight, o3 = e2.strideWidth, a2 = e2.dilationHeight, i2 = e2.dilationWidth, u2 = e2.effectiveFilterHeight, s2 = e2.effectiveFilterWidth, c2 = e2.padInfo.top, l2 = e2.padInfo.left, h2 = this.bufferSync(t3), f2 = 0; f2 < e2.batchSize; ++f2)
      for (var p2 = 0; p2 < e2.inChannels; ++p2)
        for (var d2 = 0; d2 < e2.outHeight; ++d2) {
          for (var v2 = d2 * r2 - c2, m2 = v2; m2 < 0; )
            m2 += a2;
          for (var g2 = Math.min(e2.inHeight, u2 + v2), y2 = 0; y2 < e2.outWidth; ++y2) {
            for (var x2 = y2 * o3 - l2, b2 = x2; b2 < 0; )
              b2 += i2;
            for (var w2 = Math.min(e2.inWidth, s2 + x2), C2 = Number.NEGATIVE_INFINITY, E2 = -1, R2 = m2; R2 < g2; R2 += a2)
              for (var I2 = R2 - v2, k2 = b2; k2 < w2; k2 += i2) {
                var S2 = k2 - x2, A2 = h2.get(f2, R2, k2, p2);
                A2 > C2 && (C2 = A2, E2 = I2 * s2 + S2);
              }
            n2.set(E2, f2, d2, y2, p2);
          }
        }
    return n2.toTensor();
  }, o2.prototype.maxPoolBackprop = function(t3, e2, n2, r2) {
    kh([e2, n2], "maxPoolBackprop");
    for (var o3 = this.maxPoolPositions(e2, r2), a2 = r2.strideHeight, i2 = r2.strideWidth, u2 = r2.dilationHeight, s2 = r2.dilationWidth, c2 = r2.effectiveFilterHeight, l2 = r2.effectiveFilterWidth, h2 = l2 - 1 - r2.padInfo.left, f2 = c2 - 1 - r2.padInfo.top, p2 = ur(e2.shape, "float32"), d2 = this.bufferSync(o3), v2 = this.bufferSync(t3), m2 = 0; m2 < r2.batchSize; ++m2)
      for (var g2 = 0; g2 < r2.inChannels; ++g2)
        for (var y2 = 0; y2 < r2.inHeight; ++y2)
          for (var x2 = 0; x2 < r2.inWidth; ++x2) {
            for (var b2 = y2 - f2, w2 = x2 - h2, C2 = 0, E2 = 0; E2 < c2; E2 += u2) {
              var R2 = (b2 + E2) / a2;
              if (!(R2 < 0 || R2 >= r2.outHeight || Math.floor(R2) !== R2))
                for (var I2 = 0; I2 < l2; I2 += s2) {
                  var k2 = (w2 + I2) / i2;
                  if (!(k2 < 0 || k2 >= r2.outWidth || Math.floor(k2) !== k2)) {
                    var S2 = c2 * l2 - 1 - d2.get(m2, R2, k2, g2) === E2 * l2 + I2 ? 1 : 0;
                    if (0 !== S2)
                      C2 += v2.get(m2, R2, k2, g2) * S2;
                  }
                }
            }
            p2.set(C2, m2, y2, x2, g2);
          }
    return p2.toTensor();
  }, o2.prototype.avgPoolBackprop = function(t3, e2, n2) {
    kh([t3, e2], "avgPoolBackprop");
    for (var r2 = n2.strideHeight, o3 = n2.strideWidth, a2 = n2.filterHeight, i2 = n2.filterWidth, u2 = n2.dilationHeight, s2 = n2.dilationWidth, c2 = n2.effectiveFilterHeight, l2 = n2.effectiveFilterWidth, h2 = l2 - 1 - n2.padInfo.left, f2 = c2 - 1 - n2.padInfo.top, p2 = ur(e2.shape, "float32"), d2 = 1 / (a2 * i2), v2 = this.bufferSync(t3), m2 = 0; m2 < n2.batchSize; ++m2)
      for (var g2 = 0; g2 < n2.inChannels; ++g2)
        for (var y2 = 0; y2 < n2.inHeight; ++y2)
          for (var x2 = 0; x2 < n2.inWidth; ++x2) {
            for (var b2 = y2 - f2, w2 = x2 - h2, C2 = 0, E2 = 0; E2 < c2; E2 += u2) {
              var R2 = (b2 + E2) / r2;
              if (!(R2 < 0 || R2 >= n2.outHeight || Math.floor(R2) !== R2))
                for (var I2 = 0; I2 < l2; I2 += s2) {
                  var k2 = (w2 + I2) / o3;
                  if (!(k2 < 0 || k2 >= n2.outWidth || Math.floor(k2) !== k2))
                    C2 += v2.get(m2, R2, k2, g2);
                }
            }
            p2.set(C2 * d2, m2, y2, x2, g2);
          }
    return p2.toTensor();
  }, o2.prototype.pool3d = function(t3, e2, n2) {
    kh(t3, "pool3d");
    for (var r2 = e2.strideDepth, o3 = e2.strideHeight, a2 = e2.strideWidth, i2 = e2.dilationDepth, u2 = e2.dilationHeight, s2 = e2.dilationWidth, c2 = e2.effectiveFilterDepth, l2 = e2.effectiveFilterHeight, h2 = e2.effectiveFilterWidth, f2 = e2.padInfo.front, p2 = e2.padInfo.top, d2 = e2.padInfo.left, v2 = "max" === n2 ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, m2 = this.readSync(t3.dataId), g2 = ur(e2.outShape, t3.dtype), y2 = g2.values, x2 = e2.outShape[1] * e2.outShape[2] * e2.outShape[3] * e2.outShape[4], b2 = e2.outShape[2] * e2.outShape[3] * e2.outShape[4], w2 = e2.outShape[3] * e2.outShape[4], C2 = e2.outShape[4], E2 = 0; E2 < e2.batchSize; ++E2)
      for (var R2 = E2 * x2, I2 = E2 * t3.strides[0], k2 = 0; k2 < e2.inChannels; ++k2)
        for (var S2 = 0; S2 < e2.outDepth; ++S2) {
          for (var A2 = S2 * r2 - f2, D2 = A2; D2 < 0; )
            D2 += i2;
          for (var T2 = Math.min(e2.inDepth, c2 + A2), N2 = R2 + S2 * b2, F2 = 0; F2 < e2.outHeight; ++F2) {
            for (var O2 = F2 * o3 - p2, _2 = O2; _2 < 0; )
              _2 += u2;
            for (var M2 = Math.min(e2.inHeight, l2 + O2), B2 = N2 + F2 * w2, P2 = 0; P2 < e2.outWidth; ++P2) {
              for (var L2 = P2 * a2 - d2, W2 = L2; W2 < 0; )
                W2 += s2;
              for (var U2 = Math.min(e2.inWidth, h2 + L2), V2 = B2 + P2 * C2, z2 = v2, G2 = 0, H2 = 0, q2 = D2; q2 < T2; q2 += i2) {
                for (var K2 = I2 + q2 * t3.strides[1], j2 = _2; j2 < M2; j2 += u2) {
                  for (var X2 = K2 + j2 * t3.strides[2], $2 = W2; $2 < U2; $2 += s2) {
                    var Y2 = m2[X2 + $2 * t3.strides[3] + k2];
                    if ("max" === n2 && Y2 > z2 ? z2 = Y2 : "avg" === n2 && (G2 += Y2, H2++), isNaN(z2))
                      break;
                  }
                  if (isNaN(z2))
                    break;
                }
                if (isNaN(z2))
                  break;
              }
              y2[V2 + k2] = "avg" === n2 ? G2 / H2 : z2;
            }
          }
        }
    return g2.toTensor();
  }, o2.prototype.avgPool3d = function(t3, e2) {
    return kh(t3, "avgPool3d"), this.pool3d(t3, e2, "avg").toFloat();
  }, o2.prototype.avgPool3dBackprop = function(t3, e2, n2) {
    kh([t3, e2], "avgPool3dBackprop");
    for (var r2 = n2.strideDepth, o3 = n2.strideHeight, a2 = n2.strideWidth, i2 = n2.filterDepth, u2 = n2.filterHeight, s2 = n2.filterWidth, c2 = n2.dilationDepth, l2 = n2.dilationHeight, h2 = n2.dilationWidth, f2 = n2.effectiveFilterDepth, p2 = n2.effectiveFilterHeight, d2 = n2.effectiveFilterWidth, v2 = f2 - 1 - n2.padInfo.front, m2 = d2 - 1 - n2.padInfo.left, g2 = p2 - 1 - n2.padInfo.top, y2 = ur(e2.shape, "float32"), x2 = 1 / (i2 * u2 * s2), b2 = this.bufferSync(t3), w2 = 0; w2 < n2.batchSize; ++w2)
      for (var C2 = 0; C2 < n2.inChannels; ++C2)
        for (var E2 = 0; E2 < n2.inDepth; ++E2)
          for (var R2 = 0; R2 < n2.inHeight; ++R2)
            for (var I2 = 0; I2 < n2.inWidth; ++I2) {
              for (var k2 = E2 - v2, S2 = R2 - g2, A2 = I2 - m2, D2 = 0, T2 = 0; T2 < f2; T2 += c2) {
                var N2 = (k2 + T2) / r2;
                if (!(N2 < 0 || N2 >= n2.outDepth || Math.floor(N2) !== N2))
                  for (var F2 = 0; F2 < p2; F2 += l2) {
                    var O2 = (S2 + F2) / o3;
                    if (!(O2 < 0 || O2 >= n2.outHeight || Math.floor(O2) !== O2))
                      for (var _2 = 0; _2 < d2; _2 += h2) {
                        var M2 = (A2 + _2) / a2;
                        if (!(M2 < 0 || M2 >= n2.outWidth || Math.floor(M2) !== M2))
                          D2 += b2.get(w2, N2, O2, M2, C2);
                      }
                  }
              }
              y2.set(D2 * x2, w2, E2, R2, I2, C2);
            }
    return y2.toTensor();
  }, o2.prototype.maxPool3d = function(t3, e2) {
    return kh(t3, "maxPool3d"), this.pool3d(t3, e2, "max").toFloat();
  }, o2.prototype.maxPool3dPositions = function(t3, e2) {
    for (var n2 = ur(e2.outShape, "int32"), r2 = e2.strideDepth, o3 = e2.strideHeight, a2 = e2.strideWidth, i2 = e2.dilationDepth, u2 = e2.dilationHeight, s2 = e2.dilationWidth, c2 = e2.effectiveFilterDepth, l2 = e2.effectiveFilterHeight, h2 = e2.effectiveFilterWidth, f2 = e2.padInfo.front, p2 = e2.padInfo.top, d2 = e2.padInfo.left, v2 = this.bufferSync(t3), m2 = 0; m2 < e2.batchSize; ++m2)
      for (var g2 = 0; g2 < e2.inChannels; ++g2)
        for (var y2 = 0; y2 < e2.outDepth; ++y2) {
          for (var x2 = y2 * r2 - f2, b2 = x2; b2 < 0; )
            b2 += i2;
          for (var w2 = Math.min(e2.inDepth, c2 + x2), C2 = 0; C2 < e2.outHeight; ++C2) {
            for (var E2 = C2 * o3 - p2, R2 = E2; R2 < 0; )
              R2 += u2;
            for (var I2 = Math.min(e2.inHeight, l2 + E2), k2 = 0; k2 < e2.outWidth; ++k2) {
              for (var S2 = k2 * a2 - d2, A2 = S2; A2 < 0; )
                A2 += s2;
              for (var D2 = Math.min(e2.inWidth, h2 + S2), T2 = Number.NEGATIVE_INFINITY, N2 = -1, F2 = b2; F2 < w2; F2 += i2)
                for (var O2 = F2 - x2, _2 = R2; _2 < I2; _2 += u2)
                  for (var M2 = _2 - E2, B2 = A2; B2 < D2; B2 += s2) {
                    var P2 = B2 - S2, L2 = v2.get(m2, F2, _2, B2, g2);
                    L2 >= T2 && (T2 = L2, N2 = O2 * l2 * h2 + M2 * l2 + P2);
                  }
              n2.set(N2, m2, y2, C2, k2, g2);
            }
          }
        }
    return n2.toTensor();
  }, o2.prototype.maxPool3dBackprop = function(t3, e2, n2, r2) {
    kh([e2, n2], "maxPool3dBackprop");
    for (var o3 = this.maxPool3dPositions(e2, r2), a2 = r2.strideDepth, i2 = r2.strideHeight, u2 = r2.strideWidth, s2 = r2.dilationDepth, c2 = r2.dilationHeight, l2 = r2.dilationWidth, h2 = r2.effectiveFilterDepth, f2 = r2.effectiveFilterHeight, p2 = r2.effectiveFilterWidth, d2 = h2 - 1 - r2.padInfo.front, v2 = p2 - 1 - r2.padInfo.left, m2 = f2 - 1 - r2.padInfo.top, g2 = ur(e2.shape, "float32"), y2 = this.bufferSync(o3), x2 = this.bufferSync(t3), b2 = 0; b2 < r2.batchSize; ++b2)
      for (var w2 = 0; w2 < r2.inChannels; ++w2)
        for (var C2 = 0; C2 < r2.inDepth; ++C2)
          for (var E2 = 0; E2 < r2.inHeight; ++E2)
            for (var R2 = 0; R2 < r2.inWidth; ++R2) {
              for (var I2 = C2 - d2, k2 = E2 - m2, S2 = R2 - v2, A2 = 0, D2 = 0; D2 < h2; D2 += s2) {
                var T2 = (I2 + D2) / a2;
                if (!(T2 < 0 || T2 >= r2.outDepth || Math.floor(T2) !== T2))
                  for (var N2 = 0; N2 < f2; N2 += c2) {
                    var F2 = (k2 + N2) / i2;
                    if (!(F2 < 0 || F2 >= r2.outHeight || Math.floor(F2) !== F2))
                      for (var O2 = 0; O2 < p2; O2 += l2) {
                        var _2 = (S2 + O2) / u2;
                        if (!(_2 < 0 || _2 >= r2.outWidth || Math.floor(_2) !== _2)) {
                          var M2 = h2 * f2 * p2 - 1 - y2.get(b2, T2, F2, _2, w2) === D2 * f2 * p2 + N2 * p2 + O2 ? 1 : 0;
                          if (0 !== M2)
                            A2 += x2.get(b2, T2, F2, _2, w2) * M2;
                        }
                      }
                  }
              }
              g2.set(A2, b2, C2, E2, R2, w2);
            }
    return g2.toTensor();
  }, o2.prototype.cast = function(t3, e2) {
    return So(t3, e2, this);
  }, o2.prototype.reshape = function(t3, e2) {
    return Ao(t3, e2);
  }, o2.prototype.avgPool = function(t3, e2) {
    return kh(t3, "avgPool"), this.pool(t3, e2, "avg").toFloat();
  }, o2.prototype.resizeBilinear = function(t3, e2, n2, r2) {
    kh(t3, "resizeBilinear");
    for (var o3 = t3.shape, a2 = o3[0], i2 = o3[1], u2 = o3[2], s2 = o3[3], c2 = this.readSync(t3.dataId), l2 = new Float32Array(w([a2, e2, n2, s2])), h2 = [r2 && e2 > 1 ? i2 - 1 : i2, r2 && n2 > 1 ? u2 - 1 : u2], f2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2], p2 = 0, d2 = h2[0] / f2[0], v2 = h2[1] / f2[1], m2 = 0; m2 < a2; m2++)
      for (var g2 = 0; g2 < e2; g2++)
        for (var y2 = d2 * g2, x2 = Math.floor(y2), b2 = y2 - x2, C2 = Math.min(i2 - 1, Math.ceil(y2)), E2 = m2 * t3.strides[0] + x2 * t3.strides[1], R2 = m2 * t3.strides[0] + C2 * t3.strides[1], I2 = 0; I2 < n2; I2++)
          for (var k2 = v2 * I2, S2 = Math.floor(k2), A2 = k2 - S2, D2 = Math.min(u2 - 1, Math.ceil(k2)), T2 = E2 + S2 * t3.strides[2], N2 = R2 + S2 * t3.strides[2], F2 = E2 + +D2 * t3.strides[2], O2 = R2 + D2 * t3.strides[2], _2 = 0; _2 < s2; _2++) {
            var M2 = c2[T2 + _2], B2 = c2[N2 + _2], P2 = M2 + (c2[F2 + _2] - M2) * A2, L2 = P2 + (B2 + (c2[O2 + _2] - B2) * A2 - P2) * b2;
            l2[p2++] = L2;
          }
    return kn(l2, [a2, e2, n2, s2]);
  }, o2.prototype.resizeBilinearBackprop = function(t3, e2, n2) {
    kh([t3, e2], "resizeBilinearBackprop");
    for (var r2 = e2.shape, o3 = r2[0], a2 = r2[1], i2 = r2[2], u2 = r2[3], s2 = t3.shape, c2 = s2[1], l2 = s2[2], h2 = new Float32Array(o3 * a2 * i2 * u2), f2 = [n2 && c2 > 1 ? a2 - 1 : a2, n2 && l2 > 1 ? i2 - 1 : i2], p2 = [n2 && c2 > 1 ? c2 - 1 : c2, n2 && l2 > 1 ? l2 - 1 : l2], d2 = f2[0] / p2[0], v2 = f2[1] / p2[1], m2 = this.readSync(t3.dataId), g2 = 0, y2 = 0; y2 < o3; y2++)
      for (var x2 = y2 * e2.strides[0], b2 = 0; b2 < c2; b2++)
        for (var w2 = b2 * d2, C2 = Math.floor(w2), E2 = Math.min(Math.ceil(w2), a2 - 1), R2 = x2 + C2 * e2.strides[1], I2 = x2 + E2 * e2.strides[1], k2 = w2 - C2, S2 = 1 - k2, A2 = 0; A2 < l2; A2++)
          for (var D2 = A2 * v2, T2 = Math.floor(D2), N2 = Math.min(Math.ceil(D2), i2 - 1), F2 = D2 - T2, O2 = 1 - F2, _2 = R2 + T2 * e2.strides[2], M2 = R2 + N2 * e2.strides[2], B2 = I2 + T2 * e2.strides[2], P2 = I2 + N2 * e2.strides[2], L2 = S2 * O2, W2 = S2 * F2, U2 = k2 * O2, V2 = k2 * F2, z2 = 0; z2 < u2; z2++) {
            var G2 = m2[g2++];
            h2[_2 + z2] += G2 * L2, h2[M2 + z2] += G2 * W2, h2[B2 + z2] += G2 * U2, h2[P2 + z2] += G2 * V2;
          }
    return Fn(h2, [o3, i2, a2, u2], e2.dtype);
  }, o2.prototype.resizeNearestNeighbor = function(t3, e2, n2, r2) {
    kh(t3, "resizeNearestNeighbor");
    for (var o3 = t3.shape, a2 = o3[0], i2 = o3[1], u2 = o3[2], s2 = o3[3], c2 = this.readSync(t3.dataId), l2 = new Float32Array(a2 * e2 * n2 * s2), h2 = [r2 && e2 > 1 ? i2 - 1 : i2, r2 && n2 > 1 ? u2 - 1 : u2], f2 = [r2 && e2 > 1 ? e2 - 1 : e2, r2 && n2 > 1 ? n2 - 1 : n2], p2 = h2[0] / f2[0], d2 = h2[1] / f2[1], v2 = 0, m2 = 0; m2 < a2; m2++)
      for (var g2 = m2 * t3.strides[0], y2 = 0; y2 < e2; y2++)
        for (var x2 = p2 * y2, b2 = g2 + Math.min(i2 - 1, r2 ? Math.round(x2) : Math.floor(x2)) * t3.strides[1], w2 = 0; w2 < n2; w2++)
          for (var C2 = d2 * w2, E2 = b2 + Math.min(u2 - 1, r2 ? Math.round(C2) : Math.floor(C2)) * t3.strides[2], R2 = 0; R2 < s2; R2++) {
            var I2 = c2[E2 + R2];
            l2[v2++] = I2;
          }
    return kn(l2, [a2, e2, n2, s2], t3.dtype);
  }, o2.prototype.resizeNearestNeighborBackprop = function(t3, e2, n2) {
    kh([t3, e2], "resizeNearestNeighborBackprop");
    for (var r2 = e2.shape, o3 = r2[0], a2 = r2[1], i2 = r2[2], u2 = r2[3], s2 = t3.shape, c2 = s2[1], l2 = s2[2], h2 = new Float32Array(o3 * a2 * i2 * u2), f2 = this.readSync(t3.dataId), p2 = [n2 && c2 > 1 ? a2 - 1 : a2, n2 && l2 > 1 ? i2 - 1 : i2], d2 = [n2 && c2 > 1 ? c2 - 1 : c2, n2 && l2 > 1 ? l2 - 1 : l2], v2 = p2[0] / d2[0], m2 = p2[1] / d2[1], g2 = 1 / v2, y2 = 1 / m2, x2 = 2 * Math.ceil(g2) + 2, b2 = 2 * Math.ceil(y2) + 2, w2 = 0; w2 < o3; w2++)
      for (var C2 = w2 * e2.strides[0], E2 = 0; E2 < a2; E2++)
        for (var R2 = C2 + E2 * e2.strides[1], I2 = Math.floor(E2 * g2), k2 = Math.floor(I2 - x2 / 2), S2 = 0; S2 < i2; S2++)
          for (var A2 = R2 + S2 * e2.strides[2], D2 = Math.floor(S2 * y2), T2 = Math.floor(D2 - b2 / 2), N2 = 0; N2 < u2; N2++) {
            for (var F2 = 0, O2 = 0; O2 < x2; O2++) {
              var _2 = O2 + k2;
              if (!(_2 < 0 || _2 >= c2)) {
                var M2 = C2 + _2 * t3.strides[1], B2 = _2 * v2;
                if (E2 === Math.min(a2 - 1, n2 ? Math.round(B2) : Math.floor(B2)))
                  for (var P2 = 0; P2 < b2; P2++) {
                    var L2 = P2 + T2;
                    if (!(L2 < 0 || L2 >= l2)) {
                      var W2 = M2 + L2 * t3.strides[2], U2 = L2 * m2;
                      S2 === Math.min(i2 - 1, n2 ? Math.round(U2) : Math.floor(U2)) && (F2 += f2[W2 + N2]);
                    }
                  }
              }
            }
            h2[A2 + N2] = F2;
          }
    return Fn(h2, e2.shape, e2.dtype);
  }, o2.prototype.batchNormalization = function(t3, e2, n2, r2, o3, a2) {
    kh([t3, e2, n2, o3, a2], "batchNorm");
    for (var i2 = this.readSync(t3.dataId), u2 = this.readSync(e2.dataId), s2 = this.readSync(n2.dataId), c2 = o3 ? this.readSync(o3.dataId) : new Float32Array([1]), l2 = a2 ? this.readSync(a2.dataId) : new Float32Array([0]), h2 = new Float32Array(i2.length), f2 = l2.length, p2 = c2.length, d2 = s2.length, v2 = u2.length, m2 = 0, g2 = 0, y2 = 0, x2 = 0, b2 = 0; b2 < i2.length; ++b2)
      h2[b2] = l2[m2++] + (i2[b2] - u2[g2++]) * c2[y2++] / Math.sqrt(s2[x2++] + r2), m2 >= f2 && (m2 = 0), g2 >= v2 && (g2 = 0), y2 >= p2 && (y2 = 0), x2 >= d2 && (x2 = 0);
    return Fn(h2, t3.shape);
  }, o2.prototype.localResponseNormalization4D = function(t3, e2, n2, r2, o3) {
    kh(t3, "localResponseNormalization4D");
    var a2 = t3.shape[3], i2 = a2 - 1, u2 = this.readSync(t3.dataId), s2 = t3.size, c2 = new Float32Array(s2);
    function l2(t4) {
      for (var n3 = t4 % a2, r3 = t4 - n3 + Math.max(0, n3 - e2), o4 = t4 - n3 + Math.min(n3 + e2, i2), s3 = 0; r3 <= o4; r3++) {
        var c3 = u2[r3];
        s3 += c3 * c3;
      }
      return s3;
    }
    for (var h2 = 0; h2 < s2; h2++) {
      var f2 = l2(h2), p2 = u2[h2] * Math.pow(n2 + r2 * f2, -o3);
      c2[h2] = p2;
    }
    return Fn(c2, t3.shape);
  }, o2.prototype.LRNGrad = function(t3, e2, n2, r2, o3, a2, i2) {
    kh(t3, "LRNGrad");
    for (var u2 = t3.shape[3], s2 = this.readSync(t3.dataId), c2 = this.readSync(e2.dataId), l2 = this.readSync(n2.dataId), h2 = new Float32Array(t3.size), f2 = t3.size, p2 = 0; p2 < f2; p2++) {
      for (var d2 = p2 % u2, v2 = p2 - d2 + Math.max(0, d2 - r2), m2 = p2 - d2 + Math.min(u2, d2 + r2 + 1), g2 = 0, y2 = v2; y2 < m2; y2++)
        g2 += Math.pow(c2[y2], 2);
      g2 = a2 * g2 + o3;
      for (y2 = v2; y2 < m2; y2++) {
        var x2 = -2 * a2 * i2 * c2[y2] * l2[p2] / g2;
        p2 === y2 && (x2 += Math.pow(g2, -i2)), x2 *= s2[p2], h2[y2] += x2;
      }
    }
    return Fn(h2, t3.shape);
  }, o2.prototype.multinomial = function(t3, e2, n2, r2) {
    kh(t3, "multinomial");
    for (var o3 = e2 ? t3 : io(t3), a2 = o3.shape[0], i2 = o3.shape[1], u2 = Pn([a2, n2], "int32"), s2 = this.readSync(u2.dataId), c2 = this.readSync(o3.dataId), l2 = 0; l2 < a2; ++l2) {
      var h2 = l2 * i2, f2 = new Float32Array(i2 - 1);
      f2[0] = c2[h2];
      for (var p2 = 1; p2 < f2.length; ++p2)
        f2[p2] = f2[p2 - 1] + c2[h2 + p2];
      for (var d2 = rr(r2.toString()), v2 = l2 * n2, m2 = 0; m2 < n2; ++m2) {
        var g2 = d2();
        s2[v2 + m2] = f2.length;
        for (var y2 = 0; y2 < f2.length; y2++)
          if (g2 < f2[y2]) {
            s2[v2 + m2] = y2;
            break;
          }
      }
    }
    return u2;
  }, o2.prototype.oneHot = function(t3, e2, n2, r2) {
    kh(t3, "oneHot");
    var o3 = new Float32Array(t3.size * e2);
    o3.fill(r2);
    for (var a2 = this.readSync(t3.dataId), i2 = 0; i2 < t3.size; ++i2)
      a2[i2] >= 0 && a2[i2] < e2 && (o3[i2 * e2 + a2[i2]] = n2);
    return Tn(o3, [t3.size, e2], "int32");
  }, o2.prototype.nonMaxSuppression = function(t3, e2, n2, r2, o3) {
    return kh(t3, "nonMaxSuppression"), Mo(this.readSync(t3.dataId), this.readSync(e2.dataId), n2, r2, o3);
  }, o2.prototype.fft = function(t3) {
    return this.fftBatch(t3, false);
  }, o2.prototype.ifft = function(t3) {
    return this.fftBatch(t3, true);
  }, o2.prototype.fftBatch = function(t3, e2) {
    for (var n2 = t3.shape[0], r2 = t3.shape[1], o3 = ur(t3.shape, "float32"), a2 = ur(t3.shape, "float32"), i2 = Rn(t3).as2D(n2, r2), u2 = In(t3).as2D(n2, r2), s2 = 0; s2 < n2; s2++)
      for (var c2 = i2.slice([s2, 0], [1, r2]), l2 = u2.slice([s2, 0], [1, r2]), h2 = En(c2, l2), f2 = this.readSync(this.fftImpl(h2, e2).dataId), p2 = 0; p2 < r2; p2++) {
        var d2 = Fo(f2, p2);
        o3.values[s2 * r2 + p2] = d2.real, a2.values[s2 * r2 + p2] = d2.imag;
      }
    return En(o3.toTensor(), a2.toTensor()).as2D(n2, r2);
  }, o2.prototype.fftImpl = function(t3, e2) {
    var n2 = t3.as1D(), r2 = n2.size;
    if (this.isExponentOf2(r2)) {
      var o3 = this.fftRadix2(n2, r2, e2).as2D(t3.shape[0], t3.shape[1]);
      return e2 && (o3 = En(Rn(o3).div(An(r2)), In(o3).div(An(r2)))), o3;
    }
    var a2 = this.readSync(t3.dataId), i2 = function(t4) {
      for (var e3 = new Float32Array(t4.length / 2), n3 = new Float32Array(t4.length / 2), r3 = 0; r3 < t4.length; r3 += 2)
        e3[r3 / 2] = t4[r3], n3[r3 / 2] = t4[r3 + 1];
      return {real: e3, imag: n3};
    }(this.fourierTransformByMatmul(a2, r2, e2));
    return En(i2.real, i2.imag).as2D(t3.shape[0], t3.shape[1]);
  }, o2.prototype.isExponentOf2 = function(t3) {
    return 0 == (t3 & t3 - 1);
  }, o2.prototype.fftRadix2 = function(t3, e2, n2) {
    if (1 === e2)
      return t3;
    var r2 = this.readSync(t3.dataId), o3 = e2 / 2, a2 = function(t4) {
      for (var e3 = Math.ceil(t4.length / 4), n3 = new Float32Array(e3), r3 = new Float32Array(e3), o4 = 0; o4 < t4.length; o4 += 4)
        n3[Math.floor(o4 / 4)] = t4[o4], r3[Math.floor(o4 / 4)] = t4[o4 + 1];
      return {real: n3, imag: r3};
    }(r2), i2 = En(a2.real, a2.imag).as1D(), u2 = function(t4) {
      for (var e3 = Math.floor(t4.length / 4), n3 = new Float32Array(e3), r3 = new Float32Array(e3), o4 = 2; o4 < t4.length; o4 += 4)
        n3[Math.floor(o4 / 4)] = t4[o4], r3[Math.floor(o4 / 4)] = t4[o4 + 1];
      return {real: n3, imag: r3};
    }(r2), s2 = En(u2.real, u2.imag).as1D();
    i2 = this.fftRadix2(i2, o3, n2), s2 = this.fftRadix2(s2, o3, n2);
    var c2 = function(t4, e3) {
      for (var n3 = new Float32Array(t4 / 2), r3 = new Float32Array(t4 / 2), o4 = 0; o4 < Math.ceil(t4 / 2); o4++) {
        var a3 = (e3 ? 2 : -2) * Math.PI * (o4 / t4);
        n3[o4] = Math.cos(a3), r3[o4] = Math.sin(a3);
      }
      return {real: n3, imag: r3};
    }(e2, n2), l2 = En(c2.real, c2.imag).mul(s2), h2 = i2.add(l2), f2 = i2.sub(l2), p2 = Rn(h2).concat(Rn(f2)), d2 = In(h2).concat(In(f2));
    return En(p2, d2).as1D();
  }, o2.prototype.fourierTransformByMatmul = function(t3, e2, n2) {
    for (var r2 = new Float32Array(2 * e2), o3 = 0; o3 < e2; o3++) {
      for (var a2 = 0, i2 = 0, u2 = 0; u2 < e2; u2++) {
        var s2 = _o(o3 * u2, e2, n2), c2 = Fo(t3, u2);
        a2 += c2.real * s2.real - c2.imag * s2.imag, i2 += c2.real * s2.imag + c2.imag * s2.real;
      }
      n2 && (a2 /= e2, i2 /= e2), Oo(r2, a2, i2, o3);
    }
    return r2;
  }, o2.prototype.depthToSpace = function(t3, e2, n2) {
    g("NHWC" === n2, function() {
      return "Only NHWC dataFormat supported on CPU for depthToSpace. Got " + n2;
    }), g(e2 > 1, function() {
      return "blockSize should be > 1 for depthToSpace, but was: " + e2;
    });
    for (var r2 = t3.shape[0], o3 = t3.shape[1], a2 = t3.shape[2], i2 = t3.shape[3], u2 = o3 * e2, s2 = a2 * e2, c2 = i2 / (e2 * e2), l2 = this.readSync(t3.dataId), h2 = new Float32Array(r2 * u2 * s2 * c2), f2 = 0, p2 = 0; p2 < r2; ++p2)
      for (var d2 = 0; d2 < u2; ++d2)
        for (var v2 = Math.floor(d2 / e2), m2 = d2 % e2, y2 = 0; y2 < s2; ++y2)
          for (var x2 = Math.floor(y2 / e2), b2 = (m2 * e2 + y2 % e2) * c2, w2 = 0; w2 < c2; ++w2) {
            var C2 = w2 + b2 + i2 * (x2 + a2 * (v2 + o3 * p2));
            h2[f2++] = l2[C2];
          }
    return Fn(h2, [r2, u2, s2, c2]);
  }, o2.prototype.broadcastedBinaryOp = function(t3, e2, n2, r2) {
    var o3 = po(t3.shape, e2.shape), a2 = ur(o3, n2), i2 = this.readSync(t3.dataId), u2 = this.readSync(e2.dataId), s2 = ho(t3.shape, o3), c2 = ho(e2.shape, o3), l2 = a2.values;
    if (s2.length + c2.length === 0)
      for (var h2 = 0; h2 < l2.length; ++h2)
        l2[h2] = r2(i2[h2 % i2.length], u2[h2 % u2.length]);
    else {
      var f2 = this.bufferSync(t3), p2 = this.bufferSync(e2), d2 = function(n3) {
        var o4 = a2.indexToLoc(n3), h3 = o4.slice(-t3.rank);
        s2.forEach(function(t4) {
          return h3[t4] = 0;
        });
        var d3 = f2.locToIndex(h3), v2 = o4.slice(-e2.rank);
        c2.forEach(function(t4) {
          return v2[t4] = 0;
        });
        var m2 = p2.locToIndex(v2);
        l2[n3] = r2(i2[d3], u2[m2]);
      };
      for (h2 = 0; h2 < l2.length; ++h2)
        d2(h2);
    }
    return a2.toTensor();
  }, o2.prototype.broadcastedBinaryComplexOp = function(t3, e2, n2) {
    var r2 = po(t3.shape, e2.shape), o3 = ur(r2, "float32"), a2 = ur(r2, "float32"), i2 = this.readSync(t3.dataId), u2 = this.readSync(e2.dataId), s2 = ho(t3.shape, r2), c2 = ho(e2.shape, r2), l2 = o3.values, h2 = a2.values;
    if (s2.length + c2.length === 0)
      for (var f2 = 0; f2 < l2.length; f2++) {
        var p2 = f2 % i2.length, d2 = f2 % u2.length, v2 = n2(i2[2 * p2], i2[2 * p2 + 1], u2[2 * d2], u2[2 * d2 + 1]);
        l2[f2] = v2.real, h2[f2] = v2.imag;
      }
    else {
      var m2 = this.bufferSync(this.data.get(t3.dataId).complexTensors.real), g2 = this.bufferSync(this.data.get(e2.dataId).complexTensors.real), y2 = function(r3) {
        var a3 = o3.indexToLoc(r3), f3 = a3.slice(-t3.rank);
        s2.forEach(function(t4) {
          return f3[t4] = 0;
        });
        var p3 = m2.locToIndex(f3), d3 = a3.slice(-e2.rank);
        c2.forEach(function(t4) {
          return d3[t4] = 0;
        });
        var v3 = g2.locToIndex(d3), y3 = n2(i2[2 * p3], i2[2 * p3 + 1], u2[2 * v3], u2[2 * v3 + 1]);
        l2[r3] = y3.real, h2[r3] = y3.imag;
      };
      for (f2 = 0; f2 < l2.length; f2++)
        y2(f2);
    }
    return this.complex(o3.toTensor(), a2.toTensor());
  }, o2.prototype.split = function(t3, e2, n2) {
    return Po(t3, e2, n2);
  }, o2.prototype.dispose = function() {
  }, o2.prototype.floatPrecision = function() {
    return 32;
  }, o2.prototype.epsilon = function() {
    return 1e-7;
  }, o2.prototype.cropAndResize = function(t3, e2, n2, r2, o3, a2) {
    for (var i2 = t3.shape, u2 = i2[0], s2 = i2[1], c2 = i2[2], l2 = i2[3], h2 = e2.shape[0], f2 = r2[0], p2 = r2[1], d2 = ur([h2, f2, p2, l2], t3.dtype), v2 = this.readSync(e2.dataId), m2 = this.readSync(n2.dataId), g2 = this.readSync(t3.dataId), y2 = t3.strides, x2 = d2.strides, b2 = 0; b2 < h2; b2++) {
      var w2 = 4 * b2, C2 = v2[w2], E2 = v2[w2 + 1], R2 = v2[w2 + 2], I2 = v2[w2 + 3], k2 = m2[b2];
      if (!(k2 >= u2))
        for (var S2 = f2 > 1 ? (R2 - C2) * (s2 - 1) / (f2 - 1) : 0, A2 = p2 > 1 ? (I2 - E2) * (c2 - 1) / (p2 - 1) : 0, D2 = 0; D2 < f2; D2++) {
          var T2 = f2 > 1 ? C2 * (s2 - 1) + D2 * S2 : 0.5 * (C2 + R2) * (s2 - 1);
          if (T2 < 0 || T2 > s2 - 1)
            for (var N2 = 0; N2 < p2; N2++)
              for (var F2 = 0; F2 < l2; F2++) {
                var O2 = F2 + N2 * x2[2] + D2 * x2[1] + b2 * x2[0];
                d2.values[O2] = a2;
              }
          else if ("bilinear" === o3) {
            var _2 = Math.floor(T2), M2 = Math.ceil(T2), B2 = T2 - _2;
            for (N2 = 0; N2 < p2; N2++) {
              if ((q2 = p2 > 1 ? E2 * (c2 - 1) + N2 * A2 : 0.5 * (E2 + I2) * (c2 - 1)) < 0 || q2 > c2 - 1)
                for (F2 = 0; F2 < l2; F2++) {
                  O2 = F2 + N2 * x2[2] + D2 * x2[1] + b2 * x2[0];
                  d2.values[O2] = a2;
                }
              else {
                var P2 = Math.floor(q2), L2 = Math.ceil(q2), W2 = q2 - P2;
                for (F2 = 0; F2 < l2; F2++) {
                  var U2 = g2[O2 = F2 + P2 * y2[2] + _2 * y2[1] + k2 * y2[0]], V2 = g2[O2 = F2 + L2 * y2[2] + _2 * y2[1] + k2 * y2[0]], z2 = g2[O2 = F2 + P2 * y2[2] + M2 * y2[1] + k2 * y2[0]], G2 = U2 + (V2 - U2) * W2, H2 = z2 + (g2[O2 = F2 + L2 * y2[2] + M2 * y2[1] + k2 * y2[0]] - z2) * W2;
                  O2 = F2 + N2 * x2[2] + D2 * x2[1] + b2 * x2[0], d2.values[O2] = G2 + (H2 - G2) * B2;
                }
              }
            }
          } else
            for (N2 = 0; N2 < p2; ++N2) {
              var q2;
              if ((q2 = p2 > 1 ? E2 * (c2 - 1) + N2 * A2 : 0.5 * (E2 + I2) * (c2 - 1)) < 0 || q2 > c2 - 1)
                for (F2 = 0; F2 < l2; F2++) {
                  O2 = F2 + N2 * x2[2] + D2 * x2[1] + b2 * x2[0];
                  d2.values[O2] = a2;
                }
              else {
                var K2 = Math.round(q2), j2 = Math.round(T2);
                for (F2 = 0; F2 < l2; F2++) {
                  var X2 = F2 + K2 * y2[2] + j2 * y2[1] + k2 * y2[0], $2 = F2 + N2 * x2[2] + D2 * x2[1] + b2 * x2[0];
                  d2.values[$2] = g2[X2];
                }
              }
            }
        }
    }
    return d2.toTensor();
  }, o2.prototype.sparseToDense = function(t3, e2, n2, r2) {
    var o3 = Hr(0, t3, n2), a2 = o3.sliceRank, i2 = o3.numUpdates, u2 = o3.sliceSize, s2 = o3.strides, c2 = o3.outputSize;
    return this.scatter(t3, e2, n2, c2, u2, i2, a2, s2, r2, false);
  }, o2.prototype.gatherND = function(t3, e2) {
    var n2 = e2.shape, r2 = n2[n2.length - 1], o3 = Ur(t3, e2), a2 = o3[0], i2 = o3[1], u2 = o3[2], s2 = o3[3];
    if (0 === i2)
      return kn([], a2, t3.dtype);
    for (var c2 = new lt([i2, u2], t3.dtype), l2 = this.readSync(e2.dataId), h2 = this.readSync(t3.dataId), f2 = 0; f2 < i2; f2++) {
      for (var p2 = [], d2 = 0, v2 = 0; v2 < r2; v2++) {
        var m2 = l2[f2 * r2 + v2];
        d2 += m2 * s2[v2], p2.push(m2);
      }
      if (d2 < 0 || d2 >= t3.size / u2)
        throw new Error("Invalid indices: " + p2 + " does not index into " + t3.shape);
      for (var g2 = 0; g2 < u2; g2++)
        c2.values[f2 * u2 + g2] = h2[d2 * u2 + g2];
    }
    return c2.toTensor().reshape(a2);
  }, o2.prototype.scatterND = function(t3, e2, n2) {
    var r2 = Hr(0, t3, n2), o3 = r2.sliceRank, a2 = r2.numUpdates, i2 = r2.sliceSize, u2 = r2.strides, s2 = r2.outputSize, c2 = An(0);
    return this.scatter(t3, e2, n2, s2, i2, a2, o3, u2, c2, true);
  }, o2.prototype.fill = function(t3, e2, n2) {
    var r2 = F(n2 = n2 || z(e2), w(t3));
    return r2.fill(e2), Nt.makeTensor(r2, t3, n2, this);
  }, o2.prototype.onesLike = function(t3) {
    if ("string" === t3.dtype)
      throw new Error("onesLike is not supported for string tensors");
    return this.fill(t3.shape, 1, t3.dtype);
  }, o2.prototype.zerosLike = function(t3) {
    var e2 = F(t3.dtype, w(t3.shape));
    return this.makeOutput(e2, t3.shape, t3.dtype);
  }, o2.prototype.linspace = function(t3, e2, n2) {
    return Do(t3, e2, n2);
  }, o2.prototype.scatter = function(t3, e2, n2, r2, o3, a2, i2, u2, s2, c2) {
    var l2 = [r2 / o3, o3], h2 = this.readSync(t3.dataId), f2 = this.readSync(e2.dataId);
    if (0 === r2)
      return kn([], n2, e2.dtype);
    var p2 = new lt(l2, e2.dtype);
    p2.values.fill(this.readSync(s2.dataId)[0]);
    for (var d2 = 0; d2 < a2; d2++) {
      for (var v2 = [], m2 = 0, g2 = 0; g2 < i2; g2++) {
        var y2 = h2[d2 * i2 + g2];
        v2.push(y2), m2 += y2 * u2[g2];
      }
      if (m2 < 0 || m2 >= r2 / o3)
        throw new Error("Invalid indices: " + v2 + " does not index into " + n2);
      for (var x2 = 0; x2 < o3; x2++)
        c2 ? p2.values[m2 * o3 + x2] += f2[d2 * o3 + x2] : p2.values[m2 * o3 + x2] = 0 === e2.rank ? f2[0] : f2[d2 * o3 + x2];
    }
    return p2.toTensor().reshape(n2);
  }, o2;
}(co);
Nt.registerBackend("cpu", function() {
  return new Ah();
}, 1), l({kernelName: "Square", backendName: "cpu", kernelFunc: function(t2) {
  var e2 = t2.inputs, n2 = t2.backend, r2 = e2.x, o2 = n2;
  kh(r2, "square");
  for (var a2 = o2.data.get(r2.dataId).values, i2 = new Float32Array(a2.length), u2 = 0; u2 < a2.length; ++u2) {
    var s2 = a2[u2];
    i2[u2] = s2 * s2;
  }
  return {dataId: o2.write(i2, r2.shape, r2.dtype), shape: r2.shape, dtype: r2.dtype};
}}), l({kernelName: "Square", backendName: "webgl", kernelFunc: function(t2) {
  var e2 = t2.inputs, n2 = t2.backend, r2 = e2.x, o2 = n2, a2 = new su(r2.shape, "return x * x;");
  return o2.runWebGLProgram(a2, [r2], r2.dtype);
}});
var Dh = function() {
  function t2() {
  }
  return t2.prototype.fetch = function(t3, e2) {
    return fetch(t3, e2);
  }, t2.prototype.now = function() {
    return performance.now();
  }, t2.prototype.encode = function(t3, e2) {
    if ("utf-8" !== e2 && "utf8" !== e2)
      throw new Error("Browser's encoder only supports utf-8, but got " + e2);
    return null == this.textEncoder && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(t3);
  }, t2.prototype.decode = function(t3, e2) {
    return new TextDecoder(e2).decode(t3);
  }, t2;
}();
a().get("IS_BROWSER") && a().setPlatform("browser", new Dh());
var Th;
var Nh = function() {
  return require_index_es();
};
var Fh = function() {
  function t2() {
    this.util = require("util"), this.textEncoder = new this.util.TextEncoder();
  }
  return t2.prototype.fetch = function(t3, e2) {
    return null != a().global.fetch ? a().global.fetch(t3, e2) : (null == Th && (Th = Nh()), Th(t3, e2));
  }, t2.prototype.now = function() {
    var t3 = process.hrtime();
    return 1e3 * t3[0] + t3[1] / 1e6;
  }, t2.prototype.encode = function(t3, e2) {
    if ("utf-8" !== e2 && "utf8" !== e2)
      throw new Error("Node built-in encoder only supports utf-8, but got " + e2);
    return this.textEncoder.encode(t3);
  }, t2.prototype.decode = function(t3, e2) {
    return 0 === t3.length ? "" : new this.util.TextDecoder(e2).decode(t3);
  }, t2;
}();
a().get("IS_NODE") && a().setPlatform("node", new Fh());
var Oh = {float32: 4, int32: 4, uint16: 2, uint8: 1, bool: 1};
var _h = 4;
function Mh(t2, e2) {
  for (var n2 = {}, r2 = 0, o2 = function(e3) {
    var o3 = e3.name, a3 = e3.dtype, i3 = e3.shape, u2 = w(i3), s2 = void 0;
    if ("quantization" in e3) {
      var c2 = e3.quantization;
      if ("uint8" !== c2.dtype && "uint16" !== c2.dtype)
        throw new Error("Weight " + e3.name + " has unknown quantization dtype " + c2.dtype + ". Supported quantization dtypes are: 'uint8' and 'uint16'.");
      var l2 = Oh[c2.dtype], h2 = t2.slice(r2, r2 + u2 * l2), f2 = "uint8" === c2.dtype ? new Uint8Array(h2) : new Uint16Array(h2);
      if ("float32" === a3)
        s2 = Float32Array.from(f2, function(t3) {
          return t3 * c2.scale + c2.min;
        });
      else {
        if ("int32" !== a3)
          throw new Error("Unsupported dtype in weight '" + o3 + "': " + a3);
        s2 = Int32Array.from(f2, function(t3) {
          return Math.round(t3 * c2.scale + c2.min);
        });
      }
      r2 += u2 * l2;
    } else if ("string" === a3) {
      var p2 = w(e3.shape);
      s2 = [];
      for (var d2 = 0; d2 < p2; d2++) {
        var v2 = new Uint32Array(t2.slice(r2, r2 + _h))[0];
        r2 += _h;
        var m2 = new Uint8Array(t2.slice(r2, r2 + v2));
        s2.push(m2), r2 += v2;
      }
    } else {
      var g2 = Oh[a3];
      h2 = t2.slice(r2, r2 + u2 * g2);
      if ("float32" === a3)
        s2 = new Float32Array(h2);
      else if ("int32" === a3)
        s2 = new Int32Array(h2);
      else {
        if ("bool" !== a3)
          throw new Error("Unsupported dtype in weight '" + o3 + "': " + a3);
        s2 = new Uint8Array(h2);
      }
      r2 += u2 * g2;
    }
    n2[o3] = kn(s2, i3, a3);
  }, a2 = 0, i2 = e2; a2 < i2.length; a2++) {
    o2(i2[a2]);
  }
  return n2;
}
function Bh(t2) {
  if (null === t2)
    throw new Error("Invalid input value: " + JSON.stringify(t2));
  var e2 = 0, n2 = [];
  t2.forEach(function(t3) {
    if (e2 += t3.byteLength, n2.push(t3.byteLength === t3.buffer.byteLength ? t3 : new t3.constructor(t3)), !(t3 instanceof Float32Array || t3 instanceof Int32Array || t3 instanceof Uint8Array))
      throw new Error("Unsupported TypedArray subtype: " + t3.constructor.name);
  });
  var r2 = new Uint8Array(e2), o2 = 0;
  return n2.forEach(function(t3) {
    r2.set(new Uint8Array(t3.buffer), o2), o2 += t3.byteLength;
  }), r2.buffer;
}
var Ph = "undefined" != typeof Buffer && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);
function Lh(t2) {
  return Ph ? Buffer.byteLength(t2) : new Blob([t2]).size;
}
function Wh(t2) {
  var e2 = 0;
  t2.forEach(function(t3) {
    e2 += t3.byteLength;
  });
  var n2 = new Uint8Array(e2), r2 = 0;
  return t2.forEach(function(t3) {
    n2.set(new Uint8Array(t3), r2), r2 += t3.byteLength;
  }), n2.buffer;
}
function Uh(t2) {
  for (t2 = t2.trim(); t2.endsWith("/"); )
    t2 = t2.slice(0, t2.length - 1);
  var e2 = t2.split("/");
  return e2[e2.length - 1];
}
function Vh(t2) {
  if (t2.modelTopology instanceof ArrayBuffer)
    throw new Error("Expected JSON model topology, received ArrayBuffer.");
  return {dateSaved: new Date(), modelTopologyType: "JSON", modelTopologyBytes: null == t2.modelTopology ? 0 : Lh(JSON.stringify(t2.modelTopology)), weightSpecsBytes: null == t2.weightSpecs ? 0 : Lh(JSON.stringify(t2.weightSpecs)), weightDataBytes: null == t2.weightData ? 0 : t2.weightData.byteLength};
}
var zh = function() {
  function t2() {
    this.saveRouters = [], this.loadRouters = [];
  }
  return t2.getInstance = function() {
    return null == t2.instance && (t2.instance = new t2()), t2.instance;
  }, t2.registerSaveRouter = function(e2) {
    t2.getInstance().saveRouters.push(e2);
  }, t2.registerLoadRouter = function(e2) {
    t2.getInstance().loadRouters.push(e2);
  }, t2.getSaveHandlers = function(e2) {
    return t2.getHandlers(e2, "save");
  }, t2.getLoadHandlers = function(e2, n2) {
    return t2.getHandlers(e2, "load", n2);
  }, t2.getHandlers = function(e2, n2, r2) {
    var o2 = [];
    return ("load" === n2 ? t2.getInstance().loadRouters : t2.getInstance().saveRouters).forEach(function(t3) {
      var n3 = t3(e2, r2);
      null !== n3 && o2.push(n3);
    }), o2;
  }, t2;
}();
var Gh = "://";
var Hh = function() {
  function t2() {
    this.managers = {};
  }
  return t2.getInstance = function() {
    return null == t2.instance && (t2.instance = new t2()), t2.instance;
  }, t2.registerManager = function(e2, n2) {
    g(null != e2, function() {
      return "scheme must not be undefined or null.";
    }), e2.endsWith(Gh) && (e2 = e2.slice(0, e2.indexOf(Gh))), g(e2.length > 0, function() {
      return "scheme must not be an empty string.";
    });
    var r2 = t2.getInstance();
    g(null == r2.managers[e2], function() {
      return "A model store manager is already registered for scheme '" + e2 + "'.";
    }), r2.managers[e2] = n2;
  }, t2.getManager = function(t3) {
    var e2 = this.getInstance().managers[t3];
    if (null == e2)
      throw new Error("Cannot find model manager for scheme '" + t3 + "'");
    return e2;
  }, t2.getSchemes = function() {
    return Object.keys(this.getInstance().managers);
  }, t2;
}();
function qh(t2) {
  if (-1 === t2.indexOf(Gh))
    throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + Hh.getSchemes().join(","));
  return {scheme: t2.split(Gh)[0], path: t2.split(Gh)[1]};
}
function Kh(t2, e2, o2) {
  return void 0 === o2 && (o2 = false), n(this, void 0, void 0, function() {
    var n2, a2, i2, u2, s2, c2, l2, h2, f2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          return g(t2 !== e2, function() {
            return "Old path and new path are the same: '" + t2 + "'";
          }), g((n2 = zh.getLoadHandlers(t2)).length > 0, function() {
            return "Copying failed because no load handler is found for source URL " + t2 + ".";
          }), g(n2.length < 2, function() {
            return "Copying failed because more than one (" + n2.length + ") load handlers for source URL " + t2 + ".";
          }), a2 = n2[0], g((i2 = zh.getSaveHandlers(e2)).length > 0, function() {
            return "Copying failed because no save handler is found for destination URL " + e2 + ".";
          }), g(i2.length < 2, function() {
            return "Copying failed because more than one (" + n2.length + ") save handlers for destination URL " + e2 + ".";
          }), u2 = i2[0], s2 = qh(t2).scheme, c2 = qh(t2).path, l2 = s2 === qh(t2).scheme, [4, a2.load()];
        case 1:
          return h2 = r2.sent(), o2 && l2 ? [4, Hh.getManager(s2).removeModel(c2)] : [3, 3];
        case 2:
          r2.sent(), r2.label = 3;
        case 3:
          return [4, u2.save(h2)];
        case 4:
          return f2 = r2.sent(), !o2 || l2 ? [3, 6] : [4, Hh.getManager(s2).removeModel(c2)];
        case 5:
          r2.sent(), r2.label = 6;
        case 6:
          return [2, f2.modelArtifactsInfo];
      }
    });
  });
}
var jh = "models_store";
var Xh = "model_info_store";
function $h() {
  if (!a().getBool("IS_BROWSER"))
    throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
  var t2 = window, e2 = t2.indexedDB || t2.mozIndexedDB || t2.webkitIndexedDB || t2.msIndexedDB || t2.shimIndexedDB;
  if (null == e2)
    throw new Error("The current browser does not appear to support IndexedDB.");
  return e2;
}
function Yh(t2) {
  var e2 = t2.result;
  e2.createObjectStore(jh, {keyPath: "modelPath"}), e2.createObjectStore(Xh, {keyPath: "modelPath"});
}
var Qh = function() {
  function t2(t3) {
    if (this.indexedDB = $h(), null == t3 || !t3)
      throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
    this.modelPath = t3;
  }
  return t2.prototype.save = function(t3) {
    return n(this, void 0, void 0, function() {
      return r(this, function(e2) {
        if (t3.modelTopology instanceof ArrayBuffer)
          throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        return [2, this.databaseAction(this.modelPath, t3)];
      });
    });
  }, t2.prototype.load = function() {
    return n(this, void 0, void 0, function() {
      return r(this, function(t3) {
        return [2, this.databaseAction(this.modelPath)];
      });
    });
  }, t2.prototype.databaseAction = function(t3, e2) {
    var n2 = this;
    return new Promise(function(t4, r2) {
      var o2 = n2.indexedDB.open("tensorflowjs", 1);
      o2.onupgradeneeded = function() {
        return Yh(o2);
      }, o2.onsuccess = function() {
        var a2 = o2.result;
        if (null == e2) {
          var i2 = a2.transaction(jh, "readonly"), u2 = i2.objectStore(jh).get(n2.modelPath);
          u2.onsuccess = function() {
            if (null == u2.result)
              return a2.close(), r2(new Error("Cannot find model with path '" + n2.modelPath + "' in IndexedDB."));
            t4(u2.result.modelArtifacts);
          }, u2.onerror = function(t5) {
            return a2.close(), r2(u2.error);
          }, i2.oncomplete = function() {
            return a2.close();
          };
        } else {
          var s2, c2 = Vh(e2), l2 = a2.transaction(Xh, "readwrite"), h2 = l2.objectStore(Xh), f2 = h2.put({modelPath: n2.modelPath, modelArtifactsInfo: c2});
          f2.onsuccess = function() {
            var o3 = (s2 = a2.transaction(jh, "readwrite")).objectStore(jh).put({modelPath: n2.modelPath, modelArtifacts: e2, modelArtifactsInfo: c2});
            o3.onsuccess = function() {
              return t4({modelArtifactsInfo: c2});
            }, o3.onerror = function(t5) {
              var e3 = (h2 = l2.objectStore(Xh)).delete(n2.modelPath);
              e3.onsuccess = function() {
                return a2.close(), r2(o3.error);
              }, e3.onerror = function(t6) {
                return a2.close(), r2(o3.error);
              };
            };
          }, f2.onerror = function(t5) {
            return a2.close(), r2(f2.error);
          }, l2.oncomplete = function() {
            null == s2 ? a2.close() : s2.oncomplete = function() {
              return a2.close();
            };
          };
        }
      }, o2.onerror = function(t5) {
        return r2(o2.error);
      };
    });
  }, t2.URL_SCHEME = "indexeddb://", t2;
}();
var Jh = function(t2) {
  return a().getBool("IS_BROWSER") && !Array.isArray(t2) && t2.startsWith(Qh.URL_SCHEME) ? (e2 = t2.slice(Qh.URL_SCHEME.length), new Qh(e2)) : null;
  var e2;
};
zh.registerSaveRouter(Jh), zh.registerLoadRouter(Jh);
var Zh = function() {
  function t2() {
    this.indexedDB = $h();
  }
  return t2.prototype.listModels = function() {
    return n(this, void 0, void 0, function() {
      var t3 = this;
      return r(this, function(e2) {
        return [2, new Promise(function(e3, n2) {
          var r2 = t3.indexedDB.open("tensorflowjs", 1);
          r2.onupgradeneeded = function() {
            return Yh(r2);
          }, r2.onsuccess = function() {
            var t4 = r2.result, o2 = t4.transaction(Xh, "readonly"), a2 = o2.objectStore(Xh).getAll();
            a2.onsuccess = function() {
              for (var t5 = {}, n3 = 0, r3 = a2.result; n3 < r3.length; n3++) {
                var o3 = r3[n3];
                t5[o3.modelPath] = o3.modelArtifactsInfo;
              }
              e3(t5);
            }, a2.onerror = function(e4) {
              return t4.close(), n2(a2.error);
            }, o2.oncomplete = function() {
              return t4.close();
            };
          }, r2.onerror = function(t4) {
            return n2(r2.error);
          };
        })];
      });
    });
  }, t2.prototype.removeModel = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2 = this;
      return r(this, function(n2) {
        var r2;
        return t3 = (r2 = t3).startsWith(Qh.URL_SCHEME) ? r2.slice(Qh.URL_SCHEME.length) : r2, [2, new Promise(function(n3, r3) {
          var o2 = e2.indexedDB.open("tensorflowjs", 1);
          o2.onupgradeneeded = function() {
            return Yh(o2);
          }, o2.onsuccess = function() {
            var e3, a2 = o2.result, i2 = a2.transaction(Xh, "readwrite"), u2 = i2.objectStore(Xh), s2 = u2.get(t3);
            s2.onsuccess = function() {
              if (null == s2.result)
                return a2.close(), r3(new Error("Cannot find model with path '" + t3 + "' in IndexedDB."));
              var o3 = u2.delete(t3), i3 = function() {
                var o4 = (e3 = a2.transaction(jh, "readwrite")).objectStore(jh).delete(t3);
                o4.onsuccess = function() {
                  return n3(s2.result.modelArtifactsInfo);
                }, o4.onerror = function(t4) {
                  return r3(s2.error);
                };
              };
              o3.onsuccess = i3, o3.onerror = function(t4) {
                return i3(), a2.close(), r3(s2.error);
              };
            }, s2.onerror = function(t4) {
              return a2.close(), r3(s2.error);
            }, i2.oncomplete = function() {
              null == e3 ? a2.close() : e3.oncomplete = function() {
                return a2.close();
              };
            };
          }, o2.onerror = function(t4) {
            return r3(o2.error);
          };
        })];
      });
    });
  }, t2;
}();
if (a().getBool("IS_BROWSER"))
  try {
    Hh.registerManager(Qh.URL_SCHEME, new Zh());
  } catch (t2) {
  }
var tf = "/";
var ef = "tensorflowjs_models";
var nf = "info";
var rf = "model_topology";
var of = "weight_specs";
var af = "weight_data";
var uf = "model_metadata";
function sf(t2) {
  return {info: [ef, t2, nf].join(tf), topology: [ef, t2, rf].join(tf), weightSpecs: [ef, t2, of].join(tf), weightData: [ef, t2, af].join(tf), modelMetadata: [ef, t2, uf].join(tf)};
}
function cf(t2) {
  var e2 = t2.split(tf);
  if (e2.length < 3)
    throw new Error("Invalid key format: " + t2);
  return e2.slice(1, e2.length - 1).join(tf);
}
var lf = function() {
  function t2(t3) {
    if (!a().getBool("IS_BROWSER") || void 0 === window.localStorage)
      throw new Error("The current environment does not support local storage.");
    if (this.LS = window.localStorage, null == t3 || !t3)
      throw new Error("For local storage, modelPath must not be null, undefined or empty.");
    this.modelPath = t3, this.keys = sf(this.modelPath);
  }
  return t2.prototype.save = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2, o2;
      return r(this, function(r2) {
        if (t3.modelTopology instanceof ArrayBuffer)
          throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        e2 = JSON.stringify(t3.modelTopology), n2 = JSON.stringify(t3.weightSpecs), o2 = Vh(t3);
        try {
          return this.LS.setItem(this.keys.info, JSON.stringify(o2)), this.LS.setItem(this.keys.topology, e2), this.LS.setItem(this.keys.weightSpecs, n2), this.LS.setItem(this.keys.weightData, (a2 = t3.weightData, Ph ? Buffer.from(a2).toString("base64") : btoa(String.fromCharCode.apply(null, new Uint8Array(a2))))), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({format: t3.format, generatedBy: t3.generatedBy, convertedBy: t3.convertedBy})), [2, {modelArtifactsInfo: o2}];
        } catch (t4) {
          throw this.LS.removeItem(this.keys.info), this.LS.removeItem(this.keys.topology), this.LS.removeItem(this.keys.weightSpecs), this.LS.removeItem(this.keys.weightData), this.LS.removeItem(this.keys.modelMetadata), new Error("Failed to save model '" + this.modelPath + "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=" + o2.modelTopologyBytes + ", weightSpecsBytes=" + o2.weightSpecsBytes + ", weightDataBytes=" + o2.weightDataBytes + ".");
        }
        var a2;
        return [2];
      });
    });
  }, t2.prototype.load = function() {
    return n(this, void 0, void 0, function() {
      var t3, e2, n2, o2, a2, i2, u2;
      return r(this, function(r2) {
        if (null == (t3 = JSON.parse(this.LS.getItem(this.keys.info))))
          throw new Error("In local storage, there is no model with name '" + this.modelPath + "'");
        if ("JSON" !== t3.modelTopologyType)
          throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
        if (e2 = {}, null == (n2 = JSON.parse(this.LS.getItem(this.keys.topology))))
          throw new Error("In local storage, the topology of model '" + this.modelPath + "' is missing.");
        if (e2.modelTopology = n2, null == (o2 = JSON.parse(this.LS.getItem(this.keys.weightSpecs))))
          throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' are missing.");
        if (e2.weightSpecs = o2, null != (a2 = this.LS.getItem(this.keys.modelMetadata)) && (i2 = JSON.parse(a2), e2.format = i2.format, e2.generatedBy = i2.generatedBy, e2.convertedBy = i2.convertedBy), null == (u2 = this.LS.getItem(this.keys.weightData)))
          throw new Error("In local storage, the binary weight values of model '" + this.modelPath + "' are missing.");
        return e2.weightData = function(t4) {
          if (Ph) {
            var e3 = Buffer.from(t4, "base64");
            return e3.buffer.slice(e3.byteOffset, e3.byteOffset + e3.byteLength);
          }
          for (var n3 = atob(t4), r3 = new Uint8Array(n3.length), o3 = 0; o3 < n3.length; ++o3)
            r3.set([n3.charCodeAt(o3)], o3);
          return r3.buffer;
        }(u2), [2, e2];
      });
    });
  }, t2.URL_SCHEME = "localstorage://", t2;
}();
var hf = function(t2) {
  return a().getBool("IS_BROWSER") && !Array.isArray(t2) && t2.startsWith(lf.URL_SCHEME) ? (e2 = t2.slice(lf.URL_SCHEME.length), new lf(e2)) : null;
  var e2;
};
zh.registerSaveRouter(hf), zh.registerLoadRouter(hf);
var ff = function() {
  function t2() {
    g(a().getBool("IS_BROWSER"), function() {
      return "Current environment is not a web browser";
    }), g(void 0 !== window.localStorage, function() {
      return "Current browser does not appear to support localStorage";
    }), this.LS = window.localStorage;
  }
  return t2.prototype.listModels = function() {
    return n(this, void 0, void 0, function() {
      var t3, e2, n2, o2, a2, i2;
      return r(this, function(r2) {
        for (t3 = {}, e2 = ef + tf, n2 = tf + nf, o2 = 0; o2 < this.LS.length; ++o2)
          (a2 = this.LS.key(o2)).startsWith(e2) && a2.endsWith(n2) && (i2 = cf(a2), t3[i2] = JSON.parse(this.LS.getItem(a2)));
        return [2, t3];
      });
    });
  }, t2.prototype.removeModel = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2;
      return r(this, function(r2) {
        var o2;
        if (t3 = (o2 = t3).startsWith(lf.URL_SCHEME) ? o2.slice(lf.URL_SCHEME.length) : o2, e2 = sf(t3), null == this.LS.getItem(e2.info))
          throw new Error("Cannot find model at path '" + t3 + "'");
        return n2 = JSON.parse(this.LS.getItem(e2.info)), this.LS.removeItem(e2.info), this.LS.removeItem(e2.topology), this.LS.removeItem(e2.weightSpecs), this.LS.removeItem(e2.weightData), [2, n2];
      });
    });
  }, t2;
}();
if (a().getBool("IS_BROWSER"))
  try {
    Hh.registerManager(lf.URL_SCHEME, new ff());
  } catch (t2) {
  }
var pf = "model";
var df = ".json";
var vf = ".weights.bin";
function mf(t2) {
  return new Promise(function(t3) {
    return setTimeout(t3);
  }).then(t2);
}
var gf = function() {
  function t2(e2) {
    if (!a().getBool("IS_BROWSER"))
      throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
    e2.startsWith(t2.URL_SCHEME) && (e2 = e2.slice(t2.URL_SCHEME.length)), null != e2 && 0 !== e2.length || (e2 = pf), this.modelTopologyFileName = e2 + df, this.weightDataFileName = e2 + vf;
  }
  return t2.prototype.save = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2, o2, a2, i2, u2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            if ("undefined" == typeof document)
              throw new Error("Browser downloads are not supported in this environment since `document` is not present");
            if (e2 = window.URL.createObjectURL(new Blob([t3.weightData], {type: "application/octet-stream"})), !(t3.modelTopology instanceof ArrayBuffer))
              return [3, 1];
            throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
          case 1:
            return n2 = [{paths: ["./" + this.weightDataFileName], weights: t3.weightSpecs}], o2 = {modelTopology: t3.modelTopology, format: t3.format, generatedBy: t3.generatedBy, convertedBy: t3.convertedBy, weightsManifest: n2}, a2 = window.URL.createObjectURL(new Blob([JSON.stringify(o2)], {type: "application/json"})), (i2 = null == this.jsonAnchor ? document.createElement("a") : this.jsonAnchor).download = this.modelTopologyFileName, i2.href = a2, [4, mf(function() {
              return i2.dispatchEvent(new MouseEvent("click"));
            })];
          case 2:
            return r2.sent(), null == t3.weightData ? [3, 4] : ((u2 = null == this.weightDataAnchor ? document.createElement("a") : this.weightDataAnchor).download = this.weightDataFileName, u2.href = e2, [4, mf(function() {
              return u2.dispatchEvent(new MouseEvent("click"));
            })]);
          case 3:
            r2.sent(), r2.label = 4;
          case 4:
            return [2, {modelArtifactsInfo: Vh(t3)}];
        }
      });
    });
  }, t2.URL_SCHEME = "downloads://", t2;
}();
var yf = function() {
  function t2(t3) {
    if (null == t3 || t3.length < 1)
      throw new Error("When calling browserFiles, at least 1 file is required, but received " + t3);
    this.files = t3;
  }
  return t2.prototype.load = function() {
    return n(this, void 0, void 0, function() {
      var t3, e2, n2 = this;
      return r(this, function(r2) {
        return t3 = this.files[0], e2 = this.files.slice(1), [2, new Promise(function(r3, o2) {
          var a2 = new FileReader();
          a2.onload = function(a3) {
            var i2 = JSON.parse(a3.target.result), u2 = i2.modelTopology;
            if (null != u2) {
              0 === e2.length && r3({modelTopology: u2});
              var s2 = i2.weightsManifest;
              if (null != s2) {
                var c2;
                try {
                  c2 = n2.checkManifestAndWeightFiles(s2, e2);
                } catch (t4) {
                  return void o2(t4);
                }
                var l2 = [], h2 = [], f2 = [];
                s2.forEach(function(t4) {
                  t4.paths.forEach(function(t5) {
                    h2.push(t5), f2.push(null);
                  }), l2.push.apply(l2, t4.weights);
                }), s2.forEach(function(t4) {
                  t4.paths.forEach(function(t5) {
                    var e3 = new FileReader();
                    e3.onload = function(e4) {
                      var n3 = e4.target.result, o3 = h2.indexOf(t5);
                      f2[o3] = n3, -1 === f2.indexOf(null) && r3({modelTopology: u2, weightSpecs: l2, weightData: Wh(f2)});
                    }, e3.onerror = function(e4) {
                      return o2("Failed to weights data from file of path '" + t5 + "'.");
                    }, e3.readAsArrayBuffer(c2[t5]);
                  });
                });
              } else
                o2(new Error("weightManifest field is missing from file " + t3.name));
            } else
              o2(new Error("modelTopology field is missing from file " + t3.name));
          }, a2.onerror = function(e3) {
            return o2("Failed to read model topology and weights manifest JSON from file '" + t3.name + "'. BrowserFiles supports loading Keras-style tf.Model artifacts only.");
          }, a2.readAsText(t3);
        })];
      });
    });
  }, t2.prototype.checkManifestAndWeightFiles = function(t3, e2) {
    for (var n2 = [], r2 = e2.map(function(t4) {
      return Uh(t4.name);
    }), o2 = {}, a2 = 0, i2 = t3; a2 < i2.length; a2++) {
      i2[a2].paths.forEach(function(t4) {
        var a3 = Uh(t4);
        if (-1 !== n2.indexOf(a3))
          throw new Error("Duplicate file basename found in weights manifest: '" + a3 + "'");
        if (n2.push(a3), -1 === r2.indexOf(a3))
          throw new Error("Weight file with basename '" + a3 + "' is not provided.");
        o2[t4] = e2[r2.indexOf(a3)];
      });
    }
    if (n2.length !== e2.length)
      throw new Error("Mismatch in the number of files in weights manifest (" + n2.length + ") and the number of weight files provided (" + e2.length + ").");
    return o2;
  }, t2;
}();
function xf(t2, e2, n2, r2) {
  !function(t3) {
    g(null != t3 && Array.isArray(t3) && t3.length > 0, function() {
      return "promises must be a none empty array";
    });
  }(t2), function(t3, e3) {
    g(t3 >= 0 && t3 <= 1, function() {
      return "Progress fraction must be in range [0, 1], but got startFraction " + t3;
    }), g(e3 >= 0 && e3 <= 1, function() {
      return "Progress fraction must be in range [0, 1], but got endFraction " + e3;
    }), g(e3 >= t3, function() {
      return "startFraction must be no more than endFraction, but got startFraction " + t3 + " and endFraction " + e3;
    });
  }(n2 = null == n2 ? 0 : n2, r2 = null == r2 ? 1 : r2);
  var o2 = 0;
  return Promise.all(t2.map(function(a2) {
    return a2.then(function(a3) {
      var i2 = n2 + ++o2 / t2.length * (r2 - n2);
      return e2(i2), a3;
    }), a2;
  }));
}
function bf(t2, e2) {
  return n(this, void 0, void 0, function() {
    var n2, o2, i2, u2, s2, c2, l2, h2, f2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          return null == e2 && (e2 = {}), n2 = null == e2.fetchFunc ? a().platform.fetch : e2.fetchFunc, o2 = t2.map(function(t3) {
            return n2(t3, e2.requestInit, {isBinary: true});
          }), i2 = 0, u2 = 0.5, null != e2.onProgress ? [3, 2] : [4, Promise.all(o2)];
        case 1:
          return s2 = r2.sent(), [3, 4];
        case 2:
          return [4, xf(o2, e2.onProgress, i2, u2)];
        case 3:
          s2 = r2.sent(), r2.label = 4;
        case 4:
          return c2 = s2.map(function(t3) {
            return t3.arrayBuffer();
          }), l2 = 0.5, h2 = 1, null != e2.onProgress ? [3, 6] : [4, Promise.all(c2)];
        case 5:
          return f2 = r2.sent(), [3, 8];
        case 6:
          return [4, xf(c2, e2.onProgress, l2, h2)];
        case 7:
          f2 = r2.sent(), r2.label = 8;
        case 8:
          return [2, f2];
      }
    });
  });
}
function wf(t2) {
  var e2 = this;
  return function(o2, a2, i2) {
    return void 0 === a2 && (a2 = ""), n(e2, void 0, void 0, function() {
      var e3, n2, u2, s2, c2, l2, h2, f2, p2, d2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (e3 = o2.map(function() {
              return false;
            }), n2 = {}, u2 = null != i2 ? i2.map(function() {
              return false;
            }) : [], s2 = [], o2.forEach(function(t3, r3) {
              var o3 = 0;
              t3.weights.forEach(function(t4) {
                var a3 = "quantization" in t4 ? t4.quantization.dtype : t4.dtype, c3 = Oh[a3] * w(t4.shape), l3 = function() {
                  e3[r3] = true, null == n2[r3] && (n2[r3] = []), n2[r3].push({manifestEntry: t4, groupOffset: o3, sizeBytes: c3});
                };
                null != i2 ? i2.forEach(function(e4, n3) {
                  e4 === t4.name && (l3(), u2[n3] = true);
                }) : l3(), s2.push(t4.name), o3 += c3;
              });
            }), !u2.every(function(t3) {
              return t3;
            }))
              throw c2 = i2.filter(function(t3, e4) {
                return !u2[e4];
              }), new Error("Could not find weights in manifest with names: " + c2.join(", ") + ". \nManifest JSON has weights with names: " + s2.join(", ") + ".");
            return l2 = e3.reduce(function(t3, e4, n3) {
              return e4 && t3.push(n3), t3;
            }, []), h2 = [], l2.forEach(function(t3) {
              o2[t3].paths.forEach(function(t4) {
                var e4 = a2 + (a2.endsWith("/") ? "" : "/") + t4;
                h2.push(e4);
              });
            }), [4, t2(h2)];
          case 1:
            return f2 = r2.sent(), p2 = {}, d2 = 0, l2.forEach(function(t3) {
              for (var e4 = o2[t3].paths.length, r3 = 0, a3 = 0; a3 < e4; a3++)
                r3 += f2[d2 + a3].byteLength;
              for (var i3 = new ArrayBuffer(r3), u3 = new Uint8Array(i3), s3 = 0, c3 = 0; c3 < e4; c3++) {
                var l3 = new Uint8Array(f2[d2 + c3]);
                u3.set(l3, s3), s3 += l3.byteLength;
              }
              n2[t3].forEach(function(t4) {
                var e5 = Mh(i3.slice(t4.groupOffset, t4.groupOffset + t4.sizeBytes), [t4.manifestEntry]);
                for (var n3 in e5)
                  p2[n3] = e5[n3];
              }), d2 += e4;
            }), [2, p2];
        }
      });
    });
  };
}
zh.registerSaveRouter(function(t2) {
  return a().getBool("IS_BROWSER") && !Array.isArray(t2) && t2.startsWith(gf.URL_SCHEME) ? (e2 = t2.slice(gf.URL_SCHEME.length), void 0 === e2 && (e2 = "model"), new gf(e2)) : null;
  var e2;
});
var Cf = function() {
  function t2(t3, e2) {
    if (this.DEFAULT_METHOD = "POST", null == e2 && (e2 = {}), this.weightPathPrefix = e2.weightPathPrefix, this.onProgress = e2.onProgress, null != e2.fetchFunc ? (g("function" == typeof e2.fetchFunc, function() {
      return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)";
    }), this.fetch = e2.fetchFunc) : this.fetch = a().platform.fetch, g(null != t3 && t3.length > 0, function() {
      return "URL path for http must not be null, undefined or empty.";
    }), Array.isArray(t3) && g(2 === t3.length, function() {
      return "URL paths for http must have a length of 2, (actual length is " + t3.length + ").";
    }), this.path = t3, null != e2.requestInit && null != e2.requestInit.body)
      throw new Error("requestInit is expected to have no pre-existing body, but has one.");
    this.requestInit = e2.requestInit || {};
  }
  return t2.prototype.save = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2, o2, a2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (t3.modelTopology instanceof ArrayBuffer)
              throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
            return (e2 = Object.assign({method: this.DEFAULT_METHOD}, this.requestInit)).body = new FormData(), n2 = [{paths: ["./model.weights.bin"], weights: t3.weightSpecs}], o2 = {modelTopology: t3.modelTopology, format: t3.format, generatedBy: t3.generatedBy, convertedBy: t3.convertedBy, userDefinedMetadata: t3.userDefinedMetadata, weightsManifest: n2}, e2.body.append("model.json", new Blob([JSON.stringify(o2)], {type: "application/json"}), "model.json"), null != t3.weightData && e2.body.append("model.weights.bin", new Blob([t3.weightData], {type: "application/octet-stream"}), "model.weights.bin"), [4, this.fetch(this.path, e2)];
          case 1:
            if ((a2 = r2.sent()).ok)
              return [2, {modelArtifactsInfo: Vh(t3), responses: [a2]}];
            throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + a2.status + ".");
        }
      });
    });
  }, t2.prototype.load = function() {
    return n(this, void 0, void 0, function() {
      var t3, e2, n2, o2, a2, i2, u2, s2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            return [4, this.fetch(this.path, this.requestInit)];
          case 1:
            if (!(t3 = r2.sent()).ok)
              throw new Error("Request to " + this.path + " failed with status code " + t3.status + ". Please verify this URL points to the model JSON of the model to load.");
            r2.label = 2;
          case 2:
            return r2.trys.push([2, 4, , 5]), [4, t3.json()];
          case 3:
            return e2 = r2.sent(), [3, 5];
          case 4:
            throw r2.sent(), n2 = "Failed to parse model JSON of response from " + this.path + ".", this.path.endsWith(".pb") ? n2 += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : n2 += " Please make sure the server is serving valid JSON for this request.", new Error(n2);
          case 5:
            if (o2 = e2.modelTopology, a2 = e2.weightsManifest, null == o2 && null == a2)
              throw new Error("The JSON from HTTP path " + this.path + " contains neither model topology or manifest for weights.");
            return null == a2 ? [3, 7] : [4, this.loadWeights(a2)];
          case 6:
            s2 = r2.sent(), i2 = s2[0], u2 = s2[1], r2.label = 7;
          case 7:
            return [2, {modelTopology: o2, weightSpecs: i2, weightData: u2}];
        }
      });
    });
  }, t2.prototype.loadWeights = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2, o2, a2, i2, u2, s2, c2, l2, h2, f2;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            for (e2 = Array.isArray(this.path) ? this.path[1] : this.path, n2 = function(t4) {
              var e3 = t4.lastIndexOf("/"), n3 = t4.lastIndexOf("?"), r3 = t4.substring(0, e3), o3 = n3 > e3 ? t4.substring(n3) : "";
              return [r3 + "/", o3];
            }(e2), o2 = n2[0], a2 = n2[1], i2 = this.weightPathPrefix || o2, u2 = [], s2 = 0, c2 = t3; s2 < c2.length; s2++)
              l2 = c2[s2], u2.push.apply(u2, l2.weights);
            return h2 = [], t3.forEach(function(t4) {
              t4.paths.forEach(function(t5) {
                h2.push(i2 + t5 + a2);
              });
            }), [4, bf(h2, {requestInit: this.requestInit, fetchFunc: this.fetch, onProgress: this.onProgress})];
          case 1:
            return f2 = r2.sent(), [2, [u2, Wh(f2)]];
        }
      });
    });
  }, t2.URL_SCHEME_REGEX = /^https?:\/\//, t2;
}();
function Ef(t2) {
  return null != t2.match(Cf.URL_SCHEME_REGEX);
}
var Rf = function(t2, e2) {
  if ("undefined" == typeof fetch)
    return null;
  return (Array.isArray(t2) ? t2.every(function(t3) {
    return Ef(t3);
  }) : Ef(t2)) ? If(t2, {onProgress: e2}) : null;
};
function If(t2, e2) {
  return new Cf(t2, e2);
}
zh.registerSaveRouter(Rf), zh.registerLoadRouter(Rf);
var kf = function() {
  function t2(t3) {
    this.modelArtifacts = t3;
  }
  return t2.prototype.load = function() {
    return n(this, void 0, void 0, function() {
      return r(this, function(t3) {
        return [2, this.modelArtifacts];
      });
    });
  }, t2;
}();
var Sf = function() {
  function t2(t3) {
    this.saveHandler = t3;
  }
  return t2.prototype.save = function(t3) {
    return n(this, void 0, void 0, function() {
      return r(this, function(e2) {
        return [2, this.saveHandler(t3)];
      });
    });
  }, t2;
}();
var Af = Object.freeze({browserFiles: function(t2) {
  return new yf(t2);
}, browserHTTPRequest: function(t2, e2) {
  return If(t2, e2);
}, concatenateArrayBuffers: Wh, decodeWeights: Mh, encodeWeights: function(t2, e2) {
  return n(this, void 0, void 0, function() {
    var o2, a2, i2, u2, s2, c2 = this;
    return r(this, function(l2) {
      switch (l2.label) {
        case 0:
          for (o2 = [], a2 = [], i2 = Array.isArray(t2) ? t2.map(function(t3) {
            return t3.name;
          }) : Object.keys(t2), u2 = function(u3) {
            var s3 = i2[u3], l3 = Array.isArray(t2) ? t2[u3].tensor : t2[s3];
            if ("float32" !== l3.dtype && "int32" !== l3.dtype && "bool" !== l3.dtype && "string" !== l3.dtype)
              throw new Error("Unsupported dtype in weight '" + s3 + "': " + l3.dtype);
            var h2 = {name: s3, shape: l3.shape, dtype: l3.dtype};
            if ("string" === l3.dtype) {
              var f2 = new Promise(function(t3) {
                return n(c2, void 0, void 0, function() {
                  var e3, n2, o3, a3, i3, u4, s4;
                  return r(this, function(r2) {
                    switch (r2.label) {
                      case 0:
                        return [4, l3.bytes()];
                      case 1:
                        for (e3 = r2.sent(), n2 = e3.reduce(function(t4, e4) {
                          return t4 + e4.length;
                        }, 0) + _h * e3.length, o3 = new Uint8Array(n2), a3 = 0, i3 = 0; i3 < e3.length; i3++)
                          u4 = e3[i3], s4 = new Uint8Array(new Uint32Array([u4.length]).buffer), o3.set(s4, a3), a3 += _h, o3.set(u4, a3), a3 += u4.length;
                        return t3(o3), [2];
                    }
                  });
                });
              });
              a2.push(f2);
            } else
              a2.push(l3.data());
            null != e2 && (h2.group = e2), o2.push(h2);
          }, s2 = 0; s2 < i2.length; ++s2)
            u2(s2);
          return [4, Promise.all(a2)];
        case 1:
          return [2, {data: Bh(l2.sent()), specs: o2}];
      }
    });
  });
}, fromMemory: function(t2, e2, n2, r2) {
  return 1 === arguments.length ? null != t2.modelTopology || null != t2.weightSpecs ? new kf(t2) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new kf({modelTopology: t2})) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new kf({modelTopology: t2, weightSpecs: e2, weightData: n2, trainingConfig: r2}));
}, getLoadHandlers: function(t2, e2) {
  return zh.getLoadHandlers(t2, e2);
}, getModelArtifactsInfoForJSON: Vh, getSaveHandlers: function(t2) {
  return zh.getSaveHandlers(t2);
}, http: If, isHTTPScheme: Ef, loadWeights: function(t2, e2, o2, a2) {
  return void 0 === e2 && (e2 = ""), n(this, void 0, void 0, function() {
    return r(this, function(n2) {
      return [2, wf(function(t3) {
        return bf(t3, {requestInit: a2});
      })(t2, e2, o2)];
    });
  });
}, registerLoadRouter: function(t2) {
  return zh.registerLoadRouter(t2);
}, registerSaveRouter: function(t2) {
  return zh.registerSaveRouter(t2);
}, weightsLoaderFactory: wf, withSaveHandler: function(t2) {
  return new Sf(t2);
}, copyModel: function(t2, e2) {
  return n(this, void 0, void 0, function() {
    return r(this, function(n2) {
      return [2, Kh(t2, e2, false)];
    });
  });
}, listModels: function() {
  return n(this, void 0, void 0, function() {
    var t2, e2, n2, o2, a2, i2, u2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          t2 = Hh.getSchemes(), e2 = {}, n2 = 0, o2 = t2, r2.label = 1;
        case 1:
          return n2 < o2.length ? (a2 = o2[n2], [4, Hh.getManager(a2).listModels()]) : [3, 4];
        case 2:
          for (u2 in i2 = r2.sent())
            e2[a2 + Gh + u2] = i2[u2];
          r2.label = 3;
        case 3:
          return n2++, [3, 1];
        case 4:
          return [2, e2];
      }
    });
  });
}, moveModel: function(t2, e2) {
  return n(this, void 0, void 0, function() {
    return r(this, function(n2) {
      return [2, Kh(t2, e2, true)];
    });
  });
}, removeModel: function(t2) {
  return n(this, void 0, void 0, function() {
    var e2;
    return r(this, function(n2) {
      return e2 = qh(t2), [2, Hh.getManager(e2.scheme).removeModel(e2.path)];
    });
  });
}});
var Df = Cn({confusionMatrix_: function(t2, e2, n2) {
  var r2 = ln(t2, "labels", "confusionMatrix"), o2 = ln(e2, "predictions", "confusionMatrix");
  g(null == n2 || n2 > 0 && Number.isInteger(n2), function() {
    return "If provided, numClasses must be a positive integer, but got " + n2;
  }), g(1 === r2.rank, function() {
    return "Expected the rank of labels to be 1, but got " + r2.rank;
  }), g(1 === o2.rank, function() {
    return "Expected the rank of predictions to be 1, but got " + o2.rank;
  }), g(r2.shape[0] === o2.shape[0], function() {
    return "Mismatch in the number of examples: " + r2.shape[0] + " vs. " + o2.shape[0] + ". Labels and predictions should have the same number of elements.";
  }), g(n2 > 0 && Number.isInteger(n2), function() {
    return "numClasses is required to be a positive integer, but got " + n2;
  });
  var a2 = gr(r2.asType("int32"), n2), i2 = gr(o2.asType("int32"), n2);
  return a2.transpose().matMul(i2).asType("int32");
}});
var Tf = Object.freeze({confusionMatrix: Df});
var Nf = Cn({fromPixels_: function(t2, e2) {
  if (void 0 === e2 && (e2 = 3), e2 > 4)
    throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
  var n2 = "undefined" != typeof HTMLVideoElement && t2 instanceof HTMLVideoElement;
  if (n2 && n2 && t2.readyState < 2)
    throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");
  return Nt.fromPixels(t2, e2);
}});
var Ff = Object.freeze({toPixels: function(t2, e2) {
  return n(this, void 0, void 0, function() {
    var n2, o2, a2, i2, u2, s2, c2, l2, h2, f2, p2, d2, v2, m2, g2, y2, x2, b2, w2, C2, E2, R2, I2;
    return r(this, function(r2) {
      switch (r2.label) {
        case 0:
          if (n2 = ln(t2, "img", "toPixels"), t2 instanceof dt || (n2 = n2.toInt()), 2 !== n2.rank && 3 !== n2.rank)
            throw new Error("toPixels only supports rank 2 or 3 tensors, got rank " + n2.rank + ".");
          if (o2 = n2.shape.slice(0, 2), a2 = o2[0], i2 = o2[1], (u2 = 2 === n2.rank ? 1 : n2.shape[2]) > 4 || 2 === u2)
            throw new Error("toPixels only supports depth of size 1, 3 or 4 but got " + u2);
          return [4, n2.data()];
        case 1:
          return s2 = r2.sent(), c2 = n2.min(), l2 = n2.max(), [4, Promise.all([c2.data(), l2.data()])];
        case 2:
          if (h2 = r2.sent(), f2 = h2[0], p2 = h2[1], d2 = f2[0], v2 = p2[0], c2.dispose(), l2.dispose(), "float32" === n2.dtype) {
            if (d2 < 0 || v2 > 1)
              throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [" + d2 + " - " + v2 + "].");
          } else {
            if ("int32" !== n2.dtype)
              throw new Error("Unsupported type for toPixels: " + n2.dtype + ". Please use float32 or int32 tensors.");
            if (d2 < 0 || v2 > 255)
              throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [" + d2 + " - " + v2 + "].");
          }
          for (m2 = "float32" === n2.dtype ? 255 : 1, g2 = new Uint8ClampedArray(i2 * a2 * 4), y2 = 0; y2 < a2 * i2; ++y2)
            x2 = void 0, b2 = void 0, w2 = void 0, C2 = void 0, 1 === u2 ? (x2 = s2[y2] * m2, b2 = s2[y2] * m2, w2 = s2[y2] * m2, C2 = 255) : 3 === u2 ? (x2 = s2[3 * y2] * m2, b2 = s2[3 * y2 + 1] * m2, w2 = s2[3 * y2 + 2] * m2, C2 = 255) : 4 === u2 && (x2 = s2[4 * y2] * m2, b2 = s2[4 * y2 + 1] * m2, w2 = s2[4 * y2 + 2] * m2, C2 = s2[4 * y2 + 3] * m2), g2[0 + (E2 = 4 * y2)] = Math.round(x2), g2[E2 + 1] = Math.round(b2), g2[E2 + 2] = Math.round(w2), g2[E2 + 3] = Math.round(C2);
          return null != e2 && (e2.width = i2, e2.height = a2, R2 = e2.getContext("2d"), I2 = new ImageData(g2, i2, a2), R2.putImageData(I2, 0, 0)), n2 !== t2 && n2.dispose(), [2, g2];
      }
    });
  });
}, fromPixels: Nf});
var Of = function() {
  function t2() {
  }
  return t2.prototype.getClassName = function() {
    return this.constructor.className;
  }, t2.fromConfig = function(t3, e2) {
    return new t3(e2);
  }, t2;
}();
var _f = function() {
  function t2() {
    this.classNameMap = {};
  }
  return t2.getMap = function() {
    return null == t2.instance && (t2.instance = new t2()), t2.instance;
  }, t2.register = function(e2) {
    t2.getMap().classNameMap[e2.className] = [e2, e2.fromConfig];
  }, t2;
}();
function Mf(t2) {
  g(null != t2.className, function() {
    return "Class being registered does not have the static className property defined.";
  }), g("string" == typeof t2.className, function() {
    return "className is required to be a string, but got type " + typeof t2.className;
  }), g(t2.className.length > 0, function() {
    return "Class being registered has an empty-string as its className, which is disallowed.";
  }), _f.register(t2);
}
var Bf = Object.freeze({Serializable: Of, SerializationMap: _f, registerClass: Mf});
var Pf = 1e-3;
var Lf = 0.1;
function Wf() {
  return 32 === Nt.backend.floatPrecision() ? Pf : Lf;
}
function Uf(t2, e2, n2) {
  var r2 = true;
  if ((B(t2) || B(e2)) && (r2 = false), B(t2) && B(e2) && (r2 = true), r2) {
    var o2 = t2.constructor.name, a2 = e2.constructor.name;
    if (o2 !== a2)
      throw new Error("Arrays are of different type. Actual: " + o2 + ". Expected: " + a2);
  }
  if (Array.isArray(t2) && Array.isArray(e2)) {
    var i2 = sn(t2), u2 = sn(e2);
    if (!C(i2, u2))
      throw new Error("Arrays have different shapes. Actual: [" + i2 + "]. Expected: [" + u2 + "]");
  }
  var s2 = B(t2) ? t2 : b(t2), c2 = B(e2) ? e2 : b(e2);
  if (s2.length !== c2.length)
    throw new Error("Arrays have different lengths actual: " + s2.length + " vs expected: " + c2.length + ".\nActual:   " + s2 + ".\nExpected: " + c2 + ".");
  for (var l2 = 0; l2 < c2.length; ++l2) {
    var h2 = s2[l2], f2 = c2[l2];
    if (!n2(h2, f2))
      throw new Error("Arrays differ: actual[" + l2 + "] = " + h2 + ", expected[" + l2 + "] = " + f2 + ".\nActual:   " + s2 + ".\nExpected: " + c2 + ".");
  }
}
function Vf(t2, e2, n2) {
  return !isFinite(t2) && !isFinite(e2) || !(isNaN(t2) || isNaN(e2) || Math.abs(t2 - e2) > n2);
}
var zf = Object.freeze({TEST_EPSILON_FLOAT16: Lf, expectArraysClose: function(t2, e2, n2) {
  return null == n2 && (n2 = Wf()), Uf(t2, e2, function(t3, e3) {
    return Vf(t3, e3, n2);
  });
}, testEpsilon: Wf, expectPromiseToFail: function(t2, e2) {
  t2().then(function() {
    return e2.fail();
  }, function() {
    return e2();
  });
}, expectArraysEqual: function(t2, e2) {
  var n2 = "string" == typeof e2 || "number" == typeof e2 || "boolean" == typeof e2 ? [e2] : e2;
  return W(t2) || W(t2[0]) || W(e2) || W(e2[0]) ? Uf(t2, n2, function(t3, e3) {
    return t3 == e3;
  }) : Uf(t2, e2, function(t3, e3) {
    return Vf(t3, e3, 0);
  });
}, expectNumbersClose: function(t2, e2, n2) {
  if (null == n2 && (n2 = Wf()), !Vf(t2, e2, n2))
    throw new Error("Numbers differ: actual === " + t2 + ", expected === " + e2);
}, expectValuesInRange: function(t2, e2, n2) {
  for (var r2 = 0; r2 < t2.length; r2++)
    if (t2[r2] < e2 || t2[r2] > n2)
      throw new Error("Value out of range:" + t2[r2] + " low: " + e2 + ", high: " + n2);
}, expectArrayBuffersEqual: function(t2, e2) {
  expect(new Float32Array(t2)).toEqual(new Float32Array(e2));
}});
var Gf = "1.3.2";
var Hf = Object.freeze({gpgpu_util: wi, webgl_util: Pe, forceHalfFloat: function() {
  a().set("WEBGL_FORCE_F16_TEXTURES", true);
}, MathBackendWebGL: Wu, setWebGLContext: Wt, GPGPUContext: Ci});
var qf = function(t2) {
  function o2() {
    return null !== t2 && t2.apply(this, arguments) || this;
  }
  return e(o2, t2), o2.prototype.minimize = function(t3, e2, n2) {
    void 0 === e2 && (e2 = false);
    var r2 = this.computeGradients(t3, n2), o3 = r2.value, a2 = r2.grads;
    if (null != n2) {
      var i2 = n2.map(function(t4) {
        return {name: t4.name, tensor: a2[t4.name]};
      });
      this.applyGradients(i2);
    } else
      this.applyGradients(a2);
    return Xe(a2), e2 ? o3 : (o3.dispose(), null);
  }, Object.defineProperty(o2.prototype, "iterations", {get: function() {
    return null == this.iterations_ && (this.iterations_ = 0), this.iterations_;
  }, enumerable: true, configurable: true}), o2.prototype.incrementIterations = function() {
    this.iterations_ = this.iterations + 1;
  }, o2.prototype.computeGradients = function(t3, e2) {
    return ro(t3, e2);
  }, o2.prototype.dispose = function() {
    null != this.iterations_ && Xe(this.iterations_);
  }, o2.prototype.saveIterations = function() {
    return n(this, void 0, void 0, function() {
      return r(this, function(t3) {
        return null == this.iterations_ && (this.iterations_ = 0), [2, {name: "iter", tensor: An(this.iterations_, "int32")}];
      });
    });
  }, o2.prototype.getWeights = function() {
    return n(this, void 0, void 0, function() {
      return r(this, function(t3) {
        throw new Error("getWeights() is not implemented for this optimizer yet.");
      });
    });
  }, o2.prototype.setWeights = function(t3) {
    return n(this, void 0, void 0, function() {
      return r(this, function(t4) {
        throw new Error("setWeights() is not implemented for this optimizer class " + this.getClassName());
      });
    });
  }, o2.prototype.extractIterations = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2;
      return r(this, function(n2) {
        switch (n2.label) {
          case 0:
            return e2 = this, [4, t3[0].tensor.data()];
          case 1:
            return e2.iterations_ = n2.sent()[0], [2, t3.slice(1)];
        }
      });
    });
  }, o2;
}(Of);
Object.defineProperty(qf, Symbol.hasInstance, {value: function(t2) {
  return null != t2.minimize && null != t2.computeGradients && null != t2.applyGradients;
}});
var Kf = function(t2) {
  function o2(e2, n2, r2) {
    void 0 === r2 && (r2 = null);
    var o3 = t2.call(this) || this;
    return o3.learningRate = e2, o3.rho = n2, o3.epsilon = r2, o3.accumulatedGrads = [], o3.accumulatedUpdates = [], null == r2 && (o3.epsilon = Nt.backend.epsilon()), o3;
  }
  return e(o2, t2), o2.prototype.applyGradients = function(t3) {
    var e2 = this;
    (Array.isArray(t3) ? t3.map(function(t4) {
      return t4.name;
    }) : Object.keys(t3)).forEach(function(n2, r2) {
      var o3 = Nt.registeredVariables[n2];
      null == e2.accumulatedGrads[r2] && (e2.accumulatedGrads[r2] = {originalName: n2 + "/accum_grad", variable: je(function() {
        return zn(o3).variable(false);
      })}), null == e2.accumulatedUpdates[r2] && (e2.accumulatedUpdates[r2] = {originalName: n2 + "/accum_var", variable: je(function() {
        return zn(o3).variable(false);
      })});
      var a2 = Array.isArray(t3) ? t3[r2].tensor : t3[n2];
      if (null != a2) {
        var i2 = e2.accumulatedGrads[r2].variable, u2 = e2.accumulatedUpdates[r2].variable;
        je(function() {
          var t4 = i2.mul(e2.rho).add(a2.square().mul(1 - e2.rho)), n3 = u2.add(e2.epsilon).sqrt().div(i2.add(e2.epsilon).sqrt()).mul(a2), r3 = u2.mul(e2.rho).add(n3.square().mul(1 - e2.rho));
          i2.assign(t4), u2.assign(r3);
          var s2 = n3.mul(-e2.learningRate).add(o3);
          o3.assign(s2);
        });
      }
    }), this.incrementIterations();
  }, o2.prototype.dispose = function() {
    null != this.accumulatedUpdates && (Xe(this.accumulatedGrads.map(function(t3) {
      return t3.variable;
    })), Xe(this.accumulatedUpdates.map(function(t3) {
      return t3.variable;
    })));
  }, o2.prototype.getWeights = function() {
    return n(this, void 0, void 0, function() {
      var t3;
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return t3 = this.accumulatedGrads.concat(this.accumulatedUpdates), [4, this.saveIterations()];
          case 1:
            return [2, [e2.sent()].concat(t3.map(function(t4) {
              return {name: t4.originalName, tensor: t4.variable};
            }))];
        }
      });
    });
  }, o2.prototype.setWeights = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2;
      return r(this, function(n2) {
        switch (n2.label) {
          case 0:
            return [4, this.extractIterations(t3)];
          case 1:
            return t3 = n2.sent(), e2 = t3.length / 2, false, this.accumulatedGrads = t3.slice(0, e2).map(function(t4) {
              return {originalName: t4.name, variable: t4.tensor.variable(false)};
            }), this.accumulatedUpdates = t3.slice(e2, 2 * e2).map(function(t4) {
              return {originalName: t4.name, variable: t4.tensor.variable(false)};
            }), [2];
        }
      });
    });
  }, o2.prototype.getConfig = function() {
    return {learningRate: this.learningRate, rho: this.rho, epsilon: this.epsilon};
  }, o2.fromConfig = function(t3, e2) {
    return new t3(e2.learningRate, e2.rho, e2.epsilon);
  }, o2.className = "Adadelta", o2;
}(qf);
Mf(Kf);
var jf = function(t2) {
  function o2(e2, n2) {
    void 0 === n2 && (n2 = 0.1);
    var r2 = t2.call(this) || this;
    return r2.learningRate = e2, r2.initialAccumulatorValue = n2, r2.accumulatedGrads = [], r2;
  }
  return e(o2, t2), o2.prototype.applyGradients = function(t3) {
    var e2 = this;
    (Array.isArray(t3) ? t3.map(function(t4) {
      return t4.name;
    }) : Object.keys(t3)).forEach(function(n2, r2) {
      var o3 = Nt.registeredVariables[n2];
      if (null == e2.accumulatedGrads[r2]) {
        e2.accumulatedGrads[r2] = {originalName: n2 + "/accumulator", variable: je(function() {
          return Ln(o3.shape, e2.initialAccumulatorValue).variable(false);
        })};
      }
      var a2 = Array.isArray(t3) ? t3[r2].tensor : t3[n2];
      if (null != a2) {
        var i2 = e2.accumulatedGrads[r2].variable;
        je(function() {
          var t4 = i2.add(a2.square());
          i2.assign(t4);
          var n3 = a2.div(t4.add(Nt.backend.epsilon()).sqrt()).mul(-e2.learningRate).add(o3);
          o3.assign(n3);
        });
      }
    }), this.incrementIterations();
  }, o2.prototype.dispose = function() {
    null != this.accumulatedGrads && Xe(this.accumulatedGrads.map(function(t3) {
      return t3.variable;
    }));
  }, o2.prototype.getWeights = function() {
    return n(this, void 0, void 0, function() {
      return r(this, function(t3) {
        switch (t3.label) {
          case 0:
            return [4, this.saveIterations()];
          case 1:
            return [2, [t3.sent()].concat(this.accumulatedGrads.map(function(t4) {
              return {name: t4.originalName, tensor: t4.variable};
            }))];
        }
      });
    });
  }, o2.prototype.setWeights = function(t3) {
    return n(this, void 0, void 0, function() {
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return [4, this.extractIterations(t3)];
          case 1:
            return t3 = e2.sent(), false, this.accumulatedGrads = t3.map(function(t4) {
              return {originalName: t4.name, variable: t4.tensor.variable(false)};
            }), [2];
        }
      });
    });
  }, o2.prototype.getConfig = function() {
    return {learningRate: this.learningRate, initialAccumulatorValue: this.initialAccumulatorValue};
  }, o2.fromConfig = function(t3, e2) {
    return new t3(e2.learningRate, e2.initialAccumulatorValue);
  }, o2.className = "Adagrad", o2;
}(qf);
Mf(jf);
var Xf = function(t2) {
  function o2(e2, n2, r2, o3) {
    void 0 === o3 && (o3 = null);
    var a2 = t2.call(this) || this;
    return a2.learningRate = e2, a2.beta1 = n2, a2.beta2 = r2, a2.epsilon = o3, a2.accumulatedFirstMoment = [], a2.accumulatedSecondMoment = [], je(function() {
      a2.accBeta1 = An(n2).variable(), a2.accBeta2 = An(r2).variable();
    }), null == o3 && (a2.epsilon = Nt.backend.epsilon()), a2;
  }
  return e(o2, t2), o2.prototype.applyGradients = function(t3) {
    var e2 = this, n2 = Array.isArray(t3) ? t3.map(function(t4) {
      return t4.name;
    }) : Object.keys(t3);
    je(function() {
      var r2 = uc(1, e2.accBeta1), o3 = uc(1, e2.accBeta2);
      n2.forEach(function(n3, a2) {
        var i2 = Nt.registeredVariables[n3];
        null == e2.accumulatedFirstMoment[a2] && (e2.accumulatedFirstMoment[a2] = {originalName: n3 + "/m", variable: je(function() {
          return zn(i2).variable(false);
        })}), null == e2.accumulatedSecondMoment[a2] && (e2.accumulatedSecondMoment[a2] = {originalName: n3 + "/v", variable: je(function() {
          return zn(i2).variable(false);
        })});
        var u2 = Array.isArray(t3) ? t3[a2].tensor : t3[n3];
        if (null != u2) {
          var s2 = e2.accumulatedFirstMoment[a2].variable, c2 = e2.accumulatedSecondMoment[a2].variable, l2 = s2.mul(e2.beta1).add(u2.mul(1 - e2.beta1)), h2 = c2.mul(e2.beta2).add(u2.square().mul(1 - e2.beta2)), f2 = l2.div(r2), p2 = h2.div(o3);
          s2.assign(l2), c2.assign(h2);
          var d2 = f2.div(p2.sqrt().add(e2.epsilon)).mul(-e2.learningRate).add(i2);
          i2.assign(d2);
        }
      }), e2.accBeta1.assign(e2.accBeta1.mul(e2.beta1)), e2.accBeta2.assign(e2.accBeta2.mul(e2.beta2));
    }), this.incrementIterations();
  }, o2.prototype.dispose = function() {
    this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && Xe(this.accumulatedFirstMoment.map(function(t3) {
      return t3.variable;
    })), null != this.accumulatedSecondMoment && Xe(this.accumulatedSecondMoment.map(function(t3) {
      return t3.variable;
    }));
  }, o2.prototype.getWeights = function() {
    return n(this, void 0, void 0, function() {
      var t3;
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return t3 = this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment), [4, this.saveIterations()];
          case 1:
            return [2, [e2.sent()].concat(t3.map(function(t4) {
              return {name: t4.originalName, tensor: t4.variable};
            }))];
        }
      });
    });
  }, o2.prototype.setWeights = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2, n2 = this;
      return r(this, function(r2) {
        switch (r2.label) {
          case 0:
            return [4, this.extractIterations(t3)];
          case 1:
            return t3 = r2.sent(), je(function() {
              n2.accBeta1.assign(rc(n2.beta1, n2.iterations_ + 1)), n2.accBeta2.assign(rc(n2.beta2, n2.iterations_ + 1));
            }), e2 = t3.length / 2, false, this.accumulatedFirstMoment = t3.slice(0, e2).map(function(t4) {
              return {originalName: t4.name, variable: t4.tensor.variable(false)};
            }), this.accumulatedSecondMoment = t3.slice(e2, 2 * e2).map(function(t4) {
              return {originalName: t4.name, variable: t4.tensor.variable(false)};
            }), [2];
        }
      });
    });
  }, o2.prototype.getConfig = function() {
    return {learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon};
  }, o2.fromConfig = function(t3, e2) {
    return new t3(e2.learningRate, e2.beta1, e2.beta2, e2.epsilon);
  }, o2.className = "Adam", o2;
}(qf);
Mf(Xf);
var $f = function(t2) {
  function o2(e2, n2, r2, o3, a2) {
    void 0 === o3 && (o3 = null), void 0 === a2 && (a2 = 0);
    var i2 = t2.call(this) || this;
    return i2.learningRate = e2, i2.beta1 = n2, i2.beta2 = r2, i2.epsilon = o3, i2.decay = a2, i2.accumulatedFirstMoment = [], i2.accumulatedWeightedInfNorm = [], je(function() {
      i2.iteration = An(0).variable(), i2.accBeta1 = An(n2).variable();
    }), null == o3 && (i2.epsilon = Nt.backend.epsilon()), i2;
  }
  return e(o2, t2), o2.prototype.applyGradients = function(t3) {
    var e2 = this, n2 = Array.isArray(t3) ? t3.map(function(t4) {
      return t4.name;
    }) : Object.keys(t3);
    je(function() {
      var r2 = uc(1, e2.accBeta1), o3 = qs(-e2.learningRate, e2.iteration.mul(e2.decay).add(1));
      n2.forEach(function(n3, a2) {
        var i2 = Nt.registeredVariables[n3];
        null == e2.accumulatedFirstMoment[a2] && (e2.accumulatedFirstMoment[a2] = {originalName: n3 + "/m", variable: zn(i2).variable(false)}), null == e2.accumulatedWeightedInfNorm[a2] && (e2.accumulatedWeightedInfNorm[a2] = {originalName: n3 + "/v", variable: zn(i2).variable(false)});
        var u2 = Array.isArray(t3) ? t3[a2].tensor : t3[n3];
        if (null != u2) {
          var s2 = e2.accumulatedFirstMoment[a2].variable, c2 = e2.accumulatedWeightedInfNorm[a2].variable, l2 = s2.mul(e2.beta1).add(u2.mul(1 - e2.beta1)), h2 = c2.mul(e2.beta2), f2 = u2.abs(), p2 = h2.maximum(f2);
          s2.assign(l2), c2.assign(p2);
          var d2 = o3.div(r2).mul(l2.div(p2.add(e2.epsilon))).add(i2);
          i2.assign(d2);
        }
      }), e2.iteration.assign(e2.iteration.add(1)), e2.accBeta1.assign(e2.accBeta1.mul(e2.beta1));
    }), this.incrementIterations();
  }, o2.prototype.dispose = function() {
    this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && Xe(this.accumulatedFirstMoment.map(function(t3) {
      return t3.variable;
    })), null != this.accumulatedWeightedInfNorm && Xe(this.accumulatedWeightedInfNorm.map(function(t3) {
      return t3.variable;
    }));
  }, o2.prototype.getWeights = function() {
    return n(this, void 0, void 0, function() {
      return r(this, function(t3) {
        throw new Error("getWeights() is not implemented for Adamax yet.");
      });
    });
  }, o2.prototype.setWeights = function(t3) {
    return n(this, void 0, void 0, function() {
      return r(this, function(t4) {
        throw new Error("setWeights() is not implemented for Adamax yet.");
      });
    });
  }, o2.prototype.getConfig = function() {
    return {learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon, decay: this.decay};
  }, o2.fromConfig = function(t3, e2) {
    return new t3(e2.learningRate, e2.beta1, e2.beta2, e2.epsilon, e2.decay);
  }, o2.className = "Adamax", o2;
}(qf);
Mf($f);
var Yf = function(t2) {
  function o2(e2) {
    var n2 = t2.call(this) || this;
    return n2.learningRate = e2, n2.setLearningRate(e2), n2;
  }
  return e(o2, t2), o2.prototype.applyGradients = function(t3) {
    var e2 = this;
    (Array.isArray(t3) ? t3.map(function(t4) {
      return t4.name;
    }) : Object.keys(t3)).forEach(function(n2, r2) {
      var o3 = Array.isArray(t3) ? t3[r2].tensor : t3[n2];
      if (null != o3) {
        var a2 = Nt.registeredVariables[n2];
        je(function() {
          var t4 = e2.c.mul(o3).add(a2);
          a2.assign(t4);
        });
      }
    }), this.incrementIterations();
  }, o2.prototype.setLearningRate = function(t3) {
    this.learningRate = t3, null != this.c && this.c.dispose(), this.c = $e(An(-t3));
  }, o2.prototype.dispose = function() {
    this.c.dispose();
  }, o2.prototype.getWeights = function() {
    return n(this, void 0, void 0, function() {
      return r(this, function(t3) {
        switch (t3.label) {
          case 0:
            return [4, this.saveIterations()];
          case 1:
            return [2, [t3.sent()]];
        }
      });
    });
  }, o2.prototype.setWeights = function(t3) {
    return n(this, void 0, void 0, function() {
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return [4, this.extractIterations(t3)];
          case 1:
            if (0 !== (t3 = e2.sent()).length)
              throw new Error("SGD optimizer does not have settable weights.");
            return [2];
        }
      });
    });
  }, o2.prototype.getConfig = function() {
    return {learningRate: this.learningRate};
  }, o2.fromConfig = function(t3, e2) {
    return new t3(e2.learningRate);
  }, o2.className = "SGD", o2;
}(qf);
Mf(Yf);
var Qf = function(t2) {
  function o2(e2, n2, r2) {
    void 0 === r2 && (r2 = false);
    var o3 = t2.call(this, e2) || this;
    return o3.learningRate = e2, o3.momentum = n2, o3.useNesterov = r2, o3.accumulations = [], o3.m = An(o3.momentum), o3;
  }
  return e(o2, t2), o2.prototype.applyGradients = function(t3) {
    var e2 = this;
    (Array.isArray(t3) ? t3.map(function(t4) {
      return t4.name;
    }) : Object.keys(t3)).forEach(function(n2, r2) {
      var o3 = Nt.registeredVariables[n2];
      if (null == e2.accumulations[r2]) {
        e2.accumulations[r2] = {originalName: n2 + "/momentum", variable: je(function() {
          return zn(o3).variable(false);
        })};
      }
      var a2 = e2.accumulations[r2].variable, i2 = Array.isArray(t3) ? t3[r2].tensor : t3[n2];
      null != i2 && je(function() {
        var t4, n3 = e2.m.mul(a2).add(i2);
        t4 = e2.useNesterov ? e2.c.mul(i2.add(n3.mul(e2.m))).add(o3) : e2.c.mul(n3).add(o3), a2.assign(n3), o3.assign(t4);
      });
    }), this.incrementIterations();
  }, o2.prototype.dispose = function() {
    this.m.dispose(), null != this.accumulations && Xe(this.accumulations.map(function(t3) {
      return t3.variable;
    }));
  }, o2.prototype.setMomentum = function(t3) {
    this.momentum = t3;
  }, o2.prototype.getWeights = function() {
    return n(this, void 0, void 0, function() {
      return r(this, function(t3) {
        switch (t3.label) {
          case 0:
            return [4, this.saveIterations()];
          case 1:
            return [2, [t3.sent()].concat(this.accumulations.map(function(t4) {
              return {name: t4.originalName, tensor: t4.variable};
            }))];
        }
      });
    });
  }, o2.prototype.setWeights = function(t3) {
    return n(this, void 0, void 0, function() {
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return [4, this.extractIterations(t3)];
          case 1:
            return t3 = e2.sent(), false, this.accumulations = t3.map(function(t4) {
              return {originalName: t4.name, variable: t4.tensor.variable(false)};
            }), [2];
        }
      });
    });
  }, o2.prototype.getConfig = function() {
    return {learningRate: this.learningRate, momentum: this.momentum, useNesterov: this.useNesterov};
  }, o2.fromConfig = function(t3, e2) {
    return new t3(e2.learningRate, e2.momentum, e2.useNesterov);
  }, o2.className = "Momentum", o2;
}(Yf);
Mf(Qf);
var Jf = function(t2) {
  function o2(e2, n2, r2, o3, a2) {
    void 0 === n2 && (n2 = 0.9), void 0 === r2 && (r2 = 0), void 0 === o3 && (o3 = null), void 0 === a2 && (a2 = false);
    var i2 = t2.call(this) || this;
    return i2.learningRate = e2, i2.decay = n2, i2.momentum = r2, i2.epsilon = o3, i2.accumulatedMeanSquares = [], i2.accumulatedMoments = [], i2.accumulatedMeanGrads = [], i2.centered = a2, null == o3 && (i2.epsilon = Nt.backend.epsilon()), i2;
  }
  return e(o2, t2), o2.prototype.applyGradients = function(t3) {
    var e2 = this;
    (Array.isArray(t3) ? t3.map(function(t4) {
      return t4.name;
    }) : Object.keys(t3)).forEach(function(n2, r2) {
      var o3 = Nt.registeredVariables[n2];
      null == e2.accumulatedMeanSquares[r2] && (e2.accumulatedMeanSquares[r2] = {originalName: n2 + "/rms", variable: je(function() {
        return zn(o3).variable(false);
      })}), null == e2.accumulatedMoments[r2] && (e2.accumulatedMoments[r2] = {originalName: n2 + "/momentum", variable: je(function() {
        return zn(o3).variable(false);
      })}), null == e2.accumulatedMeanGrads[r2] && e2.centered && (e2.accumulatedMeanGrads[r2] = {originalName: n2 + "/mg", variable: je(function() {
        return zn(o3).variable(false);
      })});
      var a2 = Array.isArray(t3) ? t3[r2].tensor : t3[n2];
      if (null != a2) {
        var i2 = e2.accumulatedMeanSquares[r2].variable, u2 = e2.accumulatedMoments[r2].variable;
        je(function() {
          var t4 = i2.mul(e2.decay).add(a2.square().mul(1 - e2.decay));
          if (e2.centered) {
            var n3 = e2.accumulatedMeanGrads[r2].variable, s2 = n3.mul(e2.decay).add(a2.mul(1 - e2.decay)), c2 = u2.mul(e2.momentum).add(a2.mul(e2.learningRate).div(t4.sub(s2.square().add(e2.epsilon)).sqrt()));
            i2.assign(t4), n3.assign(s2), u2.assign(c2);
            var l2 = o3.sub(c2);
            o3.assign(l2);
          } else {
            var h2 = i2.mul(e2.decay).add(a2.square().mul(1 - e2.decay));
            c2 = u2.mul(e2.momentum).add(a2.mul(e2.learningRate).div(h2.add(e2.epsilon).sqrt()));
            i2.assign(h2), u2.assign(c2);
            l2 = o3.sub(c2);
            o3.assign(l2);
          }
        });
      }
    }), this.incrementIterations();
  }, o2.prototype.dispose = function() {
    null != this.accumulatedMeanSquares && Xe(this.accumulatedMeanSquares.map(function(t3) {
      return t3.variable;
    })), null != this.accumulatedMeanGrads && this.centered && Xe(this.accumulatedMeanGrads.map(function(t3) {
      return t3.variable;
    })), null != this.accumulatedMoments && Xe(this.accumulatedMoments.map(function(t3) {
      return t3.variable;
    }));
  }, o2.prototype.getWeights = function() {
    return n(this, void 0, void 0, function() {
      var t3;
      return r(this, function(e2) {
        switch (e2.label) {
          case 0:
            return t3 = this.accumulatedMeanSquares.concat(this.accumulatedMoments), this.centered && t3.push.apply(t3, this.accumulatedMeanGrads), [4, this.saveIterations()];
          case 1:
            return [2, [e2.sent()].concat(t3.map(function(t4) {
              return {name: t4.originalName, tensor: t4.variable};
            }))];
        }
      });
    });
  }, o2.prototype.setWeights = function(t3) {
    return n(this, void 0, void 0, function() {
      var e2;
      return r(this, function(n2) {
        switch (n2.label) {
          case 0:
            return [4, this.extractIterations(t3)];
          case 1:
            return t3 = n2.sent(), e2 = this.centered ? t3.length / 3 : t3.length / 2, false, this.accumulatedMeanSquares = t3.slice(0, e2).map(function(t4) {
              return {originalName: t4.name, variable: t4.tensor.variable(false)};
            }), this.accumulatedMoments = t3.slice(e2, 2 * e2).map(function(t4) {
              return {originalName: t4.name, variable: t4.tensor.variable(false)};
            }), this.centered && (this.accumulatedMeanGrads = t3.slice(2 * e2, 3 * e2).map(function(t4) {
              return {originalName: t4.name, variable: t4.tensor.variable(false)};
            })), [2];
        }
      });
    });
  }, o2.prototype.getConfig = function() {
    return {learningRate: this.learningRate, decay: this.decay, momentum: this.momentum, epsilon: this.epsilon, centered: this.centered};
  }, o2.fromConfig = function(t3, e2) {
    return new t3(e2.learningRate, e2.decay, e2.momentum, e2.epsilon, e2.centered);
  }, o2.className = "RMSProp", o2;
}(qf);
Mf(Jf);
var Zf = function() {
  function t2() {
  }
  return t2.sgd = function(t3) {
    return new Yf(t3);
  }, t2.momentum = function(t3, e2, n2) {
    return void 0 === n2 && (n2 = false), new Qf(t3, e2, n2);
  }, t2.rmsprop = function(t3, e2, n2, r2, o2) {
    return void 0 === e2 && (e2 = 0.9), void 0 === n2 && (n2 = 0), void 0 === r2 && (r2 = null), void 0 === o2 && (o2 = false), new Jf(t3, e2, n2, r2, o2);
  }, t2.adam = function(t3, e2, n2, r2) {
    return void 0 === t3 && (t3 = 1e-3), void 0 === e2 && (e2 = 0.9), void 0 === n2 && (n2 = 0.999), void 0 === r2 && (r2 = null), new Xf(t3, e2, n2, r2);
  }, t2.adadelta = function(t3, e2, n2) {
    return void 0 === t3 && (t3 = 1e-3), void 0 === e2 && (e2 = 0.95), void 0 === n2 && (n2 = null), new Kf(t3, e2, n2);
  }, t2.adamax = function(t3, e2, n2, r2, o2) {
    return void 0 === t3 && (t3 = 2e-3), void 0 === e2 && (e2 = 0.9), void 0 === n2 && (n2 = 0.999), void 0 === r2 && (r2 = null), void 0 === o2 && (o2 = 0), new $f(t3, e2, n2, r2, o2);
  }, t2.adagrad = function(t3, e2) {
    return void 0 === e2 && (e2 = 0.1), new jf(t3, e2);
  }, t2;
}();
var tp = {sgd: Zf.sgd, momentum: Zf.momentum, adadelta: Zf.adadelta, adagrad: Zf.adagrad, rmsprop: Zf.rmsprop, adamax: Zf.adamax, adam: Zf.adam};
var ep = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate ? setImmediate : function(t2) {
  return t2();
};
function np() {
  return new Promise(function(t2) {
    return ep(function() {
      return t2();
    });
  });
}
ft = Ih;

// node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js
var DataType;
var SaverDef;
var __assign2 = function() {
  return (__assign2 = Object.assign || function(e2) {
    for (var t2, a2 = 1, r2 = arguments.length; a2 < r2; a2++)
      for (var n2 in t2 = arguments[a2])
        Object.prototype.hasOwnProperty.call(t2, n2) && (e2[n2] = t2[n2]);
    return e2;
  }).apply(this, arguments);
};
function __awaiter2(e2, t2, a2, r2) {
  return new (a2 || (a2 = Promise))(function(n2, s2) {
    function o2(e3) {
      try {
        u2(r2.next(e3));
      } catch (e4) {
        s2(e4);
      }
    }
    function p2(e3) {
      try {
        u2(r2.throw(e3));
      } catch (e4) {
        s2(e4);
      }
    }
    function u2(e3) {
      e3.done ? n2(e3.value) : new a2(function(t3) {
        t3(e3.value);
      }).then(o2, p2);
    }
    u2((r2 = r2.apply(e2, t2 || [])).next());
  });
}
function __generator2(e2, t2) {
  var a2, r2, n2, s2, o2 = {label: 0, sent: function() {
    if (1 & n2[0])
      throw n2[1];
    return n2[1];
  }, trys: [], ops: []};
  return s2 = {next: p2(0), throw: p2(1), return: p2(2)}, "function" == typeof Symbol && (s2[Symbol.iterator] = function() {
    return this;
  }), s2;
  function p2(s3) {
    return function(p3) {
      return function(s4) {
        if (a2)
          throw new TypeError("Generator is already executing.");
        for (; o2; )
          try {
            if (a2 = 1, r2 && (n2 = 2 & s4[0] ? r2.return : s4[0] ? r2.throw || ((n2 = r2.return) && n2.call(r2), 0) : r2.next) && !(n2 = n2.call(r2, s4[1])).done)
              return n2;
            switch (r2 = 0, n2 && (s4 = [2 & s4[0], n2.value]), s4[0]) {
              case 0:
              case 1:
                n2 = s4;
                break;
              case 4:
                return o2.label++, {value: s4[1], done: false};
              case 5:
                o2.label++, r2 = s4[1], s4 = [0];
                continue;
              case 7:
                s4 = o2.ops.pop(), o2.trys.pop();
                continue;
              default:
                if (!(n2 = (n2 = o2.trys).length > 0 && n2[n2.length - 1]) && (6 === s4[0] || 2 === s4[0])) {
                  o2 = 0;
                  continue;
                }
                if (3 === s4[0] && (!n2 || s4[1] > n2[0] && s4[1] < n2[3])) {
                  o2.label = s4[1];
                  break;
                }
                if (6 === s4[0] && o2.label < n2[1]) {
                  o2.label = n2[1], n2 = s4;
                  break;
                }
                if (n2 && o2.label < n2[2]) {
                  o2.label = n2[2], o2.ops.push(s4);
                  break;
                }
                n2[2] && o2.ops.pop(), o2.trys.pop();
                continue;
            }
            s4 = t2.call(e2, o2);
          } catch (e3) {
            s4 = [6, e3], r2 = 0;
          } finally {
            a2 = n2 = 0;
          }
        if (5 & s4[0])
          throw s4[1];
        return {value: s4[0] ? s4[1] : void 0, done: true};
      }([s3, p3]);
    };
  }
}
!function(e2) {
  e2[e2.DT_INVALID = 0] = "DT_INVALID", e2[e2.DT_FLOAT = 1] = "DT_FLOAT", e2[e2.DT_DOUBLE = 2] = "DT_DOUBLE", e2[e2.DT_INT32 = 3] = "DT_INT32", e2[e2.DT_UINT8 = 4] = "DT_UINT8", e2[e2.DT_INT16 = 5] = "DT_INT16", e2[e2.DT_INT8 = 6] = "DT_INT8", e2[e2.DT_STRING = 7] = "DT_STRING", e2[e2.DT_COMPLEX64 = 8] = "DT_COMPLEX64", e2[e2.DT_INT64 = 9] = "DT_INT64", e2[e2.DT_BOOL = 10] = "DT_BOOL", e2[e2.DT_QINT8 = 11] = "DT_QINT8", e2[e2.DT_QUINT8 = 12] = "DT_QUINT8", e2[e2.DT_QINT32 = 13] = "DT_QINT32", e2[e2.DT_BFLOAT16 = 14] = "DT_BFLOAT16", e2[e2.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", e2[e2.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", e2[e2.DT_INT32_REF = 103] = "DT_INT32_REF", e2[e2.DT_UINT8_REF = 104] = "DT_UINT8_REF", e2[e2.DT_INT16_REF = 105] = "DT_INT16_REF", e2[e2.DT_INT8_REF = 106] = "DT_INT8_REF", e2[e2.DT_STRING_REF = 107] = "DT_STRING_REF", e2[e2.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", e2[e2.DT_INT64_REF = 109] = "DT_INT64_REF", e2[e2.DT_BOOL_REF = 110] = "DT_BOOL_REF", e2[e2.DT_QINT8_REF = 111] = "DT_QINT8_REF", e2[e2.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", e2[e2.DT_QINT32_REF = 113] = "DT_QINT32_REF", e2[e2.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF";
}(DataType || (DataType = {})), function(e2) {
  !function(e3) {
    e3[e3.LEGACY = 0] = "LEGACY", e3[e3.V1 = 1] = "V1", e3[e3.V2 = 2] = "V2";
  }(e2.CheckpointFormatVersion || (e2.CheckpointFormatVersion = {}));
}(SaverDef || (SaverDef = {}));
var CUSTOM_OPS = {};
function getRegisteredOp(e2) {
  return CUSTOM_OPS[e2];
}
function getParamValue(e2, t2, a2, r2) {
  var n2 = t2.inputParams[e2];
  if (n2 && void 0 !== n2.inputIndexStart) {
    var s2 = n2.inputIndexStart, o2 = 0 === n2.inputIndexEnd ? void 0 : void 0 === n2.inputIndexEnd ? s2 + 1 : n2.inputIndexEnd;
    if ("tensor" === n2.type)
      return getTensor(t2.inputNames[n2.inputIndexStart], a2, r2);
    if ("tensors" === n2.type)
      return t2.inputNames.slice(s2, o2).map(function(e3) {
        return getTensor(e3, a2, r2);
      });
    var p2 = Array.prototype.slice.call(getTensor(t2.inputNames.slice(s2)[0], a2, r2).dataSync());
    return "number" === n2.type ? p2[0] : p2;
  }
  var u2 = t2.attrParams[e2];
  return u2 && u2.value;
}
function getTensor(e2, t2, a2) {
  var r2 = parseNodeName(e2), n2 = r2[0], s2 = r2[1], o2 = a2.currentContextIds.find(function(e3) {
    return !!t2[getNodeNameWithContextId(n2, e3)];
  });
  return void 0 !== o2 ? t2[getNodeNameWithContextId(n2, o2)][s2] : void 0;
}
function getTensorsForCurrentContenxt(e2, t2, a2) {
  return t2[getNodeNameWithContextId(e2, a2.currentContextId)];
}
function getNodeNameAndIndex(e2, t2) {
  var a2 = parseNodeName(e2), r2 = a2[0], n2 = a2[1];
  return [getNodeNameWithContextId(r2, t2 && t2.currentContextId), n2];
}
function getNodeNameWithContextId(e2, t2) {
  return t2 ? e2 + "-" + t2 : e2;
}
function parseNodeName(e2) {
  var t2 = e2.lastIndexOf(":");
  return -1 === t2 ? [e2, 0] : [e2.substring(0, t2), Number(e2.substring(t2 + 1))];
}
function split$1(e2, t2) {
  for (var a2 = [], r2 = 0; r2 < e2.length; r2 += t2)
    a2.push(e2.slice(r2, r2 + t2));
  return a2;
}
var json = [{tfOpName: "Add", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "AddV2", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "AddN", category: "arithmetic", inputs: [{start: 0, end: 0, name: "tensors", type: "tensors"}]}, {tfOpName: "BiasAdd", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Sub", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "RealDiv", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Div", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "DivNoNan", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "FloorDiv", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Mul", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Maximum", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}]}, {tfOpName: "Minimum", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}]}, {tfOpName: "Pow", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "SquaredDifference", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Mod", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "FloorMod", category: "arithmetic", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}];
var arithmetic = Object.freeze({json});
var json$1 = [{tfOpName: "Abs", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Acos", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Asin", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Atan", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Atan2", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "y", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Ceil", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "ClipByValue", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "clip_value_min", name: "clipValueMin", type: "number"}, {tfName: "clip_value_max", name: "clipValueMax", type: "number"}]}, {tfOpName: "Complex", category: "basic_math", inputs: [{start: 0, name: "real", type: "tensor"}, {start: 1, name: "imag", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "ComplexAbs", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Cos", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Cosh", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Elu", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Exp", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Floor", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Log", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Imag", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}, {tfName: "Tout", name: "outputType", type: "dtype", notSupported: true}]}, {tfOpName: "Neg", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Real", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}, {tfName: "Tout", name: "outputType", type: "dtype", notSupported: true}]}, {tfOpName: "Prelu", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "alpha", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Relu", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Relu6", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}, {tfName: "clipValueMin", name: "clipValueMin", type: "number", defaultValue: 0}, {tfName: "clipValueMax", name: "clipValueMax", type: "number", defaultValue: 6}]}, {tfOpName: "Selu", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Sigmoid", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Sin", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Sinh", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Sqrt", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Rsqrt", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Square", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Tan", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Tanh", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Sign", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Round", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Expm1", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Log1p", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Reciprocal", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Softplus", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Asinh", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Acosh", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Atanh", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Erf", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Prod", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axes", type: "number[]"}], attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool", notSupported: true}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "LeakyRelu", category: "basic_math", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "alpha", name: "alpha", type: "number", defaultValue: 0.2}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}];
var basicMath = Object.freeze({json: json$1});
var json$2 = [{tfOpName: "LoopCond", category: "control", inputs: [{start: 0, name: "pred", type: "tensor"}]}, {tfOpName: "Switch", category: "control", inputs: [{start: 0, name: "data", type: "tensor"}, {start: 1, name: "pred", type: "tensor"}]}, {tfOpName: "Merge", category: "control", inputs: [{start: 0, end: 0, name: "tensors", type: "tensors"}]}, {tfOpName: "Enter", category: "control", inputs: [{start: 0, name: "tensor", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}, {tfName: "frame_name", name: "frameName", type: "string"}, {tfName: "is_constant", name: "isConstant", type: "bool"}]}, {tfOpName: "Exit", category: "control", inputs: [{start: 0, name: "tensor", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "NextIteration", category: "control", inputs: [{start: 0, name: "tensor", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "TensorArrayV3", category: "control", inputs: [{start: 0, name: "size", type: "number"}], attrs: [{tfName: "dtype", name: "dtype", type: "dtype"}, {tfName: "element_shape", name: "elementShape", type: "shape"}, {tfName: "dynamic_size", name: "dynamicSize", type: "bool"}, {tfName: "clear_after_read", name: "clearAfterRead", type: "bool"}, {tfName: "identical_element_shapes", name: "identicalElementShapes", type: "bool"}, {tfName: "tensor_array_name", name: "name", type: "string"}]}, {tfOpName: "TensorArrayWriteV3", category: "control", inputs: [{start: 0, name: "tensorArrayId", type: "number"}, {start: 1, name: "index", type: "number"}, {start: 2, name: "tensor", type: "tensor"}, {start: 3, name: "flowIn", type: "number"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "TensorArrayReadV3", category: "control", inputs: [{start: 0, name: "tensorArrayId", type: "number"}, {start: 1, name: "index", type: "number"}, {start: 2, name: "flowIn", type: "number"}], attrs: [{tfName: "dtype", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "TensorArrayGatherV3", category: "control", inputs: [{start: 0, name: "tensorArrayId", type: "number"}, {start: 1, name: "indices", type: "number[]"}, {start: 2, name: "flowIn", type: "number"}], attrs: [{tfName: "dtype", name: "dtype", type: "dtype"}, {tfName: "element_shape", name: "elementShape", type: "shape"}]}, {tfOpName: "TensorArrayScatterV3", category: "control", inputs: [{start: 0, name: "tensorArrayId", type: "number"}, {start: 1, name: "indices", type: "number[]"}, {start: 2, name: "tensor", type: "tensor"}, {start: 3, name: "flowIn", type: "number"}], attrs: [{tfName: "T", name: "dtype", type: "dtype"}]}, {tfOpName: "TensorArrayConcatV3", category: "control", inputs: [{start: 0, name: "tensorArrayId", type: "number"}, {start: 1, name: "flowIn", type: "number"}], attrs: [{tfName: "dtype", name: "dtype", type: "dtype"}, {tfName: "element_shape_except0", name: "elementShapeExcept0", type: "shape", notSupported: true}]}, {tfOpName: "TensorArraySplitV3", category: "control", inputs: [{start: 0, name: "tensorArrayId", type: "number"}, {start: 1, name: "tensor", type: "tensor"}, {start: 2, name: "lengths", type: "number[]"}, {start: 3, name: "flowIn", type: "number"}], attrs: [{tfName: "T", name: "dtype", type: "dtype"}]}, {tfOpName: "TensorArraySizeV3", category: "control", inputs: [{start: 0, name: "tensorArrayId", type: "number"}, {start: 1, name: "flowIn", type: "number"}]}, {tfOpName: "TensorArrayCloseV3", category: "control", inputs: [{start: 0, name: "tensorArrayId", type: "number"}]}];
var control = Object.freeze({json: json$2});
var json$3 = [{tfOpName: "AvgPool", category: "convolution", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "data_format", name: "dataFormat", type: "string", notSupported: true}, {tfName: "ksize", name: "kernelSize", type: "number[]"}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "MaxPool", category: "convolution", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "data_format", name: "dataFormat", type: "string", notSupported: true}, {tfName: "ksize", name: "kernelSize", type: "number[]"}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "AvgPool3D", category: "convolution", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "data_format", name: "dataFormat", type: "string", notSupported: true}, {tfName: "ksize", name: "kernelSize", type: "number[]"}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "MaxPool3D", category: "convolution", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "data_format", name: "dataFormat", type: "string", notSupported: true}, {tfName: "ksize", name: "kernelSize", type: "number[]"}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Conv1D", category: "convolution", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "filter", type: "tensor"}], attrs: [{tfName: "stride", name: "stride", type: "number"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NWC"}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}, {tfName: "dilation", name: "dilation", type: "number", defaultValue: 1}]}, {tfOpName: "Conv2D", category: "convolution", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "filter", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}, {tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "useCudnnOnGpu", name: "useCudnnOnGpu", type: "bool"}, {tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC"}, {tfName: "dilations", name: "dilations", type: "number[]"}]}, {tfOpName: "_FusedConv2D", category: "convolution", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "filter", type: "tensor"}, {start: 2, end: 0, name: "args", type: "tensors"}], attrs: [{tfName: "num_args", name: "numArgs", type: "number"}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}, {tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: []}, {tfName: "use_cudnn_on_gpu", name: "useCudnnOnGpu", type: "bool", defaultValue: true}, {tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC"}, {tfName: "dilations", name: "dilations", type: "number[]", defaultValue: [1, 1, 1, 1]}, {tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: []}, {tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-4}]}, {tfOpName: "Conv2DBackpropInput", category: "convolution", inputs: [{start: 2, name: "x", type: "tensor"}, {start: 1, name: "filter", type: "tensor"}, {start: 0, name: "outputShape", type: "number[]"}], attrs: [{tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "data_format", name: "dataFormat", type: "string", notSupported: true}]}, {tfOpName: "DepthwiseConv2d", category: "convolution", inputs: [{start: 0, name: "input", type: "tensor"}, {start: 1, name: "filter", type: "tensor"}], attrs: [{tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC"}, {tfName: "dilations", name: "dilations", type: "number[]"}]}, {tfOpName: "DepthwiseConv2dNative", category: "convolution", inputs: [{start: 0, name: "input", type: "tensor"}, {start: 1, name: "filter", type: "tensor"}], attrs: [{tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC"}, {tfName: "dilations", name: "dilations", type: "number[]"}]}, {tfOpName: "Conv3D", category: "convolution", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "filter", type: "tensor"}], attrs: [{tfName: "strides", name: "strides", type: "number[]"}, {tfName: "padding", name: "pad", type: "string"}, {tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC"}, {tfName: "dilations", name: "dilations", type: "number[]"}]}];
var convolution = Object.freeze({json: json$3});
var json$4 = [{tfOpName: "Fill", category: "creation", inputs: [{start: 0, name: "shape", type: "number[]"}, {start: 1, name: "value", type: "number"}], attrs: [{tfName: "T", name: "dtype", type: "dtype"}]}, {tfOpName: "LinSpace", category: "creation", inputs: [{start: 0, name: "start", type: "number"}, {start: 1, name: "stop", type: "number"}, {start: 2, name: "num", type: "number"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "OneHot", category: "creation", inputs: [{start: 0, name: "indices", type: "tensor"}, {start: 1, name: "depth", type: "number"}, {start: 2, name: "onValue", type: "number", defaultValue: 1}, {start: 3, name: "offValue", type: "number", defaultValue: 0}], attrs: [{tfName: "axis", name: "axis", type: "number", notSupported: true}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Ones", category: "creation", inputs: [{start: 0, name: "shape", type: "number[]"}], attrs: [{tfName: "T", name: "dtype", type: "dtype"}]}, {tfOpName: "OnesLike", category: "creation", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "dtype", name: "dtype", type: "dtype"}]}, {tfOpName: "RandomUniform", category: "creation", inputs: [{start: 0, name: "shape", type: "number[]"}], attrs: [{tfName: "minval", name: "minval", type: "number", defaultValue: 0}, {tfName: "maxval", name: "maxval", type: "number", defaultValue: 1}, {tfName: "dtype", name: "dtype", type: "dtype"}, {tfName: "seed", name: "seed", type: "number", defaultValue: 0}, {tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true}, {tfName: "T", name: "T", type: "number", notSupported: true}]}, {tfOpName: "Range", category: "creation", inputs: [{start: 0, name: "start", type: "number"}, {start: 1, name: "stop", type: "number"}, {start: 2, name: "step", type: "number", defaultValue: 0}], attrs: [{tfName: "Tidx", name: "dtype", type: "dtype"}]}, {tfOpName: "TruncatedNormal", category: "creation", inputs: [{start: 0, name: "shape", type: "number[]"}], attrs: [{tfName: "means", name: "mean", type: "number", defaultValue: 0}, {tfName: "stddev", name: "stdDev", type: "number", defaultValue: 1}, {tfName: "seed", name: "seed", type: "number"}, {tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: true}, {tfName: "dtype", name: "dtype", type: "dtype"}, {tfName: "T", name: "T", type: "number", notSupported: true}]}, {tfOpName: "Zeros", category: "creation", inputs: [{start: 0, name: "shape", type: "number[]"}], attrs: [{tfName: "T", name: "dtype", type: "dtype"}]}, {tfOpName: "ZerosLike", category: "creation", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype"}]}, {tfOpName: "Multinomial", category: "creation", inputs: [{start: 0, name: "logits", type: "tensor"}, {start: 1, name: "numSamples", type: "number"}], attrs: [{tfName: "seed", name: "seed", type: "number"}, {tfName: "seed2", name: "seed2", type: "number"}, {tfName: "T", name: "dtype", type: "dtype"}, {tfName: "output_dtype", name: "output_dtype", type: "dtype"}]}];
var creation = Object.freeze({json: json$4});
var json$5 = [{tfOpName: "NonMaxSuppressionV2", category: "dynamic", inputs: [{start: 0, name: "boxes", type: "tensor"}, {start: 1, name: "scores", type: "tensor"}, {start: 2, name: "maxOutputSize", type: "number"}, {start: 3, name: "iouThreshold", type: "number"}]}, {tfOpName: "NonMaxSuppressionV3", category: "dynamic", inputs: [{start: 0, name: "boxes", type: "tensor"}, {start: 1, name: "scores", type: "tensor"}, {start: 2, name: "maxOutputSize", type: "number"}, {start: 3, name: "iouThreshold", type: "number"}, {start: 4, name: "scoreThreshold", type: "number"}]}, {tfOpName: "Where", category: "dynamic", inputs: [{start: 0, name: "condition", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "ListDiff", category: "dynamic", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "y", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}];
var dynamic = Object.freeze({json: json$5});
var json$6 = [{tfOpName: "TopKV2", category: "evaluation", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "k", type: "number"}], attrs: [{tfName: "sorted", name: "sorted", type: "bool"}]}];
var evaluation = Object.freeze({json: json$6});
var json$7 = [{tfOpName: "PlaceholderWithDefault", category: "graph", inputs: [{start: 0, name: "default", type: "tensor"}], attrs: [{tfName: "shape", name: "shape", type: "shape"}, {tfName: "dtype", name: "dtype", type: "dtype"}]}, {tfOpName: "Placeholder", category: "graph", attrs: [{tfName: "shape", name: "shape", type: "shape"}, {tfName: "dtype", name: "dtype", type: "dtype"}]}, {tfOpName: "Const", category: "graph"}, {tfOpName: "Identity", category: "graph", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "IdentityN", category: "graph", inputs: [{start: 0, end: 0, name: "x", type: "tensors"}]}, {tfOpName: "Snapshot", category: "graph", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "Rank", category: "graph", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "Size", category: "graph", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "Shape", category: "graph", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "ShapeN", category: "graph", inputs: [{start: 0, end: 0, name: "x", type: "tensors"}]}, {tfOpName: "Print", category: "graph", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "data", type: "tensors"}], attrs: [{tfName: "message", name: "message", type: "string"}, {tfName: "first_n", name: "firstN", type: "number", notSupported: true}, {tfName: "summarize", name: "summarize", type: "number", defaultValue: 3}]}, {tfOpName: "NoOp", category: "graph", inputs: []}, {tfOpName: "StopGradient", category: "graph", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "FakeQuantWithMinMaxVars", category: "graph", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "min", name: "min", type: "number"}, {tfName: "max", name: "max", type: "number"}]}];
var graph = Object.freeze({json: json$7});
var json$8 = [{tfOpName: "ResizeBilinear", category: "image", inputs: [{start: 0, name: "images", type: "tensor"}, {start: 1, name: "size", type: "number[]"}], attrs: [{tfName: "align_corners", name: "alignCorners", type: "bool"}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "ResizeNearestNeighbor", category: "image", inputs: [{start: 0, name: "images", type: "tensor"}, {start: 1, name: "size", type: "number[]"}], attrs: [{tfName: "align_corners", name: "alignCorners", type: "bool"}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "CropAndResize", category: "image", inputs: [{start: 0, name: "image", type: "tensor"}, {start: 1, name: "boxes", type: "tensor"}, {start: 2, name: "boxInd", type: "tensor"}, {start: 3, name: "cropSize", type: "number[]"}], attrs: [{tfName: "method", name: "method", type: "string"}, {tfName: "extrapolation_value", name: "extrapolationValue", type: "number"}]}];
var image$1 = Object.freeze({json: json$8});
var json$9 = [{tfOpName: "Equal", category: "logical", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "NotEqual", category: "logical", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Greater", category: "logical", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "GreaterEqual", category: "logical", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Less", category: "logical", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "LessEqual", category: "logical", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "LogicalAnd", category: "logical", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "LogicalNot", category: "logical", inputs: [{start: 0, name: "a", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "LogicalOr", category: "logical", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Select", category: "logical", inputs: [{start: 0, name: "condition", type: "tensor"}, {start: 1, name: "a", type: "tensor"}, {start: 2, name: "b", type: "tensor"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}];
var logical = Object.freeze({json: json$9});
var json$10 = [{tfOpName: "MatMul", category: "matrices", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "transpose_a", name: "transposeA", type: "bool", defaultValue: false}, {tfName: "transpose_b", name: "transposeB", type: "bool", defaultValue: false}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "BatchMatMul", category: "matrices", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "adj_x", name: "transposeA", type: "bool", defaultValue: false}, {tfName: "adj_y", name: "transposeB", type: "bool", defaultValue: false}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "BatchMatMulV2", category: "matrices", inputs: [{start: 0, name: "a", type: "tensor"}, {start: 1, name: "b", type: "tensor"}], attrs: [{tfName: "adj_x", name: "transposeA", type: "bool", defaultValue: false}, {tfName: "adj_y", name: "transposeB", type: "bool", defaultValue: false}, {tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}, {tfOpName: "Transpose", category: "matrices", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "perm", type: "number[]"}], attrs: [{tfName: "T", name: "dtype", type: "dtype", notSupported: true}]}];
var matrices = Object.freeze({json: json$10});
var json$11 = [{tfOpName: "FusedBatchNorm", category: "normalization", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "scale", type: "tensor"}, {start: 2, name: "offset", type: "tensor"}, {start: 3, name: "mean", type: "tensor"}, {start: 4, name: "variance", type: "tensor"}], attrs: [{tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3}, {tfName: "data_format", name: "dataFormat", type: "string", notSupported: true}]}, {tfOpName: "FusedBatchNormV2", category: "normalization", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "scale", type: "tensor"}, {start: 2, name: "offset", type: "tensor"}, {start: 3, name: "mean", type: "tensor"}, {start: 4, name: "variance", type: "tensor"}], attrs: [{tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3}, {tfName: "data_format", name: "dataFormat", type: "string", notSupported: true}]}, {tfOpName: "FusedBatchNormV3", category: "normalization", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "scale", type: "tensor"}, {start: 2, name: "offset", type: "tensor"}, {start: 3, name: "mean", type: "tensor"}, {start: 4, name: "variance", type: "tensor"}], attrs: [{tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3}, {tfName: "data_format", name: "dataFormat", type: "string", notSupported: true}]}, {tfOpName: "LRN", category: "normalization", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "depth_radius", name: "radius", type: "number", defaultValue: 5}, {tfName: "bias", name: "bias", type: "number", defaultValue: 1}, {tfName: "alpha", name: "alpha", type: "number", defaultValue: 1}, {tfName: "beta", name: "beta", type: "number", defaultValue: 0.5}]}, {tfOpName: "Softmax", category: "normalization", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "LogSoftmax", category: "normalization", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "SparseToDense", category: "normalization", inputs: [{start: 0, name: "sparseIndices", type: "tensor"}, {start: 1, name: "outputShape", type: "number[]"}, {start: 2, name: "sparseValues", type: "tensor"}, {start: 3, name: "defaultValue", type: "tensor"}], attrs: [{tfName: "validate_indices", name: "validateIndices", type: "bool", defaultValue: true, notSupported: true}]}];
var normalization = Object.freeze({json: json$11});
var json$12 = [{tfOpName: "Max", category: "reduction", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number[]"}], attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]}, {tfOpName: "Mean", category: "reduction", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number[]"}], attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]}, {tfOpName: "Min", category: "reduction", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number[]"}], attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]}, {tfOpName: "Sum", category: "reduction", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number[]"}], attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]}, {tfOpName: "All", category: "reduction", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number[]"}], attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]}, {tfOpName: "Any", category: "reduction", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number[]"}], attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]}, {tfOpName: "ArgMax", category: "reduction", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number"}]}, {tfOpName: "ArgMin", category: "reduction", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number"}]}, {tfOpName: "Prod", category: "reduction", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number[]"}], attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]}];
var reduction = Object.freeze({json: json$12});
var json$13 = [{tfOpName: "ConcatV2", category: "slice_join", inputs: [{start: 0, end: -1, name: "tensors", type: "tensors"}, {start: -1, name: "axis", type: "number"}], attrs: [{tfName: "N", name: "n", type: "number", defaultValue: 2}]}, {tfOpName: "Concat", category: "slice_join", inputs: [{start: 1, end: 0, name: "tensors", type: "tensors"}, {start: 0, name: "axis", type: "number"}], attrs: [{tfName: "N", name: "n", type: "number", defaultValue: 2}]}, {tfOpName: "GatherV2", category: "slice_join", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "indices", type: "tensor"}, {start: 2, name: "axis", type: "number", defaultValue: 0}]}, {tfOpName: "Gather", category: "slice_join", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "indices", type: "tensor"}], attrs: [{tfName: "axis", name: "axis", type: "number", defaultValue: 0}, {tfName: "validate_indices", name: "validateIndices", type: "bool", notSupported: true}]}, {tfOpName: "Reverse", category: "slice_join", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "dims", type: "bool", notSupported: true}]}, {tfOpName: "ReverseV2", category: "slice_join", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number[]"}]}, {tfOpName: "Slice", category: "slice_join", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "begin", type: "number[]"}, {start: 2, name: "size", type: "number[]"}]}, {tfOpName: "StridedSlice", category: "slice_join", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "begin", type: "number[]"}, {start: 2, name: "end", type: "number[]"}, {start: 3, name: "strides", type: "number[]"}], attrs: [{tfName: "begin_mask", name: "beginMask", type: "number", defaultValue: 0}, {tfName: "end_mask", name: "endMask", type: "number", defaultValue: 0}, {tfName: "new_axis_mask", name: "newAxisMask", type: "number", defaultValue: 0}, {tfName: "ellipsis_mask", name: "ellipsisMask", type: "number", defaultValue: 0}, {tfName: "shrink_axis_mask", name: "shrinkAxisMask", type: "number", defaultValue: 0}]}, {tfOpName: "Pack", category: "slice_join", inputs: [{start: 0, end: 0, name: "tensors", type: "tensors"}], attrs: [{tfName: "axis", name: "axis", type: "number", defaultValue: 0}]}, {tfOpName: "Unpack", category: "slice_join", inputs: [{start: 0, name: "tensor", type: "tensor"}], attrs: [{tfName: "axis", name: "axis", type: "number", defaultValue: 0}, {tfName: "num", name: "num", type: "number", defaultValue: 0, notSupported: true}]}, {tfOpName: "Tile", category: "slice_join", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "reps", type: "number[]"}]}, {tfOpName: "Split", category: "slice_join", inputs: [{start: 0, name: "axis", type: "number", defaultValue: 0}, {start: 1, name: "x", type: "tensor"}], attrs: [{tfName: "num_split", name: "numOrSizeSplits", type: "number", defaultValue: 1}]}, {tfOpName: "SplitV", category: "slice_join", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "numOrSizeSplits", type: "number[]"}, {start: 2, name: "axis", type: "number", defaultValue: 0}]}, {tfOpName: "ScatterNd", category: "slice_join", inputs: [{start: 0, name: "indices", type: "tensor"}, {start: 1, name: "values", type: "tensor"}, {start: 2, name: "shape", type: "number[]"}]}, {tfOpName: "GatherNd", category: "slice_join", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "indices", type: "tensor"}]}, {tfOpName: "SparseToDense", category: "slice_join", inputs: [{start: 0, name: "sparseIndices", type: "tensor"}, {start: 1, name: "outputShape", type: "number[]"}, {start: 2, name: "sparseValues", type: "tensor"}, {start: 3, name: "defaultValue", type: "tensor"}], attrs: [{tfName: "validate_indices", name: "validateIndices", type: "bool", defaultValue: false, notSupported: true}]}];
var sliceJoin = Object.freeze({json: json$13});
var json$14 = [{tfOpName: "FFT", category: "spectral", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "IFFT", category: "spectral", inputs: [{start: 0, name: "x", type: "tensor"}]}, {tfOpName: "RFFT", category: "spectral", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "fft_length", type: "number", notSupported: true}]}, {tfOpName: "IRFFT", category: "spectral", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "fft_length", type: "number", notSupported: true}]}];
var spectral = Object.freeze({json: json$14});
var json$15 = [{tfOpName: "Cast", category: "transformation", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "SrcT", name: "sdtype", type: "dtype", notSupported: true}, {tfName: "DstT", name: "dtype", type: "dtype"}]}, {tfOpName: "ExpandDims", category: "transformation", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "axis", type: "number"}]}, {tfOpName: "Pad", category: "transformation", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "padding", type: "number[]"}], attrs: [{tfName: "constant_value", name: "constantValue", type: "number", defaultValue: 0}]}, {tfOpName: "PadV2", category: "transformation", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "padding", type: "number[]"}, {start: 2, name: "constantValue", type: "number", defaultValue: 0}]}, {tfOpName: "Reshape", category: "transformation", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "shape", type: "number[]"}]}, {tfOpName: "Squeeze", category: "transformation", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "axis", tfDeprecatedName: "squeeze_dims", name: "axis", type: "number[]"}]}, {tfOpName: "SpaceToBatchND", category: "transformation", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "blockShape", type: "number[]"}, {start: 2, name: "paddings", type: "number[]"}]}, {tfOpName: "BatchToSpaceND", category: "transformation", inputs: [{start: 0, name: "x", type: "tensor"}, {start: 1, name: "blockShape", type: "number[]"}, {start: 2, name: "crops", type: "number[]"}]}, {tfOpName: "DepthToSpace", category: "transformation", inputs: [{start: 0, name: "x", type: "tensor"}], attrs: [{tfName: "block_size", name: "blockSize", type: "number"}, {tfName: "data_format", name: "dataFormat", type: "string"}]}];
var transformation = Object.freeze({json: json$15});
var OperationMapper = function() {
  function e2() {
    var e3 = [arithmetic, basicMath, control, convolution, creation, dynamic, evaluation, logical, image$1, graph, matrices, normalization, reduction, sliceJoin, spectral, transformation], t2 = [].concat.apply([], e3.map(function(e4) {
      return e4.json;
    }));
    this.opMappers = t2.reduce(function(e4, t3) {
      return e4[t3.tfOpName] = t3, e4;
    }, {});
  }
  return Object.defineProperty(e2, "Instance", {get: function() {
    return this._instance || (this._instance = new this());
  }, enumerable: true, configurable: true}), e2.prototype.transformGraph = function(e3) {
    var t2 = this, a2 = [], r2 = [], n2 = e3.node.reduce(function(e4, n3) {
      return e4[n3.name] = t2.mapNode(n3), "Placeholder" === n3.op && a2.push(e4[n3.name]), "Const" === n3.op && r2.push(e4[n3.name]), e4;
    }, {}), s2 = [], o2 = [], p2 = Object.keys(n2);
    return p2.forEach(function(e4) {
      var t3 = n2[e4];
      t3.inputNames.forEach(function(e5) {
        var a3 = getNodeNameAndIndex(e5)[0];
        t3.inputs.push(n2[a3]), n2[a3].children.push(t3);
      }), 0 === t3.inputs.length && s2.push(t3);
    }), p2.forEach(function(e4) {
      var t3 = n2[e4];
      0 === t3.children.length && o2.push(t3);
    }), {nodes: n2, inputs: s2, outputs: o2, weights: r2, placeholders: a2};
  }, e2.prototype.mapNode = function(e3) {
    var t2 = getRegisteredOp(e3.op) || this.opMappers[e3.op] || {};
    null == e3.attr && (e3.attr = {});
    var a2 = {name: e3.name, op: e3.op, category: t2.category, inputNames: (e3.input || []).map(function(e4) {
      return e4.startsWith("^") ? e4.substr(1) : e4;
    }), inputs: [], children: [], inputParams: {}, attrParams: {}, rawAttrs: e3.attr};
    return null != t2.inputs && (a2.inputParams = t2.inputs.reduce(function(e4, t3) {
      return e4[t3.name] = {type: t3.type, inputIndexStart: t3.start, inputIndexEnd: t3.end}, e4;
    }, {})), null != t2.attrs && (a2.attrParams = t2.attrs.reduce(function(t3, a3) {
      var r2 = a3.type, n2 = void 0;
      switch (a3.type) {
        case "string":
          void 0 === (n2 = getStringParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getStringParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "string[]":
          void 0 === (n2 = getStringArrayParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getStringArrayParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "number":
          void 0 === (n2 = getNumberParam(e3.attr, a3.tfName, a3.defaultValue || 0)) && a3.tfDeprecatedName && (n2 = getNumberParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "number[]":
          void 0 === (n2 = getNumericArrayParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getNumericArrayParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "bool":
          void 0 === (n2 = getBoolParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getBoolParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "bool[]":
          void 0 === (n2 = getBoolArrayParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getBoolArrayParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "shape":
          void 0 === (n2 = getTensorShapeParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getTensorShapeParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "shape[]":
          void 0 === (n2 = getTensorShapeArrayParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getTensorShapeArrayParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "dtype":
          void 0 === (n2 = getDtypeParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getDtypeParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "dtype[]":
          void 0 === (n2 = getDtypeArrayParam(e3.attr, a3.tfName, a3.defaultValue)) && a3.tfDeprecatedName && (n2 = getDtypeArrayParam(e3.attr, a3.tfDeprecatedName, a3.defaultValue));
          break;
        case "tensor":
        case "tensors":
          break;
        default:
          throw new Error("Unsupported param type: " + a3.type + " for op: " + e3.op);
      }
      return t3[a3.name] = {value: n2, type: r2}, t3;
    }, {})), a2;
  }, e2;
}();
function decodeBase64(e2) {
  var t2 = a().global;
  if (void 0 !== t2.atob)
    return t2.atob(e2);
  if ("undefined" != typeof Buffer)
    return new Buffer(e2, "base64").toString();
  throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
}
function parseStringParam(e2, t2) {
  var a2 = Array.isArray(e2) ? String.fromCharCode.apply(null, e2) : decodeBase64(e2);
  return t2 ? a2 : a2.toLowerCase();
}
function getStringParam(e2, t2, a2, r2) {
  void 0 === r2 && (r2 = false);
  var n2 = e2[t2];
  return null != n2 ? parseStringParam(n2.s, r2) : a2;
}
function getBoolParam(e2, t2, a2) {
  var r2 = e2[t2];
  return r2 ? r2.b : a2;
}
function getNumberParam(e2, t2, a2) {
  var r2 = e2[t2] || {}, n2 = null != r2.i ? r2.i : null != r2.f ? r2.f : a2;
  return "number" == typeof n2 ? n2 : parseInt(n2, 10);
}
function parseDtypeParam(e2) {
  switch ("string" == typeof e2 && (e2 = DataType[e2]), e2) {
    case DataType.DT_FLOAT:
      return "float32";
    case DataType.DT_INT32:
    case DataType.DT_INT64:
      return "int32";
    case DataType.DT_BOOL:
      return "bool";
    case DataType.DT_DOUBLE:
      return "float32";
    case DataType.DT_STRING:
      return "string";
    default:
      return null;
  }
}
function getDtypeParam(e2, t2, a2) {
  var r2 = e2[t2];
  return r2 && r2.type ? parseDtypeParam(r2.type) : a2;
}
function getDtypeArrayParam(e2, t2, a2) {
  var r2 = e2[t2];
  return r2 && r2.list && r2.list.type ? r2.list.type.map(function(e3) {
    return parseDtypeParam(e3);
  }) : a2;
}
function parseTensorShapeParam(e2) {
  if (!e2.unknownRank)
    return null != e2.dim ? e2.dim.map(function(e3) {
      return "number" == typeof e3.size ? e3.size : parseInt(e3.size, 10);
    }) : [];
}
function getTensorShapeParam(e2, t2, a2) {
  var r2 = e2[t2];
  return r2 && r2.shape ? parseTensorShapeParam(r2.shape) : a2;
}
function getNumericArrayParam(e2, t2, a2) {
  var r2 = e2[t2];
  return r2 ? ((r2.list.f && r2.list.f.length ? r2.list.f : r2.list.i) || []).map(function(e3) {
    return "number" == typeof e3 ? e3 : parseInt(e3, 10);
  }) : a2;
}
function getStringArrayParam(e2, t2, a2, r2) {
  void 0 === r2 && (r2 = false);
  var n2 = e2[t2];
  return n2 && n2.list && n2.list.s ? n2.list.s.map(function(e3) {
    return parseStringParam(e3, r2);
  }) : a2;
}
function getTensorShapeArrayParam(e2, t2, a2) {
  var r2 = e2[t2];
  return r2 && r2.list && r2.list.shape ? r2.list.shape.map(function(e3) {
    return parseTensorShapeParam(e3);
  }) : a2;
}
function getBoolArrayParam(e2, t2, a2) {
  var r2 = e2[t2];
  return r2 && r2.list && r2.list.b ? r2.list.b : a2;
}
var NodeValueImpl = function() {
  function e2(e3, t2, a2) {
    var r2 = this;
    this.node = e3, this.tensorMap = t2, this.context = a2, this.inputs = [], this.attrs = {}, this.inputs = e3.inputNames.map(function(e4) {
      return r2.getInput(e4);
    }), null != e3.rawAttrs && (this.attrs = Object.keys(e3.rawAttrs).reduce(function(e4, t3) {
      return e4[t3] = r2.getAttr(t3), e4;
    }, {}));
  }
  return e2.prototype.getInput = function(e3) {
    return getTensor(e3, this.tensorMap, this.context);
  }, e2.prototype.getAttr = function(e3, t2) {
    var a2 = this.node.rawAttrs[e3];
    if (null != a2.tensor)
      return getTensor(e3, this.tensorMap, this.context);
    if (null != a2.i || null != a2.f)
      return getNumberParam(this.node.rawAttrs, e3, t2);
    if (null != a2.s)
      return getStringParam(this.node.rawAttrs, e3, t2);
    if (null != a2.b)
      return getBoolParam(this.node.rawAttrs, e3, t2);
    if (null != a2.shape)
      return getTensorShapeParam(this.node.rawAttrs, e3, t2);
    if (null != a2.type)
      return getDtypeParam(this.node.rawAttrs, e3, t2);
    if (null != a2.list) {
      if (null != a2.list.i || null != a2.list.f)
        return getNumericArrayParam(this.node.rawAttrs, e3, t2);
      if (null != a2.list.s)
        return getStringArrayParam(this.node.rawAttrs, e3, t2);
      if (null != a2.list.shape)
        return getTensorShapeArrayParam(this.node.rawAttrs, e3, t2);
      if (null != a2.list.b)
        return getBoolArrayParam(this.node.rawAttrs, e3, t2);
      if (null != a2.list.type)
        return getDtypeArrayParam(this.node.rawAttrs, e3, t2);
    }
    return t2;
  }, e2;
}();
var executeOp = function(e2, t2, a2) {
  switch (e2.op) {
    case "BiasAdd":
    case "AddV2":
    case "Add":
      return [Vs(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "AddN":
      return [zs(getParamValue("tensors", e2, t2, a2))];
    case "FloorMod":
    case "Mod":
      return [Zs(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "Mul":
      return [ec(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "RealDiv":
    case "Div":
      return [qs(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "DivNoNan":
      return [Ks(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "FloorDiv":
      return [Xs(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "Sub":
      return [uc(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "Minimum":
      return [Qs(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "Maximum":
      return [$s(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "Pow":
      return [rc(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "SquaredDifference":
      return [ac(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$1 = function(e2, t2, a2) {
  switch (e2.op) {
    case "Abs":
    case "ComplexAbs":
      return [Vu(getParamValue("x", e2, t2, a2))];
    case "Acos":
      return [zu(getParamValue("x", e2, t2, a2))];
    case "Acosh":
      return [Gu(getParamValue("x", e2, t2, a2))];
    case "Asin":
      return [Hu(getParamValue("x", e2, t2, a2))];
    case "Asinh":
      return [qu(getParamValue("x", e2, t2, a2))];
    case "Atan":
      return [Ku(getParamValue("x", e2, t2, a2))];
    case "Atan2":
      return [Hs(getParamValue("x", e2, t2, a2), getParamValue("y", e2, t2, a2))];
    case "Atanh":
      return [ju(getParamValue("x", e2, t2, a2))];
    case "Ceil":
      return [Xu(getParamValue("x", e2, t2, a2))];
    case "Complex":
      return [En(getParamValue("real", e2, t2, a2), getParamValue("imag", e2, t2, a2))];
    case "Cos":
      return [Yu(getParamValue("x", e2, t2, a2))];
    case "Cosh":
      return [Qu(getParamValue("x", e2, t2, a2))];
    case "Elu":
      return [yl(getParamValue("x", e2, t2, a2))];
    case "Erf":
      return [Ju(getParamValue("x", e2, t2, a2))];
    case "Exp":
      return [Zu(getParamValue("x", e2, t2, a2))];
    case "Expm1":
      return [ts(getParamValue("x", e2, t2, a2))];
    case "Floor":
      return [es(getParamValue("x", e2, t2, a2))];
    case "Log":
      return [ns(getParamValue("x", e2, t2, a2))];
    case "Log1p":
      return [rs(getParamValue("x", e2, t2, a2))];
    case "Imag":
      return [In(getParamValue("x", e2, t2, a2))];
    case "Neg":
      return [as(getParamValue("x", e2, t2, a2))];
    case "Reciprocal":
      return [is(getParamValue("x", e2, t2, a2))];
    case "Real":
      return [Rn(getParamValue("x", e2, t2, a2))];
    case "Relu":
      return [wl(getParamValue("x", e2, t2, a2))];
    case "Round":
      return [us(getParamValue("x", e2, t2, a2))];
    case "Selu":
      return [El(getParamValue("x", e2, t2, a2))];
    case "Sigmoid":
      return [cs(getParamValue("x", e2, t2, a2))];
    case "Sin":
      return [ds(getParamValue("x", e2, t2, a2))];
    case "Sign":
      return [ls(getParamValue("x", e2, t2, a2))];
    case "Sinh":
      return [vs(getParamValue("x", e2, t2, a2))];
    case "Softplus":
      return [ms(getParamValue("x", e2, t2, a2))];
    case "Sqrt":
      return [gs(getParamValue("x", e2, t2, a2))];
    case "Square":
      return [Uu(getParamValue("x", e2, t2, a2))];
    case "Tanh":
      return [bs(getParamValue("x", e2, t2, a2))];
    case "Tan":
      return [xs(getParamValue("x", e2, t2, a2))];
    case "Relu6":
    case "ClipByValue":
      return [$u(getParamValue("x", e2, t2, a2), getParamValue("clipValueMin", e2, t2, a2), getParamValue("clipValueMax", e2, t2, a2))];
    case "Rsqrt":
      return [ss(getTensor(e2.inputNames[0], t2, a2))];
    case "Prod":
      return [gl(getParamValue("x", e2, t2, a2), getParamValue("axes", e2, t2, a2))];
    case "LeakyRelu":
      return [xl(getParamValue("x", e2, t2, a2), getParamValue("alpha", e2, t2, a2))];
    case "Prelu":
      return [bl(getParamValue("x", e2, t2, a2), getParamValue("alpha", e2, t2, a2))];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var TensorArray = function() {
  function e2(t2, a2, r2, n2, s2, o2, p2) {
    this.name = t2, this.dtype = a2, this.maxSize = r2, this.elementShape = n2, this.identicalElementShapes = s2, this.dynamicSize = o2, this.clearAfterRead = p2, this.tensors = [], this.closed_ = false, this.id = e2.nextId++;
  }
  return Object.defineProperty(e2.prototype, "closed", {get: function() {
    return this.closed_;
  }, enumerable: true, configurable: true}), e2.prototype.clearAndClose = function() {
    this.tensors.forEach(function(e3) {
      return e3.tensor.dispose();
    }), this.tensors = [], this.closed_ = true;
  }, e2.prototype.size = function() {
    return this.tensors.length;
  }, e2.prototype.read = function(e3) {
    if (this.closed_)
      throw new Error("TensorArray " + this.name + " has already been closed.");
    if (e3 < 0 || e3 >= this.tensors.length)
      throw new Error("Tried to read from index " + e3 + ", but array size is: " + this.tensors.length);
    var t2 = this.tensors[e3];
    if (t2.cleared)
      throw new Error("TensorArray " + this.name + ": Could not read index " + e3 + " twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");
    return this.clearAfterRead && (t2.cleared = true), t2.read = true, t2.tensor;
  }, e2.prototype.readMany = function(e3) {
    var t2 = this;
    return e3.map(function(e4) {
      return t2.read(e4);
    });
  }, e2.prototype.write = function(e3, t2) {
    if (this.closed_)
      throw new Error("TensorArray " + this.name + " has already been closed.");
    if (e3 < 0 || !this.dynamicSize && e3 >= this.maxSize)
      throw new Error("Tried to write to index " + e3 + ", but array is not resizeable and size is: " + this.maxSize);
    var a2 = this.tensors[e3] || {};
    if (t2.dtype !== this.dtype)
      throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e3 + ",\n          because the value dtype is " + t2.dtype + ", but TensorArray dtype is " + this.dtype + ".");
    if (0 !== this.size() || null != this.elementShape && 0 !== this.elementShape.length || (this.elementShape = t2.shape), this.assertShapesMatchAllowUndefinedSize(this.elementShape, t2.shape, "TensorArray " + this.name + ": Could not write to TensorArray index " + e3 + "."), a2 && a2.read)
      throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e3 + ", because it has already been read.");
    if (a2 && a2.written)
      throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + e3 + ", because it has already been written.");
    a2.tensor = t2, a2.written = true, this.tensors[e3] = a2;
  }, e2.prototype.writeMany = function(e3, t2) {
    var a2 = this;
    if (e3.length !== t2.length)
      throw new Error("TensorArray " + this.name + ": could not write multiple tensors,because the index size: " + e3.length + " is not the same as tensors size: " + t2.length + ".");
    e3.forEach(function(e4, r2) {
      return a2.write(e4, t2[r2]);
    });
  }, e2.prototype.gather = function(e3, t2) {
    if (t2 && t2 !== this.dtype)
      throw new Error("TensorArray dtype is " + this.dtype + " but gather requested dtype " + t2);
    if (!e3) {
      e3 = [];
      for (var a2 = 0; a2 < this.size(); a2++)
        e3.push(a2);
    }
    if (0 === e3.length)
      return kn([], [0].concat(this.elementShape));
    var r2 = this.readMany(e3);
    return this.assertShapesMatchAllowUndefinedSize(this.elementShape, r2[0].shape, "TensorArray shape mismatch: "), Tr(r2, 0);
  }, e2.prototype.concat = function(e3) {
    if (e3 && e3 !== this.dtype)
      throw new Error("TensorArray dtype is " + this.dtype + " but concat requested dtype " + e3);
    if (0 === this.size())
      return kn([], [0].concat(this.elementShape));
    for (var t2 = [], a2 = 0; a2 < this.size(); a2++)
      t2.push(a2);
    var r2 = this.readMany(t2);
    return this.assertShapesMatchAllowUndefinedSize(this.elementShape, r2[0].shape, "TensorArray shape mismatch: tensor array shape (" + this.elementShape + ") vs first tensor shape (" + r2[0].shape + ")"), Gn(r2, 0);
  }, e2.prototype.scatter = function(e3, t2) {
    if (t2.dtype !== this.dtype)
      throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + t2.dtype);
    if (e3.length !== t2.shape[0])
      throw new Error("Expected len(indices) == tensor.shape[0], but saw: " + e3.length + " vs. " + t2.shape[0]);
    var a2 = Math.max.apply(Math, e3);
    if (!this.dynamicSize && a2 >= this.maxSize)
      throw new Error("Max index must be < array size (" + a2 + "  vs. " + this.maxSize + ")");
    this.writeMany(e3, Or(t2, 0));
  }, e2.prototype.split = function(e3, t2) {
    var a2 = this;
    if (t2.dtype !== this.dtype)
      throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + t2.dtype);
    var r2 = 0, n2 = e3.map(function(e4) {
      return r2 += e4;
    });
    if (r2 !== t2.shape[0])
      throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        " + r2 + ", and tensor's shape is: " + t2.shape);
    if (!this.dynamicSize && e3.length !== this.maxSize)
      throw new Error("TensorArray's size is not equal to the size of lengths (" + this.maxSize + " vs. " + e3.length + "), and the TensorArray is not marked as dynamically resizeable");
    var s2 = 0 === r2 ? 0 : t2.size / r2, o2 = [];
    je(function() {
      t2 = t2.reshape([1, r2, s2]);
      for (var p3 = 0; p3 < e3.length; ++p3) {
        var u3 = [0, 0 === p3 ? 0 : n2[p3 - 1], 0], i2 = [1, e3[p3], s2];
        o2[p3] = el(t2, u3, i2).reshape(a2.elementShape);
      }
      return o2;
    });
    for (var p2 = [], u2 = 0; u2 < e3.length; u2++)
      p2[u2] = u2;
    this.writeMany(p2, o2);
  }, e2.prototype.assertShapesMatchAllowUndefinedSize = function(e3, t2, a2) {
    void 0 === a2 && (a2 = ""), tt.assert(this.shapesEqualAllowUndefinedSize(e3, t2), function() {
      return a2 + " Shapes " + e3 + " and " + t2 + " must match";
    });
  }, e2.prototype.shapesEqualAllowUndefinedSize = function(e3, t2) {
    if (e3.length !== t2.length)
      return false;
    for (var a2 = 0; a2 < e3.length; a2++)
      if (-1 !== e3[a2] && -1 !== t2[a2] && e3[a2] !== t2[a2])
        return false;
    return true;
  }, e2.nextId = 0, e2;
}();
function executeOp$2(e2, t2, a2) {
  return __awaiter2(this, void 0, void 0, function() {
    var r2, n2, s2, o2, p2, u2, i2, m2, l2, c2, d2, y2, f2, g2, h2, N2, x2, V2, P2, b2, T2, O2, v2, S2, _2, w2, A2, D2, E2, I2, C2, M2, k2, z2, j2;
    return __generator2(this, function(F2) {
      switch (F2.label) {
        case 0:
          switch (e2.op) {
            case "LoopCond":
              return [3, 1];
            case "Switch":
              return [3, 2];
            case "Merge":
              return [3, 4];
            case "Enter":
              return [3, 5];
            case "Exit":
              return [3, 6];
            case "NextIteration":
              return [3, 7];
            case "TensorArrayV3":
              return [3, 8];
            case "TensorArrayWriteV3":
              return [3, 9];
            case "TensorArrayReadV3":
              return [3, 10];
            case "TensorArrayGatherV3":
              return [3, 11];
            case "TensorArrayScatterV3":
              return [3, 12];
            case "TensorArrayConcatV3":
              return [3, 13];
            case "TensorArraySplitV3":
              return [3, 14];
            case "TensorArraySizeV3":
              return [3, 15];
            case "TensorArrayCloseV3":
              return [3, 16];
          }
          return [3, 17];
        case 1:
          return [2, [getParamValue("pred", e2, t2, a2).clone()]];
        case 2:
          return r2 = getParamValue("pred", e2, t2, a2), n2 = getParamValue("data", e2, t2, a2), [4, r2.data()];
        case 3:
          return [2, F2.sent()[0] ? [void 0, n2.clone()] : [n2.clone(), void 0]];
        case 4:
          return [2, (s2 = e2.inputNames.find(function(e3) {
            return void 0 !== getTensor(e3, t2, a2);
          })) ? [getTensor(s2, t2, a2).clone()] : void 0];
        case 5:
          return o2 = getParamValue("frameName", e2, t2, a2), p2 = getParamValue("tensor", e2, t2, a2), a2.enterFrame(o2), [2, [p2.clone()]];
        case 6:
          return u2 = getParamValue("tensor", e2, t2, a2), a2.exitFrame(), [2, [u2.clone()]];
        case 7:
          return i2 = getParamValue("tensor", e2, t2, a2), a2.nextIteration(), [2, [i2.clone()]];
        case 8:
          return m2 = getParamValue("size", e2, t2, a2), l2 = getParamValue("dtype", e2, t2, a2), c2 = getParamValue("elementShape", e2, t2, a2), d2 = getParamValue("dynamicSize", e2, t2, a2), y2 = getParamValue("clearAfterRead", e2, t2, a2), f2 = getParamValue("identicalElementShapes", e2, t2, a2), g2 = getParamValue("name", e2, t2, a2), h2 = new TensorArray(g2, l2, m2, c2, f2, d2, y2), a2.addTensorArray(h2), [2, [An(h2.id), An(1)]];
        case 9:
          return N2 = getParamValue("tensorArrayId", e2, t2, a2), x2 = getParamValue("index", e2, t2, a2), V2 = getParamValue("tensor", e2, t2, a2), a2.getTensorArray(N2).write(x2, V2), [2, [An(1)]];
        case 10:
          return P2 = getParamValue("tensorArrayId", e2, t2, a2), b2 = getParamValue("index", e2, t2, a2), [2, [a2.getTensorArray(P2).read(b2)]];
        case 11:
          return T2 = getParamValue("tensorArrayId", e2, t2, a2), O2 = getParamValue("indices", e2, t2, a2), v2 = getParamValue("dtype", e2, t2, a2), [2, [a2.getTensorArray(T2).gather(O2, v2)]];
        case 12:
          return S2 = getParamValue("tensorArrayId", e2, t2, a2), _2 = getParamValue("indices", e2, t2, a2), w2 = getParamValue("tensor", e2, t2, a2), a2.getTensorArray(S2).scatter(_2, w2), [2, [An(1)]];
        case 13:
          return A2 = getParamValue("tensorArrayId", e2, t2, a2), D2 = a2.getTensorArray(A2), E2 = getParamValue("dtype", e2, t2, a2), [2, [D2.concat(E2)]];
        case 14:
          return I2 = getParamValue("tensorArrayId", e2, t2, a2), C2 = getParamValue("tensor", e2, t2, a2), M2 = getParamValue("lengths", e2, t2, a2), a2.getTensorArray(I2).split(M2, C2), [2, [An(1)]];
        case 15:
          return k2 = getParamValue("tensorArrayId", e2, t2, a2), z2 = a2.getTensorArray(k2), [2, [An(z2.size(), "int32")]];
        case 16:
          return j2 = getParamValue("tensorArrayId", e2, t2, a2), a2.getTensorArray(j2).clearAndClose(), [2, [An(0)]];
        case 17:
          throw TypeError("Node type " + e2.op + " is not implemented");
      }
    });
  });
}
var executeOp$3 = function(e2, t2, a2) {
  var r2, n2;
  switch (e2.op) {
    case "Conv1D":
      var s2 = getParamValue("stride", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2), p2 = getParamValue("dataFormat", e2, t2, a2).toUpperCase(), u2 = getParamValue("dilation", e2, t2, a2);
      return [Dc(getParamValue("x", e2, t2, a2), getParamValue("filter", e2, t2, a2), s2, o2, p2, u2)];
    case "Conv2D":
      s2 = getParamValue("strides", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2), p2 = getParamValue("dataFormat", e2, t2, a2).toUpperCase();
      var i2 = getParamValue("dilations", e2, t2, a2);
      return [Tc(getParamValue("x", e2, t2, a2), getParamValue("filter", e2, t2, a2), [s2[1], s2[2]], o2, p2, [i2[1], i2[2]])];
    case "_FusedConv2D":
      var m2 = (r2 = getParamValue("fusedOps", e2, t2, a2))[0], l2 = r2[1], c2 = "biasadd" === m2, d2 = "prelu" === l2, y2 = "fusedbatchnorm" === m2, f2 = getParamValue("numArgs", e2, t2, a2);
      if (c2) {
        if (d2 && 2 !== f2)
          throw new Error("Fused Conv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
        if (!d2 && 1 !== f2)
          throw new Error("Fused Conv2d with BiasAdd must have one extra argument: bias.");
      }
      if (y2)
        throw new Error("Fused Conv2d with FusedBatchNorm is not supported.");
      s2 = getParamValue("strides", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2), p2 = getParamValue("dataFormat", e2, t2, a2).toUpperCase(), i2 = getParamValue("dilations", e2, t2, a2);
      var g2 = (n2 = getParamValue("args", e2, t2, a2))[0], h2 = n2[1];
      return [Rh.conv2d({x: getParamValue("x", e2, t2, a2), filter: getParamValue("filter", e2, t2, a2), strides: [s2[1], s2[2]], pad: o2, dataFormat: p2, dilations: [i2[1], i2[2]], bias: g2, activation: l2, preluActivationWeights: h2})];
    case "Conv2DBackpropInput":
    case "Conv2dTranspose":
      var N2 = getParamValue("outputShape", e2, t2, a2);
      s2 = getParamValue("strides", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2);
      return [Lc(getParamValue("x", e2, t2, a2), getParamValue("filter", e2, t2, a2), N2, [s2[1], s2[2]], o2)];
    case "DepthwiseConv2dNative":
    case "DepthwiseConv2d":
      s2 = getParamValue("strides", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2), i2 = getParamValue("dilations", e2, t2, a2), p2 = getParamValue("dataFormat", e2, t2, a2).toUpperCase();
      return [_c(getParamValue("input", e2, t2, a2), getParamValue("filter", e2, t2, a2), [s2[1], s2[2]], o2, p2, [i2[1], i2[2]])];
    case "Conv3D":
      s2 = getParamValue("strides", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2), p2 = getParamValue("dataFormat", e2, t2, a2).toUpperCase(), i2 = getParamValue("dilations", e2, t2, a2);
      return [Nc(getParamValue("x", e2, t2, a2), getParamValue("filter", e2, t2, a2), [s2[1], s2[2], s2[3]], o2, p2, [i2[1], i2[2], i2[3]])];
    case "AvgPool":
      s2 = getParamValue("strides", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2);
      var x2 = getParamValue("kernelSize", e2, t2, a2);
      return [Qc(getParamValue("x", e2, t2, a2), [x2[1], x2[2]], [s2[1], s2[2]], o2)];
    case "MaxPool":
      s2 = getParamValue("strides", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2), x2 = getParamValue("kernelSize", e2, t2, a2);
      return [Yc(getParamValue("x", e2, t2, a2), [x2[1], x2[2]], [s2[1], s2[2]], o2)];
    case "AvgPool3D":
      s2 = getParamValue("strides", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2), x2 = getParamValue("kernelSize", e2, t2, a2);
      return [tl(getParamValue("x", e2, t2, a2), [x2[1], x2[2], x2[3]], [s2[1], s2[2], s2[3]], o2)];
    case "MaxPool3D":
      s2 = getParamValue("strides", e2, t2, a2), o2 = getParamValue("pad", e2, t2, a2), x2 = getParamValue("kernelSize", e2, t2, a2);
      return [Zc(getParamValue("x", e2, t2, a2), [x2[1], x2[2], x2[3]], [s2[1], s2[2], s2[3]], o2)];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$4 = function(e2, t2, a2) {
  switch (e2.op) {
    case "Fill":
      var r2 = getParamValue("shape", e2, t2, a2), n2 = getParamValue("dtype", e2, t2, a2), s2 = getParamValue("value", e2, t2, a2);
      return [Ln(r2, s2, n2)];
    case "LinSpace":
      var o2 = getParamValue("start", e2, t2, a2), p2 = getParamValue("stop", e2, t2, a2), u2 = getParamValue("num", e2, t2, a2);
      return [Wn(o2, p2, u2)];
    case "Multinomial":
      var i2 = getParamValue("logits", e2, t2, a2), m2 = getParamValue("numSamples", e2, t2, a2), l2 = getParamValue("seed", e2, t2, a2);
      return [mr(i2, m2, l2)];
    case "OneHot":
      var c2 = getParamValue("indices", e2, t2, a2), d2 = getParamValue("depth", e2, t2, a2), y2 = getParamValue("onValue", e2, t2, a2), f2 = getParamValue("offValue", e2, t2, a2);
      return [gr(c2, d2, y2, f2)];
    case "Ones":
      return [Bn(getParamValue("shape", e2, t2, a2), getParamValue("dtype", e2, t2, a2))];
    case "OnesLike":
      return [Vn(getParamValue("x", e2, t2, a2))];
    case "RandomUniform":
      return [kr(getParamValue("shape", e2, t2, a2), getParamValue("minval", e2, t2, a2), getParamValue("maxval", e2, t2, a2), getParamValue("dtype", e2, t2, a2))];
    case "Range":
      o2 = getParamValue("start", e2, t2, a2);
      var g2 = getParamValue("stop", e2, t2, a2), h2 = getParamValue("step", e2, t2, a2);
      return [Un(o2, g2, h2, getParamValue("dtype", e2, t2, a2))];
    case "TruncatedNormal":
      r2 = getParamValue("shape", e2, t2, a2);
      var N2 = getParamValue("mean", e2, t2, a2), x2 = getParamValue("stdDev", e2, t2, a2);
      l2 = getParamValue("seed", e2, t2, a2);
      return [Fr(r2, N2, x2, getParamValue("dtype", e2, t2, a2), l2)];
    case "Zeros":
      return [Pn(getParamValue("shape", e2, t2, a2), getParamValue("dtype", e2, t2, a2))];
    case "ZerosLike":
      return [zn(getParamValue("x", e2, t2, a2))];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
function executeOp$5(e2, t2, a2) {
  return __awaiter2(this, void 0, void 0, function() {
    var r2, n2, s2, o2, p2;
    return __generator2(this, function(u2) {
      switch (u2.label) {
        case 0:
          switch (e2.op) {
            case "NonMaxSuppressionV3":
            case "NonMaxSuppressionV2":
              return [3, 1];
            case "Where":
              return [3, 3];
            case "ListDiff":
              return [3, 5];
          }
          return [3, 6];
        case 1:
          return r2 = getParamValue("boxes", e2, t2, a2), n2 = getParamValue("scores", e2, t2, a2), s2 = getParamValue("maxOutputSize", e2, t2, a2), o2 = getParamValue("iouThreshold", e2, t2, a2), p2 = getParamValue("scoreThreshold", e2, t2, a2), [4, mh.nonMaxSuppressionAsync(r2, n2, s2, o2, p2)];
        case 2:
          return [2, [u2.sent()]];
        case 3:
          return [4, Us(getParamValue("condition", e2, t2, a2).asType("bool"))];
        case 4:
          return [2, [u2.sent()]];
        case 5:
          return [2, _r(getParamValue("x", e2, t2, a2), getParamValue("y", e2, t2, a2))];
        case 6:
          throw TypeError("Node type " + e2.op + " is not implemented");
      }
    });
  });
}
var executeOp$6 = function(e2, t2, a2) {
  switch (e2.op) {
    case "TopKV2":
      var r2 = getParamValue("x", e2, t2, a2), n2 = getParamValue("k", e2, t2, a2), s2 = getParamValue("sorted", e2, t2, a2), o2 = Nl(r2, n2, s2);
      return [o2.values, o2.indices];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$7 = function(e2, t2, a2) {
  switch (e2.op) {
    case "Const":
      return t2[e2.name];
    case "PlaceholderWithDefault":
      var r2 = getParamValue("default", e2, t2, a2);
      return [getTensor(e2.name, t2, a2) || r2];
    case "Placeholder":
      return [getTensor(e2.name, t2, a2)];
    case "Identity":
    case "StopGradient":
    case "FakeQuantWithMinMaxVars":
      return [getParamValue("x", e2, t2, a2).clone()];
    case "IdentityN":
      return getParamValue("x", e2, t2, a2).map(function(e3) {
        return e3.clone();
      });
    case "Snapshot":
      return [getParamValue("x", e2, t2, a2).clone()];
    case "Shape":
      return [Dn(getParamValue("x", e2, t2, a2).shape, "int32")];
    case "ShapeN":
      return getParamValue("x", e2, t2, a2).map(function(e3) {
        return Dn(e3.shape);
      });
    case "Size":
      return [An(getParamValue("x", e2, t2, a2).size, "int32")];
    case "Rank":
      return [An(getParamValue("x", e2, t2, a2).rank, "int32")];
    case "NoOp":
      return [An(1)];
    case "Print":
      var n2 = getParamValue("x", e2, t2, a2), s2 = getParamValue("data", e2, t2, a2), o2 = getParamValue("message", e2, t2, a2), p2 = getParamValue("summarize", e2, t2, a2);
      console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(o2);
      for (var u2 = 0; u2 < s2.length; u2++)
        console.log(Array.prototype.slice.call(s2[u2].dataSync()).slice(0, p2));
      return [n2];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$8 = function(e2, t2, a2) {
  switch (e2.op) {
    case "ResizeBilinear":
      var r2 = getParamValue("images", e2, t2, a2), n2 = getParamValue("size", e2, t2, a2), s2 = getParamValue("alignCorners", e2, t2, a2);
      return [mh.resizeBilinear(r2, [n2[0], n2[1]], s2)];
    case "ResizeNearestNeighbor":
      r2 = getParamValue("images", e2, t2, a2), n2 = getParamValue("size", e2, t2, a2), s2 = getParamValue("alignCorners", e2, t2, a2);
      return [mh.resizeNearestNeighbor(r2, [n2[0], n2[1]], s2)];
    case "CropAndResize":
      var o2 = getParamValue("image", e2, t2, a2), p2 = getParamValue("boxes", e2, t2, a2), u2 = getParamValue("boxInd", e2, t2, a2), i2 = getParamValue("cropSize", e2, t2, a2), m2 = getParamValue("method", e2, t2, a2), l2 = getParamValue("extrapolationValue", e2, t2, a2);
      return [mh.cropAndResize(o2, p2, u2, i2, m2, l2)];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$9 = function(e2, t2, a2) {
  switch (e2.op) {
    case "Equal":
      return [cc(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "NotEqual":
      return [xc(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "Greater":
      return [hc(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "GreaterEqual":
      return [fc(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "Less":
      return [vc(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "LessEqual":
      return [mc(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "LogicalAnd":
      return [Ms(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "LogicalNot":
      return [Bs(getParamValue("a", e2, t2, a2))];
    case "LogicalOr":
      return [Ps(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    case "Select":
      return [Ws(getParamValue("condition", e2, t2, a2), getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2))];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$10 = function(e2, t2, a2) {
  switch (e2.op) {
    case "BatchMatMul":
    case "BatchMatMulV2":
    case "MatMul":
      return [Uc(getParamValue("a", e2, t2, a2), getParamValue("b", e2, t2, a2), getParamValue("transposeA", e2, t2, a2), getParamValue("transposeB", e2, t2, a2))];
    case "Transpose":
      return [Rl(getParamValue("x", e2, t2, a2), getParamValue("perm", e2, t2, a2))];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$11 = function(e2, t2, a2) {
  switch (e2.op) {
    case "FusedBatchNorm":
    case "FusedBatchNormV2":
    case "FusedBatchNormV3":
      return [Ns(getParamValue("x", e2, t2, a2), getParamValue("mean", e2, t2, a2), getParamValue("variance", e2, t2, a2), getParamValue("offset", e2, t2, a2), getParamValue("scale", e2, t2, a2), getParamValue("epsilon", e2, t2, a2))];
    case "LRN":
      return [Il(getParamValue("x", e2, t2, a2), getParamValue("radius", e2, t2, a2), getParamValue("bias", e2, t2, a2), getParamValue("alpha", e2, t2, a2), getParamValue("beta", e2, t2, a2))];
    case "Softmax":
      return [io(getParamValue("x", e2, t2, a2))];
    case "LogSoftmax":
      return [uo(getParamValue("x", e2, t2, a2))];
    case "SparseToDense":
      return [Ll(getParamValue("sparseIndices", e2, t2, a2), getParamValue("outputShape", e2, t2, a2), getParamValue("sparseValues", e2, t2, a2), getParamValue("defaultValue", e2, t2, a2))];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$12 = function(e2, t2, a2) {
  switch (e2.op) {
    case "Max":
      var r2 = getParamValue("axis", e2, t2, a2), n2 = getParamValue("keepDims", e2, t2, a2);
      return [fl(getParamValue("x", e2, t2, a2), r2, n2)];
    case "Mean":
      r2 = getParamValue("axis", e2, t2, a2), n2 = getParamValue("keepDims", e2, t2, a2);
      return [pl(getParamValue("x", e2, t2, a2), r2, n2)];
    case "Min":
      r2 = getParamValue("axis", e2, t2, a2), n2 = getParamValue("keepDims", e2, t2, a2);
      return [dl(getParamValue("x", e2, t2, a2), r2, n2)];
    case "Sum":
      r2 = getParamValue("axis", e2, t2, a2), n2 = getParamValue("keepDims", e2, t2, a2);
      return [ml(getParamValue("x", e2, t2, a2), r2, n2)];
    case "All":
      r2 = getParamValue("axis", e2, t2, a2), n2 = getParamValue("keepDims", e2, t2, a2);
      return [ul(getParamValue("x", e2, t2, a2), r2, n2)];
    case "Any":
      r2 = getParamValue("axis", e2, t2, a2), n2 = getParamValue("keepDims", e2, t2, a2);
      return [sl(getParamValue("x", e2, t2, a2), r2, n2)];
    case "ArgMax":
      r2 = getParamValue("axis", e2, t2, a2);
      return [cl(getParamValue("x", e2, t2, a2), r2)];
    case "ArgMin":
      r2 = getParamValue("axis", e2, t2, a2);
      return [ll(getParamValue("x", e2, t2, a2), r2)];
    case "Prod":
      r2 = getParamValue("axis", e2, t2, a2), n2 = getParamValue("keepDims", e2, t2, a2);
      return [gl(getParamValue("x", e2, t2, a2), r2, n2)];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$13 = function(e2, t2, a2) {
  switch (e2.op) {
    case "ConcatV2":
    case "Concat":
      var r2 = getParamValue("n", e2, t2, a2), n2 = getParamValue("axis", e2, t2, a2), s2 = getParamValue("tensors", e2, t2, a2);
      return s2 = s2.slice(0, r2), [Gn(s2, n2)];
    case "GatherV2":
    case "Gather":
      n2 = getParamValue("axis", e2, t2, a2);
      var o2 = getParamValue("x", e2, t2, a2), p2 = getParamValue("indices", e2, t2, a2);
      return [Ec(o2, p2.asType("int32"), n2)];
    case "ReverseV2":
    case "Reverse":
      n2 = getParamValue("axis", e2, t2, a2), o2 = getParamValue("x", e2, t2, a2);
      return [Gc(o2, n2)];
    case "Slice":
      var u2 = getParamValue("begin", e2, t2, a2), i2 = getParamValue("size", e2, t2, a2);
      return [el(getParamValue("x", e2, t2, a2), u2, i2)];
    case "StridedSlice":
      u2 = getParamValue("begin", e2, t2, a2);
      var m2 = getParamValue("end", e2, t2, a2), l2 = getParamValue("strides", e2, t2, a2), c2 = getParamValue("beginMask", e2, t2, a2), d2 = getParamValue("endMask", e2, t2, a2), y2 = getParamValue("ellipsisMask", e2, t2, a2), f2 = getParamValue("newAxisMask", e2, t2, a2), g2 = getParamValue("shrinkAxisMask", e2, t2, a2), h2 = getParamValue("x", e2, t2, a2);
      if (1 === u2.length && h2.shape.length > 1)
        for (var N2 = 1; N2 < h2.shape.length; N2++)
          u2.push(0), m2.push(h2.shape[N2]), l2.push(l2[0]);
      return [Tl(h2, u2, m2, l2, c2, d2, y2, f2, g2)];
    case "Pack":
      return je(function() {
        var r3 = getParamValue("axis", e2, t2, a2), n3 = getParamValue("tensors", e2, t2, a2), s3 = n3[0].shape, o3 = n3[0].squeeze().shape, p3 = n3.map(function(e3) {
          var t3 = tt.arraysEqual(e3.shape, s3);
          if (!t3 && !tt.arraysEqual(e3.squeeze().shape, o3))
            throw new Error("the input tensors shape does not match");
          return t3 ? e3 : e3.reshape(s3);
        });
        return [Tr(p3, r3)];
      });
    case "Unpack":
      return je(function() {
        var r3 = getParamValue("axis", e2, t2, a2), n3 = getParamValue("tensor", e2, t2, a2);
        return Or(n3, r3);
      });
    case "Tile":
      var x2 = getParamValue("reps", e2, t2, a2);
      return [Nr(getParamValue("x", e2, t2, a2), x2)];
    case "Split":
    case "SplitV":
      n2 = getParamValue("axis", e2, t2, a2);
      var V2 = getParamValue("numOrSizeSplits", e2, t2, a2);
      return Xn(getParamValue("x", e2, t2, a2), V2, n2);
    case "ScatterNd":
      p2 = getParamValue("indices", e2, t2, a2);
      var P2 = getParamValue("values", e2, t2, a2), b2 = getParamValue("shape", e2, t2, a2);
      return [Fl(p2, P2, b2)];
    case "GatherNd":
      var T2 = getParamValue("x", e2, t2, a2);
      p2 = getParamValue("indices", e2, t2, a2);
      return [Wl(T2, p2)];
    case "SparseToDense":
      p2 = getParamValue("sparseIndices", e2, t2, a2), b2 = getParamValue("outputShape", e2, t2, a2);
      var O2 = getParamValue("sparseValues", e2, t2, a2), v2 = getParamValue("defaultValue", e2, t2, a2);
      return [Ll(p2, O2, b2, O2.dtype === v2.dtype ? v2 : v2.asType(O2.dtype))];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$14 = function(e2, t2, a2) {
  switch (e2.op) {
    case "FFT":
      return [Ol(getParamValue("x", e2, t2, a2))];
    case "IFFT":
      return [_l(getParamValue("x", e2, t2, a2))];
    case "RFFT":
      return [Ml(getParamValue("x", e2, t2, a2))];
    case "IRFFT":
      return [Bl(getParamValue("x", e2, t2, a2))];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
var executeOp$15 = function(e2, t2, a2) {
  switch (e2.op) {
    case "Cast":
      return [lr(getParamValue("x", e2, t2, a2), getParamValue("dtype", e2, t2, a2))];
    case "ExpandDims":
      var r2 = getParamValue("axis", e2, t2, a2);
      return [dr(getParamValue("x", e2, t2, a2), r2)];
    case "Squeeze":
      r2 = getParamValue("axis", e2, t2, a2);
      return [Dr(getParamValue("x", e2, t2, a2), r2)];
    case "Reshape":
      return [Sr(getParamValue("x", e2, t2, a2), getParamValue("shape", e2, t2, a2))];
    case "PadV2":
    case "Pad":
      return [yr(getParamValue("x", e2, t2, a2), split$1(getParamValue("padding", e2, t2, a2), 2), getParamValue("constantValue", e2, t2, a2))];
    case "SpaceToBatchND":
      var n2 = getParamValue("blockShape", e2, t2, a2), s2 = split$1(getParamValue("paddings", e2, t2, a2), 2);
      return [Ar(getParamValue("x", e2, t2, a2), n2, s2)];
    case "BatchToSpaceND":
      n2 = getParamValue("blockShape", e2, t2, a2);
      var o2 = split$1(getParamValue("crops", e2, t2, a2), 2);
      return [cr(getParamValue("x", e2, t2, a2), n2, o2)];
    case "DepthToSpace":
      var p2 = getParamValue("blockSize", e2, t2, a2), u2 = getParamValue("dataFormat", e2, t2, a2).toUpperCase();
      return [pr(getParamValue("x", e2, t2, a2), p2, u2)];
    default:
      throw TypeError("Node type " + e2.op + " is not implemented");
  }
};
function executeOp$16(e2, t2, a2) {
  var r2 = function(e3, t3, a3) {
    switch (e3.category) {
      case "arithmetic":
        return executeOp(e3, t3, a3);
      case "basic_math":
        return executeOp$1(e3, t3, a3);
      case "control":
        return executeOp$2(e3, t3, a3);
      case "convolution":
        return executeOp$3(e3, t3, a3);
      case "creation":
        return executeOp$4(e3, t3, a3);
      case "dynamic":
        return executeOp$5(e3, t3, a3);
      case "evaluation":
        return executeOp$6(e3, t3, a3);
      case "image":
        return executeOp$8(e3, t3, a3);
      case "graph":
        return executeOp$7(e3, t3, a3);
      case "logical":
        return executeOp$9(e3, t3, a3);
      case "matrices":
        return executeOp$10(e3, t3, a3);
      case "normalization":
        return executeOp$11(e3, t3, a3);
      case "reduction":
        return executeOp$12(e3, t3, a3);
      case "slice_join":
        return executeOp$13(e3, t3, a3);
      case "spectral":
        return executeOp$14(e3, t3, a3);
      case "transformation":
        return executeOp$15(e3, t3, a3);
      case "custom":
        var r3 = getRegisteredOp(e3.op);
        if (r3 && r3.customExecutor)
          return r3.customExecutor(new NodeValueImpl(e3, t3, a3));
        throw TypeError("Custom op " + e3.op + " is not registered.");
      default:
        throw TypeError("Unknown op '" + e3.op + "'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()");
    }
  }(e2, t2, a2);
  return r2 instanceof Promise ? r2.then(function(e3) {
    return [].concat(e3);
  }) : [].concat(r2);
}
var ExecutionContext = function() {
  function e2(e3, t2) {
    this.weightMap = e3, this.tensorArrayMap = t2, this.rootContext = {id: 0, frameName: "", iterationId: 0}, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds();
  }
  return e2.prototype.newFrame = function(e3, t2) {
    return {id: e3, frameName: t2, iterationId: 0};
  }, Object.defineProperty(e2.prototype, "currentContext", {get: function() {
    return this.contexts;
  }, set: function(e3) {
    this.contexts !== e3 && (this.contexts = e3, this.generateCurrentContextIds());
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "currentContextId", {get: function() {
    return this._currentContextIds[0];
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "currentContextIds", {get: function() {
    return this._currentContextIds;
  }, enumerable: true, configurable: true}), e2.prototype.generateCurrentContextIds = function() {
    for (var e3 = [], t2 = 0; t2 < this.contexts.length - 1; t2++) {
      var a2 = this.contexts.slice(0, this.contexts.length - t2);
      e3.push(this.contextIdforContexts(a2));
    }
    e3.push(""), this._currentContextIds = e3;
  }, e2.prototype.contextIdforContexts = function(e3) {
    return e3 ? e3.map(function(e4) {
      return 0 === e4.id && 0 === e4.iterationId ? "" : e4.frameName + "-" + e4.iterationId;
    }).join("/") : "";
  }, e2.prototype.enterFrame = function(e3) {
    this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, e3)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)));
  }, e2.prototype.exitFrame = function() {
    if (!(this.contexts && this.contexts.length > 1))
      throw new Error("Cannot exit frame, the context is empty");
    this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift();
  }, e2.prototype.nextIteration = function() {
    if (!(this.contexts && this.contexts.length > 0))
      throw new Error("Cannot increase frame iteration, the context is empty");
    this.contexts = this.contexts.slice(), this.lastId++;
    var e3 = Object.assign({}, this.contexts[this.contexts.length - 1]);
    e3.iterationId += 1, e3.id = this.lastId, this.contexts.splice(-1, 1, e3), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
  }, e2.prototype.getWeight = function(e3) {
    return this.weightMap[e3];
  }, e2.prototype.addTensorArray = function(e3) {
    this.tensorArrayMap[e3.id] = e3;
  }, e2.prototype.getTensorArray = function(e3) {
    return this.tensorArrayMap[e3];
  }, e2;
}();
function getExecutionSubgraph(e2, t2, a2) {
  for (var r2 = new Set(), n2 = [], s2 = null, o2 = null, p2 = new Set(), u2 = t2.slice(); u2.length > 0; ) {
    var i2 = u2.pop();
    (isControlFlow(i2) || isDynamicShape(i2)) && null == s2 && (o2 = (s2 = i2).children.map(function(e3) {
      return e3.name;
    }).filter(function(e3) {
      return r2.has(e3);
    })), r2.add(i2.name), null == a2[i2.name] && (null == e2[i2.name] && (0 !== i2.inputs.length ? i2.inputs.forEach(function(e3) {
      p2.has(e3.name) || (p2.add(e3.name), u2.push(e3));
    }) : n2.push(i2.name)));
  }
  return {inputs: e2, outputs: t2, usedNodes: r2, missingInputs: n2, dynamicNode: s2, syncInputs: o2};
}
function getNodesInTopologicalOrder(e2, t2, a2) {
  var r2 = a2.usedNodes, n2 = a2.inputs, s2 = [];
  Object.keys(n2).map(function(t3) {
    return e2.nodes[t3];
  }).forEach(function(e3) {
    r2.has(e3.name) && s2.push(e3);
  }), e2.weights.forEach(function(e3) {
    r2.has(e3.name) && s2.push(e3);
  });
  for (var o2 = new Set(), p2 = []; s2.length > 0; ) {
    var u2 = s2.pop();
    o2.add(u2.name), t2[u2.name] || p2.push(u2), u2.children.forEach(function(e3) {
      !o2.has(e3.name) && r2.has(e3.name) && e3.inputs.every(function(e4) {
        return o2.has(e4.name);
      }) && s2.push(e3);
    });
  }
  return p2;
}
var CONTROL_FLOW_OPS = ["Switch", "Merge", "Enter", "Exit", "NextIteration"];
var DYNAMIC_SHAPE_OPS = ["NonMaxSuppressionV2", "NonMaxSuppressionV3", "Where"];
function isControlFlow(e2) {
  return CONTROL_FLOW_OPS.indexOf(e2.op) >= 0;
}
function isDynamicShape(e2) {
  return DYNAMIC_SHAPE_OPS.indexOf(e2.op) >= 0;
}
var GraphExecutor = function() {
  function e2(e3) {
    this.graph = e3, this.compiledMap = new Map(), this._weightMap = {}, this.SEPERATOR = ",", this.placeholders = e3.placeholders, this._outputs = e3.outputs;
  }
  return Object.defineProperty(e2.prototype, "weightMap", {get: function() {
    return this._weightMap;
  }, set: function(e3) {
    var t2 = Object.keys(e3).map(function(t3) {
      return e3[t3].map(function(e4) {
        return e4.id;
      });
    });
    this.weightIds = [].concat.apply([], t2), this._weightMap = e3;
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "inputs", {get: function() {
    return this.placeholders.map(function(e3) {
      return {name: e3.name, shape: e3.attrParams.shape ? e3.attrParams.shape.value : void 0, dtype: e3.attrParams.dtype ? e3.attrParams.dtype.value : void 0};
    });
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "outputs", {get: function() {
    return this._outputs.map(function(e3) {
      return {name: e3.name, shape: e3.attrParams.shape ? e3.attrParams.shape.value : void 0, dtype: e3.attrParams.dtype ? e3.attrParams.dtype.value : void 0};
    });
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "inputNodes", {get: function() {
    return this.placeholders.map(function(e3) {
      return e3.name;
    });
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "outputNodes", {get: function() {
    return this.outputs.map(function(e3) {
      return e3.name;
    });
  }, enumerable: true, configurable: true}), e2.prototype.getCompilationKey = function(e3, t2) {
    var a2 = e3.map(function(e4) {
      return e4.name;
    }).sort(), r2 = t2.map(function(e4) {
      return e4.name;
    }).sort();
    return a2.join(this.SEPERATOR) + "--" + r2.join(this.SEPERATOR);
  }, e2.prototype.compile = function(e3, t2) {
    var a2 = getExecutionSubgraph(e3, t2, this.weightMap), r2 = a2.missingInputs, n2 = a2.dynamicNode, s2 = a2.syncInputs;
    if (null != n2)
      throw new Error("This execution contains the node '" + n2.name + "', which has the dynamic op '" + n2.op + "'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [" + s2 + "]");
    if (r2.length > 0) {
      var o2 = t2.map(function(e4) {
        return e4.name;
      }), p2 = Object.keys(e3);
      throw new Error("Cannot compute the outputs [" + o2 + "] from the provided inputs [" + p2 + "]. Missing the following inputs: [" + r2 + "]");
    }
    return getNodesInTopologicalOrder(this.graph, this.weightMap, a2);
  }, e2.prototype.execute = function(e3, t2) {
    var a2 = this, r2 = Object.keys(e3).sort();
    this.checkInputs(e3), this.checkInputShapeAndType(e3), this.checkOutputs(t2);
    var n2 = r2.map(function(e4) {
      return a2.graph.nodes[e4];
    }), s2 = t2.map(function(e4) {
      return a2.graph.nodes[parseNodeName(e4)[0]];
    }), o2 = this.getCompilationKey(n2, s2), p2 = this.compiledMap.get(o2);
    null == p2 && (p2 = this.compile(e3, s2), this.compiledMap.set(o2, p2));
    var u2 = {};
    return je(function() {
      var r3 = new ExecutionContext(a2._weightMap, u2), n3 = __assign2({}, a2.weightMap);
      Object.keys(e3).forEach(function(t3) {
        n3[t3] = [e3[t3]];
      });
      for (var s3 = a2.getFrozenTensorIds(n3), o3 = {}, i2 = 0; i2 < p2.length; i2++) {
        var m2 = p2[i2];
        if (!n3[m2.name]) {
          var l2 = executeOp$16(m2, n3, r3);
          if (l2 instanceof Promise)
            throw new Error("The execution of the op '" + m2.op + "' returned a promise. Please use model.executeAsync() instead.");
          n3[m2.name] = l2, a2.checkTensorForDisposal(m2.name, m2, n3, r3, s3, t2, o3);
        }
      }
      return t2.map(function(e4) {
        return getTensor(e4, n3, r3);
      });
    });
  }, e2.prototype.getFrozenTensorIds = function(e3) {
    var t2 = [].concat.apply([], Object.keys(e3).map(function(t3) {
      return e3[t3];
    }).map(function(e4) {
      return e4.map(function(e5) {
        return e5.id;
      });
    }));
    return new Set(t2);
  }, e2.prototype.checkTensorForDisposal = function(e3, t2, a2, r2, n2, s2, o2) {
    "control" !== t2.category && -1 === s2.indexOf(e3) && (a2[e3].forEach(function(e4) {
      null != e4 && (o2[e4.id] = (o2[e4.id] || 0) + t2.children.length);
    }), t2.inputs.forEach(function(e4) {
      if ("control" !== e4.category) {
        var t3 = getTensorsForCurrentContenxt(e4.name, a2, r2);
        null != t3 && t3.forEach(function(e5) {
          if (e5 && !n2.has(e5.id)) {
            var t4 = o2[e5.id];
            1 === t4 ? (e5.dispose(), delete o2[e5.id]) : null != t4 && o2[e5.id]--;
          }
        });
      }
    }));
  }, e2.prototype.executeAsync = function(e3, t2) {
    return __awaiter2(this, void 0, void 0, function() {
      var a2, r2, n2, s2, o2, p2, u2 = this;
      return __generator2(this, function(i2) {
        switch (i2.label) {
          case 0:
            return this.checkInputs(e3), this.checkInputShapeAndType(e3), this.checkOutputs(t2), a2 = {}, r2 = new ExecutionContext(this._weightMap, a2), [4, this.executeWithControlFlow(e3, r2, t2)];
          case 1:
            return n2 = i2.sent(), s2 = t2.map(function(e4) {
              return getTensor(e4, n2, r2);
            }), o2 = new Set(s2.map(function(e4) {
              return e4.id;
            })), p2 = new Set(Object.keys(e3).map(function(t3) {
              return e3[t3].id;
            })), Object.keys(n2).forEach(function(e4) {
              n2[e4].forEach(function(e5) {
                !e5 || e5.isDisposed || o2.has(e5.id) || p2.has(e5.id) || -1 !== u2.weightIds.indexOf(e5.id) || e5.dispose();
              });
            }), [2, s2];
        }
      });
    });
  }, e2.prototype.executeWithControlFlow = function(e3, t2, a2) {
    return __awaiter2(this, void 0, void 0, function() {
      var r2, n2, s2, o2, p2, u2, i2, m2, l2, c2, d2, y2, f2, g2, h2, N2, x2 = this;
      return __generator2(this, function(V2) {
        switch (V2.label) {
          case 0:
            r2 = Object.keys(e3), n2 = r2.map(function(e4) {
              return x2.graph.nodes[e4];
            }), s2 = a2.map(function(e4) {
              return x2.graph.nodes[parseNodeName(e4)[0]];
            }), o2 = getExecutionSubgraph(e3, s2, this.weightMap), p2 = o2.usedNodes, u2 = o2.missingInputs, i2 = o2.dynamicNode, m2 = o2.syncInputs, l2 = n2.concat(this.graph.weights).map(function(e4) {
              return {node: e4, contexts: t2.currentContext};
            }), c2 = __assign2({}, this.weightMap), Object.keys(e3).forEach(function(t3) {
              c2[t3] = [e3[t3]];
            }), d2 = {}, y2 = this.getFrozenTensorIds(c2), f2 = {}, V2.label = 1;
          case 1:
            return l2.length > 0 ? (g2 = this.processStack(n2, l2, t2, c2, f2, y2, a2, d2, p2), [4, Promise.all(g2)]) : [3, 3];
          case 2:
            return V2.sent(), [3, 1];
          case 3:
            if (null == i2 && console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead."), (h2 = s2.filter(function(e4) {
              return !isControlFlow(e4) && !getTensor(e4.name, c2, t2);
            }).map(function(e4) {
              return e4.name;
            })).length > 0)
              throw N2 = "", null != i2 && (N2 = "Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [" + m2 + "]"), new Error("Cannot compute the outputs [" + h2 + "] from the provided inputs [" + r2 + "]. Consider providing the following inputs: [" + u2 + "]. " + N2);
            return [2, c2];
        }
      });
    });
  }, e2.prototype.processStack = function(e3, t2, a2, r2, n2, s2, o2, p2, u2) {
    for (var i2 = this, m2 = [], l2 = function() {
      var l3 = t2.pop();
      a2.currentContext = l3.contexts;
      var d2 = "";
      if ("Enter" === l3.node.op && getParamValue("isConstant", l3.node, r2, a2) && (d2 = getNodeNameAndIndex(l3.node.name, a2)[0]), -1 === e3.indexOf(l3.node)) {
        var y2 = executeOp$16(l3.node, r2, a2);
        d2 || (d2 = getNodeNameAndIndex(l3.node.name, a2)[0]);
        var f2 = a2.currentContext;
        y2 instanceof Promise ? m2.push(y2.then(function(e4) {
          return r2[d2] = e4, a2.currentContext = f2, i2.checkTensorForDisposal(d2, l3.node, r2, a2, s2, o2, p2), i2.processChildNodes(l3.node, t2, a2, r2, n2, u2), e4;
        })) : (r2[d2] = y2, c2.checkTensorForDisposal(d2, l3.node, r2, a2, s2, o2, p2), c2.processChildNodes(l3.node, t2, a2, r2, n2, u2));
      } else
        c2.processChildNodes(l3.node, t2, a2, r2, n2, u2);
    }, c2 = this; t2.length > 0; )
      l2();
    return m2;
  }, e2.prototype.processChildNodes = function(e3, t2, a2, r2, n2, s2) {
    e3.children.forEach(function(e4) {
      var o2 = getNodeNameAndIndex(e4.name, a2)[0];
      !n2[o2] && s2.has(e4.name) && ("Merge" === e4.op ? e4.inputNames.some(function(e5) {
        return !!getTensor(e5, r2, a2);
      }) && (n2[o2] = true, t2.push({contexts: a2.currentContext, node: e4})) : e4.inputNames.every(function(e5) {
        return !!getTensor(e5, r2, a2);
      }) && (n2[o2] = true, t2.push({contexts: a2.currentContext, node: e4})));
    });
  }, e2.prototype.dispose = function() {
    var e3 = this;
    Object.keys(this.weightMap).forEach(function(t2) {
      return e3.weightMap[t2].forEach(function(e4) {
        return e4.dispose();
      });
    });
  }, e2.prototype.checkInputShapeAndType = function(e3) {
    var t2 = this;
    Object.keys(e3).forEach(function(a2) {
      var r2 = e3[a2], n2 = t2.graph.nodes[a2];
      if (n2.attrParams.shape && n2.attrParams.shape.value) {
        var s2 = n2.attrParams.shape.value, o2 = s2.length === r2.shape.length && r2.shape.every(function(e4, t3) {
          return -1 === s2[t3] || s2[t3] === e4;
        });
        tt.assert(o2, function() {
          return "The shape of dict['" + n2.name + "'] provided in model.execute(dict) must be [" + s2 + "], but was [" + r2.shape + "]";
        });
      }
      n2.attrParams.dtype && n2.attrParams.dtype.value && tt.assert(r2.dtype === n2.attrParams.dtype.value, function() {
        return "The dtype of dict['" + n2.name + "'] provided in model.execute(dict) must be " + n2.attrParams.dtype.value + ", but was " + r2.dtype;
      });
    });
  }, e2.prototype.checkInputs = function(e3) {
    var t2 = this, a2 = Object.keys(e3).filter(function(e4) {
      return !t2.graph.nodes[e4];
    });
    if (a2.length > 0)
      throw new Error("The dict provided in model.execute(dict) has keys: [" + a2 + "] that are not part of graph");
  }, e2.prototype.checkOutputs = function(e3) {
    var t2 = this;
    e3.forEach(function(e4) {
      var a2 = parseNodeName(e4)[0];
      if (!t2.graph.nodes[a2])
        throw new Error("The output '" + e4 + "' is not found in the graph");
    });
  }, e2;
}();
var TFHUB_SEARCH_PARAM = "?tfjs-format=file";
var DEFAULT_MODEL_NAME = "model.json";
var GraphModel = function() {
  function e2(e3, t2) {
    void 0 === t2 && (t2 = {}), this.modelUrl = e3, this.loadOptions = t2, this.version = "n/a", null == t2 && (this.loadOptions = {});
  }
  return Object.defineProperty(e2.prototype, "modelVersion", {get: function() {
    return this.version;
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "inputNodes", {get: function() {
    return this.executor.inputNodes;
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "outputNodes", {get: function() {
    return this.executor.outputNodes;
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "inputs", {get: function() {
    return this.executor.inputs;
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "outputs", {get: function() {
    return this.executor.outputs;
  }, enumerable: true, configurable: true}), Object.defineProperty(e2.prototype, "weights", {get: function() {
    return this.executor.weightMap;
  }, enumerable: true, configurable: true}), e2.prototype.findIOHandler = function() {
    var e3 = this.modelUrl;
    if (null != e3.load)
      this.handler = e3;
    else if (null != this.loadOptions.requestInit)
      this.handler = Af.browserHTTPRequest(e3, this.loadOptions);
    else {
      var t2 = Af.getLoadHandlers(e3, this.loadOptions.onProgress);
      if (0 === t2.length)
        t2.push(Af.browserHTTPRequest(e3, this.loadOptions));
      else if (t2.length > 1)
        throw new Error("Found more than one (" + t2.length + ") load handlers for URL '" + [e3] + "'");
      this.handler = t2[0];
    }
  }, e2.prototype.load = function() {
    return __awaiter2(this, void 0, void 0, function() {
      var e3, t2, a2;
      return __generator2(this, function(r2) {
        switch (r2.label) {
          case 0:
            if (this.findIOHandler(), null == this.handler.load)
              throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
            return [4, this.handler.load()];
          case 1:
            return e3 = r2.sent(), t2 = e3.modelTopology, this.version = t2.versions.producer + "." + t2.versions.minConsumer, a2 = Af.decodeWeights(e3.weightData, e3.weightSpecs), this.executor = new GraphExecutor(OperationMapper.Instance.transformGraph(t2)), this.executor.weightMap = this.convertTensorMapToTensorsMap(a2), [2, true];
        }
      });
    });
  }, e2.prototype.predict = function(e3, t2) {
    return this.execute(e3, this.outputNodes);
  }, e2.prototype.normalizeInputs = function(e3) {
    if (!(e3 instanceof dt || Array.isArray(e3)))
      return e3;
    if ((e3 = Array.isArray(e3) ? e3 : [e3]).length !== this.inputNodes.length)
      throw new Error("Input tensor count mismatch,the graph model has " + this.inputNodes.length + " placeholders, while there are " + e3.length + " input tensors.");
    return this.inputNodes.reduce(function(t2, a2, r2) {
      return t2[a2] = e3[r2], t2;
    }, {});
  }, e2.prototype.normalizeOutputs = function(e3) {
    return e3 = e3 || this.outputNodes, Array.isArray(e3) ? e3 : [e3];
  }, e2.prototype.execute = function(e3, t2) {
    e3 = this.normalizeInputs(e3), t2 = this.normalizeOutputs(t2);
    var a2 = this.executor.execute(e3, t2);
    return a2.length > 1 ? a2 : a2[0];
  }, e2.prototype.executeAsync = function(e3, t2) {
    return __awaiter2(this, void 0, void 0, function() {
      var a2;
      return __generator2(this, function(r2) {
        switch (r2.label) {
          case 0:
            return e3 = this.normalizeInputs(e3), t2 = this.normalizeOutputs(t2), [4, this.executor.executeAsync(e3, t2)];
          case 1:
            return [2, (a2 = r2.sent()).length > 1 ? a2 : a2[0]];
        }
      });
    });
  }, e2.prototype.convertTensorMapToTensorsMap = function(e3) {
    return Object.keys(e3).reduce(function(t2, a2) {
      return t2[a2] = [e3[a2]], t2;
    }, {});
  }, e2.prototype.dispose = function() {
    this.executor.dispose();
  }, e2;
}();
function loadGraphModel(e2, t2) {
  return void 0 === t2 && (t2 = {}), __awaiter2(this, void 0, void 0, function() {
    var a2;
    return __generator2(this, function(r2) {
      switch (r2.label) {
        case 0:
          if (null == e2)
            throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
          return null == t2 && (t2 = {}), t2.fromTFHub && null == e2.load && (e2.endsWith("/") || (e2 += "/"), e2 = "" + e2 + DEFAULT_MODEL_NAME + TFHUB_SEARCH_PARAM), [4, (a2 = new GraphModel(e2, t2)).load()];
        case 1:
          return r2.sent(), [2, a2];
      }
    });
  });
}

// node_modules/@tensorflow-models/posenet/dist/posenet.esm.js
var extendStatics = function(e2, t2) {
  return (extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(e3, t3) {
    e3.__proto__ = t3;
  } || function(e3, t3) {
    for (var n2 in t3)
      t3.hasOwnProperty(n2) && (e3[n2] = t3[n2]);
  })(e2, t2);
};
function __extends(e2, t2) {
  function n2() {
    this.constructor = e2;
  }
  extendStatics(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (n2.prototype = t2.prototype, new n2());
}
var __assign = function() {
  return (__assign = Object.assign || function(e2) {
    for (var t2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
      for (var o2 in t2 = arguments[n2])
        Object.prototype.hasOwnProperty.call(t2, o2) && (e2[o2] = t2[o2]);
    return e2;
  }).apply(this, arguments);
};
function __awaiter(e2, t2, n2, r2) {
  return new (n2 || (n2 = Promise))(function(o2, i2) {
    function s2(e3) {
      try {
        a2(r2.next(e3));
      } catch (e4) {
        i2(e4);
      }
    }
    function u2(e3) {
      try {
        a2(r2.throw(e3));
      } catch (e4) {
        i2(e4);
      }
    }
    function a2(e3) {
      e3.done ? o2(e3.value) : new n2(function(t3) {
        t3(e3.value);
      }).then(s2, u2);
    }
    a2((r2 = r2.apply(e2, t2 || [])).next());
  });
}
function __generator(e2, t2) {
  var n2, r2, o2, i2, s2 = {label: 0, sent: function() {
    if (1 & o2[0])
      throw o2[1];
    return o2[1];
  }, trys: [], ops: []};
  return i2 = {next: u2(0), throw: u2(1), return: u2(2)}, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
    return this;
  }), i2;
  function u2(i3) {
    return function(u3) {
      return function(i4) {
        if (n2)
          throw new TypeError("Generator is already executing.");
        for (; s2; )
          try {
            if (n2 = 1, r2 && (o2 = 2 & i4[0] ? r2.return : i4[0] ? r2.throw || ((o2 = r2.return) && o2.call(r2), 0) : r2.next) && !(o2 = o2.call(r2, i4[1])).done)
              return o2;
            switch (r2 = 0, o2 && (i4 = [2 & i4[0], o2.value]), i4[0]) {
              case 0:
              case 1:
                o2 = i4;
                break;
              case 4:
                return s2.label++, {value: i4[1], done: false};
              case 5:
                s2.label++, r2 = i4[1], i4 = [0];
                continue;
              case 7:
                i4 = s2.ops.pop(), s2.trys.pop();
                continue;
              default:
                if (!(o2 = (o2 = s2.trys).length > 0 && o2[o2.length - 1]) && (6 === i4[0] || 2 === i4[0])) {
                  s2 = 0;
                  continue;
                }
                if (3 === i4[0] && (!o2 || i4[1] > o2[0] && i4[1] < o2[3])) {
                  s2.label = i4[1];
                  break;
                }
                if (6 === i4[0] && s2.label < o2[1]) {
                  s2.label = o2[1], o2 = i4;
                  break;
                }
                if (o2 && s2.label < o2[2]) {
                  s2.label = o2[2], s2.ops.push(i4);
                  break;
                }
                o2[2] && s2.ops.pop(), s2.trys.pop();
                continue;
            }
            i4 = t2.call(e2, s2);
          } catch (e3) {
            i4 = [6, e3], r2 = 0;
          } finally {
            n2 = o2 = 0;
          }
        if (5 & i4[0])
          throw i4[1];
        return {value: i4[0] ? i4[1] : void 0, done: true};
      }([i3, u3]);
    };
  }
}
var BaseModel = function() {
  function e2(e3, t2) {
    this.model = e3, this.outputStride = t2;
    var n2 = this.model.inputs[0].shape;
    tt.assert(-1 === n2[1] && -1 === n2[2], function() {
      return "Input shape [" + n2[1] + ", " + n2[2] + "] must both be equal to or -1";
    });
  }
  return e2.prototype.predict = function(e3) {
    var t2 = this;
    return je(function() {
      var n2 = t2.preprocessInput(e3.toFloat()).expandDims(0), r2 = t2.model.predict(n2).map(function(e4) {
        return e4.squeeze([0]);
      }), o2 = t2.nameOutputResults(r2);
      return {heatmapScores: o2.heatmap.sigmoid(), offsets: o2.offsets, displacementFwd: o2.displacementFwd, displacementBwd: o2.displacementBwd};
    });
  }, e2.prototype.dispose = function() {
    this.model.dispose();
  }, e2;
}();
var MobileNet = function(e2) {
  function t2() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(t2, e2), t2.prototype.preprocessInput = function(e3) {
    return je(function() {
      return qs(e3, 127.5).sub(1);
    });
  }, t2.prototype.nameOutputResults = function(e3) {
    return {offsets: e3[0], heatmap: e3[1], displacementFwd: e3[2], displacementBwd: e3[3]};
  }, t2;
}(BaseModel);
function half(e2) {
  return Math.floor(e2 / 2);
}
var MaxHeap = function() {
  function e2(e3, t2) {
    this.priorityQueue = new Array(e3), this.numberOfElements = -1, this.getElementValue = t2;
  }
  return e2.prototype.enqueue = function(e3) {
    this.priorityQueue[++this.numberOfElements] = e3, this.swim(this.numberOfElements);
  }, e2.prototype.dequeue = function() {
    var e3 = this.priorityQueue[0];
    return this.exchange(0, this.numberOfElements--), this.sink(0), this.priorityQueue[this.numberOfElements + 1] = null, e3;
  }, e2.prototype.empty = function() {
    return -1 === this.numberOfElements;
  }, e2.prototype.size = function() {
    return this.numberOfElements + 1;
  }, e2.prototype.all = function() {
    return this.priorityQueue.slice(0, this.numberOfElements + 1);
  }, e2.prototype.max = function() {
    return this.priorityQueue[0];
  }, e2.prototype.swim = function(e3) {
    for (; e3 > 0 && this.less(half(e3), e3); )
      this.exchange(e3, half(e3)), e3 = half(e3);
  }, e2.prototype.sink = function(e3) {
    for (; 2 * e3 <= this.numberOfElements; ) {
      var t2 = 2 * e3;
      if (t2 < this.numberOfElements && this.less(t2, t2 + 1) && t2++, !this.less(e3, t2))
        break;
      this.exchange(e3, t2), e3 = t2;
    }
  }, e2.prototype.getValueAt = function(e3) {
    return this.getElementValue(this.priorityQueue[e3]);
  }, e2.prototype.less = function(e3, t2) {
    return this.getValueAt(e3) < this.getValueAt(t2);
  }, e2.prototype.exchange = function(e3, t2) {
    var n2 = this.priorityQueue[e3];
    this.priorityQueue[e3] = this.priorityQueue[t2], this.priorityQueue[t2] = n2;
  }, e2;
}();
function scoreIsMaximumInLocalWindow(e2, t2, n2, r2, o2, i2) {
  for (var s2 = i2.shape, u2 = s2[0], a2 = s2[1], l2 = true, p2 = Math.max(n2 - o2, 0), c2 = Math.min(n2 + o2 + 1, u2), f2 = p2; f2 < c2; ++f2) {
    for (var d2 = Math.max(r2 - o2, 0), h2 = Math.min(r2 + o2 + 1, a2), m2 = d2; m2 < h2; ++m2)
      if (i2.get(f2, m2, e2) > t2) {
        l2 = false;
        break;
      }
    if (!l2)
      break;
  }
  return l2;
}
function buildPartWithScoreQueue(e2, t2, n2) {
  for (var r2 = n2.shape, o2 = r2[0], i2 = r2[1], s2 = r2[2], u2 = new MaxHeap(o2 * i2 * s2, function(e3) {
    return e3.score;
  }), a2 = 0; a2 < o2; ++a2)
    for (var l2 = 0; l2 < i2; ++l2)
      for (var p2 = 0; p2 < s2; ++p2) {
        var c2 = n2.get(a2, l2, p2);
        c2 < e2 || scoreIsMaximumInLocalWindow(p2, c2, a2, l2, t2, n2) && u2.enqueue({score: c2, part: {heatmapY: a2, heatmapX: l2, id: p2}});
      }
  return u2;
}
var partNames = ["nose", "leftEye", "rightEye", "leftEar", "rightEar", "leftShoulder", "rightShoulder", "leftElbow", "rightElbow", "leftWrist", "rightWrist", "leftHip", "rightHip", "leftKnee", "rightKnee", "leftAnkle", "rightAnkle"];
var NUM_KEYPOINTS = partNames.length;
var partIds = partNames.reduce(function(e2, t2, n2) {
  return e2[t2] = n2, e2;
}, {});
var connectedPartNames = [["leftHip", "leftShoulder"], ["leftElbow", "leftShoulder"], ["leftElbow", "leftWrist"], ["leftHip", "leftKnee"], ["leftKnee", "leftAnkle"], ["rightHip", "rightShoulder"], ["rightElbow", "rightShoulder"], ["rightElbow", "rightWrist"], ["rightHip", "rightKnee"], ["rightKnee", "rightAnkle"], ["leftShoulder", "rightShoulder"], ["leftHip", "rightHip"]];
var poseChain = [["nose", "leftEye"], ["leftEye", "leftEar"], ["nose", "rightEye"], ["rightEye", "rightEar"], ["nose", "leftShoulder"], ["leftShoulder", "leftElbow"], ["leftElbow", "leftWrist"], ["leftShoulder", "leftHip"], ["leftHip", "leftKnee"], ["leftKnee", "leftAnkle"], ["nose", "rightShoulder"], ["rightShoulder", "rightElbow"], ["rightElbow", "rightWrist"], ["rightShoulder", "rightHip"], ["rightHip", "rightKnee"], ["rightKnee", "rightAnkle"]];
var connectedPartIndices = connectedPartNames.map(function(e2) {
  var t2 = e2[0], n2 = e2[1];
  return [partIds[t2], partIds[n2]];
});
var partChannels = ["left_face", "right_face", "right_upper_leg_front", "right_lower_leg_back", "right_upper_leg_back", "left_lower_leg_front", "left_upper_leg_front", "left_upper_leg_back", "left_lower_leg_back", "right_feet", "right_lower_leg_front", "left_feet", "torso_front", "torso_back", "right_upper_arm_front", "right_upper_arm_back", "right_lower_arm_back", "left_lower_arm_front", "left_upper_arm_front", "left_upper_arm_back", "left_lower_arm_back", "right_hand", "right_lower_arm_front", "left_hand"];
function getOffsetPoint(e2, t2, n2, r2) {
  return {y: r2.get(e2, t2, n2), x: r2.get(e2, t2, n2 + NUM_KEYPOINTS)};
}
function getImageCoords(e2, t2, n2) {
  var r2 = getOffsetPoint(e2.heatmapY, e2.heatmapX, e2.id, n2), o2 = r2.y, i2 = r2.x;
  return {x: e2.heatmapX * t2 + i2, y: e2.heatmapY * t2 + o2};
}
function clamp(e2, t2, n2) {
  return e2 < t2 ? t2 : e2 > n2 ? n2 : e2;
}
function squaredDistance(e2, t2, n2, r2) {
  var o2 = n2 - e2, i2 = r2 - t2;
  return o2 * o2 + i2 * i2;
}
function addVectors(e2, t2) {
  return {x: e2.x + t2.x, y: e2.y + t2.y};
}
var parentChildrenTuples = poseChain.map(function(e2) {
  var t2 = e2[0], n2 = e2[1];
  return [partIds[t2], partIds[n2]];
});
var parentToChildEdges = parentChildrenTuples.map(function(e2) {
  return e2[1];
});
var childToParentEdges = parentChildrenTuples.map(function(e2) {
  return e2[0];
});
function getDisplacement(e2, t2, n2) {
  var r2 = n2.shape[2] / 2;
  return {y: n2.get(t2.y, t2.x, e2), x: n2.get(t2.y, t2.x, r2 + e2)};
}
function getStridedIndexNearPoint(e2, t2, n2, r2) {
  return {y: clamp(Math.round(e2.y / t2), 0, n2 - 1), x: clamp(Math.round(e2.x / t2), 0, r2 - 1)};
}
function traverseToTargetKeypoint(e2, t2, n2, r2, o2, i2, s2, u2) {
  void 0 === u2 && (u2 = 2);
  for (var a2 = r2.shape, l2 = a2[0], p2 = a2[1], c2 = getDisplacement(e2, getStridedIndexNearPoint(t2.position, i2, l2, p2), s2), f2 = addVectors(t2.position, c2), d2 = 0; d2 < u2; d2++) {
    var h2 = getStridedIndexNearPoint(f2, i2, l2, p2), m2 = getOffsetPoint(h2.y, h2.x, n2, o2);
    f2 = addVectors({x: h2.x * i2, y: h2.y * i2}, {x: m2.x, y: m2.y});
  }
  var g2 = getStridedIndexNearPoint(f2, i2, l2, p2), _2 = r2.get(g2.y, g2.x, n2);
  return {position: f2, part: partNames[n2], score: _2};
}
function decodePose(e2, t2, n2, r2, o2, i2) {
  var s2 = t2.shape[2], u2 = parentToChildEdges.length, a2 = new Array(s2), l2 = e2.part, p2 = e2.score, c2 = getImageCoords(l2, r2, n2);
  a2[l2.id] = {score: p2, part: partNames[l2.id], position: c2};
  for (var f2 = u2 - 1; f2 >= 0; --f2) {
    var d2 = parentToChildEdges[f2], h2 = childToParentEdges[f2];
    a2[d2] && !a2[h2] && (a2[h2] = traverseToTargetKeypoint(f2, a2[d2], h2, t2, n2, r2, i2));
  }
  for (f2 = 0; f2 < u2; ++f2) {
    d2 = childToParentEdges[f2], h2 = parentToChildEdges[f2];
    a2[d2] && !a2[h2] && (a2[h2] = traverseToTargetKeypoint(f2, a2[d2], h2, t2, n2, r2, o2));
  }
  return a2;
}
function withinNmsRadiusOfCorrespondingPoint(e2, t2, n2, r2) {
  var o2 = n2.x, i2 = n2.y;
  return e2.some(function(e3) {
    var n3 = e3.keypoints[r2].position;
    return squaredDistance(i2, o2, n3.y, n3.x) <= t2;
  });
}
function getInstanceScore(e2, t2, n2) {
  return n2.reduce(function(n3, r2, o2) {
    var i2 = r2.position, s2 = r2.score;
    return withinNmsRadiusOfCorrespondingPoint(e2, t2, i2, o2) || (n3 += s2), n3;
  }, 0) / n2.length;
}
var kLocalMaximumRadius = 1;
function decodeMultiplePoses(e2, t2, n2, r2, o2, i2, s2, u2) {
  void 0 === s2 && (s2 = 0.5), void 0 === u2 && (u2 = 20);
  for (var a2 = [], l2 = buildPartWithScoreQueue(s2, kLocalMaximumRadius, e2), p2 = u2 * u2; a2.length < i2 && !l2.empty(); ) {
    var c2 = l2.dequeue();
    if (!withinNmsRadiusOfCorrespondingPoint(a2, p2, getImageCoords(c2.part, o2, t2), c2.part.id)) {
      var f2 = decodePose(c2, e2, t2, o2, n2, r2), d2 = getInstanceScore(a2, p2, f2);
      a2.push({keypoints: f2, score: d2});
    }
  }
  return a2;
}
function mod(e2, t2) {
  return je(function() {
    var n2 = e2.div(An(t2, "int32"));
    return e2.sub(n2.mul(An(t2, "int32")));
  });
}
function argmax2d(e2) {
  var t2 = e2.shape, n2 = t2[0], r2 = t2[1], o2 = t2[2];
  return je(function() {
    var t3 = e2.reshape([n2 * r2, o2]).argMax(0), i2 = t3.div(An(r2, "int32")).expandDims(1), s2 = mod(t3, r2).expandDims(1);
    return Gn([i2, s2], 1);
  });
}
function getPointsConfidence(e2, t2) {
  for (var n2 = t2.shape[0], r2 = new Float32Array(n2), o2 = 0; o2 < n2; o2++) {
    var i2 = t2.get(o2, 0), s2 = t2.get(o2, 1);
    r2[o2] = e2.get(i2, s2, o2);
  }
  return r2;
}
function getOffsetPoint$1(e2, t2, n2, r2) {
  return {y: r2.get(e2, t2, n2), x: r2.get(e2, t2, n2 + NUM_KEYPOINTS)};
}
function getOffsetVectors(e2, t2) {
  for (var n2 = [], r2 = 0; r2 < NUM_KEYPOINTS; r2++) {
    var o2 = getOffsetPoint$1(e2.get(r2, 0).valueOf(), e2.get(r2, 1).valueOf(), r2, t2), i2 = o2.x, s2 = o2.y;
    n2.push(s2), n2.push(i2);
  }
  return Tn(n2, [NUM_KEYPOINTS, 2]);
}
function getOffsetPoints(e2, t2, n2) {
  return je(function() {
    var r2 = getOffsetVectors(e2, n2);
    return e2.toTensor().mul(An(t2, "int32")).toFloat().add(r2);
  });
}
function decodeSinglePose(e2, t2, n2) {
  return __awaiter(this, void 0, void 0, function() {
    var r2, o2, i2, s2, u2, a2, l2, p2, c2, f2;
    return __generator(this, function(d2) {
      switch (d2.label) {
        case 0:
          return r2 = 0, o2 = argmax2d(e2), [4, Promise.all([e2.buffer(), t2.buffer(), o2.buffer()])];
        case 1:
          return i2 = d2.sent(), s2 = i2[0], u2 = i2[1], a2 = i2[2], [4, (l2 = getOffsetPoints(a2, n2, u2)).buffer()];
        case 2:
          return p2 = d2.sent(), c2 = Array.from(getPointsConfidence(s2, a2)), f2 = c2.map(function(e3, t3) {
            return r2 += e3, {position: {y: p2.get(t3, 0), x: p2.get(t3, 1)}, part: partNames[t3], score: e3};
          }), o2.dispose(), l2.dispose(), [2, {keypoints: f2, score: r2 / f2.length}];
      }
    });
  });
}
var MOBILENET_BASE_URL = "https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/";
var RESNET50_BASE_URL = "https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";
function resNet50Checkpoint(e2, t2) {
  var n2 = "model-stride" + e2 + ".json";
  return 4 === t2 ? RESNET50_BASE_URL + "float/" + n2 : RESNET50_BASE_URL + "quant" + t2 + "/" + n2;
}
function mobileNetCheckpoint(e2, t2, n2) {
  var r2 = {1: "100", 0.75: "075", 0.5: "050"}, o2 = "model-stride" + e2 + ".json";
  return 4 === n2 ? MOBILENET_BASE_URL + "float/" + r2[t2] + "/" + o2 : MOBILENET_BASE_URL + "quant" + n2 + "/" + r2[t2] + "/" + o2;
}
var imageNetMean = [-123.15, -115.9, -103.06];
var ResNet = function(e2) {
  function t2() {
    return null !== e2 && e2.apply(this, arguments) || this;
  }
  return __extends(t2, e2), t2.prototype.preprocessInput = function(e3) {
    return e3.add(imageNetMean);
  }, t2.prototype.nameOutputResults = function(e3) {
    var t3 = e3[0], n2 = e3[1];
    return {offsets: e3[2], heatmap: e3[3], displacementFwd: t3, displacementBwd: n2};
  }, t2;
}(BaseModel);
function eitherPointDoesntMeetConfidence(e2, t2, n2) {
  return e2 < n2 || t2 < n2;
}
function getAdjacentKeyPoints(e2, t2) {
  return connectedPartIndices.reduce(function(n2, r2) {
    var o2 = r2[0], i2 = r2[1];
    return eitherPointDoesntMeetConfidence(e2[o2].score, e2[i2].score, t2) ? n2 : (n2.push([e2[o2], e2[i2]]), n2);
  }, []);
}
var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY;
var POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
function getBoundingBox(e2) {
  return e2.reduce(function(e3, t2) {
    var n2 = e3.maxX, r2 = e3.maxY, o2 = e3.minX, i2 = e3.minY, s2 = t2.position, u2 = s2.x, a2 = s2.y;
    return {maxX: Math.max(n2, u2), maxY: Math.max(r2, a2), minX: Math.min(o2, u2), minY: Math.min(i2, a2)};
  }, {maxX: NEGATIVE_INFINITY, maxY: NEGATIVE_INFINITY, minX: POSITIVE_INFINITY, minY: POSITIVE_INFINITY});
}
function getBoundingBoxPoints(e2) {
  var t2 = getBoundingBox(e2), n2 = t2.minX, r2 = t2.minY, o2 = t2.maxX, i2 = t2.maxY;
  return [{x: n2, y: r2}, {x: o2, y: r2}, {x: o2, y: i2}, {x: n2, y: i2}];
}
function toTensorBuffers3D(e2) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(t2) {
      return [2, Promise.all(e2.map(function(e3) {
        return e3.buffer();
      }))];
    });
  });
}
function scalePose(e2, t2, n2, r2, o2) {
  return void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = 0), {score: e2.score, keypoints: e2.keypoints.map(function(e3) {
    var i2 = e3.score, s2 = e3.part, u2 = e3.position;
    return {score: i2, part: s2, position: {x: u2.x * n2 + o2, y: u2.y * t2 + r2}};
  })};
}
function scalePoses(e2, t2, n2, r2, o2) {
  return void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = 0), 1 === n2 && 1 === t2 && 0 === r2 && 0 === o2 ? e2 : e2.map(function(e3) {
    return scalePose(e3, t2, n2, r2, o2);
  });
}
function flipPoseHorizontal(e2, t2) {
  return {score: e2.score, keypoints: e2.keypoints.map(function(e3) {
    var n2 = e3.score, r2 = e3.part, o2 = e3.position;
    return {score: n2, part: r2, position: {x: t2 - 1 - o2.x, y: o2.y}};
  })};
}
function flipPosesHorizontal(e2, t2) {
  return t2 <= 0 ? e2 : e2.map(function(e3) {
    return flipPoseHorizontal(e3, t2);
  });
}
function toValidInputResolution(e2, t2) {
  return isValidInputResolution(e2, t2) ? e2 : Math.floor(e2 / t2) * t2 + 1;
}
function validateInputResolution(e2) {
  tt.assert("number" == typeof e2 || "object" == typeof e2, function() {
    return "Invalid inputResolution " + e2 + ". Should be a number or an object with width and height";
  }), "object" == typeof e2 && (tt.assert("number" == typeof e2.width, function() {
    return "inputResolution.width has a value of " + e2.width + " which is invalid; it must be a number";
  }), tt.assert("number" == typeof e2.height, function() {
    return "inputResolution.height has a value of " + e2.height + " which is invalid; it must be a number";
  }));
}
function getValidInputResolutionDimensions(e2, t2) {
  return validateInputResolution(e2), "object" == typeof e2 ? [toValidInputResolution(e2.height, t2), toValidInputResolution(e2.width, t2)] : [toValidInputResolution(e2, t2), toValidInputResolution(e2, t2)];
}
var VALID_OUTPUT_STRIDES = [8, 16, 32];
function assertValidOutputStride(e2) {
  tt.assert("number" == typeof e2, function() {
    return "outputStride is not a number";
  }), tt.assert(VALID_OUTPUT_STRIDES.indexOf(e2) >= 0, function() {
    return "outputStride of " + e2 + " is invalid. It must be either 8, 16, or 32";
  });
}
function isValidInputResolution(e2, t2) {
  return (e2 - 1) % t2 == 0;
}
function assertValidResolution(e2, t2) {
  tt.assert("number" == typeof e2[0] && "number" == typeof e2[1], function() {
    return "both resolution values must be a number but had values " + e2;
  }), tt.assert(isValidInputResolution(e2[0], t2), function() {
    return "height of " + e2[0] + " is invalid for output stride " + t2 + ".";
  }), tt.assert(isValidInputResolution(e2[1], t2), function() {
    return "width of " + e2[1] + " is invalid for output stride " + t2 + ".";
  });
}
function getInputTensorDimensions(e2) {
  return e2 instanceof dt ? [e2.shape[0], e2.shape[1]] : [e2.height, e2.width];
}
function toInputTensor(e2) {
  return e2 instanceof dt ? e2 : Ff.fromPixels(e2);
}
function padAndResizeTo(e2, t2) {
  var n2 = t2[0], r2 = t2[1], o2 = getInputTensorDimensions(e2), i2 = o2[0], s2 = o2[1], u2 = r2 / n2, a2 = [0, 0, 0, 0], l2 = a2[0], p2 = a2[1], c2 = a2[2], f2 = a2[3];
  return s2 / i2 < u2 ? (l2 = 0, p2 = 0, c2 = Math.round(0.5 * (u2 * i2 - s2)), f2 = Math.round(0.5 * (u2 * i2 - s2))) : (l2 = Math.round(0.5 * (1 / u2 * s2 - i2)), p2 = Math.round(0.5 * (1 / u2 * s2 - i2)), c2 = 0, f2 = 0), {resized: je(function() {
    var t3 = toInputTensor(e2);
    return (t3 = wr(t3, [[l2, p2], [c2, f2], [0, 0]])).resizeBilinear([n2, r2]);
  }), padding: {top: l2, left: c2, right: f2, bottom: p2}};
}
function scaleAndFlipPoses(e2, t2, n2, r2, o2) {
  var i2 = t2[0], s2 = t2[1], u2 = n2[0], a2 = n2[1], l2 = scalePoses(e2, (i2 + r2.top + r2.bottom) / u2, (s2 + r2.left + r2.right) / a2, -r2.top, -r2.left);
  return o2 ? flipPosesHorizontal(l2, s2) : l2;
}
var MOBILENET_V1_CONFIG = {architecture: "MobileNetV1", outputStride: 16, multiplier: 0.75, inputResolution: 257};
var VALID_ARCHITECTURE = ["MobileNetV1", "ResNet50"];
var VALID_STRIDE = {MobileNetV1: [8, 16, 32], ResNet50: [32, 16]};
var VALID_MULTIPLIER = {MobileNetV1: [0.5, 0.75, 1], ResNet50: [1]};
var VALID_QUANT_BYTES = [1, 2, 4];
function validateModelConfig(e2) {
  if (null == (e2 = e2 || MOBILENET_V1_CONFIG).architecture && (e2.architecture = "MobileNetV1"), VALID_ARCHITECTURE.indexOf(e2.architecture) < 0)
    throw new Error("Invalid architecture " + e2.architecture + ". Should be one of " + VALID_ARCHITECTURE);
  if (null == e2.inputResolution && (e2.inputResolution = 257), validateInputResolution(e2.inputResolution), null == e2.outputStride && (e2.outputStride = 16), VALID_STRIDE[e2.architecture].indexOf(e2.outputStride) < 0)
    throw new Error("Invalid outputStride " + e2.outputStride + ". Should be one of " + VALID_STRIDE[e2.architecture] + " for architecutre " + e2.architecture + ".");
  if (null == e2.multiplier && (e2.multiplier = 1), VALID_MULTIPLIER[e2.architecture].indexOf(e2.multiplier) < 0)
    throw new Error("Invalid multiplier " + e2.multiplier + ". Should be one of " + VALID_MULTIPLIER[e2.architecture] + " for architecutre " + e2.architecture + ".");
  if (null == e2.quantBytes && (e2.quantBytes = 4), VALID_QUANT_BYTES.indexOf(e2.quantBytes) < 0)
    throw new Error("Invalid quantBytes " + e2.quantBytes + ". Should be one of " + VALID_QUANT_BYTES + " for architecutre " + e2.architecture + ".");
  return e2;
}
var SINGLE_PERSON_INFERENCE_CONFIG = {flipHorizontal: false};
var MULTI_PERSON_INFERENCE_CONFIG = {flipHorizontal: false, maxDetections: 5, scoreThreshold: 0.5, nmsRadius: 20};
function validateMultiPersonInputConfig(e2) {
  var t2 = e2.maxDetections, n2 = e2.scoreThreshold, r2 = e2.nmsRadius;
  if (t2 <= 0)
    throw new Error("Invalid maxDetections " + t2 + ". Should be > 0");
  if (n2 < 0 || n2 > 1)
    throw new Error("Invalid scoreThreshold " + n2 + ". Should be in range [0.0, 1.0]");
  if (r2 <= 0)
    throw new Error("Invalid nmsRadius " + r2 + ".");
}
var PoseNet = function() {
  function e2(e3, t2) {
    assertValidOutputStride(e3.outputStride), assertValidResolution(t2, e3.outputStride), this.baseModel = e3, this.inputResolution = t2;
  }
  return e2.prototype.estimateMultiplePoses = function(e3, t2) {
    return void 0 === t2 && (t2 = MULTI_PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function() {
      var n2, r2, o2, i2, s2, u2, a2, l2, p2, c2, f2, d2, h2, m2, g2, _2, I2, v2, y2, E2, b2;
      return __generator(this, function(N2) {
        switch (N2.label) {
          case 0:
            return n2 = __assign({}, MULTI_PERSON_INFERENCE_CONFIG, t2), validateMultiPersonInputConfig(t2), r2 = this.baseModel.outputStride, o2 = this.inputResolution, i2 = getInputTensorDimensions(e3), s2 = i2[0], u2 = i2[1], a2 = padAndResizeTo(e3, o2), l2 = a2.resized, p2 = a2.padding, c2 = this.baseModel.predict(l2), f2 = c2.heatmapScores, d2 = c2.offsets, h2 = c2.displacementFwd, m2 = c2.displacementBwd, [4, toTensorBuffers3D([f2, d2, h2, m2])];
          case 1:
            return g2 = N2.sent(), _2 = g2[0], I2 = g2[1], v2 = g2[2], y2 = g2[3], [4, decodeMultiplePoses(_2, I2, v2, y2, r2, n2.maxDetections, n2.scoreThreshold, n2.nmsRadius)];
          case 2:
            return E2 = N2.sent(), b2 = scaleAndFlipPoses(E2, [s2, u2], o2, p2, n2.flipHorizontal), f2.dispose(), d2.dispose(), h2.dispose(), m2.dispose(), l2.dispose(), [2, b2];
        }
      });
    });
  }, e2.prototype.estimateSinglePose = function(e3, t2) {
    return void 0 === t2 && (t2 = SINGLE_PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function() {
      var n2, r2, o2, i2, s2, u2, a2, l2, p2, c2, f2, d2, h2, m2, g2, _2;
      return __generator(this, function(I2) {
        switch (I2.label) {
          case 0:
            return n2 = __assign({}, SINGLE_PERSON_INFERENCE_CONFIG, t2), r2 = this.baseModel.outputStride, o2 = this.inputResolution, i2 = getInputTensorDimensions(e3), s2 = i2[0], u2 = i2[1], a2 = padAndResizeTo(e3, o2), l2 = a2.resized, p2 = a2.padding, c2 = this.baseModel.predict(l2), f2 = c2.heatmapScores, d2 = c2.offsets, h2 = c2.displacementFwd, m2 = c2.displacementBwd, [4, decodeSinglePose(f2, d2, r2)];
          case 1:
            return g2 = I2.sent(), _2 = scaleAndFlipPoses([g2], [s2, u2], o2, p2, n2.flipHorizontal), f2.dispose(), d2.dispose(), h2.dispose(), m2.dispose(), l2.dispose(), [2, _2[0]];
        }
      });
    });
  }, e2.prototype.estimatePoses = function(e3, t2) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(n2) {
        switch (n2.label) {
          case 0:
            return "single-person" !== t2.decodingMethod ? [3, 2] : [4, this.estimateSinglePose(e3, t2)];
          case 1:
            return [2, [n2.sent()]];
          case 2:
            return [2, this.estimateMultiplePoses(e3, t2)];
        }
      });
    });
  }, e2.prototype.dispose = function() {
    this.baseModel.dispose();
  }, e2;
}();
function loadMobileNet(e2) {
  return __awaiter(this, void 0, void 0, function() {
    var t2, n2, r2, o2, i2, s2, u2;
    return __generator(this, function(a2) {
      switch (a2.label) {
        case 0:
          if (t2 = e2.outputStride, n2 = e2.quantBytes, r2 = e2.multiplier, null == tf_core_esm_exports)
            throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");
          return o2 = mobileNetCheckpoint(t2, r2, n2), [4, loadGraphModel(e2.modelUrl || o2)];
        case 1:
          return i2 = a2.sent(), s2 = new MobileNet(i2, t2), u2 = getValidInputResolutionDimensions(e2.inputResolution, s2.outputStride), [2, new PoseNet(s2, u2)];
      }
    });
  });
}
function loadResNet(e2) {
  return __awaiter(this, void 0, void 0, function() {
    var t2, n2, r2, o2, i2, s2;
    return __generator(this, function(u2) {
      switch (u2.label) {
        case 0:
          if (t2 = e2.outputStride, n2 = e2.quantBytes, null == tf_core_esm_exports)
            throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");
          return r2 = resNet50Checkpoint(t2, n2), [4, loadGraphModel(e2.modelUrl || r2)];
        case 1:
          return o2 = u2.sent(), i2 = new ResNet(o2, t2), s2 = getValidInputResolutionDimensions(e2.inputResolution, i2.outputStride), [2, new PoseNet(i2, s2)];
      }
    });
  });
}
function load(e2) {
  return void 0 === e2 && (e2 = MOBILENET_V1_CONFIG), __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(t2) {
      return "ResNet50" === (e2 = validateModelConfig(e2)).architecture ? [2, loadResNet(e2)] : "MobileNetV1" === e2.architecture ? [2, loadMobileNet(e2)] : [2, null];
    });
  });
}
var version = "2.2.1";

// index.js
export {
  MobileNet,
  PoseNet,
  decodeMultiplePoses,
  decodeSinglePose,
  getAdjacentKeyPoints,
  getBoundingBox,
  getBoundingBoxPoints,
  load,
  partChannels,
  partIds,
  partNames,
  poseChain,
  scaleAndFlipPoses,
  scalePose,
  version
};
